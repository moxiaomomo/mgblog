---
title: golang之gRPC
date: 2017-02-09 10:10:53
tags: golang
---

#### 关于gRPC
gRPC是google公司面向移动应用, 基于http2.0协议标准而设计, 基于Protocol Buffers而开发的一种开源RPC框架。<br>
ProtoBuf可以用于通讯协议、数据存储等一些语言/平台无关的数据序列化, 号称高性能, 通用性强, 具体可以看下这里的分析：
[Google Protocol Buffer 的使用和原理](https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/)
<br>gRPC提供了一种相对简单的方法来精确地定义服务, 和为ios/andoird/后台服务自动生成可靠的数据结构功能库; 通过它可以节省带宽和CPU资源, 降低TCP连接次数, 和延长电池寿命。
<!--more-->

#### 1.安装protobuf与gRPC of go
去到[Protocol Buffers](https://github.com/google/protobuf/releases)下载器最新版。 笔者当前获取的版本为3.0.0, 安装过程如下：
```
tar -zxf protobuf-cpp-3.0.0-beta-2.tar.gz
cd protobuf-3.0.0-beta-2/
./configure
make && sudo make install
go get -u github.com/golang/protobuf/protoc-gen-go   # proto for golang
go get -u google.golang.org/grpc                     # grpc for golang
```
#### 2.定义proto文件
```protobuf
//protobuf3 protocol
syntax = "proto3";
package account;

// request struct
message UserRq {
    int32 id = 1;
}

// response struct
message UserRp {
    string name = 1;
}

// service
service Data {
    rpc GetUser(UserRq) returns (UserRp);
}
```
上面定义了一个服务Data，有一个API叫GetUser，接收参数类型UserRq, 返回参数类型UserRp。

<br>在proto中, service可以定义server， 有四种实现方式:(参考http://www.jianshu.com/p/774b38306c30)
- rpc GetFeature(Point) returns (Feature) {}
  <br>类似普通的函数调用，客户端发送请求Point到服务器，服务器返回相应Feature.

- rpc ListFeatures(Rectangle) returns (stream Feature) {}
  <br>客户端发起一次请求，服务器端返回一个流式数据，比如一个数组中的逐个元素

- rpc RecordRoute(stream Point) returns (RouteSummary) {}
  <br>客户端发起的请求是一个流式的数据，比如数组中的逐个元素，服务器返回一个相应

- rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
  <br>客户端发起的请求是一个流式数据，比如数组中的逐个元素，二服务器返回的也是一个类似的数据结构

上面的proto定义实现的是第一种方式。

#### 3.使用protoc command生成go源文件
```bash
protoc --go_out=plugins=grpc:. account.proto
ls
account.pb.go  account.proto
```
通过protoc生成了account.pb.go，其源码看起来是这样子的:
```golang
// Code generated by protoc-gen-go.
// source: account.proto
// DO NOT EDIT!

/*
Package account is a generated protocol buffer package.

It is generated from these files:
	account.proto

It has these top-level messages:
	UserRq
	UserRp
*/
package account

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// request struct
type UserRq struct {
	Id int32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *UserRq) Reset()                    { *m = UserRq{} }
func (m *UserRq) String() string            { return proto.CompactTextString(m) }
func (*UserRq) ProtoMessage()               {}
func (*UserRq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// response struct
type UserRp struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *UserRp) Reset()                    { *m = UserRp{} }
func (m *UserRp) String() string            { return proto.CompactTextString(m) }
func (*UserRp) ProtoMessage()               {}
func (*UserRp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func init() {
	proto.RegisterType((*UserRq)(nil), "account.UserRq")
	proto.RegisterType((*UserRp)(nil), "account.UserRp")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion1

// Client API for Data service

type DataClient interface {
	GetUser(ctx context.Context, in *UserRq, opts ...grpc.CallOption) (*UserRp, error)
}

type dataClient struct {
	cc *grpc.ClientConn
}

func NewDataClient(cc *grpc.ClientConn) DataClient {
	return &dataClient{cc}
}

func (c *dataClient) GetUser(ctx context.Context, in *UserRq, opts ...grpc.CallOption) (*UserRp, error) {
	out := new(UserRp)
	err := grpc.Invoke(ctx, "/account.Data/GetUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Data service

type DataServer interface {
	GetUser(context.Context, *UserRq) (*UserRp, error)
}

func RegisterDataServer(s *grpc.Server, srv DataServer) {
	s.RegisterService(&_Data_serviceDesc, srv)
}

func _Data_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UserRq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DataServer).GetUser(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Data_serviceDesc = grpc.ServiceDesc{
	ServiceName: "account.Data",
	HandlerType: (*DataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUser",
			Handler:    _Data_GetUser_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor0 = []byte{
	// 119 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0xe2, 0x4d, 0x4c, 0x4e, 0xce,
	0x2f, 0xcd, 0x2b, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x87, 0x72, 0x95, 0x24, 0xb8,
	0xd8, 0x42, 0x8b, 0x53, 0x8b, 0x82, 0x0a, 0x85, 0xf8, 0xb8, 0x98, 0x32, 0x53, 0x24, 0x18, 0x15,
	0x18, 0x35, 0x58, 0x83, 0x80, 0x2c, 0x25, 0x19, 0xa8, 0x4c, 0x81, 0x90, 0x10, 0x17, 0x4b, 0x5e,
	0x62, 0x6e, 0x2a, 0x58, 0x8e, 0x33, 0x08, 0xcc, 0x36, 0x32, 0xe6, 0x62, 0x71, 0x49, 0x2c, 0x49,
	0x14, 0xd2, 0xe6, 0x62, 0x77, 0x4f, 0x2d, 0x01, 0x29, 0x14, 0xe2, 0xd7, 0x83, 0xd9, 0x01, 0x31,
	0x51, 0x0a, 0x4d, 0xa0, 0x20, 0x89, 0x0d, 0x6c, 0xb9, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0xa6,
	0x63, 0xe9, 0x2f, 0x8d, 0x00, 0x00, 0x00,
}
```

#### 4. 服务端svr.go
```
package main

// created by moguang(moxiaomomo@gmail.com)
// created at 2016-01-10

import (
	"account"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
	"log"
	"net"
	"strconv"
)

type Data struct{}

func main() {
	host := "127.0.0.1:8080"
	//listen on port
	lis, err := net.Listen("tcp", host)
	if err != nil {
		log.Fatalf("Failed to listen: %v", err)
	}
	s := grpc.NewServer()
	account.RegisterDataServer(s, &Data{})
	// accept message
	log.Printf("Begin to serve on %v", host)
	s.Serve(lis)
	log.Println("Server is shutdown.")
}

// 给Data类型定义方法
func (t *Data) GetUser(ctx context.Context, request *account.UserRq) (response *account.UserRp, err error) {
	log.Printf("To get user, request.Id: %v", request.Id)
	response = &account.UserRp{
		Name: strconv.Itoa(int(request.Id)) + "_test",
	}
	return response, err
}
```

#### 5. 客户端cli.go
```golang
package main

// created by moguang(moxiaomomo@gmail.com)
// created at 2016-01-10

import (
	"account"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
	"log"
	"math/rand"
	"strconv"
	"strings"
	"sync"
	"time"
)

var (
	wg sync.WaitGroup
)

const (
	server      = "127.0.0.1"
	port        = "8080"
	parallel    = 10 //连接并行数
	times       = 10 //每连接请求次数
)

func main() {
	beginTime := time.Now()
	//结合WaitGroup, 实现并行请求
	for i := 0; i < int(parallel); i++ {
		wg.Add(1)
		go execRPC(&wg)
	}
	wg.Wait()

	endTime := time.Now()
	log.Printf("Exec time secs: %.2f ", endTime.Sub(beginTime).Seconds())
}

func execRPC(wg *sync.WaitGroup) {
	defer wg.Done()
	// 建立连接
	host := server + ":" + port
	conn, err := grpc.Dial(host, grpc.WithInsecure())
	if err != nil {
		log.Printf("Dial Err: %v", err)
		return
	}
	defer conn.Close()

	client := account.NewDataClient(conn)
	// 连续发起多次请求
	for i := 0; i < int(times); i++ {
		getUser(client)
	}
}

func getUser(client account.DataClient) {
	var request account.UserRq
	r := rand.Intn(parallel)
	request.Id = int32(r)

	// 调用远程方法
	response, _ := client.GetUser(context.Background(), &request)
	// 判断返回结果
	if id, _ := strconv.Atoi(strings.Split(response.Name, ":")[0]); id != r {
		log.Printf("Response error %#v", response)
	} else {
		log.Printf("Response ok %#v", response)
	}
}
```
