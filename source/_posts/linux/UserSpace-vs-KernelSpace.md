---
title: '[Linux]用户空间与内核空间'
date: 2017-10-25 14:42:48
tags: linux kernel
---

源文: http://learnlinuxconcepts.blogspot.com/2014/02/kernel-space-and-user-space.html

理解用户空间及内核空间对于增强理解Linux内核知识是非常重要的。

- 这里的用户空间及内核空间对应于虚拟地址空间.
- 每个linux中的进程占用独立的虚拟空间.
- 在32位架构linux系统中, 用户空间至少对应3GB虚拟空间, 而内核空间至多占1GB空间.(普遍情况)
- 内核空间的虚拟地址空间共享给所有进程使用.
- 当一个进程活跃时, 要么处于用户态, 要么处于内核态.
<!--more-->
- 当一个进程运行在用户态时, 意味着CPU正在运行用户空间中的代码.
- 用户态进程权限会受限, 并由CPU中的标志flag控制.
- 虽然内核内存地址可在进程的内存映射表中访问得到, 但用户空间代码并不被允许去访问内核空间代码.(不过可通过特殊方法做到).
- 当一个进程想要进行类似拷贝外部数据到它内存空间的操作(如打开某个文件), 它必须通过系统调用来与内核通讯.
- 每种CPU架构都有它独特方式去进行系统调用, 但底层基础都是一致的, 也就是:
- 一条指令被执行时, CPU将flag标志为"privileged mode", 同时跳到制定的内核空间地址, 也就是"系统调用入口地址".( 关于系统调用可参考另一篇文章)
- 现在系统调用已进入内核空间, 进程也就进入内核态并在内核空间内存中执行指令.
- 同样以系统调用为例, 要找到所请求的文件, 内核需要与文件系统驱动进行商议(确认文件在哪个位置) 并阻塞设备驱动 (从disk中加载必要的块) 或网络设备驱动 (从远程源中加载文件).
- 这些驱动可以是内建或额外加载的模块， 而重点是他们都是内核空间的一部分.
- 在系统调用请求内核拷贝模块代码和数据到内核空间, 并在内核态中运行它的初始化代码后, 模块加载便完成.
- 如果内核不能立刻完成请求处理则将进程置为睡眠状态, 当请求处理完成后系统调用再返回到用户态.
- 回到用户态意味着将CPU寄存器恢复到进入内核态之前的状态, 同时将CPU优先级置为none-privilege.
- 除了系统调用, 还有一些操作也可以使CPU进入内核态, 比如

1. 缺页错误- 如果进程尝试访问一个没有对应物理地址的虚拟内存地址时, CPU将进入内核态并跳到缺页错误处理模块, 判断虚拟地址是否有效, 如果有效则尝试创建一个物理页给该虚拟地址, 否则发出段错误信号(SIGSEGV).

2. 中断- 当CPU接收到来自硬件的中断指令时, 将进入内核态并执行中断处理方法。当内核完成指令处理时, CPU返回用户态并从上次代码中断位置继续执行.
