{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yelee/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-1.jpg","path":"background/bg-1.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-2.jpg","path":"background/bg-2.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-3.jpg","path":"background/bg-3.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-4.jpg","path":"background/bg-4.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/CSDN.png","path":"img/CSDN.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/AcFun.png","path":"img/AcFun.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Plunker.png","path":"img/Plunker.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/LOFTER.png","path":"img/LOFTER.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Coding.png","path":"img/Coding.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Quora.png","path":"img/Quora.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/SegmentFault.png","path":"img/SegmentFault.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/V2EX.png","path":"img/V2EX.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/TiddlyWiki.png","path":"img/TiddlyWiki.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/bilibili.png","path":"img/bilibili.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/golang_pprof.png","path":"img/golang_pprof.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/dataframe.png","path":"img/dataframe.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/pinned-octocat.svg","path":"img/pinned-octocat.svg","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/niconico.png","path":"img/niconico.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/golang_pprof_cpu.png","path":"img/golang_pprof_cpu.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/知乎.png","path":"img/知乎.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/新浪微博.png","path":"img/新浪微博.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/博客园.png","path":"img/博客园.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/udppackage.png","path":"img/udppackage.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/网易云音乐.png","path":"img/网易云音乐.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/简书.png","path":"img/简书.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/虾米音乐.png","path":"img/虾米音乐.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/豆瓣.png","path":"img/豆瓣.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/pc.js","path":"js/pc.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","path":"js/GithubRepoWidget.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/instagram.js","path":"js/instagram.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/mobile.js","path":"js/mobile.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-5.jpg","path":"background/bg-5.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-6.jpg","path":"background/bg-6.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/consul_archi.png","path":"img/consul_archi.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/tcppackage.png","path":"img/tcppackage.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/golang_pprof_heap.png","path":"img/golang_pprof_heap.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","path":"background/backup/bg-1.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","path":"background/backup/bg-3.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","path":"background/backup/bg-2.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","path":"background/backup/bg-4.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/avatar3.jpg","path":"img/avatar3.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/yelee/_config.yml","hash":"e688e8a8b1e4f6d1cc7fd4f07d67d5229da3d6eb","modified":1558073184601},{"_id":"themes/yelee/README.md","hash":"12bc9cdb68f51df81bcc36a5263e0a6c5860f646","modified":1500703875687},{"_id":"themes/yelee/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1500703875689},{"_id":"source/_posts/Threejs-get-child.md","hash":"ac7200c0110192f2aec87074eeb449fcc0ba40a7","modified":1572362450971},{"_id":"themes/yelee/languages/default.yml","hash":"80cc17267333753accc0b1c85a73678fedcbce76","modified":1500703875687},{"_id":"source/aboutme/index.md","hash":"e183469b3573a4b73366125ec59fa81c5a94f05a","modified":1529849185557},{"_id":"themes/yelee/languages/zh-Hans.yml","hash":"b5b2d20cde04db3773962284a002d025b09134b0","modified":1500703875688},{"_id":"themes/yelee/languages/en.yml","hash":"2c096d06c0af4ddf9c128fc8f77fb276b59a47fb","modified":1500703875688},{"_id":"themes/yelee/languages/zh-Hant-HK.yml","hash":"c38a95f5076ad951839aaf7748295d7eea277c61","modified":1500703875688},{"_id":"themes/yelee/languages/zh-Hant-TW.yml","hash":"f372cc0d758a7d8bbb885aa9756d607bec26469a","modified":1500703875688},{"_id":"themes/yelee/source/apple-touch-icon.png","hash":"c0fda117fa166d63b9eb690cc5e4fb2caaf493b3","modified":1500703875689},{"_id":"source/tags/index.md","hash":"595d07dc68e6ecca77fe38b425caefdf2e9d91cb","modified":1501740303672},{"_id":"source/404/index.md","hash":"ba4482e55221f6c6466d2435e9d66d9a644b5d83","modified":1501740315350},{"_id":"source/_posts/about/about.md","hash":"51851602a98538693728eea908e2ab877669d7c9","modified":1501658910881},{"_id":"themes/yelee/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1500703875689},{"_id":"themes/yelee/layout/layout.ejs","hash":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1500703875689},{"_id":"themes/yelee/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1500703875689},{"_id":"themes/yelee/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1500703875689},{"_id":"themes/yelee/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1500703875689},{"_id":"source/_posts/bigdata/data-developing-md.md","hash":"b291a5f4468e990f544c0f048d1d920de059a938","modified":1512118086563},{"_id":"themes/yelee/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1500703875689},{"_id":"themes/yelee/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1500703875689},{"_id":"source/_posts/bigdata/deployment-spark-on-yarn.md","hash":"772b0f12bcc2974e44543ef9c2dcb75f90984e9f","modified":1508138412892},{"_id":"source/_posts/bigdata/flume-kafka-deploy.md","hash":"e01c1b828d1be368a9ffeb9dc6ef7dde6b0adf04","modified":1508149065468},{"_id":"source/_posts/bigdata/es-backup-restore-md.md","hash":"4b6efe49a80fc0280a399a9420679b018d6f73c4","modified":1509420454070},{"_id":"source/_posts/bigdata/flume-spark-streaming.md","hash":"c56c294fed5569a4a59db0efc592eb8416e1b5d1","modified":1508392683113},{"_id":"source/_posts/bigdata/distributed-video-convert.md","hash":"07a6f9cb54bea32ea3461052fed481a0dc198cb0","modified":1511929078620},{"_id":"source/_posts/bigdata/hadoop-spark-errors.md","hash":"0146dce9a78b5b61428577692884ad4a0f81d344","modified":1528180893047},{"_id":"source/_posts/app/关于ionic3升级到ionic4.md","hash":"fe343ed40b237891a84567727f6a3e5b437fc721","modified":1546562309909},{"_id":"source/_posts/archi/CAS单点登录前后端分离.md","hash":"c9f1cfae668b53847413f7878ff860f32019fd40","modified":1533049425571},{"_id":"source/_posts/bigdata/基于Docker的Consul-官方镜像-集群部署指南.md","hash":"416866ab3ce3b67f9f80ff4b14d8b4c90c41280f","modified":1502072018394},{"_id":"source/_posts/archi/jaeger-deploy-on-ubuntu.md","hash":"73680c35090c351225f11da71692aef13c70bd32","modified":1529312786603},{"_id":"source/_posts/archi/microservice-SSO.md","hash":"5db2ca258f309656063f5ac9c069c98e8ff7f129","modified":1531915680683},{"_id":"source/_posts/archi/microservice-circuitbreaker.md","hash":"526382fe8027b2c90e27a79947e14b2a8e1259ae","modified":1529661891595},{"_id":"source/_posts/mysql/mysql_concurrent_query.md","hash":"d7383843d149e7ee25ddff1d551c05bbef3bc23c","modified":1502084830147},{"_id":"source/_posts/linux/Centos7快速搭建FTP服务.md","hash":"f00a4e40e4ce557104141aae7f716d1dda694fcd","modified":1534385461891},{"_id":"source/_posts/linux/devtech-overview.md","hash":"3ff4f107568d7a56f6608797eb19f40b39808746","modified":1509948032084},{"_id":"source/_posts/linux/UserSpace-vs-KernelSpace.md","hash":"b86bd385390e029fc016b819e2b9bacf5042836e","modified":1508913849317},{"_id":"source/_posts/encode/centos_zh.md","hash":"3eb23c9fea65eb9f05fc901fada4bfde4b3982a2","modified":1503208127995},{"_id":"source/_posts/encode/base64.md","hash":"3ba5f81eb101cb9f7e58c01cb6f97e9c149345ff","modified":1500791777117},{"_id":"source/_posts/network/Understand-TCP-IP-Stack.md","hash":"355262e4420f59cf6073fe4429818df19e177566","modified":1509009689584},{"_id":"source/_posts/network/Understand-TCP-IP-Stack2.md","hash":"ae328a181f7605cc4abd100fc39fb7a5764a322a","modified":1509961662061},{"_id":"source/_posts/network/Understand-TCP-IP-Stack3.md","hash":"29640514d816a5b20b3293a80ef9435fb42ca64f","modified":1510035366608},{"_id":"source/_posts/network/network-transport-layer.md","hash":"f511e99b73e8b064f407322be9fca7c04d217868","modified":1502769529205},{"_id":"source/_posts/java/springboot-on-vscode.md","hash":"31f0e3a0fa469c75842446adbc7418a1adf63b8c","modified":1529849111575},{"_id":"source/_posts/script/parallel-shell-md.md","hash":"20867f7d0a5975e7c8e2fbe90c10470876fe1625","modified":1512445384340},{"_id":"themes/yelee/source/background/bg-1.jpg","hash":"9a5241de4c880f13a278f6980bf11d4dfb214d82","modified":1500703875691},{"_id":"themes/yelee/source/background/bg-2.jpg","hash":"d1e0b92e8fa822e44d185b5e1bf94ab47bc98a0a","modified":1500703875691},{"_id":"source/_posts/java/springboot-gradle-mysql.md","hash":"96291af4a54b6aaba3aa242507a0d29deae1872e","modified":1530278249205},{"_id":"source/_posts/script/shell-compare-files.md","hash":"ead22c02ace34575bb5cfc61b7273f19255ecf47","modified":1506614595998},{"_id":"themes/yelee/source/background/bg-3.jpg","hash":"d476909f06fe8267c676952e3582bf9e9ff73585","modified":1500703875691},{"_id":"themes/yelee/source/background/bg-4.jpg","hash":"8e80d0b7786c3bf7b9648c0190719e78001e9eeb","modified":1500703875692},{"_id":"themes/yelee/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1500703875693},{"_id":"themes/yelee/source/css/_variables.styl","hash":"f429eb9bc9f0a270ec68c4f4c63903250746a01c","modified":1500703875694},{"_id":"themes/yelee/source/css/style.styl","hash":"b285f9a75abd09c7d06fe89e70f9e1819eac27dd","modified":1500703875695},{"_id":"themes/yelee/source/img/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1500703875695},{"_id":"themes/yelee/source/img/AcFun.png","hash":"df6b0fa39ced4dc988359fc7b7cd1e5403de08a6","modified":1500703875695},{"_id":"source/_posts/script/shell-curl-httpheader.md","hash":"8e8019ddf5cbd506e5d609a3bdd8242e7f8905ea","modified":1508818748706},{"_id":"themes/yelee/source/img/Plunker.png","hash":"14a0054b9b4a0e459987f34b9ab48ab22dbe5cf9","modified":1500703875695},{"_id":"themes/yelee/source/img/LOFTER.png","hash":"88670eaea8612839e9d6a40a3636e4231ab56c0f","modified":1500703875695},{"_id":"themes/yelee/source/img/Coding.png","hash":"afb4bce19bebf61e3c486fd5199369d6eb191b78","modified":1500703875695},{"_id":"themes/yelee/source/img/Quora.png","hash":"1a624ade0d07f2482b21bef1e2a5ddd0110ba352","modified":1500703875695},{"_id":"themes/yelee/source/img/SegmentFault.png","hash":"1afbc7e575e2e9ed9404be84a3f92f7ca8345a9c","modified":1500703875695},{"_id":"themes/yelee/source/img/avatar.png","hash":"e4bca3d60087cd6e775d8e2aa2bf0d35e3859592","modified":1500703875695},{"_id":"themes/yelee/source/img/V2EX.png","hash":"d0768de8555f9be0ee8ce956198cef454d4e4d7c","modified":1500703875695},{"_id":"themes/yelee/source/img/TiddlyWiki.png","hash":"b7f68f8f9c45561a9455aee0bfb80e35cae6f8df","modified":1500703875695},{"_id":"themes/yelee/source/img/bilibili.png","hash":"be37b7e9a091c8547b8ee8b9d29583af8ded61c0","modified":1500703875695},{"_id":"themes/yelee/source/img/golang_pprof.png","hash":"6dd94ffb6a2e1e8995c23e36dd8643a0195ac919","modified":1502448930323},{"_id":"themes/yelee/source/img/dataframe.png","hash":"1a43a9b03ec57ad914dfcb287bc27cb6018621e7","modified":1502767933085},{"_id":"themes/yelee/source/img/pinned-octocat.svg","hash":"5dec89dc9dbcebff4a2aeddb9426c7a8e237ca16","modified":946684800000},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","hash":"af987032f2171867bb58b165d2180eb5dcbea637","modified":1500703875695},{"_id":"themes/yelee/source/img/niconico.png","hash":"fabc7ca45e9ee5698db33a25de8b1f8a7c7d6723","modified":1500703875695},{"_id":"themes/yelee/source/img/golang_pprof_cpu.png","hash":"377d7745d765d6a6f28a343dc556151ce8177aed","modified":1502448930323},{"_id":"themes/yelee/source/img/知乎.png","hash":"ed6d3c304789e112d09f40784fa6add1f1a38bd6","modified":1500703875695},{"_id":"themes/yelee/source/img/新浪微博.png","hash":"7a145ed1daee0c172cda77098f4254fc21f9eeee","modified":1500703875695},{"_id":"themes/yelee/source/img/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1500703875695},{"_id":"themes/yelee/source/img/udppackage.png","hash":"551069851fa2307e5b6d800b128ed09636d90832","modified":1502767933094},{"_id":"themes/yelee/source/img/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1500703875695},{"_id":"themes/yelee/source/img/简书.png","hash":"5c91ee83cab4abe160240e09de345b6935c8cb37","modified":1500703875695},{"_id":"themes/yelee/source/img/虾米音乐.png","hash":"a0039b049779b1f37c0b0b91760943b7bf25c8f1","modified":1500703875695},{"_id":"themes/yelee/source/js/main.js","hash":"369774a7ff45a2e5117a796330a04aeb50a61fdf","modified":1500703875695},{"_id":"themes/yelee/source/img/豆瓣.png","hash":"f1fc97f98612bcdf4a681542e5388483b40a5300","modified":1500703875695},{"_id":"themes/yelee/source/js/pc.js","hash":"bc289c5dc610e2a34d308daeb9adea96d01f7788","modified":1500703875695},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","hash":"624e81a3b0e57495b0c0e0b3e056296c6e8ae5df","modified":1500703875695},{"_id":"themes/yelee/source/js/toc.js","hash":"72ba1228fc1a44df45b8f4b562eba78594f13016","modified":1500703875696},{"_id":"themes/yelee/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1500703875695},{"_id":"themes/yelee/source/js/mobile.js","hash":"8abc32d18f16db56f51caad607cffb6ca756eca9","modified":1500703875695},{"_id":"themes/yelee/source/js/search.js","hash":"b456aaab98bbc3b0906f8a16d1e6e4f74dfcffda","modified":1500703875696},{"_id":"source/_posts/python/curl-vs-python-requests.md","hash":"c39acb4d8074cdc14a3e607af9d90b573917db4f","modified":1524117191403},{"_id":"source/_posts/python/python-map-function.md","hash":"9a99a0c86eb580cc2c7e77772bc0426d945679a8","modified":1502378625225},{"_id":"source/_posts/python/python-upload-download-large-file.md","hash":"7342da91d49924ee4051561aede587efc3fd3435","modified":1503153715737},{"_id":"source/_posts/python/python3-aiohttp.md","hash":"eae3d87f30c710ef32a53cf70f9f3b1c2d657df0","modified":1510725286535},{"_id":"source/_posts/ops/Centos7安装ElasticSearch6.md","hash":"ffd218cc88d7f222f296aead5996c7bc4b7e7c4e","modified":1537348870395},{"_id":"source/_posts/python/python-pika-broken-pipe.md","hash":"eb272a6a7f755be7ae38f3713f60d7391a6e03c4","modified":1503141602241},{"_id":"source/_posts/ops/Nginx如何配置跨域-多域名.md","hash":"0e285df36519d8b99257c2c779888b33f4ee53d6","modified":1539048356856},{"_id":"source/_posts/golang/a-way-to-understand-goroutine.md","hash":"8fafe3020a221f83bc1ad1ea35791a6756b70036","modified":1510279366210},{"_id":"source/_posts/golang/golang-json-rpc.md","hash":"6a9655542e24db7360e3fc5d5b4d8eb539f6773b","modified":1502359816094},{"_id":"source/_posts/golang/golang-memory-management.md","hash":"485d7c3810e0bc37445dfcdf5247ea844c99533d","modified":1510798265694},{"_id":"source/_posts/golang/golang-pprof性能分析工具.md","hash":"4e4a9beaca38d51557b88acc12c92f3d2aab5dff","modified":1502449214151},{"_id":"source/_posts/golang/golang-simple-uploadsrv.md","hash":"5fd30cd3e1cc3504ddbb100bc8e5fc9cf6ba3beb","modified":1504844360025},{"_id":"source/_posts/golang/golang-tech-examination.md","hash":"3b05c7821ad1391fb3969a07ac731bb829f5e365","modified":1510620401257},{"_id":"source/_posts/golang/golang-tech-keys.md","hash":"22bc19eeb6d0826cfa44ce691e03de50496f5c5f","modified":1510821483485},{"_id":"source/_posts/golang/golang_array-slice.md","hash":"1f35f3fd506f13bdd713c10d34f6392c01665663","modified":1502084830146},{"_id":"source/_posts/golang/golang_channel.md","hash":"9ee1ccd321012b2fbd75860fce2c2acdd04290b6","modified":1502084830146},{"_id":"source/_posts/golang/golang_function.md","hash":"9bed7e3694772ccb9e50e36fc328c688782d8356","modified":1502084830146},{"_id":"source/_posts/golang/golang_gRPC.md","hash":"496617d1f97094b9821e71de1fc57fe9c2a385fa","modified":1502084830146},{"_id":"source/_posts/golang/golang_goroutine.md","hash":"8c63262c813a64c82f1f9a564a300ac6a72bb334","modified":1502084830146},{"_id":"source/_posts/golang/golang_interface.md","hash":"189fb036b2dbd2fd546f0dc5a10fa00048d8c6e3","modified":1502084830146},{"_id":"source/_posts/golang/golang_http-server.md","hash":"96becc852c7d024a8ae5c8104f9f72d3be6579bc","modified":1502084830146},{"_id":"source/_posts/golang/golang_map-set.md","hash":"443180c06997219541b3cc19ac557943dc0a6c88","modified":1502084830147},{"_id":"source/_posts/golang/golang-工作池workerpool.md","hash":"fcbc5ec783982e12bbf98a04ed1d87f34d2a8336","modified":1502360436402},{"_id":"source/_posts/golang/golang-异常处理.md","hash":"333960ce94f7048e3c36fd2d33b34ab9ac688f54","modified":1502344673396},{"_id":"source/_posts/golang/golang_pointer.md","hash":"5a1379684f65006091edaaab9ec68f58d22069db","modified":1502074717447},{"_id":"source/_posts/golang/goraft.md","hash":"4173dc49aab49c6704864f82992c30b3904d81d7","modified":1527492419390},{"_id":"source/_posts/golang/grpc-jaeger.md","hash":"4ee88a676445876c4cc87f2f4fbdb31367ceb7e1","modified":1529312858149},{"_id":"source/_posts/golang/parallel-download-file-md.md","hash":"65aef7f71099ef21d6599404a4983699c989d038","modified":1514972681792},{"_id":"themes/yelee/source/background/bg-5.jpg","hash":"e4a3631b6b0f94ebce30a6f01ecb2b6ed7cfdb0b","modified":1500703875692},{"_id":"themes/yelee/source/background/bg-6.jpg","hash":"51b427f07ffc6f2ad97651f23cc16e8f19ed02f9","modified":1500703875693},{"_id":"themes/yelee/source/img/consul_archi.png","hash":"420ce04ab6439e1f615adc878c259568ac2d4a90","modified":1502379551365},{"_id":"themes/yelee/source/img/tcppackage.png","hash":"a758f22d612ee27578eb6a700ec3df12be13ace7","modified":1502767933085},{"_id":"themes/yelee/source/img/golang_pprof_heap.png","hash":"65c69fc1b61d263e0ad4e337dc38ac9861a33961","modified":1502448930323},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","hash":"31d7bb15211000c05656899302f8ec9ee3de0e9f","modified":1500703875689},{"_id":"source/_posts/golang/token-bucket.md","hash":"c6661821d6d8fb58bad8e0abb532cb52cd2a9931","modified":1529312901141},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","hash":"1a06d3a660bfb99b62d760e4e1e09de168a4c74c","modified":1500703875690},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","hash":"7ae358f3ab8b41558444053400e796c41b3ba0e2","modified":1500703875690},{"_id":"themes/yelee/layout/_partial/archive-post.ejs","hash":"0ecc2ad07b4abad80f564ac1858c50bcbdff34f8","modified":1500703875688},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","hash":"6df1383d0f6134016d844df9abb740a6e0c0b2c5","modified":1500703875690},{"_id":"themes/yelee/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/article.ejs","hash":"afd85b362d732fa9b439af7dc44b657d0d1aae3d","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/background.ejs","hash":"aeef39abef66ee0bd6c9efe856eaeb1b81416d41","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/head.ejs","hash":"55e90c3d5de6d7ffcfe26c4dc22189a7a27b6651","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/after-footer.ejs","hash":"d85bec9089abdf962387ab0adc0f2a735e87d9d4","modified":1539075949034},{"_id":"themes/yelee/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/left-col.ejs","hash":"90fd7c763faf8d64d58612f592cbacbefdaea161","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/ie-updater.ejs","hash":"3e5f2e41bbb1a5b93a8a7a6cb9ccd191ced54408","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/mobile-nav.ejs","hash":"306be982577b0ef968f855d0dfeaab6b180b8a50","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/open-in-new-tab.ejs","hash":"a6046bc322ce9194faa9559c70e1618a7e1e4cbc","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/post-nav-button.ejs","hash":"0a98bffdd14f6677721841c0ac4487a86c77266c","modified":1500703875689},{"_id":"themes/yelee/layout/_partial/page.ejs","hash":"cfce60062cdb60893baeda7fa0266ae4086c2bc8","modified":1500703875689},{"_id":"themes/yelee/layout/_partial/footer.ejs","hash":"9f5f688fc6e64fbef2dd3b96068bbc7d0111457a","modified":1559095925363},{"_id":"themes/yelee/layout/_partial/scrolling-button.ejs","hash":"c5e1c3a8e1e6b0d927ac25a7fb8720ee7ac83ad8","modified":1500703875689},{"_id":"themes/yelee/layout/_partial/tab-title-change.ejs","hash":"1bebab6eb7a849319cd48fe051f3c71b9349a723","modified":1500703875689},{"_id":"themes/yelee/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1500703875694},{"_id":"themes/yelee/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1500703875694},{"_id":"themes/yelee/source/css/_partial/archive.styl","hash":"102c23dbb6cde3cbfca3b151c742e0d77911186e","modified":1500703875693},{"_id":"themes/yelee/source/css/_partial/article.styl","hash":"190828c822096bb3098a7d14c3340eb004057aa0","modified":1500703875693},{"_id":"themes/yelee/source/css/_partial/footer.styl","hash":"a419108f1b820c59fcc56d218bfaaa4ffc4f1d4d","modified":1500703875694},{"_id":"themes/yelee/layout/_partial/tag-cloud-page.ejs","hash":"432ded02bcc1f0d52cd833e8eeac688ee886169a","modified":1500703875689},{"_id":"themes/yelee/source/css/_partial/highlight.styl","hash":"18c337238f3d3fd26349909515396310c9e0f45b","modified":1503389358474},{"_id":"themes/yelee/source/css/_partial/instagram.styl","hash":"a093443add2f529396d6b6bdef1675bc3acf3958","modified":1500703875694},{"_id":"themes/yelee/source/css/_partial/main.styl","hash":"405db411896f3c7de9e7dd27e58c920fb90b9834","modified":1500703875694},{"_id":"themes/yelee/source/css/_partial/mobile-slider.styl","hash":"39db458d4e9f6973afc1390b4d3fc0291fff4c40","modified":1500703875694},{"_id":"themes/yelee/source/css/_partial/mobile.styl","hash":"dfb20f2515a26d75e42fe09741e91cc889426b11","modified":1500703875694},{"_id":"themes/yelee/source/css/_partial/page.styl","hash":"ca3f871adf8fdb296e4394070605dded53d93cb2","modified":1500703875694},{"_id":"themes/yelee/source/css/_partial/scroll.styl","hash":"f32deb9192568a2ea789d77a23a08d07f4e57d59","modified":1500703875694},{"_id":"themes/yelee/layout/_partial/toc.ejs","hash":"7ee88b1a98eea5cbd44c0f9a11b86b46aa2d6752","modified":1500703875689},{"_id":"themes/yelee/source/css/_partial/share.styl","hash":"88c1277397b71eb1f3473a94d9542314f983cd09","modified":1500703875694},{"_id":"themes/yelee/source/css/_partial/tagcloud.styl","hash":"b38b275728bfe11809defe1077b03cb423c3c92f","modified":1500703875694},{"_id":"themes/yelee/source/css/_partial/toc.styl","hash":"eb19bbd37fc2c1abd238e2ed96b22cb1aae41ab7","modified":1500703875694},{"_id":"themes/yelee/source/css/_partial/search.styl","hash":"fcaa5deaa654aaec69e267e23b49df07f84f633a","modified":1500703875694},{"_id":"themes/yelee/source/img/avatar3.jpg","hash":"07a29a8aada9ef73bf6cc150bf1d88df4bc9a89b","modified":1502085714023},{"_id":"themes/yelee/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1500703875694},{"_id":"themes/yelee/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1500703875694},{"_id":"themes/yelee/layout/_partial/mathjax.ejs","hash":"ce868f8b2b5b377cadc270e3a5bb5826f8bf0dee","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/post/category.ejs","hash":"08c8d98bc6a73d3f72a3b0b30521ff28e1b657a7","modified":1500703875689},{"_id":"themes/yelee/layout/_partial/post/date.ejs","hash":"329ed372296a86bce73ff8936af5601723fdd70a","modified":1500703875689},{"_id":"themes/yelee/layout/_partial/post/share.ejs","hash":"58c2db54a9867aaafe68a7f052b04701c7c3df0f","modified":1500703875689},{"_id":"themes/yelee/layout/_partial/post/nav.ejs","hash":"6f531dbc9cc7ae42d2486d6707f826cfe7d9d8bc","modified":1500703875689},{"_id":"themes/yelee/layout/_partial/post/tag.ejs","hash":"7d2693a1162bf26e4b1ae9b789e0b2a2637ddbd5","modified":1500703875689},{"_id":"themes/yelee/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1500703875689},{"_id":"themes/yelee/layout/_partial/comments/disqus.ejs","hash":"df7ee469b648b12b5ee3104ef513d54cbb7418af","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/comments/duoshuo.ejs","hash":"e7f12f1246a67a5b556c2d5b37dc78733f1cf15a","modified":1500703875688},{"_id":"themes/yelee/source/css/_partial/customise/blockquote.styl","hash":"5e6edb9ad49288743ed550a2bd8c9a3c8e208455","modified":1500703875693},{"_id":"themes/yelee/source/css/_partial/customise/code-block.styl","hash":"4db1a992a06fd92b779f0afc9bb8bb3667bdb101","modified":1500703875693},{"_id":"themes/yelee/source/css/_partial/customise/color-scheme.styl","hash":"b58262a9f8903e75df431291745e19ccd8ff243a","modified":1500703875693},{"_id":"themes/yelee/source/css/_partial/customise/heading.styl","hash":"f309241c1daa9b6c04aa04063307537c219fdd59","modified":1500703875693},{"_id":"themes/yelee/source/css/_partial/customise/inline-code.styl","hash":"a15292b2b3541ea022c0fb7441875192dee5ad9d","modified":1500703875693},{"_id":"themes/yelee/source/css/_partial/customise/list.styl","hash":"b1e564ed76d6e892556b61b4278270fc9eeea961","modified":1500703875693},{"_id":"themes/yelee/source/css/_partial/customise/social-icon.styl","hash":"49363265b0f68f7d2528561bd869635f83261a57","modified":1539076018332},{"_id":"themes/yelee/layout/_partial/comments/count-comment.ejs","hash":"d3c1b0b31db9d80e857f3054d010ea49c0f88134","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/comments/click2show.ejs","hash":"678f3aec2980d378ea44be60eec3eb504c8ba668","modified":1500703875688},{"_id":"themes/yelee/layout/_partial/comments/youyan.ejs","hash":"bcf2070587645afd20a4eb046b9c8bb9c44d1cf5","modified":1500703875688},{"_id":"public/404/index.html","hash":"5027fad7a903ab8c56e055172f3f4e6d4057b40b","modified":1572362461599},{"_id":"public/aboutme/index.html","hash":"96a12aba55af52f9dbd4d3389f76e4401ee64638","modified":1572362462041},{"_id":"public/tags/index.html","hash":"abc134338dbd70784407efdf2873f31281772a94","modified":1572362462169},{"_id":"public/2019/01/04/app/关于ionic3升级到ionic4/index.html","hash":"676e00e13fc3ca97a7c0a571513b39f8e2a9fd0e","modified":1572362462174},{"_id":"public/2019/10/29/Threejs-get-child/index.html","hash":"797beeeb698859ac77c8fe5fde6166410dfd6003","modified":1572362464221},{"_id":"public/2018/10/09/ops/Nginx如何配置跨域-多域名/index.html","hash":"48a2c551ce3a7d84bb1b71447966c94e3814b46b","modified":1572362464992},{"_id":"public/2018/08/16/linux/Centos7快速搭建FTP服务/index.html","hash":"43280866ea950c2143fe841a7ed2775c4978ab6f","modified":1572362465022},{"_id":"public/2018/09/19/ops/Centos7安装ElasticSearch6/index.html","hash":"64530d489a232d9f706d04498a35082ab8780c0d","modified":1572362465022},{"_id":"public/2018/07/31/archi/CAS单点登录前后端分离/index.html","hash":"a97574dd953695eeed1eb0adecb78830119b1535","modified":1572362465022},{"_id":"public/2018/06/29/java/springboot-gradle-mysql/index.html","hash":"98c7803ad780273d4dcfec119e653bd9c704cdcd","modified":1572362465022},{"_id":"public/2018/07/18/archi/microservice-SSO/index.html","hash":"87fdba1a0008c8847cade07f81e1f70f7b46a2eb","modified":1572362465022},{"_id":"public/2018/06/23/java/springboot-on-vscode/index.html","hash":"2bea7d5459c6d8b7e575b799a86fe4fbab1147cf","modified":1572362465022},{"_id":"public/2018/06/22/archi/microservice-circuitbreaker/index.html","hash":"73e71f73053282e51c6ee8ac3ea1809160819332","modified":1572362465022},{"_id":"public/2018/06/18/archi/jaeger-deploy-on-ubuntu/index.html","hash":"84a9be6354c30cd059ade4b2cc23d4287e0679c2","modified":1572362465022},{"_id":"public/2018/06/01/golang/token-bucket/index.html","hash":"47c0e0da30d2501d995500a3b4932d855cd3d7c7","modified":1572362465024},{"_id":"public/2018/06/17/golang/grpc-jaeger/index.html","hash":"c28c9c345396f53cd6024f2596666a6873fba247","modified":1572362465024},{"_id":"public/archives/2015/index.html","hash":"c08584b2d7e9ea64e019607fd5e3de3745cd6a33","modified":1572362482663},{"_id":"public/archives/2016/02/index.html","hash":"50bab1535ebeaa226dbbc7fa204f1d7c096dc3d8","modified":1572362483358},{"_id":"public/archives/2016/01/index.html","hash":"893d8ac2c4fc8f97f146cfbd908cf4cd18f14701","modified":1572362483368},{"_id":"public/2018/04/19/python/curl-vs-python-requests/index.html","hash":"cd1c3c4e4d95cf3ff894d8ed5f2540eac85962b5","modified":1572362483368},{"_id":"public/2018/05/28/golang/goraft/index.html","hash":"474e9a65e0ebf88861e06186b0f7d4083f0becf0","modified":1572362483369},{"_id":"public/2017/12/05/script/parallel-shell-md/index.html","hash":"725d55eae2bd24106c0e25e157b4367567c5da7d","modified":1572362483369},{"_id":"public/2018/01/03/golang/parallel-download-file-md/index.html","hash":"43cbcd4b3e45d799bbbdc33af0f149e755921516","modified":1572362483369},{"_id":"public/2017/12/01/bigdata/data-developing-md/index.html","hash":"520758218088ca8c3f3815135a3c789492f29131","modified":1572362483369},{"_id":"public/2017/11/29/bigdata/distributed-video-convert/index.html","hash":"aadf2c7f2f8e47776fc9f22ce91ab39a1544b0d2","modified":1572362483369},{"_id":"public/2017/11/16/golang/golang-memory-management/index.html","hash":"577ea9366d24cad885328c2bd6ad4c9c7bb750f4","modified":1572362483369},{"_id":"public/2017/11/14/golang/golang-tech-keys/index.html","hash":"38a10301f88c09cbf49bee2de9c0f043f93675a2","modified":1572362483369},{"_id":"public/2017/11/14/golang/golang-tech-examination/index.html","hash":"383c019497ad17106ba02546cd6c8b4baad819fd","modified":1572362483369},{"_id":"public/2017/11/07/network/Understand-TCP-IP-Stack3/index.html","hash":"08f9ff02c6b50d3709aa5c192b3a274fa2a516ca","modified":1572362483369},{"_id":"public/2017/11/06/network/Understand-TCP-IP-Stack2/index.html","hash":"be4eac590d1ad6a9703734fa1692890c42ddbabb","modified":1572362483369},{"_id":"public/2017/11/10/golang/a-way-to-understand-goroutine/index.html","hash":"38e36f191c78172254560a80c340f956ec9b2810","modified":1572362483369},{"_id":"public/2017/11/03/linux/devtech-overview/index.html","hash":"a710557bbcc39933c6a3ecda558c63c98a732cc2","modified":1572362483369},{"_id":"public/2017/10/26/network/Understand-TCP-IP-Stack/index.html","hash":"f330687368fddd87a0f7f30cef5342eebc023232","modified":1572362483369},{"_id":"public/2017/10/25/linux/UserSpace-vs-KernelSpace/index.html","hash":"61f8ceac0458d92977b2ebe5e41d7e631e575504","modified":1572362483369},{"_id":"public/2017/10/31/bigdata/es-backup-restore-md/index.html","hash":"98614482db43665698ea43ec09fd05dd601d9738","modified":1572362483369},{"_id":"public/2017/10/24/script/shell-curl-httpheader/index.html","hash":"5e55962e7a1d7da24f060dcf3371fd49ca3b31aa","modified":1572362483369},{"_id":"public/2017/10/16/bigdata/flume-kafka-deploy/index.html","hash":"daa72ae55a4b169a8dddb12518b3554274675189","modified":1572362483369},{"_id":"public/2017/10/19/bigdata/flume-spark-streaming/index.html","hash":"2076982452695fbdb2f8bc2050470d080afd0b13","modified":1572362483369},{"_id":"public/2017/10/16/bigdata/hadoop-spark-errors/index.html","hash":"205b738b80417d6d6dbbecc677a2639074ecda5e","modified":1572362483369},{"_id":"public/2017/09/05/python/python3-aiohttp/index.html","hash":"d50734e09b7510857c6d7453b2d4424e4d812a42","modified":1572362483370},{"_id":"public/2017/09/07/golang/golang-simple-uploadsrv/index.html","hash":"aac9dc81774d10ba786ea71cb62c5666a215549d","modified":1572362483370},{"_id":"public/2017/09/28/script/shell-compare-files/index.html","hash":"cf0cc969e4a99fb117a5a347193e0c5df608e9b2","modified":1572362483370},{"_id":"public/2017/08/19/python/python-upload-download-large-file/index.html","hash":"7d5e04fab31a4dd3154478c73c54ce2e764d9ff3","modified":1572362483370},{"_id":"public/2017/08/19/python/python-pika-broken-pipe/index.html","hash":"152753e19857da5540d505be7dd39f373eb02eef","modified":1572362483370},{"_id":"public/2017/08/06/mysql/mysql_concurrent_query/index.html","hash":"79dc84a80fe8bc2829a3bf4326f1e3251352989d","modified":1572362483370},{"_id":"public/2017/07/23/encode/base64/index.html","hash":"499d3fd066902ae81027ed1272df03ef14da4f2f","modified":1572362483370},{"_id":"public/2017/07/31/bigdata/基于Docker的Consul-官方镜像-集群部署指南/index.html","hash":"2ead4dc6bebd25c8fc17df98b599f031a5762985","modified":1572362483370},{"_id":"public/2017/07/23/encode/centos_zh/index.html","hash":"40f72326ec0e3fac726544648640ba41cdabdf3f","modified":1572362483375},{"_id":"public/2017/02/01/golang/golang_map-set/index.html","hash":"c7286e24dd13b5424af88adc3f961a595f6390bb","modified":1572362483375},{"_id":"public/2017/02/09/golang/golang_gRPC/index.html","hash":"fc8de9dfa8118d2e9bdd47a760935ac73329b5b1","modified":1572362483376},{"_id":"public/2017/01/30/golang/golang_array-slice/index.html","hash":"bf6a4c0c8f021adc07fcf4397ee0d7ce3b8f04c0","modified":1572362483376},{"_id":"public/2016/12/03/golang/golang_http-server/index.html","hash":"1c276b737804ea9a874db400884e7661a814908f","modified":1572362483376},{"_id":"public/2016/12/16/bigdata/deployment-spark-on-yarn/index.html","hash":"505c614b4687bb18361c673d02e4742dbfa87b22","modified":1572362483376},{"_id":"public/2016/08/15/network/network-transport-layer/index.html","hash":"8cf9a887c0051529b7f078852bb83c2ea3c42532","modified":1572362483376},{"_id":"public/2016/08/11/golang/golang-pprof性能分析工具/index.html","hash":"f40d3b3903e65b0759c79df5aa8ff7d6593b4ff1","modified":1572362483376},{"_id":"public/2016/04/05/golang/golang_pointer/index.html","hash":"eac4b288639e57ba13df290dc8779064d6ded361","modified":1572362483376},{"_id":"public/2016/04/05/python/python-map-function/index.html","hash":"b0cde495acc4fe064ac9f85ee7ab9b26b07a259c","modified":1572362483376},{"_id":"public/2016/03/15/golang/golang-工作池workerpool/index.html","hash":"3281a10bef0aac5f63517ea17afbb2cef028454e","modified":1572362483376},{"_id":"public/2016/03/12/golang/golang-json-rpc/index.html","hash":"1e06b407f896f37ba95850aec4bf33a469f4396d","modified":1572362483376},{"_id":"public/2016/03/04/golang/golang_channel/index.html","hash":"3b5270f819fe0b2e486592f9d94f7d949505e0d3","modified":1572362483376},{"_id":"public/2016/03/10/golang/golang-异常处理/index.html","hash":"89b7dd84a4956543c72db42cdfe898ba6314113b","modified":1572362483376},{"_id":"public/2016/03/03/golang/golang_goroutine/index.html","hash":"76523c082cbc6a6517594fa05a326c13753b4e99","modified":1572362483376},{"_id":"public/archives/index.html","hash":"0838cd7cb65a94bc3ebd85c63f549e44f5ca892e","modified":1572362483376},{"_id":"public/2016/02/07/golang/golang_function/index.html","hash":"e0fb30745ce549137f2b069f872f6475215c5d12","modified":1572362483377},{"_id":"public/archives/page/2/index.html","hash":"95ddfeb324d8ce85e1b066dc964f6a6d8ac7c7ea","modified":1572362483377},{"_id":"public/2016/01/02/golang/golang_interface/index.html","hash":"3cc9edef42010f05d08c970394db65647e91f9bb","modified":1572362483377},{"_id":"public/archives/page/5/index.html","hash":"8a5596abfe0d2a29585697a4e4bcd1d8c2ce2aa3","modified":1572362483377},{"_id":"public/2015/07/22/about/about/index.html","hash":"23adfaf1954f09bf7d15635068a9a772c48800fa","modified":1572362483377},{"_id":"public/archives/page/3/index.html","hash":"0297c29b9f8b8638f21f2c1b98931dc400f30521","modified":1572362483377},{"_id":"public/archives/page/4/index.html","hash":"388a42fcc30886bf71f91a32a0f098dacd65164f","modified":1572362483377},{"_id":"public/archives/2016/index.html","hash":"c137670d6cb312e4a091c8f4e490a90ea6eb5fac","modified":1572362483377},{"_id":"public/archives/page/6/index.html","hash":"7306a1806e19231bc30844cf921e54e758eb3932","modified":1572362483377},{"_id":"public/archives/2015/07/index.html","hash":"2957707a0d7dde64c0df66a1f5536aa5d8c60186","modified":1572362483419},{"_id":"public/archives/2017/01/index.html","hash":"ff45d95f6b83301e6693704c63000a8ec5d96b81","modified":1572362483443},{"_id":"public/archives/2018/05/index.html","hash":"6933ae569f1dbdda4fac181e3f371eeadeb348d2","modified":1572362483444},{"_id":"public/archives/2018/01/index.html","hash":"127287b45c4f63a576b0d1165c3b11477cfa43fd","modified":1572362483445},{"_id":"public/archives/2018/04/index.html","hash":"956cbd4a25b6fd7c29c6d0a11f00371cb0248e12","modified":1572362483445},{"_id":"public/archives/2018/08/index.html","hash":"d18ae166e3237b689588849f1ee9bd740397c186","modified":1572362483445},{"_id":"public/archives/2018/10/index.html","hash":"6a4243e565361b4f5f2136e6c383d34b36330fd1","modified":1572362483445},{"_id":"public/archives/2018/09/index.html","hash":"9f78373b06f3e4ca4148aa4668a223795d07e088","modified":1572362483445},{"_id":"public/archives/2019/01/index.html","hash":"12264e8c35615a1f571e707f6b096d20f892dd76","modified":1572362483445},{"_id":"public/tags/flume-spark-streaming/index.html","hash":"e2d4e76dc58f26c000a3d18fa2234dd11f870e7a","modified":1572362483445},{"_id":"public/tags/elasticsearch-备份恢复/index.html","hash":"952f92f6afbca598fb2734ed37d021673514f7c4","modified":1572362483445},{"_id":"public/tags/flume-kafka/index.html","hash":"1e9a50f09ec64db4812ed5e2d5e92ee46b500fda","modified":1572362483445},{"_id":"public/tags/视频/index.html","hash":"36533acd7d005da7ecef68fcd4df08d392e2633e","modified":1572362483446},{"_id":"public/tags/ionic/index.html","hash":"009218114833d8af1034b35b3f996dcef148995c","modified":1572362483446},{"_id":"public/tags/consul/index.html","hash":"52762240eee0569dd89b321cf897cf1d72a5dc16","modified":1572362483446},{"_id":"public/tags/spring/index.html","hash":"ee85cd21f60e87f66c95a830665a38cfe4f9a6f8","modified":1572362483446},{"_id":"public/tags/docker/index.html","hash":"39b7288b023bf651463c2acd4fbe559ccf0a760a","modified":1572362483446},{"_id":"public/tags/mysql/index.html","hash":"8a021c9918e92aa008e15dcf4092daf6f5ea7e24","modified":1572362483446},{"_id":"public/tags/Centos-DevOps/index.html","hash":"8c970d7f2ebd194231cfcd451883ce3acfef4a3d","modified":1572362483446},{"_id":"public/tags/OS-kernel/index.html","hash":"08d51ecf061f0e0766a3a1fd69b18f79bd8a6e57","modified":1572362483446},{"_id":"public/tags/linux-kernel/index.html","hash":"0bfb781033236cac4ded6a5f1669f7ad2e980ef3","modified":1572362483446},{"_id":"public/tags/springboot/index.html","hash":"bf7c980630ecaefde3ad7799cdb815577940d849","modified":1572362483446},{"_id":"public/tags/nginx/index.html","hash":"22ca22ef7eac0856995e56f14ffd0d3c59196b3e","modified":1572362483446},{"_id":"public/tags/elasticsearch/index.html","hash":"3eeed5e04ea6b3ba31cf9cf968cfa66661a0db1d","modified":1572362483446},{"_id":"public/archives/2016/03/index.html","hash":"cc654d6c358136bf247b31d4a26e8c459e7b90e4","modified":1572362483446},{"_id":"public/archives/2016/04/index.html","hash":"b6093a2dd150bb119fc7def58ac8e8771e459b6a","modified":1572362483446},{"_id":"public/archives/2016/08/index.html","hash":"a3b151c429ca6c4f94b807ec74b02a0ee9dc69b9","modified":1572362483446},{"_id":"public/archives/2016/12/index.html","hash":"89adaeaf6cd9b69669ed52fbfd0746f74dff6b36","modified":1572362483446},{"_id":"public/archives/2016/page/2/index.html","hash":"85fac34ee19910b3978df1506d63f2707b966e03","modified":1572362483446},{"_id":"public/archives/2017/index.html","hash":"b5f3e0e95b8d0e5f266bf53dcb70e1fea3ff395e","modified":1572362483446},{"_id":"public/archives/2017/02/index.html","hash":"ed3929b64792bfc3e299b2ebdc83d0ab95d3cb89","modified":1572362483446},{"_id":"public/archives/2017/07/index.html","hash":"62b90adc9e91a890089220280afacadb3216121b","modified":1572362483446},{"_id":"public/archives/2017/page/2/index.html","hash":"8c488cadd3e7100743c6a47f9958f012b07d76e5","modified":1572362483446},{"_id":"public/archives/2017/08/index.html","hash":"27eb587ed11507db269c34637118de376d3e1a25","modified":1572362483446},{"_id":"public/archives/2017/page/3/index.html","hash":"8f5119cde764a7a902e70dfe66a359bf9cd95b50","modified":1572362483446},{"_id":"public/archives/2017/10/index.html","hash":"537a2807afd5a5dc663544d27d0cee6ac263315d","modified":1572362483446},{"_id":"public/archives/2017/09/index.html","hash":"87b9cfe6a64d7992471d5f9a51825bb715f185fe","modified":1572362483446},{"_id":"public/archives/2017/11/index.html","hash":"bc1285cafd421fe1edde8e368ae6f0f08dddd944","modified":1572362483446},{"_id":"public/archives/2017/12/index.html","hash":"d8c6a126cb2dd38aca30a4d38cc7474629f2966c","modified":1572362483446},{"_id":"public/archives/2018/index.html","hash":"11d394788304ea5a02c0e5fdf788d5109601949e","modified":1572362483447},{"_id":"public/archives/2018/page/2/index.html","hash":"e5847ebce2d2734c8a4e4c672c73f78cdfb18f2c","modified":1572362483447},{"_id":"public/archives/2018/06/index.html","hash":"85244ba5f8b4e2ceb73588bc8149dd22754d5b77","modified":1572362483447},{"_id":"public/archives/2018/07/index.html","hash":"694aac1ee9e8c1f853cd2d489320a2e0cd95fc94","modified":1572362483447},{"_id":"public/index.html","hash":"9b72793e3d1162f3cf62e67e074afbb65dc830bb","modified":1572362483447},{"_id":"public/page/2/index.html","hash":"75ea39e015f4b817f8c6fe091143a91df745aa41","modified":1572362483447},{"_id":"public/page/3/index.html","hash":"ea8aab16041e4455ccafa41c4a49b1b84bd910d5","modified":1572362483447},{"_id":"public/archives/2019/index.html","hash":"fa7342d7ad15856d4c36f4c65b49aea83c287278","modified":1572362483447},{"_id":"public/page/4/index.html","hash":"7c10fe6b84cf3dd89e64298a97790e10e44a8ff2","modified":1572362483447},{"_id":"public/page/5/index.html","hash":"0bee2585e7f230e428e86f19d720f63b61bf9ca6","modified":1572362483447},{"_id":"public/page/6/index.html","hash":"09701fb434fa5556ec2460c78d96f5095b8c422d","modified":1572362483447},{"_id":"public/tags/bigdata/index.html","hash":"0253d812ec9d94f390553d7f49464e17f2512f3d","modified":1572362483447},{"_id":"public/tags/tracing/index.html","hash":"b0c5688d6ca9a76c9ecc05ef9dd1670928397a17","modified":1572362483447},{"_id":"public/tags/golang/index.html","hash":"d84c9ade1fb019377ccffe52346756ef6ae09e8c","modified":1572362483447},{"_id":"public/tags/microservice/index.html","hash":"8592ccf6c1403f8aac978d3bee15632060764e44","modified":1572362483447},{"_id":"public/tags/golang/page/3/index.html","hash":"4e17670c02a28eba861131d011d877e709dc11b2","modified":1572362483447},{"_id":"public/tags/golang/page/2/index.html","hash":"2403e0aeb64bd3baefaf29d8c91ee6d830aa65b5","modified":1572362483447},{"_id":"public/tags/networking/index.html","hash":"9690d42c34666b1737064ab2a07dc0f654c7cfb7","modified":1572362483447},{"_id":"public/tags/java/index.html","hash":"a8d05e00355a550f84ba9f986a0814f12e98ae29","modified":1572362483447},{"_id":"public/tags/python/index.html","hash":"4bef12f8ed3453b11afed98a9fe8b81fc7ff39a2","modified":1572362483447},{"_id":"public/tags/shell/index.html","hash":"2c6e69b3a5d04c2fd0db914f63ebac8176c767d4","modified":1572362483447},{"_id":"public/archives/2019/10/index.html","hash":"30bbadc166f6773dcc72f02c3cbbbe45aa8c2533","modified":1572362483450},{"_id":"public/tags/threejs-Object3D/index.html","hash":"7a1d4a82ebb70a42944db13fbb9c4dacf46ca84c","modified":1572362483450},{"_id":"public/background/bg-1.jpg","hash":"9a5241de4c880f13a278f6980bf11d4dfb214d82","modified":1572362483450},{"_id":"public/apple-touch-icon.png","hash":"c0fda117fa166d63b9eb690cc5e4fb2caaf493b3","modified":1572362483450},{"_id":"public/background/bg-3.jpg","hash":"d476909f06fe8267c676952e3582bf9e9ff73585","modified":1572362483451},{"_id":"public/img/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1572362483451},{"_id":"public/img/SegmentFault.png","hash":"1afbc7e575e2e9ed9404be84a3f92f7ca8345a9c","modified":1572362483451},{"_id":"public/img/avatar.png","hash":"e4bca3d60087cd6e775d8e2aa2bf0d35e3859592","modified":1572362483451},{"_id":"public/img/V2EX.png","hash":"d0768de8555f9be0ee8ce956198cef454d4e4d7c","modified":1572362483451},{"_id":"public/background/bg-4.jpg","hash":"8e80d0b7786c3bf7b9648c0190719e78001e9eeb","modified":1572362483451},{"_id":"public/background/bg-2.jpg","hash":"d1e0b92e8fa822e44d185b5e1bf94ab47bc98a0a","modified":1572362483451},{"_id":"public/img/bilibili.png","hash":"be37b7e9a091c8547b8ee8b9d29583af8ded61c0","modified":1572362483451},{"_id":"public/img/TiddlyWiki.png","hash":"b7f68f8f9c45561a9455aee0bfb80e35cae6f8df","modified":1572362483451},{"_id":"public/img/golang_pprof.png","hash":"6dd94ffb6a2e1e8995c23e36dd8643a0195ac919","modified":1572362483451},{"_id":"public/img/scrollbar_arrow.png","hash":"af987032f2171867bb58b165d2180eb5dcbea637","modified":1572362483451},{"_id":"public/img/niconico.png","hash":"fabc7ca45e9ee5698db33a25de8b1f8a7c7d6723","modified":1572362483451},{"_id":"public/img/知乎.png","hash":"ed6d3c304789e112d09f40784fa6add1f1a38bd6","modified":1572362483451},{"_id":"public/img/pinned-octocat.svg","hash":"5dec89dc9dbcebff4a2aeddb9426c7a8e237ca16","modified":1572362483451},{"_id":"public/img/golang_pprof_cpu.png","hash":"377d7745d765d6a6f28a343dc556151ce8177aed","modified":1572362483451},{"_id":"public/img/新浪微博.png","hash":"7a145ed1daee0c172cda77098f4254fc21f9eeee","modified":1572362483451},{"_id":"public/img/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1572362483451},{"_id":"public/img/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1572362483451},{"_id":"public/img/udppackage.png","hash":"551069851fa2307e5b6d800b128ed09636d90832","modified":1572362483451},{"_id":"public/img/虾米音乐.png","hash":"a0039b049779b1f37c0b0b91760943b7bf25c8f1","modified":1572362483451},{"_id":"public/img/AcFun.png","hash":"df6b0fa39ced4dc988359fc7b7cd1e5403de08a6","modified":1572362483451},{"_id":"public/img/dataframe.png","hash":"1a43a9b03ec57ad914dfcb287bc27cb6018621e7","modified":1572362483451},{"_id":"public/img/简书.png","hash":"5c91ee83cab4abe160240e09de345b6935c8cb37","modified":1572362483451},{"_id":"public/img/Coding.png","hash":"afb4bce19bebf61e3c486fd5199369d6eb191b78","modified":1572362483451},{"_id":"public/img/LOFTER.png","hash":"88670eaea8612839e9d6a40a3636e4231ab56c0f","modified":1572362483451},{"_id":"public/img/Plunker.png","hash":"14a0054b9b4a0e459987f34b9ab48ab22dbe5cf9","modified":1572362483451},{"_id":"public/img/豆瓣.png","hash":"f1fc97f98612bcdf4a681542e5388483b40a5300","modified":1572362483451},{"_id":"public/img/Quora.png","hash":"1a624ade0d07f2482b21bef1e2a5ddd0110ba352","modified":1572362483451},{"_id":"public/background/backup/bg-3.jpg","hash":"1a06d3a660bfb99b62d760e4e1e09de168a4c74c","modified":1572362483452},{"_id":"public/background/backup/bg-1.jpg","hash":"31d7bb15211000c05656899302f8ec9ee3de0e9f","modified":1572362483452},{"_id":"public/background/backup/bg-2.jpg","hash":"7ae358f3ab8b41558444053400e796c41b3ba0e2","modified":1572362483452},{"_id":"public/background/backup/bg-4.jpg","hash":"6df1383d0f6134016d844df9abb740a6e0c0b2c5","modified":1572362483452},{"_id":"public/img/consul_archi.png","hash":"420ce04ab6439e1f615adc878c259568ac2d4a90","modified":1572362486613},{"_id":"public/img/tcppackage.png","hash":"a758f22d612ee27578eb6a700ec3df12be13ace7","modified":1572362486614},{"_id":"public/background/bg-5.jpg","hash":"e4a3631b6b0f94ebce30a6f01ecb2b6ed7cfdb0b","modified":1572362486615},{"_id":"public/background/bg-6.jpg","hash":"51b427f07ffc6f2ad97651f23cc16e8f19ed02f9","modified":1572362486615},{"_id":"public/img/golang_pprof_heap.png","hash":"65c69fc1b61d263e0ad4e337dc38ac9861a33961","modified":1572362486616},{"_id":"public/js/main.js","hash":"d58bbc593d94d48e85d4ebfb002910444080cb06","modified":1572362486719},{"_id":"public/js/pc.js","hash":"19a1660b10358046e7a1f398284491519b2ffd47","modified":1572362486719},{"_id":"public/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1572362486720},{"_id":"public/js/toc.js","hash":"72ba1228fc1a44df45b8f4b562eba78594f13016","modified":1572362486720},{"_id":"public/js/mobile.js","hash":"0f4c1fcd6df47a196ed9495c225173402aa7d769","modified":1572362486720},{"_id":"public/js/search.js","hash":"b456aaab98bbc3b0906f8a16d1e6e4f74dfcffda","modified":1572362486720},{"_id":"public/js/GithubRepoWidget.js","hash":"624e81a3b0e57495b0c0e0b3e056296c6e8ae5df","modified":1572362486720},{"_id":"public/css/style.css","hash":"36f28738aa5cf296dfcf4f199c9144c9e5245ecc","modified":1572362486720},{"_id":"public/img/avatar3.jpg","hash":"07a29a8aada9ef73bf6cc150bf1d88df4bc9a89b","modified":1572362486761}],"Category":[],"Data":[],"Page":[{"title":"aboutme","date":"2015-07-31T04:04:33.000Z","_content":"\n## 联系方式\n- 手机：1343409\\*\\*\\*\\*\n- Email：moxiaomomo@gmail.com\n- QQ：809444138\n\n---\n\n## 个人信息\n\n - 姓名: moguang\n - 性别: 男\n - 出生年月: 1988/08\n - 教育背景：本科/华南理工大学软件工程\n - 工作年限：2012年本科毕业至今\n - 个人主页\n[http://blog.moguang.me](http://blog.moguang.me)\n[http://blog.csdn.net/moxiaomomo](http://blog.csdn.net/moxiaomomo)\n[https://github.com/moxiaomomo](https://github.com/moxiaomomo)\n\n---\n\n## 工作经历\n\n### 115网盘科技\n  任职部门: 平台部<br>\n  任职时间：2016年12月 ~ 至今<br>\n  职位名称: 高级研发工程师\n  \n#### 主要职责\n- 搭建数据分析平台\n    - 基于hadoop搭建资源调度系统, 基于spark搭建分布式计算系统;<br>\n    - 完成数据仓库构建工作，包括日志的过滤转换，HDFS文件存储维护等;<br>\n    - 结合spark SQL, 对每天数亿条记录进行各维度分布式统计分析;<br>\n    - 结合spark MLib和机器学习算法, 对用户数据进行聚类/分类学习, 构建用户画像;<br>\n    - 基于python tornado, echarts及mongoDB构建报表系统;\n    - 基于阿里云大数据平台，重建并优化数据分析平台和报表平台。\n   \n- 微服务平台开发\n    - 基于Go语言, go-micro框架设计后端微服务架构;<br>\n    - 基于Docker, 实现consul服务发现的快速部署方案;<br>\n    - 完成Gateway, LoadBalance, 配置中心, MergeAPI等组件的开发;\n \n- 存储服务维护\n    - 日常维护百PB量级文件存储服务, 完善服务的可用性监控及流量监控平台;<br>\n    - 参与PB级文件数据的迁移工作，确保文件迁移的完整性和业务的无缝过渡;\n    - 其他, 如数据修复工作，配合运维处理突发问题等;\n \n- CDN节点加速\n    - 根据视频播放记录, 统计分析各地区热门视频数据;<br>\n    - 流量谷值时将热门视频预缓存到自建CDN加速节点中, 以减少回源率, 降低流量峰值。\n\n### 创业团队\n  任职部门: 研发部<br>\n  任职时间：2016年5月 ~ 2016年11月<br>\n  职位名称: 研发主管\n\n#### 主要职责\n  - 负责智能坐便器系统架构设计, 任务分配以及进度控制;<br>\n  - 负责业务后台搭建、业务接口开发: 采用Nginx+python_tornado+Mysql+MongoDB逻辑结构进行构建;<br>\n  - 负责消息推送服务的实现: 基于MQTT协议+SSL/TLS安全加密的mosquitto开源框架进行开发，及接入阿里云IoT平台;<br>\n  - 负责嵌入式控制系统设计及研发: 基于类BeagleboneBlack开发板+linux C环境, 实现进程间通信及串口通信。\n\n### 猎豹移动科技\n  任职部门：金山毒霸云后台研发部, 备份大师云后台研发部<br>\n  任职时间：2014年4月 ~ 2016年5月<br>\n  职位名称：服务端开发工程师\n\n#### 主要职责\n\n- 备份大师项目, 云后台服务开发\n   - 备份大师业务API\n    基于python tornado框架实现业务接口, 通过亚马逊AWS EC2部署服务, 使用AWS RDS/DDB/S3实现数据存取;<br>\n   - 备份大师API升级\n    基于Golang搭建API服务, 逐步接替tornado框架, 支持千万级用户量的接口访问;<br>\n   - 已有业务云数据的迁移\n    设计迁移方案, 通过在线/离线方式从AWS 结构化数据库往非结构化数据库迁移，以满足快速增长的数据的高效存取;<br>\n   - 备份大师账号系统完善\n    优化账号系统模块, 并接入第三方账号Google/Facebook登录功能;<br>\n   - 搭建日志收集与统计平台\n    每天过滤与统计亿条日志，通过django生成报表。\n\n- 洋葱Live直播项目, 消息系统开发\n   - 直播消息系统开发\n     基于GO+websocket+redis构建消息服务, 单机支持约30w+长连接;\n   - 架构升级\n     支持分布式部署，负载均衡机制。\n\n### 正点时空\n  任职部门：平台部<br>\n  任职时间：2012年6月 ~ 2014年4月<br>\n  职位名称：数据开发工程师\n\n#### 主要职责\n\n- 搭建及维护数据平台\n  - 构建日志统计平台: 基于python+shell+mysql, 对每天约100GB应用日志进行过滤与统计;<br>\n  - 搭建Hadoop离线统计平台: 通过搭建hadoop集群和定制MapReduce流程, 实现离线数据分布式统计;<br>\n  - MySQL数据库维护: 包括数据库相关表设计, 冷热数据分离, 数据冗余备份等。\n\n- 客户端应用开发(WP7/Qt)开发\n  - 参与开发WP7/PC端闹钟及日历应用开发 \n\n---\n\n## 擅长技能清单\n\n- 语言：Python / Go / C / Java / NodeJS\n- 操作系统: 熟悉Linux下文件IO / 网络IO / IPC / 内存管理等\n- 网络原理: 熟悉TCP/IP协议, HTTP/Websocket/MQTT等网络协议, Raft/Gossip等分布式一致性协议\n- 编程框架：python-tornado / python-django / gin / spring-boot\n- 开源架构: Hadoop-hdfs / Hadoop-spark / micro-service\n- 数据库：熟悉MySQL / Redis / MongoDB / HBase\n- 消息中间件：Flume / RabbitMQ / Kafka等\n- 代码管理：Svn / Git\n- 文档管理: Markdown / Gitbook / Google-docs / Graphviz\n- 公有云：AWS(亚马逊云) / KS3(金山云) / 阿里云IoT\n- 物联网: ARM-linux(BBB), C/python, MQTT, TCP/IP, 串口通信\n\n---\n","source":"aboutme/index.md","raw":"---\ntitle: aboutme\ndate: 2015-07-31 12:04:33\n---\n\n## 联系方式\n- 手机：1343409\\*\\*\\*\\*\n- Email：moxiaomomo@gmail.com\n- QQ：809444138\n\n---\n\n## 个人信息\n\n - 姓名: moguang\n - 性别: 男\n - 出生年月: 1988/08\n - 教育背景：本科/华南理工大学软件工程\n - 工作年限：2012年本科毕业至今\n - 个人主页\n[http://blog.moguang.me](http://blog.moguang.me)\n[http://blog.csdn.net/moxiaomomo](http://blog.csdn.net/moxiaomomo)\n[https://github.com/moxiaomomo](https://github.com/moxiaomomo)\n\n---\n\n## 工作经历\n\n### 115网盘科技\n  任职部门: 平台部<br>\n  任职时间：2016年12月 ~ 至今<br>\n  职位名称: 高级研发工程师\n  \n#### 主要职责\n- 搭建数据分析平台\n    - 基于hadoop搭建资源调度系统, 基于spark搭建分布式计算系统;<br>\n    - 完成数据仓库构建工作，包括日志的过滤转换，HDFS文件存储维护等;<br>\n    - 结合spark SQL, 对每天数亿条记录进行各维度分布式统计分析;<br>\n    - 结合spark MLib和机器学习算法, 对用户数据进行聚类/分类学习, 构建用户画像;<br>\n    - 基于python tornado, echarts及mongoDB构建报表系统;\n    - 基于阿里云大数据平台，重建并优化数据分析平台和报表平台。\n   \n- 微服务平台开发\n    - 基于Go语言, go-micro框架设计后端微服务架构;<br>\n    - 基于Docker, 实现consul服务发现的快速部署方案;<br>\n    - 完成Gateway, LoadBalance, 配置中心, MergeAPI等组件的开发;\n \n- 存储服务维护\n    - 日常维护百PB量级文件存储服务, 完善服务的可用性监控及流量监控平台;<br>\n    - 参与PB级文件数据的迁移工作，确保文件迁移的完整性和业务的无缝过渡;\n    - 其他, 如数据修复工作，配合运维处理突发问题等;\n \n- CDN节点加速\n    - 根据视频播放记录, 统计分析各地区热门视频数据;<br>\n    - 流量谷值时将热门视频预缓存到自建CDN加速节点中, 以减少回源率, 降低流量峰值。\n\n### 创业团队\n  任职部门: 研发部<br>\n  任职时间：2016年5月 ~ 2016年11月<br>\n  职位名称: 研发主管\n\n#### 主要职责\n  - 负责智能坐便器系统架构设计, 任务分配以及进度控制;<br>\n  - 负责业务后台搭建、业务接口开发: 采用Nginx+python_tornado+Mysql+MongoDB逻辑结构进行构建;<br>\n  - 负责消息推送服务的实现: 基于MQTT协议+SSL/TLS安全加密的mosquitto开源框架进行开发，及接入阿里云IoT平台;<br>\n  - 负责嵌入式控制系统设计及研发: 基于类BeagleboneBlack开发板+linux C环境, 实现进程间通信及串口通信。\n\n### 猎豹移动科技\n  任职部门：金山毒霸云后台研发部, 备份大师云后台研发部<br>\n  任职时间：2014年4月 ~ 2016年5月<br>\n  职位名称：服务端开发工程师\n\n#### 主要职责\n\n- 备份大师项目, 云后台服务开发\n   - 备份大师业务API\n    基于python tornado框架实现业务接口, 通过亚马逊AWS EC2部署服务, 使用AWS RDS/DDB/S3实现数据存取;<br>\n   - 备份大师API升级\n    基于Golang搭建API服务, 逐步接替tornado框架, 支持千万级用户量的接口访问;<br>\n   - 已有业务云数据的迁移\n    设计迁移方案, 通过在线/离线方式从AWS 结构化数据库往非结构化数据库迁移，以满足快速增长的数据的高效存取;<br>\n   - 备份大师账号系统完善\n    优化账号系统模块, 并接入第三方账号Google/Facebook登录功能;<br>\n   - 搭建日志收集与统计平台\n    每天过滤与统计亿条日志，通过django生成报表。\n\n- 洋葱Live直播项目, 消息系统开发\n   - 直播消息系统开发\n     基于GO+websocket+redis构建消息服务, 单机支持约30w+长连接;\n   - 架构升级\n     支持分布式部署，负载均衡机制。\n\n### 正点时空\n  任职部门：平台部<br>\n  任职时间：2012年6月 ~ 2014年4月<br>\n  职位名称：数据开发工程师\n\n#### 主要职责\n\n- 搭建及维护数据平台\n  - 构建日志统计平台: 基于python+shell+mysql, 对每天约100GB应用日志进行过滤与统计;<br>\n  - 搭建Hadoop离线统计平台: 通过搭建hadoop集群和定制MapReduce流程, 实现离线数据分布式统计;<br>\n  - MySQL数据库维护: 包括数据库相关表设计, 冷热数据分离, 数据冗余备份等。\n\n- 客户端应用开发(WP7/Qt)开发\n  - 参与开发WP7/PC端闹钟及日历应用开发 \n\n---\n\n## 擅长技能清单\n\n- 语言：Python / Go / C / Java / NodeJS\n- 操作系统: 熟悉Linux下文件IO / 网络IO / IPC / 内存管理等\n- 网络原理: 熟悉TCP/IP协议, HTTP/Websocket/MQTT等网络协议, Raft/Gossip等分布式一致性协议\n- 编程框架：python-tornado / python-django / gin / spring-boot\n- 开源架构: Hadoop-hdfs / Hadoop-spark / micro-service\n- 数据库：熟悉MySQL / Redis / MongoDB / HBase\n- 消息中间件：Flume / RabbitMQ / Kafka等\n- 代码管理：Svn / Git\n- 文档管理: Markdown / Gitbook / Google-docs / Graphviz\n- 公有云：AWS(亚马逊云) / KS3(金山云) / 阿里云IoT\n- 物联网: ARM-linux(BBB), C/python, MQTT, TCP/IP, 串口通信\n\n---\n","updated":"2018-06-24T14:06:25.557Z","path":"aboutme/index.html","comments":1,"layout":"page","_id":"ck2c00dtq00034j4dgdkjril4","content":"<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li>手机：1343409****</li>\n<li>Email：moxiaomomo@gmail.com</li>\n<li>QQ：809444138</li>\n</ul>\n<hr>\n<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li>姓名: moguang</li>\n<li>性别: 男</li>\n<li>出生年月: 1988/08</li>\n<li>教育背景：本科/华南理工大学软件工程</li>\n<li>工作年限：2012年本科毕业至今</li>\n<li>个人主页<br><a href=\"http://blog.moguang.me\" target=\"_blank\" rel=\"external\">http://blog.moguang.me</a><br><a href=\"http://blog.csdn.net/moxiaomomo\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/moxiaomomo</a><br><a href=\"https://github.com/moxiaomomo\" target=\"_blank\" rel=\"external\">https://github.com/moxiaomomo</a></li>\n</ul>\n<hr>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"115网盘科技\"><a href=\"#115网盘科技\" class=\"headerlink\" title=\"115网盘科技\"></a>115网盘科技</h3><p>  任职部门: 平台部<br><br>  任职时间：2016年12月 ~ 至今<br><br>  职位名称: 高级研发工程师</p>\n<h4 id=\"主要职责\"><a href=\"#主要职责\" class=\"headerlink\" title=\"主要职责\"></a>主要职责</h4><ul>\n<li><p>搭建数据分析平台</p>\n<ul>\n<li>基于hadoop搭建资源调度系统, 基于spark搭建分布式计算系统;<br></li>\n<li>完成数据仓库构建工作，包括日志的过滤转换，HDFS文件存储维护等;<br></li>\n<li>结合spark SQL, 对每天数亿条记录进行各维度分布式统计分析;<br></li>\n<li>结合spark MLib和机器学习算法, 对用户数据进行聚类/分类学习, 构建用户画像;<br></li>\n<li>基于python tornado, echarts及mongoDB构建报表系统;</li>\n<li>基于阿里云大数据平台，重建并优化数据分析平台和报表平台。</li>\n</ul>\n</li>\n<li><p>微服务平台开发</p>\n<ul>\n<li>基于Go语言, go-micro框架设计后端微服务架构;<br></li>\n<li>基于Docker, 实现consul服务发现的快速部署方案;<br></li>\n<li>完成Gateway, LoadBalance, 配置中心, MergeAPI等组件的开发;</li>\n</ul>\n</li>\n<li><p>存储服务维护</p>\n<ul>\n<li>日常维护百PB量级文件存储服务, 完善服务的可用性监控及流量监控平台;<br></li>\n<li>参与PB级文件数据的迁移工作，确保文件迁移的完整性和业务的无缝过渡;</li>\n<li>其他, 如数据修复工作，配合运维处理突发问题等;</li>\n</ul>\n</li>\n<li><p>CDN节点加速</p>\n<ul>\n<li>根据视频播放记录, 统计分析各地区热门视频数据;<br></li>\n<li>流量谷值时将热门视频预缓存到自建CDN加速节点中, 以减少回源率, 降低流量峰值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"创业团队\"><a href=\"#创业团队\" class=\"headerlink\" title=\"创业团队\"></a>创业团队</h3><p>  任职部门: 研发部<br><br>  任职时间：2016年5月 ~ 2016年11月<br><br>  职位名称: 研发主管</p>\n<h4 id=\"主要职责-1\"><a href=\"#主要职责-1\" class=\"headerlink\" title=\"主要职责\"></a>主要职责</h4><ul>\n<li>负责智能坐便器系统架构设计, 任务分配以及进度控制;<br></li>\n<li>负责业务后台搭建、业务接口开发: 采用Nginx+python_tornado+Mysql+MongoDB逻辑结构进行构建;<br></li>\n<li>负责消息推送服务的实现: 基于MQTT协议+SSL/TLS安全加密的mosquitto开源框架进行开发，及接入阿里云IoT平台;<br></li>\n<li>负责嵌入式控制系统设计及研发: 基于类BeagleboneBlack开发板+linux C环境, 实现进程间通信及串口通信。</li>\n</ul>\n<h3 id=\"猎豹移动科技\"><a href=\"#猎豹移动科技\" class=\"headerlink\" title=\"猎豹移动科技\"></a>猎豹移动科技</h3><p>  任职部门：金山毒霸云后台研发部, 备份大师云后台研发部<br><br>  任职时间：2014年4月 ~ 2016年5月<br><br>  职位名称：服务端开发工程师</p>\n<h4 id=\"主要职责-2\"><a href=\"#主要职责-2\" class=\"headerlink\" title=\"主要职责\"></a>主要职责</h4><ul>\n<li><p>备份大师项目, 云后台服务开发</p>\n<ul>\n<li>备份大师业务API<br>基于python tornado框架实现业务接口, 通过亚马逊AWS EC2部署服务, 使用AWS RDS/DDB/S3实现数据存取;<br></li>\n<li>备份大师API升级<br>基于Golang搭建API服务, 逐步接替tornado框架, 支持千万级用户量的接口访问;<br></li>\n<li>已有业务云数据的迁移<br>设计迁移方案, 通过在线/离线方式从AWS 结构化数据库往非结构化数据库迁移，以满足快速增长的数据的高效存取;<br></li>\n<li>备份大师账号系统完善<br>优化账号系统模块, 并接入第三方账号Google/Facebook登录功能;<br></li>\n<li>搭建日志收集与统计平台<br>每天过滤与统计亿条日志，通过django生成报表。</li>\n</ul>\n</li>\n<li><p>洋葱Live直播项目, 消息系统开发</p>\n<ul>\n<li>直播消息系统开发<br>基于GO+websocket+redis构建消息服务, 单机支持约30w+长连接;</li>\n<li>架构升级<br>支持分布式部署，负载均衡机制。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"正点时空\"><a href=\"#正点时空\" class=\"headerlink\" title=\"正点时空\"></a>正点时空</h3><p>  任职部门：平台部<br><br>  任职时间：2012年6月 ~ 2014年4月<br><br>  职位名称：数据开发工程师</p>\n<h4 id=\"主要职责-3\"><a href=\"#主要职责-3\" class=\"headerlink\" title=\"主要职责\"></a>主要职责</h4><ul>\n<li><p>搭建及维护数据平台</p>\n<ul>\n<li>构建日志统计平台: 基于python+shell+mysql, 对每天约100GB应用日志进行过滤与统计;<br></li>\n<li>搭建Hadoop离线统计平台: 通过搭建hadoop集群和定制MapReduce流程, 实现离线数据分布式统计;<br></li>\n<li>MySQL数据库维护: 包括数据库相关表设计, 冷热数据分离, 数据冗余备份等。</li>\n</ul>\n</li>\n<li><p>客户端应用开发(WP7/Qt)开发</p>\n<ul>\n<li>参与开发WP7/PC端闹钟及日历应用开发 </li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"擅长技能清单\"><a href=\"#擅长技能清单\" class=\"headerlink\" title=\"擅长技能清单\"></a>擅长技能清单</h2><ul>\n<li>语言：Python / Go / C / Java / NodeJS</li>\n<li>操作系统: 熟悉Linux下文件IO / 网络IO / IPC / 内存管理等</li>\n<li>网络原理: 熟悉TCP/IP协议, HTTP/Websocket/MQTT等网络协议, Raft/Gossip等分布式一致性协议</li>\n<li>编程框架：python-tornado / python-django / gin / spring-boot</li>\n<li>开源架构: Hadoop-hdfs / Hadoop-spark / micro-service</li>\n<li>数据库：熟悉MySQL / Redis / MongoDB / HBase</li>\n<li>消息中间件：Flume / RabbitMQ / Kafka等</li>\n<li>代码管理：Svn / Git</li>\n<li>文档管理: Markdown / Gitbook / Google-docs / Graphviz</li>\n<li>公有云：AWS(亚马逊云) / KS3(金山云) / 阿里云IoT</li>\n<li>物联网: ARM-linux(BBB), C/python, MQTT, TCP/IP, 串口通信</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li>手机：1343409****</li>\n<li>Email：moxiaomomo@gmail.com</li>\n<li>QQ：809444138</li>\n</ul>\n<hr>\n<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li>姓名: moguang</li>\n<li>性别: 男</li>\n<li>出生年月: 1988/08</li>\n<li>教育背景：本科/华南理工大学软件工程</li>\n<li>工作年限：2012年本科毕业至今</li>\n<li>个人主页<br><a href=\"http://blog.moguang.me\" target=\"_blank\" rel=\"external\">http://blog.moguang.me</a><br><a href=\"http://blog.csdn.net/moxiaomomo\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/moxiaomomo</a><br><a href=\"https://github.com/moxiaomomo\" target=\"_blank\" rel=\"external\">https://github.com/moxiaomomo</a></li>\n</ul>\n<hr>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"115网盘科技\"><a href=\"#115网盘科技\" class=\"headerlink\" title=\"115网盘科技\"></a>115网盘科技</h3><p>  任职部门: 平台部<br><br>  任职时间：2016年12月 ~ 至今<br><br>  职位名称: 高级研发工程师</p>\n<h4 id=\"主要职责\"><a href=\"#主要职责\" class=\"headerlink\" title=\"主要职责\"></a>主要职责</h4><ul>\n<li><p>搭建数据分析平台</p>\n<ul>\n<li>基于hadoop搭建资源调度系统, 基于spark搭建分布式计算系统;<br></li>\n<li>完成数据仓库构建工作，包括日志的过滤转换，HDFS文件存储维护等;<br></li>\n<li>结合spark SQL, 对每天数亿条记录进行各维度分布式统计分析;<br></li>\n<li>结合spark MLib和机器学习算法, 对用户数据进行聚类/分类学习, 构建用户画像;<br></li>\n<li>基于python tornado, echarts及mongoDB构建报表系统;</li>\n<li>基于阿里云大数据平台，重建并优化数据分析平台和报表平台。</li>\n</ul>\n</li>\n<li><p>微服务平台开发</p>\n<ul>\n<li>基于Go语言, go-micro框架设计后端微服务架构;<br></li>\n<li>基于Docker, 实现consul服务发现的快速部署方案;<br></li>\n<li>完成Gateway, LoadBalance, 配置中心, MergeAPI等组件的开发;</li>\n</ul>\n</li>\n<li><p>存储服务维护</p>\n<ul>\n<li>日常维护百PB量级文件存储服务, 完善服务的可用性监控及流量监控平台;<br></li>\n<li>参与PB级文件数据的迁移工作，确保文件迁移的完整性和业务的无缝过渡;</li>\n<li>其他, 如数据修复工作，配合运维处理突发问题等;</li>\n</ul>\n</li>\n<li><p>CDN节点加速</p>\n<ul>\n<li>根据视频播放记录, 统计分析各地区热门视频数据;<br></li>\n<li>流量谷值时将热门视频预缓存到自建CDN加速节点中, 以减少回源率, 降低流量峰值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"创业团队\"><a href=\"#创业团队\" class=\"headerlink\" title=\"创业团队\"></a>创业团队</h3><p>  任职部门: 研发部<br><br>  任职时间：2016年5月 ~ 2016年11月<br><br>  职位名称: 研发主管</p>\n<h4 id=\"主要职责-1\"><a href=\"#主要职责-1\" class=\"headerlink\" title=\"主要职责\"></a>主要职责</h4><ul>\n<li>负责智能坐便器系统架构设计, 任务分配以及进度控制;<br></li>\n<li>负责业务后台搭建、业务接口开发: 采用Nginx+python_tornado+Mysql+MongoDB逻辑结构进行构建;<br></li>\n<li>负责消息推送服务的实现: 基于MQTT协议+SSL/TLS安全加密的mosquitto开源框架进行开发，及接入阿里云IoT平台;<br></li>\n<li>负责嵌入式控制系统设计及研发: 基于类BeagleboneBlack开发板+linux C环境, 实现进程间通信及串口通信。</li>\n</ul>\n<h3 id=\"猎豹移动科技\"><a href=\"#猎豹移动科技\" class=\"headerlink\" title=\"猎豹移动科技\"></a>猎豹移动科技</h3><p>  任职部门：金山毒霸云后台研发部, 备份大师云后台研发部<br><br>  任职时间：2014年4月 ~ 2016年5月<br><br>  职位名称：服务端开发工程师</p>\n<h4 id=\"主要职责-2\"><a href=\"#主要职责-2\" class=\"headerlink\" title=\"主要职责\"></a>主要职责</h4><ul>\n<li><p>备份大师项目, 云后台服务开发</p>\n<ul>\n<li>备份大师业务API<br>基于python tornado框架实现业务接口, 通过亚马逊AWS EC2部署服务, 使用AWS RDS/DDB/S3实现数据存取;<br></li>\n<li>备份大师API升级<br>基于Golang搭建API服务, 逐步接替tornado框架, 支持千万级用户量的接口访问;<br></li>\n<li>已有业务云数据的迁移<br>设计迁移方案, 通过在线/离线方式从AWS 结构化数据库往非结构化数据库迁移，以满足快速增长的数据的高效存取;<br></li>\n<li>备份大师账号系统完善<br>优化账号系统模块, 并接入第三方账号Google/Facebook登录功能;<br></li>\n<li>搭建日志收集与统计平台<br>每天过滤与统计亿条日志，通过django生成报表。</li>\n</ul>\n</li>\n<li><p>洋葱Live直播项目, 消息系统开发</p>\n<ul>\n<li>直播消息系统开发<br>基于GO+websocket+redis构建消息服务, 单机支持约30w+长连接;</li>\n<li>架构升级<br>支持分布式部署，负载均衡机制。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"正点时空\"><a href=\"#正点时空\" class=\"headerlink\" title=\"正点时空\"></a>正点时空</h3><p>  任职部门：平台部<br><br>  任职时间：2012年6月 ~ 2014年4月<br><br>  职位名称：数据开发工程师</p>\n<h4 id=\"主要职责-3\"><a href=\"#主要职责-3\" class=\"headerlink\" title=\"主要职责\"></a>主要职责</h4><ul>\n<li><p>搭建及维护数据平台</p>\n<ul>\n<li>构建日志统计平台: 基于python+shell+mysql, 对每天约100GB应用日志进行过滤与统计;<br></li>\n<li>搭建Hadoop离线统计平台: 通过搭建hadoop集群和定制MapReduce流程, 实现离线数据分布式统计;<br></li>\n<li>MySQL数据库维护: 包括数据库相关表设计, 冷热数据分离, 数据冗余备份等。</li>\n</ul>\n</li>\n<li><p>客户端应用开发(WP7/Qt)开发</p>\n<ul>\n<li>参与开发WP7/PC端闹钟及日历应用开发 </li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"擅长技能清单\"><a href=\"#擅长技能清单\" class=\"headerlink\" title=\"擅长技能清单\"></a>擅长技能清单</h2><ul>\n<li>语言：Python / Go / C / Java / NodeJS</li>\n<li>操作系统: 熟悉Linux下文件IO / 网络IO / IPC / 内存管理等</li>\n<li>网络原理: 熟悉TCP/IP协议, HTTP/Websocket/MQTT等网络协议, Raft/Gossip等分布式一致性协议</li>\n<li>编程框架：python-tornado / python-django / gin / spring-boot</li>\n<li>开源架构: Hadoop-hdfs / Hadoop-spark / micro-service</li>\n<li>数据库：熟悉MySQL / Redis / MongoDB / HBase</li>\n<li>消息中间件：Flume / RabbitMQ / Kafka等</li>\n<li>代码管理：Svn / Git</li>\n<li>文档管理: Markdown / Gitbook / Google-docs / Graphviz</li>\n<li>公有云：AWS(亚马逊云) / KS3(金山云) / 阿里云IoT</li>\n<li>物联网: ARM-linux(BBB), C/python, MQTT, TCP/IP, 串口通信</li>\n</ul>\n<hr>\n"},{"title":"tags","date":"2017-08-03T06:05:03.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-08-03 14:05:03\n---\n","updated":"2017-08-03T06:05:03.672Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck2c00dur00044j4dz9im65p0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"404","date":"2017-08-03T06:05:15.000Z","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2017-08-03 14:05:15\n---\n","updated":"2017-08-03T06:05:15.350Z","path":"404/index.html","comments":1,"layout":"page","_id":"ck2c00dut00064j4du7mazdbx","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":" [Threejs]Object3d对象如何获取指定名字的子元素？","date":"2019-10-29T15:19:16.000Z","_content":"\n## 现有的获取对象的方法\n\n- getObjectById()\n\n根据指定的id获取对应的对象，总是返回第一个匹配到的对象\n\n- getObjectByName()\n\n根据指定的name获取对应的对象，总是返回第一个匹配到的对象\n\n- getObjectByProperty()\n\n根据指定的属性(键值对)获取对应的对象，总是返回第一个匹配到的对象\n\n<!--more-->\n\n其实**getObjectById**和**getObjectByName**的方法内部都是调用了**getObjectByProperty**方法，我们打开它的源码，逻辑具体如下:\n\n```javascript\n// ...\n   getObjectById: function ( id ) {\n      return this.getObjectByProperty( 'id', id );\n   },\n   getObjectByName: function ( name ) {\n      return this.getObjectByProperty( 'name', name );\n   },\n   getObjectByProperty: function ( name, value ) {\n      if ( this[ name ] === value ) return this;\n      for ( var i = 0, l = this.children.length; i < l; i ++ ) {\n         var child = this.children[ i ];\n         var object = child.getObjectByProperty( name, value );\n         if ( object !== undefined ) {\n            return object;\n         }\n      }\n      return undefined;\n   },\n// ...\n```\n\n## Object3D对象如何获取指定名字的子元素?\n\n对比以上三个方法，看起来都不太适合解决这个问题．假设多个不同的Object3D的child中都有一个name/id相同的对象，那么通过这些方法找到的对象无法确定是哪个Object3D的．\n\n我当前的一种解决方法是，我们可以在Object3D类(而不是Scene类)上扩展一个方法出来，比如*getChildByName*, 参考如下:\n\n```javascript\n  getChildByName(childName: string): Object3D {\n    const getChild = (obj: Object3D) => {\n      if (obj.name === childName) {\n        return obj;\n      }\n      if (obj.children.length <= 0) {\n        return null;\n      }\n\n      let c = null;\n      obj.children.forEach(child => {\n        const tmp = getChild(child);\n        if (tmp != null) {\n          c = tmp;\n        }\n      });\n      return c;\n    };\n\n    return getChild(this);\n  }\n```\n\n可以定义一个Object3D的子类，把这个getChildByName方法给添加进来子类中．调用的时候，类似这样即可:\n\n```javascript\n// const obj = xxx; //Object3D\nobj.getChildByName('someName');\n```\n","source":"_posts/Threejs-get-child.md","raw":"---\ntitle: ' [Threejs]Object3d对象如何获取指定名字的子元素？'\ndate: 2019-10-29 23:19:16\ntags: threejs Object3D\n---\n\n## 现有的获取对象的方法\n\n- getObjectById()\n\n根据指定的id获取对应的对象，总是返回第一个匹配到的对象\n\n- getObjectByName()\n\n根据指定的name获取对应的对象，总是返回第一个匹配到的对象\n\n- getObjectByProperty()\n\n根据指定的属性(键值对)获取对应的对象，总是返回第一个匹配到的对象\n\n<!--more-->\n\n其实**getObjectById**和**getObjectByName**的方法内部都是调用了**getObjectByProperty**方法，我们打开它的源码，逻辑具体如下:\n\n```javascript\n// ...\n   getObjectById: function ( id ) {\n      return this.getObjectByProperty( 'id', id );\n   },\n   getObjectByName: function ( name ) {\n      return this.getObjectByProperty( 'name', name );\n   },\n   getObjectByProperty: function ( name, value ) {\n      if ( this[ name ] === value ) return this;\n      for ( var i = 0, l = this.children.length; i < l; i ++ ) {\n         var child = this.children[ i ];\n         var object = child.getObjectByProperty( name, value );\n         if ( object !== undefined ) {\n            return object;\n         }\n      }\n      return undefined;\n   },\n// ...\n```\n\n## Object3D对象如何获取指定名字的子元素?\n\n对比以上三个方法，看起来都不太适合解决这个问题．假设多个不同的Object3D的child中都有一个name/id相同的对象，那么通过这些方法找到的对象无法确定是哪个Object3D的．\n\n我当前的一种解决方法是，我们可以在Object3D类(而不是Scene类)上扩展一个方法出来，比如*getChildByName*, 参考如下:\n\n```javascript\n  getChildByName(childName: string): Object3D {\n    const getChild = (obj: Object3D) => {\n      if (obj.name === childName) {\n        return obj;\n      }\n      if (obj.children.length <= 0) {\n        return null;\n      }\n\n      let c = null;\n      obj.children.forEach(child => {\n        const tmp = getChild(child);\n        if (tmp != null) {\n          c = tmp;\n        }\n      });\n      return c;\n    };\n\n    return getChild(this);\n  }\n```\n\n可以定义一个Object3D的子类，把这个getChildByName方法给添加进来子类中．调用的时候，类似这样即可:\n\n```javascript\n// const obj = xxx; //Object3D\nobj.getChildByName('someName');\n```\n","slug":"Threejs-get-child","published":1,"updated":"2019-10-29T15:20:50.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dsq00004j4dfjt3nux7","content":"<h2 id=\"现有的获取对象的方法\"><a href=\"#现有的获取对象的方法\" class=\"headerlink\" title=\"现有的获取对象的方法\"></a>现有的获取对象的方法</h2><ul>\n<li>getObjectById()</li>\n</ul>\n<p>根据指定的id获取对应的对象，总是返回第一个匹配到的对象</p>\n<ul>\n<li>getObjectByName()</li>\n</ul>\n<p>根据指定的name获取对应的对象，总是返回第一个匹配到的对象</p>\n<ul>\n<li>getObjectByProperty()</li>\n</ul>\n<p>根据指定的属性(键值对)获取对应的对象，总是返回第一个匹配到的对象</p>\n<a id=\"more\"></a>\n<p>其实<strong>getObjectById</strong>和<strong>getObjectByName</strong>的方法内部都是调用了<strong>getObjectByProperty</strong>方法，我们打开它的源码，逻辑具体如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">   getObjectById: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"> id </span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getObjectByProperty( <span class=\"string\">'id'</span>, id );</div><div class=\"line\">   &#125;,</div><div class=\"line\">   <span class=\"attr\">getObjectByName</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"> name </span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getObjectByProperty( <span class=\"string\">'name'</span>, name );</div><div class=\"line\">   &#125;,</div><div class=\"line\">   <span class=\"attr\">getObjectByProperty</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"> name, value </span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> ( <span class=\"keyword\">this</span>[ name ] === value ) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">      <span class=\"keyword\">for</span> ( <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = <span class=\"keyword\">this</span>.children.length; i &lt; l; i ++ ) &#123;</div><div class=\"line\">         <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>.children[ i ];</div><div class=\"line\">         <span class=\"keyword\">var</span> object = child.getObjectByProperty( name, value );</div><div class=\"line\">         <span class=\"keyword\">if</span> ( object !== <span class=\"literal\">undefined</span> ) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> object;</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">   &#125;,</div><div class=\"line\"><span class=\"comment\">// ...</span></div></pre></td></tr></table></figure>\n<h2 id=\"Object3D对象如何获取指定名字的子元素\"><a href=\"#Object3D对象如何获取指定名字的子元素\" class=\"headerlink\" title=\"Object3D对象如何获取指定名字的子元素?\"></a>Object3D对象如何获取指定名字的子元素?</h2><p>对比以上三个方法，看起来都不太适合解决这个问题．假设多个不同的Object3D的child中都有一个name/id相同的对象，那么通过这些方法找到的对象无法确定是哪个Object3D的．</p>\n<p>我当前的一种解决方法是，我们可以在Object3D类(而不是Scene类)上扩展一个方法出来，比如<em>getChildByName</em>, 参考如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">getChildByName(childName: string): Object3D &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> getChild = <span class=\"function\">(<span class=\"params\">obj: Object3D</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (obj.name === childName) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> obj;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (obj.children.length &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> c = <span class=\"literal\">null</span>;</div><div class=\"line\">    obj.children.forEach(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> tmp = getChild(child);</div><div class=\"line\">      <span class=\"keyword\">if</span> (tmp != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        c = tmp;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> c;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> getChild(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以定义一个Object3D的子类，把这个getChildByName方法给添加进来子类中．调用的时候，类似这样即可:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// const obj = xxx; //Object3D</span></div><div class=\"line\">obj.getChildByName(<span class=\"string\">'someName'</span>);</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"现有的获取对象的方法\"><a href=\"#现有的获取对象的方法\" class=\"headerlink\" title=\"现有的获取对象的方法\"></a>现有的获取对象的方法</h2><ul>\n<li>getObjectById()</li>\n</ul>\n<p>根据指定的id获取对应的对象，总是返回第一个匹配到的对象</p>\n<ul>\n<li>getObjectByName()</li>\n</ul>\n<p>根据指定的name获取对应的对象，总是返回第一个匹配到的对象</p>\n<ul>\n<li>getObjectByProperty()</li>\n</ul>\n<p>根据指定的属性(键值对)获取对应的对象，总是返回第一个匹配到的对象</p>","more":"<p>其实<strong>getObjectById</strong>和<strong>getObjectByName</strong>的方法内部都是调用了<strong>getObjectByProperty</strong>方法，我们打开它的源码，逻辑具体如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">   getObjectById: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"> id </span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getObjectByProperty( <span class=\"string\">'id'</span>, id );</div><div class=\"line\">   &#125;,</div><div class=\"line\">   <span class=\"attr\">getObjectByName</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"> name </span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getObjectByProperty( <span class=\"string\">'name'</span>, name );</div><div class=\"line\">   &#125;,</div><div class=\"line\">   <span class=\"attr\">getObjectByProperty</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"> name, value </span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> ( <span class=\"keyword\">this</span>[ name ] === value ) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">      <span class=\"keyword\">for</span> ( <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = <span class=\"keyword\">this</span>.children.length; i &lt; l; i ++ ) &#123;</div><div class=\"line\">         <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>.children[ i ];</div><div class=\"line\">         <span class=\"keyword\">var</span> object = child.getObjectByProperty( name, value );</div><div class=\"line\">         <span class=\"keyword\">if</span> ( object !== <span class=\"literal\">undefined</span> ) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> object;</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">   &#125;,</div><div class=\"line\"><span class=\"comment\">// ...</span></div></pre></td></tr></table></figure>\n<h2 id=\"Object3D对象如何获取指定名字的子元素\"><a href=\"#Object3D对象如何获取指定名字的子元素\" class=\"headerlink\" title=\"Object3D对象如何获取指定名字的子元素?\"></a>Object3D对象如何获取指定名字的子元素?</h2><p>对比以上三个方法，看起来都不太适合解决这个问题．假设多个不同的Object3D的child中都有一个name/id相同的对象，那么通过这些方法找到的对象无法确定是哪个Object3D的．</p>\n<p>我当前的一种解决方法是，我们可以在Object3D类(而不是Scene类)上扩展一个方法出来，比如<em>getChildByName</em>, 参考如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">getChildByName(childName: string): Object3D &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> getChild = <span class=\"function\">(<span class=\"params\">obj: Object3D</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (obj.name === childName) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> obj;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (obj.children.length &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> c = <span class=\"literal\">null</span>;</div><div class=\"line\">    obj.children.forEach(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> tmp = getChild(child);</div><div class=\"line\">      <span class=\"keyword\">if</span> (tmp != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        c = tmp;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> c;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> getChild(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以定义一个Object3D的子类，把这个getChildByName方法给添加进来子类中．调用的时候，类似这样即可:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// const obj = xxx; //Object3D</span></div><div class=\"line\">obj.getChildByName(<span class=\"string\">'someName'</span>);</div></pre></td></tr></table></figure>"},{"title":"关于本站","date":"2015-07-22T14:31:49.000Z","_content":"\n本站主要记录了我的一些技术笔记， 及生活上的一些感悟。\n\nLife is short, let's programing.\n","source":"_posts/about/about.md","raw":"---\ntitle: 关于本站\ndate: 2015-07-22 22:31:49\ntags:\n---\n\n本站主要记录了我的一些技术笔记， 及生活上的一些感悟。\n\nLife is short, let's programing.\n","slug":"about/about","published":1,"updated":"2017-08-02T07:28:30.881Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dus00054j4dr4mts00a","content":"<p>本站主要记录了我的一些技术笔记， 及生活上的一些感悟。</p>\n<p>Life is short, let’s programing.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本站主要记录了我的一些技术笔记， 及生活上的一些感悟。</p>\n<p>Life is short, let’s programing.</p>\n"},{"title":"大数据开发技术知识点","date":"2017-12-01T08:44:10.000Z","_content":"\n\n#### CAP理论\n```\n1) 理论概述\n分布式领域中CAP理论：\n① C：Consistency，一致性，数据一致更新，所有数据变动都是同步的。\n② A：Availability，可用性，系统具有好的响应性能。\n③ P：Partition tolerance，分区容错性。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，也就是说无论任何消息丢失，系统都可用。\n\n该理论已被证明：任何分布式系统只可同时满足两点，无法三者兼顾。 因此，将精力浪费在思考如何设计能满足三者的完美系统上是愚钝的，应该根据应用场景进行适当取舍。\n\n2) 一致性分类\n一致性是指从系统外部读取系统内部的数据时，在一定约束条件下相同，即数据变动在系统内部各节点应该是同步的。根据一致性的强弱程度不同，可以将一致性级别分为如下几种：\n① 强一致性（strong consistency）。任何时刻，任何用户都能读取到最近一次成功更新的数据。\n② 单调一致性（monotonic consistency）。任何时刻，任何用户一旦读到某个数据在某次更新后的值，那么就不会再读到比这个值更旧的值。也就是说，可获取的数据顺序必是单调递增的。\n③ 会话一致性（session consistency）。任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在本次会话中就不会再读到比这个值更旧的值。会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话内的单调性，在不同用户或同一用户不同会话间则没有保障。\n④ 最终一致性（eventual consistency）。用户只能读到某次更新后的值，但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障。\n⑤ 弱一致性（weak consistency）。用户无法在确定时间内读到最新更新的值。\n```\n<!--more-->\n#### MapReduce\n```\nMapReduce主要包括JobClient、JobTracker、TaskTracker、HDFS四个独立的部分。\n\n1、JobClient\n配置参数Configuration，并打包成jar文件存储在HDFS上，将文件路径提交给JobTracker的master服务，然后由master创建每个task将它们分发到各个TaskTracker服务中去执行。\n\n2、JobTracker\n这是一个master服务，程序启动后，JobTracker负责资源监控和作业调度。JobTracker监控所有的TaskTracker和job的健康状况，一旦发生失败，即将之转移到其他节点上，同时JobTracker会跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器，而调度器会在资源出现空闲时，选择合适的任务使用这些资源。在Hadoop 中，任务调度器是一个可插拔的模块，用户可以根据自己的需要设计相应的调度器。\n\n3、TaskTracker\n运行在多个节点上的slaver服务。TaskTracker主动与JobTracker通信接受作业，并负责直接执行每个任务。TaskTracker 会周期性地通过Heartbeat 将本节点上资源的使用情况和任务的运行进度汇报给JobTracker，同时接收JobTracker 发送过来的命令并执行相应的操作（如启动新任务、杀死任务等）。TaskTracker 使用“slot”等量划分本节点上的资源量。“slot”代表计算资源（CPU、内存等）。一个Task 获取到一个slot 后才有机会运行，而Hadoop 调度器的作用就是将各个TaskTracker 上的空闲slot 分配给Task 使用。slot 分为Map slot 和Reduce slot 两种，分别供MapTask 和Reduce Task 使用。TaskTracker 通过slot 数目（可配置参数）限定Task 的并发度。\nTask分为Map Task和Reduce Task两种，均由TaskTracker启动。HDFS以block块存储数据，mapreduce处理的最小数据单位为split。\n　　\n4. HDFS\n保存数据和配置信息等。\n```\n\n#### ZooKeeper\n```\n设计目的\n1.最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。\n2 .可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。\n3 .实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。\n4 .等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。\n5.原子性：更新只能成功或者失败，没有中间状态。\n6 .顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。\n\n工作原理\nZAB: ZooKeeper Atomic Broadcast zk原子广播协议\nZookeeper的核心是原子广播机制，这个机制保证了各个server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式和广播模式。\n1) 恢复模式\n当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和server具有相同的系统状态。\n2) 广播模式\n一旦Leader已经和多数的Follower进行了状态同步后，他就可以开始广播消息了，即进入广播状态。这时候当一个Server加入ZooKeeper服务中，它会在恢复模式下启动，发现Leader，并和Leader进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper服务一直维持在Broadcast状态，直到Leader崩溃了或者Leader失去了大部分的Followers支持。\n```\n\n#### HDFS\n```\n一个高可靠，高吞吐量的分布式文件系统，通俗的说就是把文件存储到多台服务器上\n\nNamenode全权管理数据块的复制，它周期性地从集群中的每个Datanode接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该Datanode节点工作正常\n。块状态报告包含了一个该Datanode上所有数据块的列表。\n\nNamenode是一个中心服务器:单一节点（简化系统的设计和实现），负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。\nSecondaryNameNode 用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。\nDatanode一个数据块在DataNode以文件存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳DataNode启动后向NameNode注册，通过后，周期性（1小时）的向NameNode上报所有的块信息\n\n文件操作:NameNode负责文件元数据的操作，DataNode负责处理文件内容的读写请求，跟文件内容相关的数据流不经过NameNode，只会询问它跟那个DataNode联系，否则NameNode会成为系统的瓶颈。\n\n副本存放位置：DataNode上由NameNode来控制，根据全局情况做出块放置决定，读取文件时NameNode尽量让用户先读取最近的副本，降低带块消耗和读取时延\n```\n\n#### spark\n\n- spark数据倾斜时如何优化处理？\n```\n在shuffle阶段会出现数据倾斜，distinct/groupbyKey/reducebykey/join/repartition时会导致这些情况。\n解决方案：\n1）预处理数据，将发生数据倾斜提前解决，一般一天处理一次；对于频繁调度spark的场景使用。\n2）过滤导致倾斜的key：如果这些key对统计分析结果不重要，那么就过滤掉。\n3）阶段聚合：（局部聚合+全局聚合）\n4）将reduce join转为map join：适合大表对小表场景，将小表进行广播\n5）采样倾斜key并分拆join操作： 对导致倾斜的key加上随机前缀，将rdd打散到多个task中\n6）多种方法组合\n```\n\n- 日志系统的etl环节具体每步都做了哪些事情？数据质量是如何保证的？\n```\n数据采集：从不同的数据来源收集日志，如nginx访问日志，应用日志，用户上报日志等\n数据清洗：过滤一些无效日志，重复日志等\n数据转换：将原始数据转换到适合数据挖掘分析的形式\n数据存储：将格式化后的日志存储到文件系统或数据库中，如hdfs、hbase\n数据分析：通过大数据技术进行数据挖掘分析，得到某些维度或分类数据结果\n数据展示：分析后的数据存储于某数据库，通过报表的形式展现给需求方\n```\n\n#### hbase\n```\nhbase 的特点是什么\n(1) Hbase一个分布式的基于列式存储的数据库,基于Hadoop的hdfs存储，zookeeper进行管理。\n(2) Hbase适合存储半结构化或非结构化数据，对于数据结构字段不够确定或者杂乱无章很难按一个概念去抽取的数据。\n(3) Hbase为null的记录不会被存储.\n(4)基于的表包含rowkey，时间戳，和列族。新写入数据时，时间戳更新，同时可以查询到以前的版本.\n(5) hbase是主从架构。hmaster作为主节点，hregionserver作为从节点。\n\nHbase和hive 有什么区别\nHive和Hbase是两种基于Hadoop的不同技术 - -Hive是一种类SQL 的引擎，并且运行MapReduce 任务，Hbase 是一种在Hadoop之上的NoSQL的Key/vale数据库。当然，这两种工具是可以同时使用的。就像用Google 来搜索，用FaceBook 进行社交一样，Hive 可以用来进行统计查询，HBase 可以用来进行实时查询，数据也可以从Hive 写到Hbase，设置再从Hbase 写回Hive。\nHbase非常适合用来进行大数据的实时查询。Facebook用Hbase 进行消息和实时的分析。它也可以用来统计Facebook的连接数。\n\n描述Hbase的rowKey的设计原则.\nRowkey长度原则\nRowkey 是一个二进制码流，Rowkey 的长度被很多开发者建议说设计在10~100 个字节，\n不过建议是越短越好，不要超过16 个字节。\nRowkey散列原则\n如果Rowkey 是按时间戳的方式递增，不要将时间放在二进制码的前面，建议将Rowkey\n的高位作为散列字段，由程序循环生成，低位放时间字段，这样将提高数据均衡分布在每个\nRegionserver 实现负载均衡的几率。\nRowkey唯一原则\n必须在设计上保证其唯一性。\n\n请描述如何解决Hbase中region太小和region太大带来的冲突.\nRegion过大会发生多次compaction，将数据读一遍并重写一遍到hdfs 上，占用io，region过小会造成多次split，region 会下线，影响访问服务，调整hbase.hregion.max.filesize 为256m.\n\n简述 HBASE中compact用途是什么，什么时候触发，分为哪两种,有什么区别，有哪些相关配置参数？\n在hbase中每当有memstore数据flush到磁盘之后，就形成一个storefile，当storeFile的数量达到一定程度后，就需要将 storefile 文件来进行 compaction 操作。\nCompact 的作用：\n1>.合并文件\n2>.清除过期，多余版本的数据\n3>.提高读写数据的效率\nHBase 中实现了两种 compaction 的方式：minor and major. 这两种 compaction 方式的区别是：\n1、Minor 操作只用来做部分文件的合并操作以及包括 minVersion=0 并且设置 ttl 的过\n期版本清理，不做任何删除数据、多版本数据的清理工作。\n2、Major 操作是对 Region 下的HStore下的所有StoreFile执行合并操作，最终的结果是整理合并出一个文件。\n```\n\n\n#### flume\n```\nflume-ng中最重要的核心三大组件是source, channel, sink\n\nsource负责从源端收集数据，产出event：\nSource是数据源的总称，我们往往设定好源后，数据将源源不断的被抓取或者被推送。\n常见的数据源有：ExecSource，KafkaSource，HttpSource，NetcatSource，JmsSource，AvroSource等等。\n\nchannel负责暂存event，以备下游取走消费：\nChannel用于连接Source和Sink，Source将日志信息发送到Channel，Sink从Channel消费日志信息；Channel是中转日志信息的一个临时存储，保存有Source组件传递过来的日志信息。\n\nsink负责消费通道中的event，写到最终的输出端上：\nSink在设置存储数据时，可以向文件系统中，数据库中，hadoop中储数据，在日志数据较少时，可以将数据存储在文件系中，并且设定一定的时间间隔保存数据。在日志数据较多时，可以将相应的日志数据存储到Hadoop中，便于日后进行相应的数据分析。\n```\n\n#### kafka\n```\nKafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统(也可以当做MQ系统)，常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。\n\nKafka部分名词解释如下：\nBroker：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。\nTopic：一类消息，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发。\nPartition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。\nSegment：partition物理上由多个segment组成，下面2.2和2.3有详细说明。\noffset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition唯一标识一条消息.\n\n分析过程分为以下4个步骤：\ntopic中partition存储分布\npartiton中文件存储方式\npartiton中segment文件存储结构\n在partition中如何通过offset查找message\n\nKafka高效文件存储设计特点\nKafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。\n通过索引信息可以快速定位message和确定response的最大大小。\n通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作。\n通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小。\n```\n\n#### streaming analysis\n```\nStorm&SparkStreaming\n处理模型,延迟\n虽然这两个框架都提供可扩展性和容错性,它们根本的区别在于他们的处理模型。而Storm处理的是每次传入的一个事件，而Spark Streaming是处理某个时间段窗口内的事件流。因此,Storm处理一个事件可以达到秒内的延迟，而Spark Streaming则有几秒钟的延迟。\n\n容错、数据保证\n在容错数据保证方面的权衡是，Spark Streaming提供了更好的支持容错状态计算。在Storm中,每个单独的记录当它通过系统时必须被跟踪，所以Storm能够至少保证每个记录将被处理一次，但是在从错误中恢复过来时候允许出现重复记录。这意味着可变状态可能不正确地被更新两次。\n\n另一方面，Spark Streaming只需要在批级别进行跟踪处理，因此可以有效地保证每个mini-batch将完全被处理一次，即便一个节点发生故障。(实际上,Storm的 Trident library库也提供了完全一次处理。但是,它依赖于事务更新状态,这比较慢,通常必须由用户实现。)\n\n简而言之,如果你需要秒内的延迟，Storm是一个不错的选择，而且没有数据丢失。如果你需要有状态的计算，而且要完全保证每个事件只被处理一次，Spark Streaming则更好。Spark Streaming编程逻辑也可能更容易，因为它类似于批处理程序(Hadoop)，特别是在你使用批次(尽管是很小的)时。\n\n实现,编程api\nStorm初次是由Clojure实现，而 Spark Streaming是使用Scala. 如果你想看看代码还是让自己的定制时需要注意的地方，这样以便发现每个系统是如何工作的。Storm是由BackType和Twitter开发; Spark Streaming是在加州大学伯克利分校开发的。\n\nStorm 有一个Java API, 也支持其他语言，而Spark Streaming是以Scala编程，当然也支持Java\n\nSpark Streaming一个好的特性是其运行在Spark上. 这样你能够你编写批处理的同样代码，这就不需要编写单独的代码来处理实时流数据和历史数据。\n\n产品支持\nStorm已经发布几年了，在Twitter从2011年运行至今，同时也有其他公司使用，而Spark Streaming是一个新的项目，它从2013年在Sharethrough有一个项目运行。\n\nHadoop支持\nStorm是一个 Hortonworks Hadoop数据平台上的流解决方案，而Spark Streaming有 MapR的版本还有Cloudera的企业数据平台，Databricks也提供Spark支持。\n\n集群管理集成\n尽管两个系统都运行在它们自己的集群上，Storm也能运行在Mesos, 而Spark Streaming能运行在YARN 和 Mesos上。\n```\n\n#### ELK\n```\nhttps://www.ibm.com/developerworks/cn/opensource/os-cn-elk/\n\nElasticsearch\nElasticsearch 是一个实时的分布式搜索和分析引擎，它可以用于全文搜索，结构化搜索以及分析。它是一个建立在全文搜索引擎 Apache Lucene 基础上的搜索引擎，使用 Java 语言编写。目前，最新的版本是 2.1.0。\n主要特点\n实时分析\n分布式实时文件存储，并将每一个字段都编入索引\n文档导向，所有的对象全部是文档\n高可用性，易扩展，支持集群（Cluster）、分片和复制（Shards 和 Replicas）。见图 2 和图 3\n接口友好，支持 JSON\n\nLogstash\nLogstash 是一个具有实时渠道能力的数据收集引擎。使用 JRuby 语言编写。其作者是世界著名的运维工程师乔丹西塞 (JordanSissel)。\n主要特点\n几乎可以访问任何数据\n可以和多种外部应用结合\n支持弹性扩展\n它由三个主要部分组成，见图 4：\nShipper－发送日志数据\nBroker－收集数据，缺省内置 Redis\nIndexer－数据写入\n\nKibana\nKibana 是一款基于 Apache 开源协议，使用 JavaScript 语言编写，为 Elasticsearch 提供分析和可视化的 Web 平台。它可以在 Elasticsearch 的索引中查找，交互数据，并生成各种维度的表图。\n```\n\n#### machine learning\n```\nhttp://blog.jobbole.com/108395/\nhttp://blog.jobbole.com/92021/\n\n广义来说，有三种机器学习算法\n\n1、 监督式学习\n\n工作机制：这个算法由一个目标变量或结果变量（或因变量）组成。这些变量由已知的一系列预示变量（自变量）预测而来。利用这一系列变量，我们生成一个将输入值映射到期望输出值的函数。这个训练过程会一直持续，直到模型在训练数据上获得期望的精确度。监督式学习的例子有：回归、决策树、随机森林、K – 近邻算法、逻辑回归等。\n\n2、非监督式学习\n\n工作机制：在这个算法中，没有任何目标变量或结果变量要预测或估计。这个算法用在不同的组内聚类分析。这种分析方式被广泛地用来细分客户，根据干预的方式分为不同的用户组。非监督式学习的例子有：关联算法和 K – 均值算法。\n\n3、强化学习\n\n工作机制：这个算法训练机器进行决策。它是这样工作的：机器被放在一个能让它通过反复试错来训练自己的环境中。机器从过去的经验中进行学习，并且尝试利用了解最透彻的知识作出精确的商业判断。 强化学习的例子有马尔可夫决策过程。\n\n常见机器学习算法名单\n\n这里是一个常用的机器学习算法名单。这些算法几乎可以用在所有的数据问题上：\n\n线性回归\n逻辑回归\n决策树\nSVM\n朴素贝叶斯\nK最近邻算法\nK均值算法\n随机森林算法\n降维算法\nGradient Boost 和 Adaboost 算法\n\n\n可以先说说主要的一些概念， 然后挑一个比较熟悉的算法来讲， 包括算法原理、使用场景和缺点等\n```\n\n\n#### 大数据处理相关面试题\n\n- TopK问题\n求最大K个数用最小堆，最小K个数用最大堆\n- 大数据处理常用排序\n快速排序/堆排序/归并排序/桶排序\n- 有a、b两个文件，各存放50亿个url，每个url各占64byte，内存限制是4G，如何找出a、b文件共同的url？\n- 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，要求返回频数最高的100个词。\n- 现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的那个IP。\n- 现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的那个IP；假设这个IP总会超过总数的一半。\n","source":"_posts/bigdata/data-developing-md.md","raw":"---\ntitle: '大数据开发技术知识点'\ndate: 2017-12-01 16:44:10\ntags: bigdata\n---\n\n\n#### CAP理论\n```\n1) 理论概述\n分布式领域中CAP理论：\n① C：Consistency，一致性，数据一致更新，所有数据变动都是同步的。\n② A：Availability，可用性，系统具有好的响应性能。\n③ P：Partition tolerance，分区容错性。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，也就是说无论任何消息丢失，系统都可用。\n\n该理论已被证明：任何分布式系统只可同时满足两点，无法三者兼顾。 因此，将精力浪费在思考如何设计能满足三者的完美系统上是愚钝的，应该根据应用场景进行适当取舍。\n\n2) 一致性分类\n一致性是指从系统外部读取系统内部的数据时，在一定约束条件下相同，即数据变动在系统内部各节点应该是同步的。根据一致性的强弱程度不同，可以将一致性级别分为如下几种：\n① 强一致性（strong consistency）。任何时刻，任何用户都能读取到最近一次成功更新的数据。\n② 单调一致性（monotonic consistency）。任何时刻，任何用户一旦读到某个数据在某次更新后的值，那么就不会再读到比这个值更旧的值。也就是说，可获取的数据顺序必是单调递增的。\n③ 会话一致性（session consistency）。任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在本次会话中就不会再读到比这个值更旧的值。会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话内的单调性，在不同用户或同一用户不同会话间则没有保障。\n④ 最终一致性（eventual consistency）。用户只能读到某次更新后的值，但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障。\n⑤ 弱一致性（weak consistency）。用户无法在确定时间内读到最新更新的值。\n```\n<!--more-->\n#### MapReduce\n```\nMapReduce主要包括JobClient、JobTracker、TaskTracker、HDFS四个独立的部分。\n\n1、JobClient\n配置参数Configuration，并打包成jar文件存储在HDFS上，将文件路径提交给JobTracker的master服务，然后由master创建每个task将它们分发到各个TaskTracker服务中去执行。\n\n2、JobTracker\n这是一个master服务，程序启动后，JobTracker负责资源监控和作业调度。JobTracker监控所有的TaskTracker和job的健康状况，一旦发生失败，即将之转移到其他节点上，同时JobTracker会跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器，而调度器会在资源出现空闲时，选择合适的任务使用这些资源。在Hadoop 中，任务调度器是一个可插拔的模块，用户可以根据自己的需要设计相应的调度器。\n\n3、TaskTracker\n运行在多个节点上的slaver服务。TaskTracker主动与JobTracker通信接受作业，并负责直接执行每个任务。TaskTracker 会周期性地通过Heartbeat 将本节点上资源的使用情况和任务的运行进度汇报给JobTracker，同时接收JobTracker 发送过来的命令并执行相应的操作（如启动新任务、杀死任务等）。TaskTracker 使用“slot”等量划分本节点上的资源量。“slot”代表计算资源（CPU、内存等）。一个Task 获取到一个slot 后才有机会运行，而Hadoop 调度器的作用就是将各个TaskTracker 上的空闲slot 分配给Task 使用。slot 分为Map slot 和Reduce slot 两种，分别供MapTask 和Reduce Task 使用。TaskTracker 通过slot 数目（可配置参数）限定Task 的并发度。\nTask分为Map Task和Reduce Task两种，均由TaskTracker启动。HDFS以block块存储数据，mapreduce处理的最小数据单位为split。\n　　\n4. HDFS\n保存数据和配置信息等。\n```\n\n#### ZooKeeper\n```\n设计目的\n1.最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。\n2 .可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。\n3 .实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。\n4 .等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。\n5.原子性：更新只能成功或者失败，没有中间状态。\n6 .顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。\n\n工作原理\nZAB: ZooKeeper Atomic Broadcast zk原子广播协议\nZookeeper的核心是原子广播机制，这个机制保证了各个server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式和广播模式。\n1) 恢复模式\n当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和server具有相同的系统状态。\n2) 广播模式\n一旦Leader已经和多数的Follower进行了状态同步后，他就可以开始广播消息了，即进入广播状态。这时候当一个Server加入ZooKeeper服务中，它会在恢复模式下启动，发现Leader，并和Leader进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper服务一直维持在Broadcast状态，直到Leader崩溃了或者Leader失去了大部分的Followers支持。\n```\n\n#### HDFS\n```\n一个高可靠，高吞吐量的分布式文件系统，通俗的说就是把文件存储到多台服务器上\n\nNamenode全权管理数据块的复制，它周期性地从集群中的每个Datanode接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该Datanode节点工作正常\n。块状态报告包含了一个该Datanode上所有数据块的列表。\n\nNamenode是一个中心服务器:单一节点（简化系统的设计和实现），负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。\nSecondaryNameNode 用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。\nDatanode一个数据块在DataNode以文件存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳DataNode启动后向NameNode注册，通过后，周期性（1小时）的向NameNode上报所有的块信息\n\n文件操作:NameNode负责文件元数据的操作，DataNode负责处理文件内容的读写请求，跟文件内容相关的数据流不经过NameNode，只会询问它跟那个DataNode联系，否则NameNode会成为系统的瓶颈。\n\n副本存放位置：DataNode上由NameNode来控制，根据全局情况做出块放置决定，读取文件时NameNode尽量让用户先读取最近的副本，降低带块消耗和读取时延\n```\n\n#### spark\n\n- spark数据倾斜时如何优化处理？\n```\n在shuffle阶段会出现数据倾斜，distinct/groupbyKey/reducebykey/join/repartition时会导致这些情况。\n解决方案：\n1）预处理数据，将发生数据倾斜提前解决，一般一天处理一次；对于频繁调度spark的场景使用。\n2）过滤导致倾斜的key：如果这些key对统计分析结果不重要，那么就过滤掉。\n3）阶段聚合：（局部聚合+全局聚合）\n4）将reduce join转为map join：适合大表对小表场景，将小表进行广播\n5）采样倾斜key并分拆join操作： 对导致倾斜的key加上随机前缀，将rdd打散到多个task中\n6）多种方法组合\n```\n\n- 日志系统的etl环节具体每步都做了哪些事情？数据质量是如何保证的？\n```\n数据采集：从不同的数据来源收集日志，如nginx访问日志，应用日志，用户上报日志等\n数据清洗：过滤一些无效日志，重复日志等\n数据转换：将原始数据转换到适合数据挖掘分析的形式\n数据存储：将格式化后的日志存储到文件系统或数据库中，如hdfs、hbase\n数据分析：通过大数据技术进行数据挖掘分析，得到某些维度或分类数据结果\n数据展示：分析后的数据存储于某数据库，通过报表的形式展现给需求方\n```\n\n#### hbase\n```\nhbase 的特点是什么\n(1) Hbase一个分布式的基于列式存储的数据库,基于Hadoop的hdfs存储，zookeeper进行管理。\n(2) Hbase适合存储半结构化或非结构化数据，对于数据结构字段不够确定或者杂乱无章很难按一个概念去抽取的数据。\n(3) Hbase为null的记录不会被存储.\n(4)基于的表包含rowkey，时间戳，和列族。新写入数据时，时间戳更新，同时可以查询到以前的版本.\n(5) hbase是主从架构。hmaster作为主节点，hregionserver作为从节点。\n\nHbase和hive 有什么区别\nHive和Hbase是两种基于Hadoop的不同技术 - -Hive是一种类SQL 的引擎，并且运行MapReduce 任务，Hbase 是一种在Hadoop之上的NoSQL的Key/vale数据库。当然，这两种工具是可以同时使用的。就像用Google 来搜索，用FaceBook 进行社交一样，Hive 可以用来进行统计查询，HBase 可以用来进行实时查询，数据也可以从Hive 写到Hbase，设置再从Hbase 写回Hive。\nHbase非常适合用来进行大数据的实时查询。Facebook用Hbase 进行消息和实时的分析。它也可以用来统计Facebook的连接数。\n\n描述Hbase的rowKey的设计原则.\nRowkey长度原则\nRowkey 是一个二进制码流，Rowkey 的长度被很多开发者建议说设计在10~100 个字节，\n不过建议是越短越好，不要超过16 个字节。\nRowkey散列原则\n如果Rowkey 是按时间戳的方式递增，不要将时间放在二进制码的前面，建议将Rowkey\n的高位作为散列字段，由程序循环生成，低位放时间字段，这样将提高数据均衡分布在每个\nRegionserver 实现负载均衡的几率。\nRowkey唯一原则\n必须在设计上保证其唯一性。\n\n请描述如何解决Hbase中region太小和region太大带来的冲突.\nRegion过大会发生多次compaction，将数据读一遍并重写一遍到hdfs 上，占用io，region过小会造成多次split，region 会下线，影响访问服务，调整hbase.hregion.max.filesize 为256m.\n\n简述 HBASE中compact用途是什么，什么时候触发，分为哪两种,有什么区别，有哪些相关配置参数？\n在hbase中每当有memstore数据flush到磁盘之后，就形成一个storefile，当storeFile的数量达到一定程度后，就需要将 storefile 文件来进行 compaction 操作。\nCompact 的作用：\n1>.合并文件\n2>.清除过期，多余版本的数据\n3>.提高读写数据的效率\nHBase 中实现了两种 compaction 的方式：minor and major. 这两种 compaction 方式的区别是：\n1、Minor 操作只用来做部分文件的合并操作以及包括 minVersion=0 并且设置 ttl 的过\n期版本清理，不做任何删除数据、多版本数据的清理工作。\n2、Major 操作是对 Region 下的HStore下的所有StoreFile执行合并操作，最终的结果是整理合并出一个文件。\n```\n\n\n#### flume\n```\nflume-ng中最重要的核心三大组件是source, channel, sink\n\nsource负责从源端收集数据，产出event：\nSource是数据源的总称，我们往往设定好源后，数据将源源不断的被抓取或者被推送。\n常见的数据源有：ExecSource，KafkaSource，HttpSource，NetcatSource，JmsSource，AvroSource等等。\n\nchannel负责暂存event，以备下游取走消费：\nChannel用于连接Source和Sink，Source将日志信息发送到Channel，Sink从Channel消费日志信息；Channel是中转日志信息的一个临时存储，保存有Source组件传递过来的日志信息。\n\nsink负责消费通道中的event，写到最终的输出端上：\nSink在设置存储数据时，可以向文件系统中，数据库中，hadoop中储数据，在日志数据较少时，可以将数据存储在文件系中，并且设定一定的时间间隔保存数据。在日志数据较多时，可以将相应的日志数据存储到Hadoop中，便于日后进行相应的数据分析。\n```\n\n#### kafka\n```\nKafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统(也可以当做MQ系统)，常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。\n\nKafka部分名词解释如下：\nBroker：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。\nTopic：一类消息，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发。\nPartition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。\nSegment：partition物理上由多个segment组成，下面2.2和2.3有详细说明。\noffset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition唯一标识一条消息.\n\n分析过程分为以下4个步骤：\ntopic中partition存储分布\npartiton中文件存储方式\npartiton中segment文件存储结构\n在partition中如何通过offset查找message\n\nKafka高效文件存储设计特点\nKafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。\n通过索引信息可以快速定位message和确定response的最大大小。\n通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作。\n通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小。\n```\n\n#### streaming analysis\n```\nStorm&SparkStreaming\n处理模型,延迟\n虽然这两个框架都提供可扩展性和容错性,它们根本的区别在于他们的处理模型。而Storm处理的是每次传入的一个事件，而Spark Streaming是处理某个时间段窗口内的事件流。因此,Storm处理一个事件可以达到秒内的延迟，而Spark Streaming则有几秒钟的延迟。\n\n容错、数据保证\n在容错数据保证方面的权衡是，Spark Streaming提供了更好的支持容错状态计算。在Storm中,每个单独的记录当它通过系统时必须被跟踪，所以Storm能够至少保证每个记录将被处理一次，但是在从错误中恢复过来时候允许出现重复记录。这意味着可变状态可能不正确地被更新两次。\n\n另一方面，Spark Streaming只需要在批级别进行跟踪处理，因此可以有效地保证每个mini-batch将完全被处理一次，即便一个节点发生故障。(实际上,Storm的 Trident library库也提供了完全一次处理。但是,它依赖于事务更新状态,这比较慢,通常必须由用户实现。)\n\n简而言之,如果你需要秒内的延迟，Storm是一个不错的选择，而且没有数据丢失。如果你需要有状态的计算，而且要完全保证每个事件只被处理一次，Spark Streaming则更好。Spark Streaming编程逻辑也可能更容易，因为它类似于批处理程序(Hadoop)，特别是在你使用批次(尽管是很小的)时。\n\n实现,编程api\nStorm初次是由Clojure实现，而 Spark Streaming是使用Scala. 如果你想看看代码还是让自己的定制时需要注意的地方，这样以便发现每个系统是如何工作的。Storm是由BackType和Twitter开发; Spark Streaming是在加州大学伯克利分校开发的。\n\nStorm 有一个Java API, 也支持其他语言，而Spark Streaming是以Scala编程，当然也支持Java\n\nSpark Streaming一个好的特性是其运行在Spark上. 这样你能够你编写批处理的同样代码，这就不需要编写单独的代码来处理实时流数据和历史数据。\n\n产品支持\nStorm已经发布几年了，在Twitter从2011年运行至今，同时也有其他公司使用，而Spark Streaming是一个新的项目，它从2013年在Sharethrough有一个项目运行。\n\nHadoop支持\nStorm是一个 Hortonworks Hadoop数据平台上的流解决方案，而Spark Streaming有 MapR的版本还有Cloudera的企业数据平台，Databricks也提供Spark支持。\n\n集群管理集成\n尽管两个系统都运行在它们自己的集群上，Storm也能运行在Mesos, 而Spark Streaming能运行在YARN 和 Mesos上。\n```\n\n#### ELK\n```\nhttps://www.ibm.com/developerworks/cn/opensource/os-cn-elk/\n\nElasticsearch\nElasticsearch 是一个实时的分布式搜索和分析引擎，它可以用于全文搜索，结构化搜索以及分析。它是一个建立在全文搜索引擎 Apache Lucene 基础上的搜索引擎，使用 Java 语言编写。目前，最新的版本是 2.1.0。\n主要特点\n实时分析\n分布式实时文件存储，并将每一个字段都编入索引\n文档导向，所有的对象全部是文档\n高可用性，易扩展，支持集群（Cluster）、分片和复制（Shards 和 Replicas）。见图 2 和图 3\n接口友好，支持 JSON\n\nLogstash\nLogstash 是一个具有实时渠道能力的数据收集引擎。使用 JRuby 语言编写。其作者是世界著名的运维工程师乔丹西塞 (JordanSissel)。\n主要特点\n几乎可以访问任何数据\n可以和多种外部应用结合\n支持弹性扩展\n它由三个主要部分组成，见图 4：\nShipper－发送日志数据\nBroker－收集数据，缺省内置 Redis\nIndexer－数据写入\n\nKibana\nKibana 是一款基于 Apache 开源协议，使用 JavaScript 语言编写，为 Elasticsearch 提供分析和可视化的 Web 平台。它可以在 Elasticsearch 的索引中查找，交互数据，并生成各种维度的表图。\n```\n\n#### machine learning\n```\nhttp://blog.jobbole.com/108395/\nhttp://blog.jobbole.com/92021/\n\n广义来说，有三种机器学习算法\n\n1、 监督式学习\n\n工作机制：这个算法由一个目标变量或结果变量（或因变量）组成。这些变量由已知的一系列预示变量（自变量）预测而来。利用这一系列变量，我们生成一个将输入值映射到期望输出值的函数。这个训练过程会一直持续，直到模型在训练数据上获得期望的精确度。监督式学习的例子有：回归、决策树、随机森林、K – 近邻算法、逻辑回归等。\n\n2、非监督式学习\n\n工作机制：在这个算法中，没有任何目标变量或结果变量要预测或估计。这个算法用在不同的组内聚类分析。这种分析方式被广泛地用来细分客户，根据干预的方式分为不同的用户组。非监督式学习的例子有：关联算法和 K – 均值算法。\n\n3、强化学习\n\n工作机制：这个算法训练机器进行决策。它是这样工作的：机器被放在一个能让它通过反复试错来训练自己的环境中。机器从过去的经验中进行学习，并且尝试利用了解最透彻的知识作出精确的商业判断。 强化学习的例子有马尔可夫决策过程。\n\n常见机器学习算法名单\n\n这里是一个常用的机器学习算法名单。这些算法几乎可以用在所有的数据问题上：\n\n线性回归\n逻辑回归\n决策树\nSVM\n朴素贝叶斯\nK最近邻算法\nK均值算法\n随机森林算法\n降维算法\nGradient Boost 和 Adaboost 算法\n\n\n可以先说说主要的一些概念， 然后挑一个比较熟悉的算法来讲， 包括算法原理、使用场景和缺点等\n```\n\n\n#### 大数据处理相关面试题\n\n- TopK问题\n求最大K个数用最小堆，最小K个数用最大堆\n- 大数据处理常用排序\n快速排序/堆排序/归并排序/桶排序\n- 有a、b两个文件，各存放50亿个url，每个url各占64byte，内存限制是4G，如何找出a、b文件共同的url？\n- 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，要求返回频数最高的100个词。\n- 现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的那个IP。\n- 现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的那个IP；假设这个IP总会超过总数的一半。\n","slug":"bigdata/data-developing-md","published":1,"updated":"2017-12-01T08:48:06.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00duv00074j4dtoi2n7wz","content":"<h4 id=\"CAP理论\"><a href=\"#CAP理论\" class=\"headerlink\" title=\"CAP理论\"></a>CAP理论</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">1) 理论概述</div><div class=\"line\">分布式领域中CAP理论：</div><div class=\"line\">① C：Consistency，一致性，数据一致更新，所有数据变动都是同步的。</div><div class=\"line\">② A：Availability，可用性，系统具有好的响应性能。</div><div class=\"line\">③ P：Partition tolerance，分区容错性。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，也就是说无论任何消息丢失，系统都可用。</div><div class=\"line\"></div><div class=\"line\">该理论已被证明：任何分布式系统只可同时满足两点，无法三者兼顾。 因此，将精力浪费在思考如何设计能满足三者的完美系统上是愚钝的，应该根据应用场景进行适当取舍。</div><div class=\"line\"></div><div class=\"line\">2) 一致性分类</div><div class=\"line\">一致性是指从系统外部读取系统内部的数据时，在一定约束条件下相同，即数据变动在系统内部各节点应该是同步的。根据一致性的强弱程度不同，可以将一致性级别分为如下几种：</div><div class=\"line\">① 强一致性（strong consistency）。任何时刻，任何用户都能读取到最近一次成功更新的数据。</div><div class=\"line\">② 单调一致性（monotonic consistency）。任何时刻，任何用户一旦读到某个数据在某次更新后的值，那么就不会再读到比这个值更旧的值。也就是说，可获取的数据顺序必是单调递增的。</div><div class=\"line\">③ 会话一致性（session consistency）。任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在本次会话中就不会再读到比这个值更旧的值。会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话内的单调性，在不同用户或同一用户不同会话间则没有保障。</div><div class=\"line\">④ 最终一致性（eventual consistency）。用户只能读到某次更新后的值，但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障。</div><div class=\"line\">⑤ 弱一致性（weak consistency）。用户无法在确定时间内读到最新更新的值。</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h4 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">MapReduce主要包括JobClient、JobTracker、TaskTracker、HDFS四个独立的部分。</div><div class=\"line\"></div><div class=\"line\">1、JobClient</div><div class=\"line\">配置参数Configuration，并打包成jar文件存储在HDFS上，将文件路径提交给JobTracker的master服务，然后由master创建每个task将它们分发到各个TaskTracker服务中去执行。</div><div class=\"line\"></div><div class=\"line\">2、JobTracker</div><div class=\"line\">这是一个master服务，程序启动后，JobTracker负责资源监控和作业调度。JobTracker监控所有的TaskTracker和job的健康状况，一旦发生失败，即将之转移到其他节点上，同时JobTracker会跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器，而调度器会在资源出现空闲时，选择合适的任务使用这些资源。在Hadoop 中，任务调度器是一个可插拔的模块，用户可以根据自己的需要设计相应的调度器。</div><div class=\"line\"></div><div class=\"line\">3、TaskTracker</div><div class=\"line\">运行在多个节点上的slaver服务。TaskTracker主动与JobTracker通信接受作业，并负责直接执行每个任务。TaskTracker 会周期性地通过Heartbeat 将本节点上资源的使用情况和任务的运行进度汇报给JobTracker，同时接收JobTracker 发送过来的命令并执行相应的操作（如启动新任务、杀死任务等）。TaskTracker 使用“slot”等量划分本节点上的资源量。“slot”代表计算资源（CPU、内存等）。一个Task 获取到一个slot 后才有机会运行，而Hadoop 调度器的作用就是将各个TaskTracker 上的空闲slot 分配给Task 使用。slot 分为Map slot 和Reduce slot 两种，分别供MapTask 和Reduce Task 使用。TaskTracker 通过slot 数目（可配置参数）限定Task 的并发度。</div><div class=\"line\">Task分为Map Task和Reduce Task两种，均由TaskTracker启动。HDFS以block块存储数据，mapreduce处理的最小数据单位为split。</div><div class=\"line\">　　</div><div class=\"line\">4. HDFS</div><div class=\"line\">保存数据和配置信息等。</div></pre></td></tr></table></figure>\n<h4 id=\"ZooKeeper\"><a href=\"#ZooKeeper\" class=\"headerlink\" title=\"ZooKeeper\"></a>ZooKeeper</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">设计目的</div><div class=\"line\">1.最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</div><div class=\"line\">2 .可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。</div><div class=\"line\">3 .实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。</div><div class=\"line\">4 .等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。</div><div class=\"line\">5.原子性：更新只能成功或者失败，没有中间状态。</div><div class=\"line\">6 .顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</div><div class=\"line\"></div><div class=\"line\">工作原理</div><div class=\"line\">ZAB: ZooKeeper Atomic Broadcast zk原子广播协议</div><div class=\"line\">Zookeeper的核心是原子广播机制，这个机制保证了各个server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式和广播模式。</div><div class=\"line\">1) 恢复模式</div><div class=\"line\">当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和server具有相同的系统状态。</div><div class=\"line\">2) 广播模式</div><div class=\"line\">一旦Leader已经和多数的Follower进行了状态同步后，他就可以开始广播消息了，即进入广播状态。这时候当一个Server加入ZooKeeper服务中，它会在恢复模式下启动，发现Leader，并和Leader进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper服务一直维持在Broadcast状态，直到Leader崩溃了或者Leader失去了大部分的Followers支持。</div></pre></td></tr></table></figure>\n<h4 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a>HDFS</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">一个高可靠，高吞吐量的分布式文件系统，通俗的说就是把文件存储到多台服务器上</div><div class=\"line\"></div><div class=\"line\">Namenode全权管理数据块的复制，它周期性地从集群中的每个Datanode接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该Datanode节点工作正常</div><div class=\"line\">。块状态报告包含了一个该Datanode上所有数据块的列表。</div><div class=\"line\"></div><div class=\"line\">Namenode是一个中心服务器:单一节点（简化系统的设计和实现），负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。</div><div class=\"line\">SecondaryNameNode 用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。</div><div class=\"line\">Datanode一个数据块在DataNode以文件存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳DataNode启动后向NameNode注册，通过后，周期性（1小时）的向NameNode上报所有的块信息</div><div class=\"line\"></div><div class=\"line\">文件操作:NameNode负责文件元数据的操作，DataNode负责处理文件内容的读写请求，跟文件内容相关的数据流不经过NameNode，只会询问它跟那个DataNode联系，否则NameNode会成为系统的瓶颈。</div><div class=\"line\"></div><div class=\"line\">副本存放位置：DataNode上由NameNode来控制，根据全局情况做出块放置决定，读取文件时NameNode尽量让用户先读取最近的副本，降低带块消耗和读取时延</div></pre></td></tr></table></figure>\n<h4 id=\"spark\"><a href=\"#spark\" class=\"headerlink\" title=\"spark\"></a>spark</h4><ul>\n<li><p>spark数据倾斜时如何优化处理？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">在shuffle阶段会出现数据倾斜，distinct/groupbyKey/reducebykey/join/repartition时会导致这些情况。</div><div class=\"line\">解决方案：</div><div class=\"line\">1）预处理数据，将发生数据倾斜提前解决，一般一天处理一次；对于频繁调度spark的场景使用。</div><div class=\"line\">2）过滤导致倾斜的key：如果这些key对统计分析结果不重要，那么就过滤掉。</div><div class=\"line\">3）阶段聚合：（局部聚合+全局聚合）</div><div class=\"line\">4）将reduce join转为map join：适合大表对小表场景，将小表进行广播</div><div class=\"line\">5）采样倾斜key并分拆join操作： 对导致倾斜的key加上随机前缀，将rdd打散到多个task中</div><div class=\"line\">6）多种方法组合</div></pre></td></tr></table></figure>\n</li>\n<li><p>日志系统的etl环节具体每步都做了哪些事情？数据质量是如何保证的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">数据采集：从不同的数据来源收集日志，如nginx访问日志，应用日志，用户上报日志等</div><div class=\"line\">数据清洗：过滤一些无效日志，重复日志等</div><div class=\"line\">数据转换：将原始数据转换到适合数据挖掘分析的形式</div><div class=\"line\">数据存储：将格式化后的日志存储到文件系统或数据库中，如hdfs、hbase</div><div class=\"line\">数据分析：通过大数据技术进行数据挖掘分析，得到某些维度或分类数据结果</div><div class=\"line\">数据展示：分析后的数据存储于某数据库，通过报表的形式展现给需求方</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"hbase\"><a href=\"#hbase\" class=\"headerlink\" title=\"hbase\"></a>hbase</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">hbase 的特点是什么</div><div class=\"line\">(1) Hbase一个分布式的基于列式存储的数据库,基于Hadoop的hdfs存储，zookeeper进行管理。</div><div class=\"line\">(2) Hbase适合存储半结构化或非结构化数据，对于数据结构字段不够确定或者杂乱无章很难按一个概念去抽取的数据。</div><div class=\"line\">(3) Hbase为null的记录不会被存储.</div><div class=\"line\">(4)基于的表包含rowkey，时间戳，和列族。新写入数据时，时间戳更新，同时可以查询到以前的版本.</div><div class=\"line\">(5) hbase是主从架构。hmaster作为主节点，hregionserver作为从节点。</div><div class=\"line\"></div><div class=\"line\">Hbase和hive 有什么区别</div><div class=\"line\">Hive和Hbase是两种基于Hadoop的不同技术 - -Hive是一种类SQL 的引擎，并且运行MapReduce 任务，Hbase 是一种在Hadoop之上的NoSQL的Key/vale数据库。当然，这两种工具是可以同时使用的。就像用Google 来搜索，用FaceBook 进行社交一样，Hive 可以用来进行统计查询，HBase 可以用来进行实时查询，数据也可以从Hive 写到Hbase，设置再从Hbase 写回Hive。</div><div class=\"line\">Hbase非常适合用来进行大数据的实时查询。Facebook用Hbase 进行消息和实时的分析。它也可以用来统计Facebook的连接数。</div><div class=\"line\"></div><div class=\"line\">描述Hbase的rowKey的设计原则.</div><div class=\"line\">Rowkey长度原则</div><div class=\"line\">Rowkey 是一个二进制码流，Rowkey 的长度被很多开发者建议说设计在10~100 个字节，</div><div class=\"line\">不过建议是越短越好，不要超过16 个字节。</div><div class=\"line\">Rowkey散列原则</div><div class=\"line\">如果Rowkey 是按时间戳的方式递增，不要将时间放在二进制码的前面，建议将Rowkey</div><div class=\"line\">的高位作为散列字段，由程序循环生成，低位放时间字段，这样将提高数据均衡分布在每个</div><div class=\"line\">Regionserver 实现负载均衡的几率。</div><div class=\"line\">Rowkey唯一原则</div><div class=\"line\">必须在设计上保证其唯一性。</div><div class=\"line\"></div><div class=\"line\">请描述如何解决Hbase中region太小和region太大带来的冲突.</div><div class=\"line\">Region过大会发生多次compaction，将数据读一遍并重写一遍到hdfs 上，占用io，region过小会造成多次split，region 会下线，影响访问服务，调整hbase.hregion.max.filesize 为256m.</div><div class=\"line\"></div><div class=\"line\">简述 HBASE中compact用途是什么，什么时候触发，分为哪两种,有什么区别，有哪些相关配置参数？</div><div class=\"line\">在hbase中每当有memstore数据flush到磁盘之后，就形成一个storefile，当storeFile的数量达到一定程度后，就需要将 storefile 文件来进行 compaction 操作。</div><div class=\"line\">Compact 的作用：</div><div class=\"line\">1&gt;.合并文件</div><div class=\"line\">2&gt;.清除过期，多余版本的数据</div><div class=\"line\">3&gt;.提高读写数据的效率</div><div class=\"line\">HBase 中实现了两种 compaction 的方式：minor and major. 这两种 compaction 方式的区别是：</div><div class=\"line\">1、Minor 操作只用来做部分文件的合并操作以及包括 minVersion=0 并且设置 ttl 的过</div><div class=\"line\">期版本清理，不做任何删除数据、多版本数据的清理工作。</div><div class=\"line\">2、Major 操作是对 Region 下的HStore下的所有StoreFile执行合并操作，最终的结果是整理合并出一个文件。</div></pre></td></tr></table></figure>\n<h4 id=\"flume\"><a href=\"#flume\" class=\"headerlink\" title=\"flume\"></a>flume</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">flume-ng中最重要的核心三大组件是source, channel, sink</div><div class=\"line\"></div><div class=\"line\">source负责从源端收集数据，产出event：</div><div class=\"line\">Source是数据源的总称，我们往往设定好源后，数据将源源不断的被抓取或者被推送。</div><div class=\"line\">常见的数据源有：ExecSource，KafkaSource，HttpSource，NetcatSource，JmsSource，AvroSource等等。</div><div class=\"line\"></div><div class=\"line\">channel负责暂存event，以备下游取走消费：</div><div class=\"line\">Channel用于连接Source和Sink，Source将日志信息发送到Channel，Sink从Channel消费日志信息；Channel是中转日志信息的一个临时存储，保存有Source组件传递过来的日志信息。</div><div class=\"line\"></div><div class=\"line\">sink负责消费通道中的event，写到最终的输出端上：</div><div class=\"line\">Sink在设置存储数据时，可以向文件系统中，数据库中，hadoop中储数据，在日志数据较少时，可以将数据存储在文件系中，并且设定一定的时间间隔保存数据。在日志数据较多时，可以将相应的日志数据存储到Hadoop中，便于日后进行相应的数据分析。</div></pre></td></tr></table></figure>\n<h4 id=\"kafka\"><a href=\"#kafka\" class=\"headerlink\" title=\"kafka\"></a>kafka</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">Kafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统(也可以当做MQ系统)，常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</div><div class=\"line\"></div><div class=\"line\">Kafka部分名词解释如下：</div><div class=\"line\">Broker：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。</div><div class=\"line\">Topic：一类消息，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发。</div><div class=\"line\">Partition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。</div><div class=\"line\">Segment：partition物理上由多个segment组成，下面2.2和2.3有详细说明。</div><div class=\"line\">offset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition唯一标识一条消息.</div><div class=\"line\"></div><div class=\"line\">分析过程分为以下4个步骤：</div><div class=\"line\">topic中partition存储分布</div><div class=\"line\">partiton中文件存储方式</div><div class=\"line\">partiton中segment文件存储结构</div><div class=\"line\">在partition中如何通过offset查找message</div><div class=\"line\"></div><div class=\"line\">Kafka高效文件存储设计特点</div><div class=\"line\">Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。</div><div class=\"line\">通过索引信息可以快速定位message和确定response的最大大小。</div><div class=\"line\">通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作。</div><div class=\"line\">通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小。</div></pre></td></tr></table></figure>\n<h4 id=\"streaming-analysis\"><a href=\"#streaming-analysis\" class=\"headerlink\" title=\"streaming analysis\"></a>streaming analysis</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">Storm&amp;SparkStreaming</div><div class=\"line\">处理模型,延迟</div><div class=\"line\">虽然这两个框架都提供可扩展性和容错性,它们根本的区别在于他们的处理模型。而Storm处理的是每次传入的一个事件，而Spark Streaming是处理某个时间段窗口内的事件流。因此,Storm处理一个事件可以达到秒内的延迟，而Spark Streaming则有几秒钟的延迟。</div><div class=\"line\"></div><div class=\"line\">容错、数据保证</div><div class=\"line\">在容错数据保证方面的权衡是，Spark Streaming提供了更好的支持容错状态计算。在Storm中,每个单独的记录当它通过系统时必须被跟踪，所以Storm能够至少保证每个记录将被处理一次，但是在从错误中恢复过来时候允许出现重复记录。这意味着可变状态可能不正确地被更新两次。</div><div class=\"line\"></div><div class=\"line\">另一方面，Spark Streaming只需要在批级别进行跟踪处理，因此可以有效地保证每个mini-batch将完全被处理一次，即便一个节点发生故障。(实际上,Storm的 Trident library库也提供了完全一次处理。但是,它依赖于事务更新状态,这比较慢,通常必须由用户实现。)</div><div class=\"line\"></div><div class=\"line\">简而言之,如果你需要秒内的延迟，Storm是一个不错的选择，而且没有数据丢失。如果你需要有状态的计算，而且要完全保证每个事件只被处理一次，Spark Streaming则更好。Spark Streaming编程逻辑也可能更容易，因为它类似于批处理程序(Hadoop)，特别是在你使用批次(尽管是很小的)时。</div><div class=\"line\"></div><div class=\"line\">实现,编程api</div><div class=\"line\">Storm初次是由Clojure实现，而 Spark Streaming是使用Scala. 如果你想看看代码还是让自己的定制时需要注意的地方，这样以便发现每个系统是如何工作的。Storm是由BackType和Twitter开发; Spark Streaming是在加州大学伯克利分校开发的。</div><div class=\"line\"></div><div class=\"line\">Storm 有一个Java API, 也支持其他语言，而Spark Streaming是以Scala编程，当然也支持Java</div><div class=\"line\"></div><div class=\"line\">Spark Streaming一个好的特性是其运行在Spark上. 这样你能够你编写批处理的同样代码，这就不需要编写单独的代码来处理实时流数据和历史数据。</div><div class=\"line\"></div><div class=\"line\">产品支持</div><div class=\"line\">Storm已经发布几年了，在Twitter从2011年运行至今，同时也有其他公司使用，而Spark Streaming是一个新的项目，它从2013年在Sharethrough有一个项目运行。</div><div class=\"line\"></div><div class=\"line\">Hadoop支持</div><div class=\"line\">Storm是一个 Hortonworks Hadoop数据平台上的流解决方案，而Spark Streaming有 MapR的版本还有Cloudera的企业数据平台，Databricks也提供Spark支持。</div><div class=\"line\"></div><div class=\"line\">集群管理集成</div><div class=\"line\">尽管两个系统都运行在它们自己的集群上，Storm也能运行在Mesos, 而Spark Streaming能运行在YARN 和 Mesos上。</div></pre></td></tr></table></figure>\n<h4 id=\"ELK\"><a href=\"#ELK\" class=\"headerlink\" title=\"ELK\"></a>ELK</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/</div><div class=\"line\"></div><div class=\"line\">Elasticsearch</div><div class=\"line\">Elasticsearch 是一个实时的分布式搜索和分析引擎，它可以用于全文搜索，结构化搜索以及分析。它是一个建立在全文搜索引擎 Apache Lucene 基础上的搜索引擎，使用 Java 语言编写。目前，最新的版本是 2.1.0。</div><div class=\"line\">主要特点</div><div class=\"line\">实时分析</div><div class=\"line\">分布式实时文件存储，并将每一个字段都编入索引</div><div class=\"line\">文档导向，所有的对象全部是文档</div><div class=\"line\">高可用性，易扩展，支持集群（Cluster）、分片和复制（Shards 和 Replicas）。见图 2 和图 3</div><div class=\"line\">接口友好，支持 JSON</div><div class=\"line\"></div><div class=\"line\">Logstash</div><div class=\"line\">Logstash 是一个具有实时渠道能力的数据收集引擎。使用 JRuby 语言编写。其作者是世界著名的运维工程师乔丹西塞 (JordanSissel)。</div><div class=\"line\">主要特点</div><div class=\"line\">几乎可以访问任何数据</div><div class=\"line\">可以和多种外部应用结合</div><div class=\"line\">支持弹性扩展</div><div class=\"line\">它由三个主要部分组成，见图 4：</div><div class=\"line\">Shipper－发送日志数据</div><div class=\"line\">Broker－收集数据，缺省内置 Redis</div><div class=\"line\">Indexer－数据写入</div><div class=\"line\"></div><div class=\"line\">Kibana</div><div class=\"line\">Kibana 是一款基于 Apache 开源协议，使用 JavaScript 语言编写，为 Elasticsearch 提供分析和可视化的 Web 平台。它可以在 Elasticsearch 的索引中查找，交互数据，并生成各种维度的表图。</div></pre></td></tr></table></figure>\n<h4 id=\"machine-learning\"><a href=\"#machine-learning\" class=\"headerlink\" title=\"machine learning\"></a>machine learning</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://blog.jobbole.com/108395/</div><div class=\"line\">http://blog.jobbole.com/92021/</div><div class=\"line\"></div><div class=\"line\">广义来说，有三种机器学习算法</div><div class=\"line\"></div><div class=\"line\">1、 监督式学习</div><div class=\"line\"></div><div class=\"line\">工作机制：这个算法由一个目标变量或结果变量（或因变量）组成。这些变量由已知的一系列预示变量（自变量）预测而来。利用这一系列变量，我们生成一个将输入值映射到期望输出值的函数。这个训练过程会一直持续，直到模型在训练数据上获得期望的精确度。监督式学习的例子有：回归、决策树、随机森林、K – 近邻算法、逻辑回归等。</div><div class=\"line\"></div><div class=\"line\">2、非监督式学习</div><div class=\"line\"></div><div class=\"line\">工作机制：在这个算法中，没有任何目标变量或结果变量要预测或估计。这个算法用在不同的组内聚类分析。这种分析方式被广泛地用来细分客户，根据干预的方式分为不同的用户组。非监督式学习的例子有：关联算法和 K – 均值算法。</div><div class=\"line\"></div><div class=\"line\">3、强化学习</div><div class=\"line\"></div><div class=\"line\">工作机制：这个算法训练机器进行决策。它是这样工作的：机器被放在一个能让它通过反复试错来训练自己的环境中。机器从过去的经验中进行学习，并且尝试利用了解最透彻的知识作出精确的商业判断。 强化学习的例子有马尔可夫决策过程。</div><div class=\"line\"></div><div class=\"line\">常见机器学习算法名单</div><div class=\"line\"></div><div class=\"line\">这里是一个常用的机器学习算法名单。这些算法几乎可以用在所有的数据问题上：</div><div class=\"line\"></div><div class=\"line\">线性回归</div><div class=\"line\">逻辑回归</div><div class=\"line\">决策树</div><div class=\"line\">SVM</div><div class=\"line\">朴素贝叶斯</div><div class=\"line\">K最近邻算法</div><div class=\"line\">K均值算法</div><div class=\"line\">随机森林算法</div><div class=\"line\">降维算法</div><div class=\"line\">Gradient Boost 和 Adaboost 算法</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">可以先说说主要的一些概念， 然后挑一个比较熟悉的算法来讲， 包括算法原理、使用场景和缺点等</div></pre></td></tr></table></figure>\n<h4 id=\"大数据处理相关面试题\"><a href=\"#大数据处理相关面试题\" class=\"headerlink\" title=\"大数据处理相关面试题\"></a>大数据处理相关面试题</h4><ul>\n<li>TopK问题<br>求最大K个数用最小堆，最小K个数用最大堆</li>\n<li>大数据处理常用排序<br>快速排序/堆排序/归并排序/桶排序</li>\n<li>有a、b两个文件，各存放50亿个url，每个url各占64byte，内存限制是4G，如何找出a、b文件共同的url？</li>\n<li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，要求返回频数最高的100个词。</li>\n<li>现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的那个IP。</li>\n<li>现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的那个IP；假设这个IP总会超过总数的一半。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"CAP理论\"><a href=\"#CAP理论\" class=\"headerlink\" title=\"CAP理论\"></a>CAP理论</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">1) 理论概述</div><div class=\"line\">分布式领域中CAP理论：</div><div class=\"line\">① C：Consistency，一致性，数据一致更新，所有数据变动都是同步的。</div><div class=\"line\">② A：Availability，可用性，系统具有好的响应性能。</div><div class=\"line\">③ P：Partition tolerance，分区容错性。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，也就是说无论任何消息丢失，系统都可用。</div><div class=\"line\"></div><div class=\"line\">该理论已被证明：任何分布式系统只可同时满足两点，无法三者兼顾。 因此，将精力浪费在思考如何设计能满足三者的完美系统上是愚钝的，应该根据应用场景进行适当取舍。</div><div class=\"line\"></div><div class=\"line\">2) 一致性分类</div><div class=\"line\">一致性是指从系统外部读取系统内部的数据时，在一定约束条件下相同，即数据变动在系统内部各节点应该是同步的。根据一致性的强弱程度不同，可以将一致性级别分为如下几种：</div><div class=\"line\">① 强一致性（strong consistency）。任何时刻，任何用户都能读取到最近一次成功更新的数据。</div><div class=\"line\">② 单调一致性（monotonic consistency）。任何时刻，任何用户一旦读到某个数据在某次更新后的值，那么就不会再读到比这个值更旧的值。也就是说，可获取的数据顺序必是单调递增的。</div><div class=\"line\">③ 会话一致性（session consistency）。任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在本次会话中就不会再读到比这个值更旧的值。会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话内的单调性，在不同用户或同一用户不同会话间则没有保障。</div><div class=\"line\">④ 最终一致性（eventual consistency）。用户只能读到某次更新后的值，但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障。</div><div class=\"line\">⑤ 弱一致性（weak consistency）。用户无法在确定时间内读到最新更新的值。</div></pre></td></tr></table></figure>","more":"<h4 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">MapReduce主要包括JobClient、JobTracker、TaskTracker、HDFS四个独立的部分。</div><div class=\"line\"></div><div class=\"line\">1、JobClient</div><div class=\"line\">配置参数Configuration，并打包成jar文件存储在HDFS上，将文件路径提交给JobTracker的master服务，然后由master创建每个task将它们分发到各个TaskTracker服务中去执行。</div><div class=\"line\"></div><div class=\"line\">2、JobTracker</div><div class=\"line\">这是一个master服务，程序启动后，JobTracker负责资源监控和作业调度。JobTracker监控所有的TaskTracker和job的健康状况，一旦发生失败，即将之转移到其他节点上，同时JobTracker会跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器，而调度器会在资源出现空闲时，选择合适的任务使用这些资源。在Hadoop 中，任务调度器是一个可插拔的模块，用户可以根据自己的需要设计相应的调度器。</div><div class=\"line\"></div><div class=\"line\">3、TaskTracker</div><div class=\"line\">运行在多个节点上的slaver服务。TaskTracker主动与JobTracker通信接受作业，并负责直接执行每个任务。TaskTracker 会周期性地通过Heartbeat 将本节点上资源的使用情况和任务的运行进度汇报给JobTracker，同时接收JobTracker 发送过来的命令并执行相应的操作（如启动新任务、杀死任务等）。TaskTracker 使用“slot”等量划分本节点上的资源量。“slot”代表计算资源（CPU、内存等）。一个Task 获取到一个slot 后才有机会运行，而Hadoop 调度器的作用就是将各个TaskTracker 上的空闲slot 分配给Task 使用。slot 分为Map slot 和Reduce slot 两种，分别供MapTask 和Reduce Task 使用。TaskTracker 通过slot 数目（可配置参数）限定Task 的并发度。</div><div class=\"line\">Task分为Map Task和Reduce Task两种，均由TaskTracker启动。HDFS以block块存储数据，mapreduce处理的最小数据单位为split。</div><div class=\"line\">　　</div><div class=\"line\">4. HDFS</div><div class=\"line\">保存数据和配置信息等。</div></pre></td></tr></table></figure>\n<h4 id=\"ZooKeeper\"><a href=\"#ZooKeeper\" class=\"headerlink\" title=\"ZooKeeper\"></a>ZooKeeper</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">设计目的</div><div class=\"line\">1.最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</div><div class=\"line\">2 .可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。</div><div class=\"line\">3 .实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。</div><div class=\"line\">4 .等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。</div><div class=\"line\">5.原子性：更新只能成功或者失败，没有中间状态。</div><div class=\"line\">6 .顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</div><div class=\"line\"></div><div class=\"line\">工作原理</div><div class=\"line\">ZAB: ZooKeeper Atomic Broadcast zk原子广播协议</div><div class=\"line\">Zookeeper的核心是原子广播机制，这个机制保证了各个server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式和广播模式。</div><div class=\"line\">1) 恢复模式</div><div class=\"line\">当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和server具有相同的系统状态。</div><div class=\"line\">2) 广播模式</div><div class=\"line\">一旦Leader已经和多数的Follower进行了状态同步后，他就可以开始广播消息了，即进入广播状态。这时候当一个Server加入ZooKeeper服务中，它会在恢复模式下启动，发现Leader，并和Leader进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper服务一直维持在Broadcast状态，直到Leader崩溃了或者Leader失去了大部分的Followers支持。</div></pre></td></tr></table></figure>\n<h4 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a>HDFS</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">一个高可靠，高吞吐量的分布式文件系统，通俗的说就是把文件存储到多台服务器上</div><div class=\"line\"></div><div class=\"line\">Namenode全权管理数据块的复制，它周期性地从集群中的每个Datanode接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该Datanode节点工作正常</div><div class=\"line\">。块状态报告包含了一个该Datanode上所有数据块的列表。</div><div class=\"line\"></div><div class=\"line\">Namenode是一个中心服务器:单一节点（简化系统的设计和实现），负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。</div><div class=\"line\">SecondaryNameNode 用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。</div><div class=\"line\">Datanode一个数据块在DataNode以文件存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳DataNode启动后向NameNode注册，通过后，周期性（1小时）的向NameNode上报所有的块信息</div><div class=\"line\"></div><div class=\"line\">文件操作:NameNode负责文件元数据的操作，DataNode负责处理文件内容的读写请求，跟文件内容相关的数据流不经过NameNode，只会询问它跟那个DataNode联系，否则NameNode会成为系统的瓶颈。</div><div class=\"line\"></div><div class=\"line\">副本存放位置：DataNode上由NameNode来控制，根据全局情况做出块放置决定，读取文件时NameNode尽量让用户先读取最近的副本，降低带块消耗和读取时延</div></pre></td></tr></table></figure>\n<h4 id=\"spark\"><a href=\"#spark\" class=\"headerlink\" title=\"spark\"></a>spark</h4><ul>\n<li><p>spark数据倾斜时如何优化处理？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">在shuffle阶段会出现数据倾斜，distinct/groupbyKey/reducebykey/join/repartition时会导致这些情况。</div><div class=\"line\">解决方案：</div><div class=\"line\">1）预处理数据，将发生数据倾斜提前解决，一般一天处理一次；对于频繁调度spark的场景使用。</div><div class=\"line\">2）过滤导致倾斜的key：如果这些key对统计分析结果不重要，那么就过滤掉。</div><div class=\"line\">3）阶段聚合：（局部聚合+全局聚合）</div><div class=\"line\">4）将reduce join转为map join：适合大表对小表场景，将小表进行广播</div><div class=\"line\">5）采样倾斜key并分拆join操作： 对导致倾斜的key加上随机前缀，将rdd打散到多个task中</div><div class=\"line\">6）多种方法组合</div></pre></td></tr></table></figure>\n</li>\n<li><p>日志系统的etl环节具体每步都做了哪些事情？数据质量是如何保证的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">数据采集：从不同的数据来源收集日志，如nginx访问日志，应用日志，用户上报日志等</div><div class=\"line\">数据清洗：过滤一些无效日志，重复日志等</div><div class=\"line\">数据转换：将原始数据转换到适合数据挖掘分析的形式</div><div class=\"line\">数据存储：将格式化后的日志存储到文件系统或数据库中，如hdfs、hbase</div><div class=\"line\">数据分析：通过大数据技术进行数据挖掘分析，得到某些维度或分类数据结果</div><div class=\"line\">数据展示：分析后的数据存储于某数据库，通过报表的形式展现给需求方</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"hbase\"><a href=\"#hbase\" class=\"headerlink\" title=\"hbase\"></a>hbase</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">hbase 的特点是什么</div><div class=\"line\">(1) Hbase一个分布式的基于列式存储的数据库,基于Hadoop的hdfs存储，zookeeper进行管理。</div><div class=\"line\">(2) Hbase适合存储半结构化或非结构化数据，对于数据结构字段不够确定或者杂乱无章很难按一个概念去抽取的数据。</div><div class=\"line\">(3) Hbase为null的记录不会被存储.</div><div class=\"line\">(4)基于的表包含rowkey，时间戳，和列族。新写入数据时，时间戳更新，同时可以查询到以前的版本.</div><div class=\"line\">(5) hbase是主从架构。hmaster作为主节点，hregionserver作为从节点。</div><div class=\"line\"></div><div class=\"line\">Hbase和hive 有什么区别</div><div class=\"line\">Hive和Hbase是两种基于Hadoop的不同技术 - -Hive是一种类SQL 的引擎，并且运行MapReduce 任务，Hbase 是一种在Hadoop之上的NoSQL的Key/vale数据库。当然，这两种工具是可以同时使用的。就像用Google 来搜索，用FaceBook 进行社交一样，Hive 可以用来进行统计查询，HBase 可以用来进行实时查询，数据也可以从Hive 写到Hbase，设置再从Hbase 写回Hive。</div><div class=\"line\">Hbase非常适合用来进行大数据的实时查询。Facebook用Hbase 进行消息和实时的分析。它也可以用来统计Facebook的连接数。</div><div class=\"line\"></div><div class=\"line\">描述Hbase的rowKey的设计原则.</div><div class=\"line\">Rowkey长度原则</div><div class=\"line\">Rowkey 是一个二进制码流，Rowkey 的长度被很多开发者建议说设计在10~100 个字节，</div><div class=\"line\">不过建议是越短越好，不要超过16 个字节。</div><div class=\"line\">Rowkey散列原则</div><div class=\"line\">如果Rowkey 是按时间戳的方式递增，不要将时间放在二进制码的前面，建议将Rowkey</div><div class=\"line\">的高位作为散列字段，由程序循环生成，低位放时间字段，这样将提高数据均衡分布在每个</div><div class=\"line\">Regionserver 实现负载均衡的几率。</div><div class=\"line\">Rowkey唯一原则</div><div class=\"line\">必须在设计上保证其唯一性。</div><div class=\"line\"></div><div class=\"line\">请描述如何解决Hbase中region太小和region太大带来的冲突.</div><div class=\"line\">Region过大会发生多次compaction，将数据读一遍并重写一遍到hdfs 上，占用io，region过小会造成多次split，region 会下线，影响访问服务，调整hbase.hregion.max.filesize 为256m.</div><div class=\"line\"></div><div class=\"line\">简述 HBASE中compact用途是什么，什么时候触发，分为哪两种,有什么区别，有哪些相关配置参数？</div><div class=\"line\">在hbase中每当有memstore数据flush到磁盘之后，就形成一个storefile，当storeFile的数量达到一定程度后，就需要将 storefile 文件来进行 compaction 操作。</div><div class=\"line\">Compact 的作用：</div><div class=\"line\">1&gt;.合并文件</div><div class=\"line\">2&gt;.清除过期，多余版本的数据</div><div class=\"line\">3&gt;.提高读写数据的效率</div><div class=\"line\">HBase 中实现了两种 compaction 的方式：minor and major. 这两种 compaction 方式的区别是：</div><div class=\"line\">1、Minor 操作只用来做部分文件的合并操作以及包括 minVersion=0 并且设置 ttl 的过</div><div class=\"line\">期版本清理，不做任何删除数据、多版本数据的清理工作。</div><div class=\"line\">2、Major 操作是对 Region 下的HStore下的所有StoreFile执行合并操作，最终的结果是整理合并出一个文件。</div></pre></td></tr></table></figure>\n<h4 id=\"flume\"><a href=\"#flume\" class=\"headerlink\" title=\"flume\"></a>flume</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">flume-ng中最重要的核心三大组件是source, channel, sink</div><div class=\"line\"></div><div class=\"line\">source负责从源端收集数据，产出event：</div><div class=\"line\">Source是数据源的总称，我们往往设定好源后，数据将源源不断的被抓取或者被推送。</div><div class=\"line\">常见的数据源有：ExecSource，KafkaSource，HttpSource，NetcatSource，JmsSource，AvroSource等等。</div><div class=\"line\"></div><div class=\"line\">channel负责暂存event，以备下游取走消费：</div><div class=\"line\">Channel用于连接Source和Sink，Source将日志信息发送到Channel，Sink从Channel消费日志信息；Channel是中转日志信息的一个临时存储，保存有Source组件传递过来的日志信息。</div><div class=\"line\"></div><div class=\"line\">sink负责消费通道中的event，写到最终的输出端上：</div><div class=\"line\">Sink在设置存储数据时，可以向文件系统中，数据库中，hadoop中储数据，在日志数据较少时，可以将数据存储在文件系中，并且设定一定的时间间隔保存数据。在日志数据较多时，可以将相应的日志数据存储到Hadoop中，便于日后进行相应的数据分析。</div></pre></td></tr></table></figure>\n<h4 id=\"kafka\"><a href=\"#kafka\" class=\"headerlink\" title=\"kafka\"></a>kafka</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">Kafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统(也可以当做MQ系统)，常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</div><div class=\"line\"></div><div class=\"line\">Kafka部分名词解释如下：</div><div class=\"line\">Broker：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。</div><div class=\"line\">Topic：一类消息，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发。</div><div class=\"line\">Partition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。</div><div class=\"line\">Segment：partition物理上由多个segment组成，下面2.2和2.3有详细说明。</div><div class=\"line\">offset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition唯一标识一条消息.</div><div class=\"line\"></div><div class=\"line\">分析过程分为以下4个步骤：</div><div class=\"line\">topic中partition存储分布</div><div class=\"line\">partiton中文件存储方式</div><div class=\"line\">partiton中segment文件存储结构</div><div class=\"line\">在partition中如何通过offset查找message</div><div class=\"line\"></div><div class=\"line\">Kafka高效文件存储设计特点</div><div class=\"line\">Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。</div><div class=\"line\">通过索引信息可以快速定位message和确定response的最大大小。</div><div class=\"line\">通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作。</div><div class=\"line\">通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小。</div></pre></td></tr></table></figure>\n<h4 id=\"streaming-analysis\"><a href=\"#streaming-analysis\" class=\"headerlink\" title=\"streaming analysis\"></a>streaming analysis</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">Storm&amp;SparkStreaming</div><div class=\"line\">处理模型,延迟</div><div class=\"line\">虽然这两个框架都提供可扩展性和容错性,它们根本的区别在于他们的处理模型。而Storm处理的是每次传入的一个事件，而Spark Streaming是处理某个时间段窗口内的事件流。因此,Storm处理一个事件可以达到秒内的延迟，而Spark Streaming则有几秒钟的延迟。</div><div class=\"line\"></div><div class=\"line\">容错、数据保证</div><div class=\"line\">在容错数据保证方面的权衡是，Spark Streaming提供了更好的支持容错状态计算。在Storm中,每个单独的记录当它通过系统时必须被跟踪，所以Storm能够至少保证每个记录将被处理一次，但是在从错误中恢复过来时候允许出现重复记录。这意味着可变状态可能不正确地被更新两次。</div><div class=\"line\"></div><div class=\"line\">另一方面，Spark Streaming只需要在批级别进行跟踪处理，因此可以有效地保证每个mini-batch将完全被处理一次，即便一个节点发生故障。(实际上,Storm的 Trident library库也提供了完全一次处理。但是,它依赖于事务更新状态,这比较慢,通常必须由用户实现。)</div><div class=\"line\"></div><div class=\"line\">简而言之,如果你需要秒内的延迟，Storm是一个不错的选择，而且没有数据丢失。如果你需要有状态的计算，而且要完全保证每个事件只被处理一次，Spark Streaming则更好。Spark Streaming编程逻辑也可能更容易，因为它类似于批处理程序(Hadoop)，特别是在你使用批次(尽管是很小的)时。</div><div class=\"line\"></div><div class=\"line\">实现,编程api</div><div class=\"line\">Storm初次是由Clojure实现，而 Spark Streaming是使用Scala. 如果你想看看代码还是让自己的定制时需要注意的地方，这样以便发现每个系统是如何工作的。Storm是由BackType和Twitter开发; Spark Streaming是在加州大学伯克利分校开发的。</div><div class=\"line\"></div><div class=\"line\">Storm 有一个Java API, 也支持其他语言，而Spark Streaming是以Scala编程，当然也支持Java</div><div class=\"line\"></div><div class=\"line\">Spark Streaming一个好的特性是其运行在Spark上. 这样你能够你编写批处理的同样代码，这就不需要编写单独的代码来处理实时流数据和历史数据。</div><div class=\"line\"></div><div class=\"line\">产品支持</div><div class=\"line\">Storm已经发布几年了，在Twitter从2011年运行至今，同时也有其他公司使用，而Spark Streaming是一个新的项目，它从2013年在Sharethrough有一个项目运行。</div><div class=\"line\"></div><div class=\"line\">Hadoop支持</div><div class=\"line\">Storm是一个 Hortonworks Hadoop数据平台上的流解决方案，而Spark Streaming有 MapR的版本还有Cloudera的企业数据平台，Databricks也提供Spark支持。</div><div class=\"line\"></div><div class=\"line\">集群管理集成</div><div class=\"line\">尽管两个系统都运行在它们自己的集群上，Storm也能运行在Mesos, 而Spark Streaming能运行在YARN 和 Mesos上。</div></pre></td></tr></table></figure>\n<h4 id=\"ELK\"><a href=\"#ELK\" class=\"headerlink\" title=\"ELK\"></a>ELK</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/</div><div class=\"line\"></div><div class=\"line\">Elasticsearch</div><div class=\"line\">Elasticsearch 是一个实时的分布式搜索和分析引擎，它可以用于全文搜索，结构化搜索以及分析。它是一个建立在全文搜索引擎 Apache Lucene 基础上的搜索引擎，使用 Java 语言编写。目前，最新的版本是 2.1.0。</div><div class=\"line\">主要特点</div><div class=\"line\">实时分析</div><div class=\"line\">分布式实时文件存储，并将每一个字段都编入索引</div><div class=\"line\">文档导向，所有的对象全部是文档</div><div class=\"line\">高可用性，易扩展，支持集群（Cluster）、分片和复制（Shards 和 Replicas）。见图 2 和图 3</div><div class=\"line\">接口友好，支持 JSON</div><div class=\"line\"></div><div class=\"line\">Logstash</div><div class=\"line\">Logstash 是一个具有实时渠道能力的数据收集引擎。使用 JRuby 语言编写。其作者是世界著名的运维工程师乔丹西塞 (JordanSissel)。</div><div class=\"line\">主要特点</div><div class=\"line\">几乎可以访问任何数据</div><div class=\"line\">可以和多种外部应用结合</div><div class=\"line\">支持弹性扩展</div><div class=\"line\">它由三个主要部分组成，见图 4：</div><div class=\"line\">Shipper－发送日志数据</div><div class=\"line\">Broker－收集数据，缺省内置 Redis</div><div class=\"line\">Indexer－数据写入</div><div class=\"line\"></div><div class=\"line\">Kibana</div><div class=\"line\">Kibana 是一款基于 Apache 开源协议，使用 JavaScript 语言编写，为 Elasticsearch 提供分析和可视化的 Web 平台。它可以在 Elasticsearch 的索引中查找，交互数据，并生成各种维度的表图。</div></pre></td></tr></table></figure>\n<h4 id=\"machine-learning\"><a href=\"#machine-learning\" class=\"headerlink\" title=\"machine learning\"></a>machine learning</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://blog.jobbole.com/108395/</div><div class=\"line\">http://blog.jobbole.com/92021/</div><div class=\"line\"></div><div class=\"line\">广义来说，有三种机器学习算法</div><div class=\"line\"></div><div class=\"line\">1、 监督式学习</div><div class=\"line\"></div><div class=\"line\">工作机制：这个算法由一个目标变量或结果变量（或因变量）组成。这些变量由已知的一系列预示变量（自变量）预测而来。利用这一系列变量，我们生成一个将输入值映射到期望输出值的函数。这个训练过程会一直持续，直到模型在训练数据上获得期望的精确度。监督式学习的例子有：回归、决策树、随机森林、K – 近邻算法、逻辑回归等。</div><div class=\"line\"></div><div class=\"line\">2、非监督式学习</div><div class=\"line\"></div><div class=\"line\">工作机制：在这个算法中，没有任何目标变量或结果变量要预测或估计。这个算法用在不同的组内聚类分析。这种分析方式被广泛地用来细分客户，根据干预的方式分为不同的用户组。非监督式学习的例子有：关联算法和 K – 均值算法。</div><div class=\"line\"></div><div class=\"line\">3、强化学习</div><div class=\"line\"></div><div class=\"line\">工作机制：这个算法训练机器进行决策。它是这样工作的：机器被放在一个能让它通过反复试错来训练自己的环境中。机器从过去的经验中进行学习，并且尝试利用了解最透彻的知识作出精确的商业判断。 强化学习的例子有马尔可夫决策过程。</div><div class=\"line\"></div><div class=\"line\">常见机器学习算法名单</div><div class=\"line\"></div><div class=\"line\">这里是一个常用的机器学习算法名单。这些算法几乎可以用在所有的数据问题上：</div><div class=\"line\"></div><div class=\"line\">线性回归</div><div class=\"line\">逻辑回归</div><div class=\"line\">决策树</div><div class=\"line\">SVM</div><div class=\"line\">朴素贝叶斯</div><div class=\"line\">K最近邻算法</div><div class=\"line\">K均值算法</div><div class=\"line\">随机森林算法</div><div class=\"line\">降维算法</div><div class=\"line\">Gradient Boost 和 Adaboost 算法</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">可以先说说主要的一些概念， 然后挑一个比较熟悉的算法来讲， 包括算法原理、使用场景和缺点等</div></pre></td></tr></table></figure>\n<h4 id=\"大数据处理相关面试题\"><a href=\"#大数据处理相关面试题\" class=\"headerlink\" title=\"大数据处理相关面试题\"></a>大数据处理相关面试题</h4><ul>\n<li>TopK问题<br>求最大K个数用最小堆，最小K个数用最大堆</li>\n<li>大数据处理常用排序<br>快速排序/堆排序/归并排序/桶排序</li>\n<li>有a、b两个文件，各存放50亿个url，每个url各占64byte，内存限制是4G，如何找出a、b文件共同的url？</li>\n<li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，要求返回频数最高的100个词。</li>\n<li>现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的那个IP。</li>\n<li>现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的那个IP；假设这个IP总会超过总数的一半。</li>\n</ul>"},{"title":"[deployment]spark on yarn","date":"2016-12-16T15:10:04.000Z","_content":"\n### 安装包准备\n- Oracle JDK\n安装了elasticSearch的系统应该已经配置好了JDK环境; 推荐JDK7\n- scala开发环境\nspark依赖于scala运行, scala是开发spark统计程序的官方语言; 当前使用scala-2.11版本\n- hadoop集群\nhadoop-yarn为spark运算提供资源管理及hdfs存储; 当前使用apache hadoop-2.7.3版本\n- spark集群\n用于分布式运算; 当前使用apache spark 2.0.2版本\n- ES-Hadoop插件\nes-hadoop作为hadoop/spark集成elasticSearch的插件使用; 当前使用es-hadoop_5.1.1版本\n\n### 安装步骤\n\n** 尚未找到docker对hadoop多机器多节点集群的快速部署方案, 暂时先手动部署\n\n<!--more-->\n\n#### 1. 安装JDK1.7\n\n```bash\nmkdir /usr/local/java && cd /usr/local/java\nwget \"http://download.oracle.com/otn/java/jdk/7u76-b13/jdk-7u76-linux-x64.tar.gz\"\ntar -zxf jdk-7u76-linux-x64.tar.gz && rm -f jdk-7u76-linux-x64.tar.gz\n```\n\n在/etc/profile中加入如下变量:\n\n```bash\nexport JAVA_HOME=/usr/local/java/jdk1.7.0_76\nexport JRE_HOME=/usr/local/java/jdk1.7.0_76/jre\nexport PATH=$PATH:/usr/local/java/jdk1.7.0_76/bin\nexport CLASSPATH=./:/usr/local/java/jdk1.7.0_76/lib:/usr/local/java/jdk1.7.0_76/jre/lib\n```\n\n让配置生效: *source /etc/profile*\n\n#### 2. 安装scala-2.11<br>\n```bash\n  mkdir /usr/local/scala && cd /usr/local/scala/\n  wget \"http://downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz\"\n  tar -zxf scala-2.11.8.tgz && rm -f scala-2.11.8.tgz\n  echo \"export SCALA_HOME=/usr/local/scala/scala-2.11.8\" >> /etc/profile\n  source /etc/profile\n  echo \"export PATH=$SCALA_HOME/bin:$PATH\" >> /etc/profile\n  source /etc/profile\n```\n\n#### 3. 部署Hadoop\n\n##### 为hadoop创建专有用户\n\n```bash\n    groupadd hadoop           # 添加hadoop用户组\n    useradd hadoop -g hadoop  # 添加hadoop用户并加入hadoop组\n```\n\nvim /etc/sudoers          # 编辑sudoers文件，给hadoop用户sudo权限\n    \n``` \nhadoop  ALL=(ALL) ALL    # 在sudoers末尾加上这一行\n```\n\n##### 修改各机器主机名, 用于方便区分节点\n假设有三台机器, 一个用作master节点, 两个用于slave节点，如下:\n> 192.168.1.181 master\n> 192.168.1.191 slave01\n> 192.168.1.102 slave02\n    \n那么在将各个hostname分别改为master, slave01, slave02后, 各自配置/etc/hosts:<br>\n\n```bash\n    echo \"192.168.1.181 master\" >> /etc/hosts\n    echo \"192.168.1.191 slave01\" >> /etc/hosts\n    echo \"192.168.1.102 slave02\" >> /etc/hosts\n```\n\n##### 配置免密码登录\nhadoop集群中需要配置namenode(master节点)通过用户hadoop免密码登录到本地以及其他datanode(slave节点);<br>\n具体做法是将master节点上的rsa这类证书分发到各个slave节点对应ssh配置目录， 这里略过具体过程。\n\n##### 下载hadoop2.7.3<br>\n```bash\n    mkdir /usr/local/hadoop && cd /usr/local/hadoop\n    wget \"https://archive.apache.org/dist/hadoop/core/hadoop-2.7.3/hadoop-2.7.3.tar.gz\"\n    tar -zxf hadoop-2.7.3.tar.gz && rm -f hadoop-2.7.3.tar.gz \n    mkdir -p /usr/local/hadoop/hdfs/data\n    mkdir -p /usr/local/hadoop/hdfs/name\n    mkdir -p /usr/local/hadoop/tmp\n    chown -R hadoop:hadoop /usr/local/hadoop\n    cd hadoop-2.7.3 && su hadoop\n```\n\n##### 配置环境变量(所有节点同样配置)<br>\n```bash\n    echo \"export HADOOP_HOME=/usr/local/hadoop/hadoop-2.7.3\" >> /etc/profile\n    echo \"export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin\" >> /etc/profile\n    source /etc/profile\n```\n\n##### 修改配置文件<br>\n在${HADOOP_HOME}/etc/hadoop/下(***可先在主节点中配置好, 然后拷贝到其他工作节点***)<br>\n\n1) vim etc/hadoop/hadoop-env.sh\n\n```bash\nexport JAVA_HOME=/usr/local/java/jdk1.7.0_76\n```\n\n2) vim etc/hadoop/yarn-env.sh\n\n```bash\nexport JAVA_HOME=/usr/local/java/jdk1.7.0_76\n```\n\n3) vim etc/hadoop/slaves  // 把datanode的hostname写入slaves文件, 根据实际情况修改\n\n```\n   slave01\n   slave02\n```\n\n4) vim etc/hadoop/core-site.xml\n  \n```xml\n<configuration>\n  <property>\n      <name>fs.defaultFS</name>\n      <value>hdfs://master:9000</value>\n      <description>HDFS的URI，文件系统://namenode标识:端口号</description>\n  </property>          \n  <property>\n      <name>hadoop.tmp.dir</name>\n      <value>/usr/local/hadoop/tmp</value>\n      <description>namenode上本地的hadoop临时文件夹</description>\n  </property>\n</configuration>\n```\n\n5) vim etc/hadoop/hdfs-site.xml\n\n```xml\n      <configuration>\n          <property>\n              <name>dfs.name.dir</name>\n              <value>file:/usr/local/hadoop/hdfs/name</value>\n              <description>namenode上存储hdfs名字空间元数据 </description> \n          </property>\n          \n          <property>\n              <name>dfs.data.dir</name>\n              <value>file:/usr/local/hadoop/hdfs/data</value>\n              <description>datanode上数据块的物理存储位置</description>\n          </property>\n          \n          <property>\n              <name>dfs.replication</name>\n              <value>2</value>\n              <description>副本个数，配置默认是3,应小于datanode机器数量</description>\n          </property>\n          <property>\n              <name>dfs.client.read.shortcircuit</name>\n              <value>true</value>\n          </property>\n          <property>\n              <name>dfs.domain.socket.path</name>\n              <value>/var/lib/hadoop-hdfs/dn_socket</value>\n          </property>\n      </configuration>\n```\n\n6) vim etc/hadoop/yarn-site.xml\n\n```xml\n      <configuration>\n          <property>\n              <name>yarn.nodemanager.aux-services</name>\n              <value>mapreduce_shuffle</value>\n          </property>\n          <property>\n              <name>yarn.resourcemanager.hostname</name>\n              <value>master</value>\n          </property>\n      </configuration>\n```\n\n7) vim etc/hadoop/mapred-site.xml\n```xml\n      <configuration>\n          <property>\n              <name>mapreduce.framework.name</name>\n              <value>yarn</value>\n          </property>\n      </configuration>\n```\n\n  *所有配置文件修改后, 将/usr/local/hadoop/文件夹拷贝到datanode中相应的位置*\n\n##### hadoop集群初始化及启动, 在主节点中执行\n```bash\ncd /usr/local/hadoop/hadoop-2.7.3 && su hadoop\nbin/hdfs namenode -format\nsbin/start-dfs.sh\nsbin/start-yarn.sh\n```\n***hadoop启动后, 通过http://master:50070/和http://master:8088/可以分别查看hdfs和task等状态信息***\n同时也可以用jps查看:\n```\n# 主节点namenode\nhadoop@1:/usr/local/hadoop$ jps\n9378 NameNode\n10218 NodeManager\n9786 SecondaryNameNode\n10077 ResourceManager\n11453 Jps\n9550 DataNode\n\n# 工作节点\nhadoop@2:/usr/local/hadoop$ jps\n1489 Jps\n796 NodeManager\n606 DataNode\n```\n\n#### 4. 部署spark\n##### 下载spark-2.0.2-bin-hadoop2.7.tgz\n```bash\nmkdir /usr/local/spark/ && cd /usr/local/spark\nchown -R hadoop:hadoop /usr/local/spark\nwget \"http://d3kbcqa49mib13.cloudfront.net/spark-2.0.2-bin-hadoop2.7.tgz\"\ntar -zxf spark-2.0.2-bin-hadoop2.7.tgz && rm -f spark-2.0.2-bin-hadoop2.7.tgz\ncd spark-2.0.2-bin-hadoop2.7\n```\n\n##### 配置环境变量 \n```bash\necho \"export SPARK_HOME=/usr/local/spark/spark-2.0.2-bin-hadoop2.7\" >> /etc/profile\nsource /etc/profile\necho \"export PATH=$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin\" >> /etc/profile\nsource /etc/profile\n```\n\n##### 修改配置文件\n\n+ vim conf/spark-env.sh\n```bash\n# export SPARK_SSH_OPTS=\"-p 23456\"\nexport JAVA_HOME=/usr/local/java/jdk1.7.0_76\nexport SCALA_HOME=/usr/local/scala/scala-2.11.8\nexport SPARK_HOME=/usr/local/spark/spark-2.0.2-bin-hadoop2.7\nexport HADOOP_HOME=/usr/local/hadoop/hadoop-2.7.3\nexport SPARK_MASTER_HOST=master\nexport HADOOP_CONF_DIR=/usr/local/hadoop/hadoop-2.7.3/etc/hadoop/\nexport SPARK_HISTORY_OPTS=\"-Dspark.history.retainedApplications=3 -Dspark.history.fs.logDirectory=hdfs://master:9000/sparklogs\"\nexport LD_LIBRARY_PATH=${HADOOP_HOME}/lib/native/:$LD_LIBRARY_PATH\n```\n+ vim spark-default.conf\n\n```\nspark.yarn.jars hdfs://1.downlog-es.10.220.2.233.fs.115cdn.net:9100/sparkjars\n#spark.yarn.archive hdfs://hadoop.master.fs.115cdn.net:9000/user/btadmin/.sparkStaging/application_1483167145424_0004/__spark_libs__8967711398799981387.zip\nspark.eventLog.enabled  true\nspark.eventLog.dir hdfs://1.downlog-es.10.220.2.233.fs.115cdn.net:9100/sparklogs\nspark.history.fs.logDirectory hdfs://1.downlog-es.10.220.2.233.fs.115cdn.net:9100/sparkHistoryLogs\n\n#spark.executor.extraClassPath /usr/local/spark/jars/mysql-connector-java-5.1.40.jar\n#spark.executor.extraClassPath /usr/local/spark/extrajars/mysql-connector-java-5.1.40.jar:/usr/local/spark/extrajars/mongo-spark-connector_2.11-0.2.jar\n#spark.mongodb.input.uri mongodb://10.220.2.223:27017/hashmap.fidsha1\nspark.executor.instances  12\nspark.driver.cores        2\nspark.executor.cores      2\nspark.executor.memory     4g\nspark.driver.memory       4g\nspark.default.parallelism 48\nspark.sql.crossJoin.enabled true\nspark.serializer org.apache.spark.serializer.KryoSerializer\n```\n\n+ vim slaves\n```\nslave01\nslave02\n```\n\n+ 在hdfs为Spark建立必要的目录\n\n```bash\n# SPARK_HOME\n# sprk集群的日志目录：配置文件中对history-server中定义的log目录\n$ hdfs dfs -mkdir /sparklogs\n# 将spark的jar包拷贝到hadoop服务器上，这样避免每次计算的时候都要做去一次拷贝操作\n$ hdfs dfs -mkdir /sparkjars\n$ cd /usr/local/spark/spark-2.0.2-bin-hadoop2.7/ && hdfs dfs -put jars/* /sparkjars/\n```\n\n  ***配置文件修改完成后， 将/usr/local/spark文件夹拷贝到其他节点对应的位置, 并配置好环境变量***\n\n+ spark集群启动, 在主节点中执行:\n```bash\ncd /usr/local/spark/spark-2.0.2-bin-hadoop2.7/ && ./sbin/start-all.sh\n```\n用自带example验证测试\n```bash\nroot@master:/usr/local/spark/spark-2.0.2-bin-hadoop2.7# bin/spark-submit --class org.apache.spark.\\\nexamples.JavaSparkPi --master spark://master:7077 examples/jars/spark-examples_2.11-2.0.2.jar\n16/12/26 15:41:13 WARN SparkContext: Use an existing SparkContext, some configuration may not take effect.\n[Stage 0:>                                                          (0 + 0) / 2]16/12/26 15:41:20 WARN \\\nTaskSetManager: Stage 0 contains a task of very large size (981 KB). The maximum recommended task size is 100 KB.\nPi is roughly 3.13608 \n```\n  *spark启动后， 通过http://master:8080/可以查看spark当前的运行状态*\n\n#### 5. 结合es-hadoop\n+ 下载ES-Hadoop\n\n```bash\nmkdir /usr/local/es-hadoop && cd /usr/local/es-hadoop\nwget \"http://download.elastic.co/hadoop/elasticsearch-hadoop-5.1.1.zip\"\nunzip elasticsearch-hadoop-5.1.1.zip && rm -f elasticsearch-hadoop-5.1.1.zip\ncp elasticsearch-hadoop-5.1.1/dist/elasticsearch-hadoop-5.1.1.jar /usr/local/spark/spark-2.0.2-bin-hadoop2.7/jars/\n```\n\n+ 通过spark访问/操作elasticSearch\n```\nroot@master:/usr/local/spark/spark-2.0.2-bin-hadoop2.7# ./bin/spark-submit your_spark_es_script.py\n```\n","source":"_posts/bigdata/deployment-spark-on-yarn.md","raw":"---\ntitle: '[deployment]spark on yarn'\ndate: 2016-12-16 23:10:04\ntags: bigdata\n---\n\n### 安装包准备\n- Oracle JDK\n安装了elasticSearch的系统应该已经配置好了JDK环境; 推荐JDK7\n- scala开发环境\nspark依赖于scala运行, scala是开发spark统计程序的官方语言; 当前使用scala-2.11版本\n- hadoop集群\nhadoop-yarn为spark运算提供资源管理及hdfs存储; 当前使用apache hadoop-2.7.3版本\n- spark集群\n用于分布式运算; 当前使用apache spark 2.0.2版本\n- ES-Hadoop插件\nes-hadoop作为hadoop/spark集成elasticSearch的插件使用; 当前使用es-hadoop_5.1.1版本\n\n### 安装步骤\n\n** 尚未找到docker对hadoop多机器多节点集群的快速部署方案, 暂时先手动部署\n\n<!--more-->\n\n#### 1. 安装JDK1.7\n\n```bash\nmkdir /usr/local/java && cd /usr/local/java\nwget \"http://download.oracle.com/otn/java/jdk/7u76-b13/jdk-7u76-linux-x64.tar.gz\"\ntar -zxf jdk-7u76-linux-x64.tar.gz && rm -f jdk-7u76-linux-x64.tar.gz\n```\n\n在/etc/profile中加入如下变量:\n\n```bash\nexport JAVA_HOME=/usr/local/java/jdk1.7.0_76\nexport JRE_HOME=/usr/local/java/jdk1.7.0_76/jre\nexport PATH=$PATH:/usr/local/java/jdk1.7.0_76/bin\nexport CLASSPATH=./:/usr/local/java/jdk1.7.0_76/lib:/usr/local/java/jdk1.7.0_76/jre/lib\n```\n\n让配置生效: *source /etc/profile*\n\n#### 2. 安装scala-2.11<br>\n```bash\n  mkdir /usr/local/scala && cd /usr/local/scala/\n  wget \"http://downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz\"\n  tar -zxf scala-2.11.8.tgz && rm -f scala-2.11.8.tgz\n  echo \"export SCALA_HOME=/usr/local/scala/scala-2.11.8\" >> /etc/profile\n  source /etc/profile\n  echo \"export PATH=$SCALA_HOME/bin:$PATH\" >> /etc/profile\n  source /etc/profile\n```\n\n#### 3. 部署Hadoop\n\n##### 为hadoop创建专有用户\n\n```bash\n    groupadd hadoop           # 添加hadoop用户组\n    useradd hadoop -g hadoop  # 添加hadoop用户并加入hadoop组\n```\n\nvim /etc/sudoers          # 编辑sudoers文件，给hadoop用户sudo权限\n    \n``` \nhadoop  ALL=(ALL) ALL    # 在sudoers末尾加上这一行\n```\n\n##### 修改各机器主机名, 用于方便区分节点\n假设有三台机器, 一个用作master节点, 两个用于slave节点，如下:\n> 192.168.1.181 master\n> 192.168.1.191 slave01\n> 192.168.1.102 slave02\n    \n那么在将各个hostname分别改为master, slave01, slave02后, 各自配置/etc/hosts:<br>\n\n```bash\n    echo \"192.168.1.181 master\" >> /etc/hosts\n    echo \"192.168.1.191 slave01\" >> /etc/hosts\n    echo \"192.168.1.102 slave02\" >> /etc/hosts\n```\n\n##### 配置免密码登录\nhadoop集群中需要配置namenode(master节点)通过用户hadoop免密码登录到本地以及其他datanode(slave节点);<br>\n具体做法是将master节点上的rsa这类证书分发到各个slave节点对应ssh配置目录， 这里略过具体过程。\n\n##### 下载hadoop2.7.3<br>\n```bash\n    mkdir /usr/local/hadoop && cd /usr/local/hadoop\n    wget \"https://archive.apache.org/dist/hadoop/core/hadoop-2.7.3/hadoop-2.7.3.tar.gz\"\n    tar -zxf hadoop-2.7.3.tar.gz && rm -f hadoop-2.7.3.tar.gz \n    mkdir -p /usr/local/hadoop/hdfs/data\n    mkdir -p /usr/local/hadoop/hdfs/name\n    mkdir -p /usr/local/hadoop/tmp\n    chown -R hadoop:hadoop /usr/local/hadoop\n    cd hadoop-2.7.3 && su hadoop\n```\n\n##### 配置环境变量(所有节点同样配置)<br>\n```bash\n    echo \"export HADOOP_HOME=/usr/local/hadoop/hadoop-2.7.3\" >> /etc/profile\n    echo \"export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin\" >> /etc/profile\n    source /etc/profile\n```\n\n##### 修改配置文件<br>\n在${HADOOP_HOME}/etc/hadoop/下(***可先在主节点中配置好, 然后拷贝到其他工作节点***)<br>\n\n1) vim etc/hadoop/hadoop-env.sh\n\n```bash\nexport JAVA_HOME=/usr/local/java/jdk1.7.0_76\n```\n\n2) vim etc/hadoop/yarn-env.sh\n\n```bash\nexport JAVA_HOME=/usr/local/java/jdk1.7.0_76\n```\n\n3) vim etc/hadoop/slaves  // 把datanode的hostname写入slaves文件, 根据实际情况修改\n\n```\n   slave01\n   slave02\n```\n\n4) vim etc/hadoop/core-site.xml\n  \n```xml\n<configuration>\n  <property>\n      <name>fs.defaultFS</name>\n      <value>hdfs://master:9000</value>\n      <description>HDFS的URI，文件系统://namenode标识:端口号</description>\n  </property>          \n  <property>\n      <name>hadoop.tmp.dir</name>\n      <value>/usr/local/hadoop/tmp</value>\n      <description>namenode上本地的hadoop临时文件夹</description>\n  </property>\n</configuration>\n```\n\n5) vim etc/hadoop/hdfs-site.xml\n\n```xml\n      <configuration>\n          <property>\n              <name>dfs.name.dir</name>\n              <value>file:/usr/local/hadoop/hdfs/name</value>\n              <description>namenode上存储hdfs名字空间元数据 </description> \n          </property>\n          \n          <property>\n              <name>dfs.data.dir</name>\n              <value>file:/usr/local/hadoop/hdfs/data</value>\n              <description>datanode上数据块的物理存储位置</description>\n          </property>\n          \n          <property>\n              <name>dfs.replication</name>\n              <value>2</value>\n              <description>副本个数，配置默认是3,应小于datanode机器数量</description>\n          </property>\n          <property>\n              <name>dfs.client.read.shortcircuit</name>\n              <value>true</value>\n          </property>\n          <property>\n              <name>dfs.domain.socket.path</name>\n              <value>/var/lib/hadoop-hdfs/dn_socket</value>\n          </property>\n      </configuration>\n```\n\n6) vim etc/hadoop/yarn-site.xml\n\n```xml\n      <configuration>\n          <property>\n              <name>yarn.nodemanager.aux-services</name>\n              <value>mapreduce_shuffle</value>\n          </property>\n          <property>\n              <name>yarn.resourcemanager.hostname</name>\n              <value>master</value>\n          </property>\n      </configuration>\n```\n\n7) vim etc/hadoop/mapred-site.xml\n```xml\n      <configuration>\n          <property>\n              <name>mapreduce.framework.name</name>\n              <value>yarn</value>\n          </property>\n      </configuration>\n```\n\n  *所有配置文件修改后, 将/usr/local/hadoop/文件夹拷贝到datanode中相应的位置*\n\n##### hadoop集群初始化及启动, 在主节点中执行\n```bash\ncd /usr/local/hadoop/hadoop-2.7.3 && su hadoop\nbin/hdfs namenode -format\nsbin/start-dfs.sh\nsbin/start-yarn.sh\n```\n***hadoop启动后, 通过http://master:50070/和http://master:8088/可以分别查看hdfs和task等状态信息***\n同时也可以用jps查看:\n```\n# 主节点namenode\nhadoop@1:/usr/local/hadoop$ jps\n9378 NameNode\n10218 NodeManager\n9786 SecondaryNameNode\n10077 ResourceManager\n11453 Jps\n9550 DataNode\n\n# 工作节点\nhadoop@2:/usr/local/hadoop$ jps\n1489 Jps\n796 NodeManager\n606 DataNode\n```\n\n#### 4. 部署spark\n##### 下载spark-2.0.2-bin-hadoop2.7.tgz\n```bash\nmkdir /usr/local/spark/ && cd /usr/local/spark\nchown -R hadoop:hadoop /usr/local/spark\nwget \"http://d3kbcqa49mib13.cloudfront.net/spark-2.0.2-bin-hadoop2.7.tgz\"\ntar -zxf spark-2.0.2-bin-hadoop2.7.tgz && rm -f spark-2.0.2-bin-hadoop2.7.tgz\ncd spark-2.0.2-bin-hadoop2.7\n```\n\n##### 配置环境变量 \n```bash\necho \"export SPARK_HOME=/usr/local/spark/spark-2.0.2-bin-hadoop2.7\" >> /etc/profile\nsource /etc/profile\necho \"export PATH=$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin\" >> /etc/profile\nsource /etc/profile\n```\n\n##### 修改配置文件\n\n+ vim conf/spark-env.sh\n```bash\n# export SPARK_SSH_OPTS=\"-p 23456\"\nexport JAVA_HOME=/usr/local/java/jdk1.7.0_76\nexport SCALA_HOME=/usr/local/scala/scala-2.11.8\nexport SPARK_HOME=/usr/local/spark/spark-2.0.2-bin-hadoop2.7\nexport HADOOP_HOME=/usr/local/hadoop/hadoop-2.7.3\nexport SPARK_MASTER_HOST=master\nexport HADOOP_CONF_DIR=/usr/local/hadoop/hadoop-2.7.3/etc/hadoop/\nexport SPARK_HISTORY_OPTS=\"-Dspark.history.retainedApplications=3 -Dspark.history.fs.logDirectory=hdfs://master:9000/sparklogs\"\nexport LD_LIBRARY_PATH=${HADOOP_HOME}/lib/native/:$LD_LIBRARY_PATH\n```\n+ vim spark-default.conf\n\n```\nspark.yarn.jars hdfs://1.downlog-es.10.220.2.233.fs.115cdn.net:9100/sparkjars\n#spark.yarn.archive hdfs://hadoop.master.fs.115cdn.net:9000/user/btadmin/.sparkStaging/application_1483167145424_0004/__spark_libs__8967711398799981387.zip\nspark.eventLog.enabled  true\nspark.eventLog.dir hdfs://1.downlog-es.10.220.2.233.fs.115cdn.net:9100/sparklogs\nspark.history.fs.logDirectory hdfs://1.downlog-es.10.220.2.233.fs.115cdn.net:9100/sparkHistoryLogs\n\n#spark.executor.extraClassPath /usr/local/spark/jars/mysql-connector-java-5.1.40.jar\n#spark.executor.extraClassPath /usr/local/spark/extrajars/mysql-connector-java-5.1.40.jar:/usr/local/spark/extrajars/mongo-spark-connector_2.11-0.2.jar\n#spark.mongodb.input.uri mongodb://10.220.2.223:27017/hashmap.fidsha1\nspark.executor.instances  12\nspark.driver.cores        2\nspark.executor.cores      2\nspark.executor.memory     4g\nspark.driver.memory       4g\nspark.default.parallelism 48\nspark.sql.crossJoin.enabled true\nspark.serializer org.apache.spark.serializer.KryoSerializer\n```\n\n+ vim slaves\n```\nslave01\nslave02\n```\n\n+ 在hdfs为Spark建立必要的目录\n\n```bash\n# SPARK_HOME\n# sprk集群的日志目录：配置文件中对history-server中定义的log目录\n$ hdfs dfs -mkdir /sparklogs\n# 将spark的jar包拷贝到hadoop服务器上，这样避免每次计算的时候都要做去一次拷贝操作\n$ hdfs dfs -mkdir /sparkjars\n$ cd /usr/local/spark/spark-2.0.2-bin-hadoop2.7/ && hdfs dfs -put jars/* /sparkjars/\n```\n\n  ***配置文件修改完成后， 将/usr/local/spark文件夹拷贝到其他节点对应的位置, 并配置好环境变量***\n\n+ spark集群启动, 在主节点中执行:\n```bash\ncd /usr/local/spark/spark-2.0.2-bin-hadoop2.7/ && ./sbin/start-all.sh\n```\n用自带example验证测试\n```bash\nroot@master:/usr/local/spark/spark-2.0.2-bin-hadoop2.7# bin/spark-submit --class org.apache.spark.\\\nexamples.JavaSparkPi --master spark://master:7077 examples/jars/spark-examples_2.11-2.0.2.jar\n16/12/26 15:41:13 WARN SparkContext: Use an existing SparkContext, some configuration may not take effect.\n[Stage 0:>                                                          (0 + 0) / 2]16/12/26 15:41:20 WARN \\\nTaskSetManager: Stage 0 contains a task of very large size (981 KB). The maximum recommended task size is 100 KB.\nPi is roughly 3.13608 \n```\n  *spark启动后， 通过http://master:8080/可以查看spark当前的运行状态*\n\n#### 5. 结合es-hadoop\n+ 下载ES-Hadoop\n\n```bash\nmkdir /usr/local/es-hadoop && cd /usr/local/es-hadoop\nwget \"http://download.elastic.co/hadoop/elasticsearch-hadoop-5.1.1.zip\"\nunzip elasticsearch-hadoop-5.1.1.zip && rm -f elasticsearch-hadoop-5.1.1.zip\ncp elasticsearch-hadoop-5.1.1/dist/elasticsearch-hadoop-5.1.1.jar /usr/local/spark/spark-2.0.2-bin-hadoop2.7/jars/\n```\n\n+ 通过spark访问/操作elasticSearch\n```\nroot@master:/usr/local/spark/spark-2.0.2-bin-hadoop2.7# ./bin/spark-submit your_spark_es_script.py\n```\n","slug":"bigdata/deployment-spark-on-yarn","published":1,"updated":"2017-10-16T07:20:12.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00duw00084j4d5ee0bp1g","content":"<h3 id=\"安装包准备\"><a href=\"#安装包准备\" class=\"headerlink\" title=\"安装包准备\"></a>安装包准备</h3><ul>\n<li>Oracle JDK<br>安装了elasticSearch的系统应该已经配置好了JDK环境; 推荐JDK7</li>\n<li>scala开发环境<br>spark依赖于scala运行, scala是开发spark统计程序的官方语言; 当前使用scala-2.11版本</li>\n<li>hadoop集群<br>hadoop-yarn为spark运算提供资源管理及hdfs存储; 当前使用apache hadoop-2.7.3版本</li>\n<li>spark集群<br>用于分布式运算; 当前使用apache spark 2.0.2版本</li>\n<li>ES-Hadoop插件<br>es-hadoop作为hadoop/spark集成elasticSearch的插件使用; 当前使用es-hadoop_5.1.1版本</li>\n</ul>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><p>** 尚未找到docker对hadoop多机器多节点集群的快速部署方案, 暂时先手动部署</p>\n<a id=\"more\"></a>\n<h4 id=\"1-安装JDK1-7\"><a href=\"#1-安装JDK1-7\" class=\"headerlink\" title=\"1. 安装JDK1.7\"></a>1. 安装JDK1.7</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /usr/<span class=\"built_in\">local</span>/java &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/java</div><div class=\"line\">wget <span class=\"string\">\"http://download.oracle.com/otn/java/jdk/7u76-b13/jdk-7u76-linux-x64.tar.gz\"</span></div><div class=\"line\">tar -zxf jdk-7u76-linux-x64.tar.gz &amp;&amp; rm -f jdk-7u76-linux-x64.tar.gz</div></pre></td></tr></table></figure>\n<p>在/etc/profile中加入如下变量:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76</div><div class=\"line\"><span class=\"built_in\">export</span> JRE_HOME=/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76/jre</div><div class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76/bin</div><div class=\"line\"><span class=\"built_in\">export</span> CLASSPATH=./:/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76/lib:/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76/jre/lib</div></pre></td></tr></table></figure>\n<p>让配置生效: <em>source /etc/profile</em></p>\n<h4 id=\"2-安装scala-2-11\"><a href=\"#2-安装scala-2-11\" class=\"headerlink\" title=\"2. 安装scala-2.11\"></a>2. 安装scala-2.11<br></h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /usr/<span class=\"built_in\">local</span>/scala &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/scala/</div><div class=\"line\">wget <span class=\"string\">\"http://downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz\"</span></div><div class=\"line\">tar -zxf scala-2.11.8.tgz &amp;&amp; rm -f scala-2.11.8.tgz</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"export SCALA_HOME=/usr/local/scala/scala-2.11.8\"</span> &gt;&gt; /etc/profile</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/profile</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"export PATH=<span class=\"variable\">$SCALA_HOME</span>/bin:<span class=\"variable\">$PATH</span>\"</span> &gt;&gt; /etc/profile</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/profile</div></pre></td></tr></table></figure>\n<h4 id=\"3-部署Hadoop\"><a href=\"#3-部署Hadoop\" class=\"headerlink\" title=\"3. 部署Hadoop\"></a>3. 部署Hadoop</h4><h5 id=\"为hadoop创建专有用户\"><a href=\"#为hadoop创建专有用户\" class=\"headerlink\" title=\"为hadoop创建专有用户\"></a>为hadoop创建专有用户</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">groupadd hadoop           <span class=\"comment\"># 添加hadoop用户组</span></div><div class=\"line\">useradd hadoop -g hadoop  <span class=\"comment\"># 添加hadoop用户并加入hadoop组</span></div></pre></td></tr></table></figure>\n<p>vim /etc/sudoers          # 编辑sudoers文件，给hadoop用户sudo权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop  ALL=(ALL) ALL    # 在sudoers末尾加上这一行</div></pre></td></tr></table></figure>\n<h5 id=\"修改各机器主机名-用于方便区分节点\"><a href=\"#修改各机器主机名-用于方便区分节点\" class=\"headerlink\" title=\"修改各机器主机名, 用于方便区分节点\"></a>修改各机器主机名, 用于方便区分节点</h5><p>假设有三台机器, 一个用作master节点, 两个用于slave节点，如下:</p>\n<blockquote>\n<p>192.168.1.181 master<br>192.168.1.191 slave01<br>192.168.1.102 slave02</p>\n</blockquote>\n<p>那么在将各个hostname分别改为master, slave01, slave02后, 各自配置/etc/hosts:<br></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"192.168.1.181 master\"</span> &gt;&gt; /etc/hosts</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"192.168.1.191 slave01\"</span> &gt;&gt; /etc/hosts</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"192.168.1.102 slave02\"</span> &gt;&gt; /etc/hosts</div></pre></td></tr></table></figure>\n<h5 id=\"配置免密码登录\"><a href=\"#配置免密码登录\" class=\"headerlink\" title=\"配置免密码登录\"></a>配置免密码登录</h5><p>hadoop集群中需要配置namenode(master节点)通过用户hadoop免密码登录到本地以及其他datanode(slave节点);<br><br>具体做法是将master节点上的rsa这类证书分发到各个slave节点对应ssh配置目录， 这里略过具体过程。</p>\n<h5 id=\"下载hadoop2-7-3\"><a href=\"#下载hadoop2-7-3\" class=\"headerlink\" title=\"下载hadoop2.7.3\"></a>下载hadoop2.7.3<br></h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /usr/<span class=\"built_in\">local</span>/hadoop &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/hadoop</div><div class=\"line\">wget <span class=\"string\">\"https://archive.apache.org/dist/hadoop/core/hadoop-2.7.3/hadoop-2.7.3.tar.gz\"</span></div><div class=\"line\">tar -zxf hadoop-2.7.3.tar.gz &amp;&amp; rm -f hadoop-2.7.3.tar.gz </div><div class=\"line\">mkdir -p /usr/<span class=\"built_in\">local</span>/hadoop/hdfs/data</div><div class=\"line\">mkdir -p /usr/<span class=\"built_in\">local</span>/hadoop/hdfs/name</div><div class=\"line\">mkdir -p /usr/<span class=\"built_in\">local</span>/hadoop/tmp</div><div class=\"line\">chown -R hadoop:hadoop /usr/<span class=\"built_in\">local</span>/hadoop</div><div class=\"line\"><span class=\"built_in\">cd</span> hadoop-2.7.3 &amp;&amp; su hadoop</div></pre></td></tr></table></figure>\n<h5 id=\"配置环境变量-所有节点同样配置\"><a href=\"#配置环境变量-所有节点同样配置\" class=\"headerlink\" title=\"配置环境变量(所有节点同样配置)\"></a>配置环境变量(所有节点同样配置)<br></h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"export HADOOP_HOME=/usr/local/hadoop/hadoop-2.7.3\"</span> &gt;&gt; /etc/profile</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"export PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$HADOOP_HOME</span>/bin:<span class=\"variable\">$HADOOP_HOME</span>/sbin\"</span> &gt;&gt; /etc/profile</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/profile</div></pre></td></tr></table></figure>\n<h5 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件<br></h5><p>在${HADOOP_HOME}/etc/hadoop/下(<strong><em>可先在主节点中配置好, 然后拷贝到其他工作节点</em></strong>)<br></p>\n<p>1) vim etc/hadoop/hadoop-env.sh</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76</div></pre></td></tr></table></figure>\n<p>2) vim etc/hadoop/yarn-env.sh</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76</div></pre></td></tr></table></figure>\n<p>3) vim etc/hadoop/slaves  // 把datanode的hostname写入slaves文件, 根据实际情况修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">slave01</div><div class=\"line\">slave02</div></pre></td></tr></table></figure>\n<p>4) vim etc/hadoop/core-site.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>fs.defaultFS<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>hdfs://master:9000<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>HDFS的URI，文件系统://namenode标识:端口号<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>          </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.tmp.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/tmp<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>namenode上本地的hadoop临时文件夹<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>5) vim etc/hadoop/hdfs-site.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.name.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>file:/usr/local/hadoop/hdfs/name<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>namenode上存储hdfs名字空间元数据 <span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.data.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>file:/usr/local/hadoop/hdfs/data<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>datanode上数据块的物理存储位置<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.replication<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>副本个数，配置默认是3,应小于datanode机器数量<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.client.read.shortcircuit<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.domain.socket.path<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/var/lib/hadoop-hdfs/dn_socket<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>6) vim etc/hadoop/yarn-site.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.nodemanager.aux-services<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>mapreduce_shuffle<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.hostname<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>7) vim etc/hadoop/mapred-site.xml<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapreduce.framework.name<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>yarn<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>  <em>所有配置文件修改后, 将/usr/local/hadoop/文件夹拷贝到datanode中相应的位置</em></p>\n<h5 id=\"hadoop集群初始化及启动-在主节点中执行\"><a href=\"#hadoop集群初始化及启动-在主节点中执行\" class=\"headerlink\" title=\"hadoop集群初始化及启动, 在主节点中执行\"></a>hadoop集群初始化及启动, 在主节点中执行</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/hadoop/hadoop-2.7.3 &amp;&amp; su hadoop</div><div class=\"line\">bin/hdfs namenode -format</div><div class=\"line\">sbin/start-dfs.sh</div><div class=\"line\">sbin/start-yarn.sh</div></pre></td></tr></table></figure>\n<p><strong><em>hadoop启动后, 通过<a href=\"http://master:50070/和http://master:8088/可以分别查看hdfs和task等状态信息\" target=\"_blank\" rel=\"external\">http://master:50070/和http://master:8088/可以分别查看hdfs和task等状态信息</a></em></strong><br>同时也可以用jps查看:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 主节点namenode</div><div class=\"line\">hadoop@1:/usr/local/hadoop$ jps</div><div class=\"line\">9378 NameNode</div><div class=\"line\">10218 NodeManager</div><div class=\"line\">9786 SecondaryNameNode</div><div class=\"line\">10077 ResourceManager</div><div class=\"line\">11453 Jps</div><div class=\"line\">9550 DataNode</div><div class=\"line\"></div><div class=\"line\"># 工作节点</div><div class=\"line\">hadoop@2:/usr/local/hadoop$ jps</div><div class=\"line\">1489 Jps</div><div class=\"line\">796 NodeManager</div><div class=\"line\">606 DataNode</div></pre></td></tr></table></figure></p>\n<h4 id=\"4-部署spark\"><a href=\"#4-部署spark\" class=\"headerlink\" title=\"4. 部署spark\"></a>4. 部署spark</h4><h5 id=\"下载spark-2-0-2-bin-hadoop2-7-tgz\"><a href=\"#下载spark-2-0-2-bin-hadoop2-7-tgz\" class=\"headerlink\" title=\"下载spark-2.0.2-bin-hadoop2.7.tgz\"></a>下载spark-2.0.2-bin-hadoop2.7.tgz</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /usr/<span class=\"built_in\">local</span>/spark/ &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/spark</div><div class=\"line\">chown -R hadoop:hadoop /usr/<span class=\"built_in\">local</span>/spark</div><div class=\"line\">wget <span class=\"string\">\"http://d3kbcqa49mib13.cloudfront.net/spark-2.0.2-bin-hadoop2.7.tgz\"</span></div><div class=\"line\">tar -zxf spark-2.0.2-bin-hadoop2.7.tgz &amp;&amp; rm -f spark-2.0.2-bin-hadoop2.7.tgz</div><div class=\"line\"><span class=\"built_in\">cd</span> spark-2.0.2-bin-hadoop2.7</div></pre></td></tr></table></figure>\n<h5 id=\"配置环境变量\"><a href=\"#配置环境变量\" class=\"headerlink\" title=\"配置环境变量\"></a>配置环境变量</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"export SPARK_HOME=/usr/local/spark/spark-2.0.2-bin-hadoop2.7\"</span> &gt;&gt; /etc/profile</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/profile</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"export PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$SPARK_HOME</span>/bin:<span class=\"variable\">$SPARK_HOME</span>/sbin\"</span> &gt;&gt; /etc/profile</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/profile</div></pre></td></tr></table></figure>\n<h5 id=\"修改配置文件-1\"><a href=\"#修改配置文件-1\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h5><ul>\n<li><p>vim conf/spark-env.sh</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># export SPARK_SSH_OPTS=\"-p 23456\"</span></div><div class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76</div><div class=\"line\"><span class=\"built_in\">export</span> SCALA_HOME=/usr/<span class=\"built_in\">local</span>/scala/scala-2.11.8</div><div class=\"line\"><span class=\"built_in\">export</span> SPARK_HOME=/usr/<span class=\"built_in\">local</span>/spark/spark-2.0.2-bin-hadoop2.7</div><div class=\"line\"><span class=\"built_in\">export</span> HADOOP_HOME=/usr/<span class=\"built_in\">local</span>/hadoop/hadoop-2.7.3</div><div class=\"line\"><span class=\"built_in\">export</span> SPARK_MASTER_HOST=master</div><div class=\"line\"><span class=\"built_in\">export</span> HADOOP_CONF_DIR=/usr/<span class=\"built_in\">local</span>/hadoop/hadoop-2.7.3/etc/hadoop/</div><div class=\"line\"><span class=\"built_in\">export</span> SPARK_HISTORY_OPTS=<span class=\"string\">\"-Dspark.history.retainedApplications=3 -Dspark.history.fs.logDirectory=hdfs://master:9000/sparklogs\"</span></div><div class=\"line\"><span class=\"built_in\">export</span> LD_LIBRARY_PATH=<span class=\"variable\">$&#123;HADOOP_HOME&#125;</span>/lib/native/:<span class=\"variable\">$LD_LIBRARY_PATH</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>vim spark-default.conf</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">spark.yarn.jars hdfs://1.downlog-es.10.220.2.233.fs.115cdn.net:9100/sparkjars</div><div class=\"line\">#spark.yarn.archive hdfs://hadoop.master.fs.115cdn.net:9000/user/btadmin/.sparkStaging/application_1483167145424_0004/__spark_libs__8967711398799981387.zip</div><div class=\"line\">spark.eventLog.enabled  true</div><div class=\"line\">spark.eventLog.dir hdfs://1.downlog-es.10.220.2.233.fs.115cdn.net:9100/sparklogs</div><div class=\"line\">spark.history.fs.logDirectory hdfs://1.downlog-es.10.220.2.233.fs.115cdn.net:9100/sparkHistoryLogs</div><div class=\"line\"></div><div class=\"line\">#spark.executor.extraClassPath /usr/local/spark/jars/mysql-connector-java-5.1.40.jar</div><div class=\"line\">#spark.executor.extraClassPath /usr/local/spark/extrajars/mysql-connector-java-5.1.40.jar:/usr/local/spark/extrajars/mongo-spark-connector_2.11-0.2.jar</div><div class=\"line\">#spark.mongodb.input.uri mongodb://10.220.2.223:27017/hashmap.fidsha1</div><div class=\"line\">spark.executor.instances  12</div><div class=\"line\">spark.driver.cores        2</div><div class=\"line\">spark.executor.cores      2</div><div class=\"line\">spark.executor.memory     4g</div><div class=\"line\">spark.driver.memory       4g</div><div class=\"line\">spark.default.parallelism 48</div><div class=\"line\">spark.sql.crossJoin.enabled true</div><div class=\"line\">spark.serializer org.apache.spark.serializer.KryoSerializer</div></pre></td></tr></table></figure>\n<ul>\n<li><p>vim slaves</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">slave01</div><div class=\"line\">slave02</div></pre></td></tr></table></figure>\n</li>\n<li><p>在hdfs为Spark建立必要的目录</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># SPARK_HOME</span></div><div class=\"line\"><span class=\"comment\"># sprk集群的日志目录：配置文件中对history-server中定义的log目录</span></div><div class=\"line\">$ hdfs dfs -mkdir /sparklogs</div><div class=\"line\"><span class=\"comment\"># 将spark的jar包拷贝到hadoop服务器上，这样避免每次计算的时候都要做去一次拷贝操作</span></div><div class=\"line\">$ hdfs dfs -mkdir /sparkjars</div><div class=\"line\">$ <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/spark/spark-2.0.2-bin-hadoop2.7/ &amp;&amp; hdfs dfs -put jars/* /sparkjars/</div></pre></td></tr></table></figure>\n<p>  <strong><em>配置文件修改完成后， 将/usr/local/spark文件夹拷贝到其他节点对应的位置, 并配置好环境变量</em></strong></p>\n<ul>\n<li>spark集群启动, 在主节点中执行:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/spark/spark-2.0.2-bin-hadoop2.7/ &amp;&amp; ./sbin/start-all.sh</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>用自带example验证测试<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@master:/usr/<span class=\"built_in\">local</span>/spark/spark-2.0.2-bin-hadoop2.7<span class=\"comment\"># bin/spark-submit --class org.apache.spark.\\</span></div><div class=\"line\">examples.JavaSparkPi --master spark://master:7077 examples/jars/spark-examples_2.11-2.0.2.jar</div><div class=\"line\">16/12/26 15:41:13 WARN SparkContext: Use an existing SparkContext, some configuration may not take effect.</div><div class=\"line\">[Stage 0:&gt;                                                          (0 + 0) / 2]16/12/26 15:41:20 WARN \\</div><div class=\"line\">TaskSetManager: Stage 0 contains a task of very large size (981 KB). The maximum recommended task size is 100 KB.</div><div class=\"line\">Pi is roughly 3.13608</div></pre></td></tr></table></figure></p>\n<p>  <em>spark启动后， 通过<a href=\"http://master:8080/可以查看spark当前的运行状态\" target=\"_blank\" rel=\"external\">http://master:8080/可以查看spark当前的运行状态</a></em></p>\n<h4 id=\"5-结合es-hadoop\"><a href=\"#5-结合es-hadoop\" class=\"headerlink\" title=\"5. 结合es-hadoop\"></a>5. 结合es-hadoop</h4><ul>\n<li>下载ES-Hadoop</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /usr/<span class=\"built_in\">local</span>/es-hadoop &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/es-hadoop</div><div class=\"line\">wget <span class=\"string\">\"http://download.elastic.co/hadoop/elasticsearch-hadoop-5.1.1.zip\"</span></div><div class=\"line\">unzip elasticsearch-hadoop-5.1.1.zip &amp;&amp; rm -f elasticsearch-hadoop-5.1.1.zip</div><div class=\"line\">cp elasticsearch-hadoop-5.1.1/dist/elasticsearch-hadoop-5.1.1.jar /usr/<span class=\"built_in\">local</span>/spark/spark-2.0.2-bin-hadoop2.7/jars/</div></pre></td></tr></table></figure>\n<ul>\n<li>通过spark访问/操作elasticSearch<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@master:/usr/local/spark/spark-2.0.2-bin-hadoop2.7# ./bin/spark-submit your_spark_es_script.py</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"安装包准备\"><a href=\"#安装包准备\" class=\"headerlink\" title=\"安装包准备\"></a>安装包准备</h3><ul>\n<li>Oracle JDK<br>安装了elasticSearch的系统应该已经配置好了JDK环境; 推荐JDK7</li>\n<li>scala开发环境<br>spark依赖于scala运行, scala是开发spark统计程序的官方语言; 当前使用scala-2.11版本</li>\n<li>hadoop集群<br>hadoop-yarn为spark运算提供资源管理及hdfs存储; 当前使用apache hadoop-2.7.3版本</li>\n<li>spark集群<br>用于分布式运算; 当前使用apache spark 2.0.2版本</li>\n<li>ES-Hadoop插件<br>es-hadoop作为hadoop/spark集成elasticSearch的插件使用; 当前使用es-hadoop_5.1.1版本</li>\n</ul>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><p>** 尚未找到docker对hadoop多机器多节点集群的快速部署方案, 暂时先手动部署</p>","more":"<h4 id=\"1-安装JDK1-7\"><a href=\"#1-安装JDK1-7\" class=\"headerlink\" title=\"1. 安装JDK1.7\"></a>1. 安装JDK1.7</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /usr/<span class=\"built_in\">local</span>/java &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/java</div><div class=\"line\">wget <span class=\"string\">\"http://download.oracle.com/otn/java/jdk/7u76-b13/jdk-7u76-linux-x64.tar.gz\"</span></div><div class=\"line\">tar -zxf jdk-7u76-linux-x64.tar.gz &amp;&amp; rm -f jdk-7u76-linux-x64.tar.gz</div></pre></td></tr></table></figure>\n<p>在/etc/profile中加入如下变量:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76</div><div class=\"line\"><span class=\"built_in\">export</span> JRE_HOME=/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76/jre</div><div class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76/bin</div><div class=\"line\"><span class=\"built_in\">export</span> CLASSPATH=./:/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76/lib:/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76/jre/lib</div></pre></td></tr></table></figure>\n<p>让配置生效: <em>source /etc/profile</em></p>\n<h4 id=\"2-安装scala-2-11\"><a href=\"#2-安装scala-2-11\" class=\"headerlink\" title=\"2. 安装scala-2.11\"></a>2. 安装scala-2.11<br></h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /usr/<span class=\"built_in\">local</span>/scala &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/scala/</div><div class=\"line\">wget <span class=\"string\">\"http://downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz\"</span></div><div class=\"line\">tar -zxf scala-2.11.8.tgz &amp;&amp; rm -f scala-2.11.8.tgz</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"export SCALA_HOME=/usr/local/scala/scala-2.11.8\"</span> &gt;&gt; /etc/profile</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/profile</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"export PATH=<span class=\"variable\">$SCALA_HOME</span>/bin:<span class=\"variable\">$PATH</span>\"</span> &gt;&gt; /etc/profile</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/profile</div></pre></td></tr></table></figure>\n<h4 id=\"3-部署Hadoop\"><a href=\"#3-部署Hadoop\" class=\"headerlink\" title=\"3. 部署Hadoop\"></a>3. 部署Hadoop</h4><h5 id=\"为hadoop创建专有用户\"><a href=\"#为hadoop创建专有用户\" class=\"headerlink\" title=\"为hadoop创建专有用户\"></a>为hadoop创建专有用户</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">groupadd hadoop           <span class=\"comment\"># 添加hadoop用户组</span></div><div class=\"line\">useradd hadoop -g hadoop  <span class=\"comment\"># 添加hadoop用户并加入hadoop组</span></div></pre></td></tr></table></figure>\n<p>vim /etc/sudoers          # 编辑sudoers文件，给hadoop用户sudo权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop  ALL=(ALL) ALL    # 在sudoers末尾加上这一行</div></pre></td></tr></table></figure>\n<h5 id=\"修改各机器主机名-用于方便区分节点\"><a href=\"#修改各机器主机名-用于方便区分节点\" class=\"headerlink\" title=\"修改各机器主机名, 用于方便区分节点\"></a>修改各机器主机名, 用于方便区分节点</h5><p>假设有三台机器, 一个用作master节点, 两个用于slave节点，如下:</p>\n<blockquote>\n<p>192.168.1.181 master<br>192.168.1.191 slave01<br>192.168.1.102 slave02</p>\n</blockquote>\n<p>那么在将各个hostname分别改为master, slave01, slave02后, 各自配置/etc/hosts:<br></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"192.168.1.181 master\"</span> &gt;&gt; /etc/hosts</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"192.168.1.191 slave01\"</span> &gt;&gt; /etc/hosts</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"192.168.1.102 slave02\"</span> &gt;&gt; /etc/hosts</div></pre></td></tr></table></figure>\n<h5 id=\"配置免密码登录\"><a href=\"#配置免密码登录\" class=\"headerlink\" title=\"配置免密码登录\"></a>配置免密码登录</h5><p>hadoop集群中需要配置namenode(master节点)通过用户hadoop免密码登录到本地以及其他datanode(slave节点);<br><br>具体做法是将master节点上的rsa这类证书分发到各个slave节点对应ssh配置目录， 这里略过具体过程。</p>\n<h5 id=\"下载hadoop2-7-3\"><a href=\"#下载hadoop2-7-3\" class=\"headerlink\" title=\"下载hadoop2.7.3\"></a>下载hadoop2.7.3<br></h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /usr/<span class=\"built_in\">local</span>/hadoop &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/hadoop</div><div class=\"line\">wget <span class=\"string\">\"https://archive.apache.org/dist/hadoop/core/hadoop-2.7.3/hadoop-2.7.3.tar.gz\"</span></div><div class=\"line\">tar -zxf hadoop-2.7.3.tar.gz &amp;&amp; rm -f hadoop-2.7.3.tar.gz </div><div class=\"line\">mkdir -p /usr/<span class=\"built_in\">local</span>/hadoop/hdfs/data</div><div class=\"line\">mkdir -p /usr/<span class=\"built_in\">local</span>/hadoop/hdfs/name</div><div class=\"line\">mkdir -p /usr/<span class=\"built_in\">local</span>/hadoop/tmp</div><div class=\"line\">chown -R hadoop:hadoop /usr/<span class=\"built_in\">local</span>/hadoop</div><div class=\"line\"><span class=\"built_in\">cd</span> hadoop-2.7.3 &amp;&amp; su hadoop</div></pre></td></tr></table></figure>\n<h5 id=\"配置环境变量-所有节点同样配置\"><a href=\"#配置环境变量-所有节点同样配置\" class=\"headerlink\" title=\"配置环境变量(所有节点同样配置)\"></a>配置环境变量(所有节点同样配置)<br></h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"export HADOOP_HOME=/usr/local/hadoop/hadoop-2.7.3\"</span> &gt;&gt; /etc/profile</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"export PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$HADOOP_HOME</span>/bin:<span class=\"variable\">$HADOOP_HOME</span>/sbin\"</span> &gt;&gt; /etc/profile</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/profile</div></pre></td></tr></table></figure>\n<h5 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件<br></h5><p>在${HADOOP_HOME}/etc/hadoop/下(<strong><em>可先在主节点中配置好, 然后拷贝到其他工作节点</em></strong>)<br></p>\n<p>1) vim etc/hadoop/hadoop-env.sh</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76</div></pre></td></tr></table></figure>\n<p>2) vim etc/hadoop/yarn-env.sh</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76</div></pre></td></tr></table></figure>\n<p>3) vim etc/hadoop/slaves  // 把datanode的hostname写入slaves文件, 根据实际情况修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">slave01</div><div class=\"line\">slave02</div></pre></td></tr></table></figure>\n<p>4) vim etc/hadoop/core-site.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>fs.defaultFS<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>hdfs://master:9000<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>HDFS的URI，文件系统://namenode标识:端口号<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>          </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.tmp.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/usr/local/hadoop/tmp<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>namenode上本地的hadoop临时文件夹<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>5) vim etc/hadoop/hdfs-site.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.name.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>file:/usr/local/hadoop/hdfs/name<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>namenode上存储hdfs名字空间元数据 <span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.data.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>file:/usr/local/hadoop/hdfs/data<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>datanode上数据块的物理存储位置<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.replication<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>副本个数，配置默认是3,应小于datanode机器数量<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.client.read.shortcircuit<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.domain.socket.path<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>/var/lib/hadoop-hdfs/dn_socket<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>6) vim etc/hadoop/yarn-site.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.nodemanager.aux-services<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>mapreduce_shuffle<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.hostname<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>7) vim etc/hadoop/mapred-site.xml<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapreduce.framework.name<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>yarn<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>  <em>所有配置文件修改后, 将/usr/local/hadoop/文件夹拷贝到datanode中相应的位置</em></p>\n<h5 id=\"hadoop集群初始化及启动-在主节点中执行\"><a href=\"#hadoop集群初始化及启动-在主节点中执行\" class=\"headerlink\" title=\"hadoop集群初始化及启动, 在主节点中执行\"></a>hadoop集群初始化及启动, 在主节点中执行</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/hadoop/hadoop-2.7.3 &amp;&amp; su hadoop</div><div class=\"line\">bin/hdfs namenode -format</div><div class=\"line\">sbin/start-dfs.sh</div><div class=\"line\">sbin/start-yarn.sh</div></pre></td></tr></table></figure>\n<p><strong><em>hadoop启动后, 通过<a href=\"http://master:50070/和http://master:8088/可以分别查看hdfs和task等状态信息\" target=\"_blank\" rel=\"external\">http://master:50070/和http://master:8088/可以分别查看hdfs和task等状态信息</a></em></strong><br>同时也可以用jps查看:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 主节点namenode</div><div class=\"line\">hadoop@1:/usr/local/hadoop$ jps</div><div class=\"line\">9378 NameNode</div><div class=\"line\">10218 NodeManager</div><div class=\"line\">9786 SecondaryNameNode</div><div class=\"line\">10077 ResourceManager</div><div class=\"line\">11453 Jps</div><div class=\"line\">9550 DataNode</div><div class=\"line\"></div><div class=\"line\"># 工作节点</div><div class=\"line\">hadoop@2:/usr/local/hadoop$ jps</div><div class=\"line\">1489 Jps</div><div class=\"line\">796 NodeManager</div><div class=\"line\">606 DataNode</div></pre></td></tr></table></figure></p>\n<h4 id=\"4-部署spark\"><a href=\"#4-部署spark\" class=\"headerlink\" title=\"4. 部署spark\"></a>4. 部署spark</h4><h5 id=\"下载spark-2-0-2-bin-hadoop2-7-tgz\"><a href=\"#下载spark-2-0-2-bin-hadoop2-7-tgz\" class=\"headerlink\" title=\"下载spark-2.0.2-bin-hadoop2.7.tgz\"></a>下载spark-2.0.2-bin-hadoop2.7.tgz</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /usr/<span class=\"built_in\">local</span>/spark/ &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/spark</div><div class=\"line\">chown -R hadoop:hadoop /usr/<span class=\"built_in\">local</span>/spark</div><div class=\"line\">wget <span class=\"string\">\"http://d3kbcqa49mib13.cloudfront.net/spark-2.0.2-bin-hadoop2.7.tgz\"</span></div><div class=\"line\">tar -zxf spark-2.0.2-bin-hadoop2.7.tgz &amp;&amp; rm -f spark-2.0.2-bin-hadoop2.7.tgz</div><div class=\"line\"><span class=\"built_in\">cd</span> spark-2.0.2-bin-hadoop2.7</div></pre></td></tr></table></figure>\n<h5 id=\"配置环境变量\"><a href=\"#配置环境变量\" class=\"headerlink\" title=\"配置环境变量\"></a>配置环境变量</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"export SPARK_HOME=/usr/local/spark/spark-2.0.2-bin-hadoop2.7\"</span> &gt;&gt; /etc/profile</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/profile</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"export PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$SPARK_HOME</span>/bin:<span class=\"variable\">$SPARK_HOME</span>/sbin\"</span> &gt;&gt; /etc/profile</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/profile</div></pre></td></tr></table></figure>\n<h5 id=\"修改配置文件-1\"><a href=\"#修改配置文件-1\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h5><ul>\n<li><p>vim conf/spark-env.sh</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># export SPARK_SSH_OPTS=\"-p 23456\"</span></div><div class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/usr/<span class=\"built_in\">local</span>/java/jdk1.7.0_76</div><div class=\"line\"><span class=\"built_in\">export</span> SCALA_HOME=/usr/<span class=\"built_in\">local</span>/scala/scala-2.11.8</div><div class=\"line\"><span class=\"built_in\">export</span> SPARK_HOME=/usr/<span class=\"built_in\">local</span>/spark/spark-2.0.2-bin-hadoop2.7</div><div class=\"line\"><span class=\"built_in\">export</span> HADOOP_HOME=/usr/<span class=\"built_in\">local</span>/hadoop/hadoop-2.7.3</div><div class=\"line\"><span class=\"built_in\">export</span> SPARK_MASTER_HOST=master</div><div class=\"line\"><span class=\"built_in\">export</span> HADOOP_CONF_DIR=/usr/<span class=\"built_in\">local</span>/hadoop/hadoop-2.7.3/etc/hadoop/</div><div class=\"line\"><span class=\"built_in\">export</span> SPARK_HISTORY_OPTS=<span class=\"string\">\"-Dspark.history.retainedApplications=3 -Dspark.history.fs.logDirectory=hdfs://master:9000/sparklogs\"</span></div><div class=\"line\"><span class=\"built_in\">export</span> LD_LIBRARY_PATH=<span class=\"variable\">$&#123;HADOOP_HOME&#125;</span>/lib/native/:<span class=\"variable\">$LD_LIBRARY_PATH</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>vim spark-default.conf</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">spark.yarn.jars hdfs://1.downlog-es.10.220.2.233.fs.115cdn.net:9100/sparkjars</div><div class=\"line\">#spark.yarn.archive hdfs://hadoop.master.fs.115cdn.net:9000/user/btadmin/.sparkStaging/application_1483167145424_0004/__spark_libs__8967711398799981387.zip</div><div class=\"line\">spark.eventLog.enabled  true</div><div class=\"line\">spark.eventLog.dir hdfs://1.downlog-es.10.220.2.233.fs.115cdn.net:9100/sparklogs</div><div class=\"line\">spark.history.fs.logDirectory hdfs://1.downlog-es.10.220.2.233.fs.115cdn.net:9100/sparkHistoryLogs</div><div class=\"line\"></div><div class=\"line\">#spark.executor.extraClassPath /usr/local/spark/jars/mysql-connector-java-5.1.40.jar</div><div class=\"line\">#spark.executor.extraClassPath /usr/local/spark/extrajars/mysql-connector-java-5.1.40.jar:/usr/local/spark/extrajars/mongo-spark-connector_2.11-0.2.jar</div><div class=\"line\">#spark.mongodb.input.uri mongodb://10.220.2.223:27017/hashmap.fidsha1</div><div class=\"line\">spark.executor.instances  12</div><div class=\"line\">spark.driver.cores        2</div><div class=\"line\">spark.executor.cores      2</div><div class=\"line\">spark.executor.memory     4g</div><div class=\"line\">spark.driver.memory       4g</div><div class=\"line\">spark.default.parallelism 48</div><div class=\"line\">spark.sql.crossJoin.enabled true</div><div class=\"line\">spark.serializer org.apache.spark.serializer.KryoSerializer</div></pre></td></tr></table></figure>\n<ul>\n<li><p>vim slaves</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">slave01</div><div class=\"line\">slave02</div></pre></td></tr></table></figure>\n</li>\n<li><p>在hdfs为Spark建立必要的目录</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># SPARK_HOME</span></div><div class=\"line\"><span class=\"comment\"># sprk集群的日志目录：配置文件中对history-server中定义的log目录</span></div><div class=\"line\">$ hdfs dfs -mkdir /sparklogs</div><div class=\"line\"><span class=\"comment\"># 将spark的jar包拷贝到hadoop服务器上，这样避免每次计算的时候都要做去一次拷贝操作</span></div><div class=\"line\">$ hdfs dfs -mkdir /sparkjars</div><div class=\"line\">$ <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/spark/spark-2.0.2-bin-hadoop2.7/ &amp;&amp; hdfs dfs -put jars/* /sparkjars/</div></pre></td></tr></table></figure>\n<p>  <strong><em>配置文件修改完成后， 将/usr/local/spark文件夹拷贝到其他节点对应的位置, 并配置好环境变量</em></strong></p>\n<ul>\n<li>spark集群启动, 在主节点中执行:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/spark/spark-2.0.2-bin-hadoop2.7/ &amp;&amp; ./sbin/start-all.sh</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>用自带example验证测试<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@master:/usr/<span class=\"built_in\">local</span>/spark/spark-2.0.2-bin-hadoop2.7<span class=\"comment\"># bin/spark-submit --class org.apache.spark.\\</span></div><div class=\"line\">examples.JavaSparkPi --master spark://master:7077 examples/jars/spark-examples_2.11-2.0.2.jar</div><div class=\"line\">16/12/26 15:41:13 WARN SparkContext: Use an existing SparkContext, some configuration may not take effect.</div><div class=\"line\">[Stage 0:&gt;                                                          (0 + 0) / 2]16/12/26 15:41:20 WARN \\</div><div class=\"line\">TaskSetManager: Stage 0 contains a task of very large size (981 KB). The maximum recommended task size is 100 KB.</div><div class=\"line\">Pi is roughly 3.13608</div></pre></td></tr></table></figure></p>\n<p>  <em>spark启动后， 通过<a href=\"http://master:8080/可以查看spark当前的运行状态\" target=\"_blank\" rel=\"external\">http://master:8080/可以查看spark当前的运行状态</a></em></p>\n<h4 id=\"5-结合es-hadoop\"><a href=\"#5-结合es-hadoop\" class=\"headerlink\" title=\"5. 结合es-hadoop\"></a>5. 结合es-hadoop</h4><ul>\n<li>下载ES-Hadoop</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /usr/<span class=\"built_in\">local</span>/es-hadoop &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/es-hadoop</div><div class=\"line\">wget <span class=\"string\">\"http://download.elastic.co/hadoop/elasticsearch-hadoop-5.1.1.zip\"</span></div><div class=\"line\">unzip elasticsearch-hadoop-5.1.1.zip &amp;&amp; rm -f elasticsearch-hadoop-5.1.1.zip</div><div class=\"line\">cp elasticsearch-hadoop-5.1.1/dist/elasticsearch-hadoop-5.1.1.jar /usr/<span class=\"built_in\">local</span>/spark/spark-2.0.2-bin-hadoop2.7/jars/</div></pre></td></tr></table></figure>\n<ul>\n<li>通过spark访问/操作elasticSearch<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@master:/usr/local/spark/spark-2.0.2-bin-hadoop2.7# ./bin/spark-submit your_spark_es_script.py</div></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"flume-kafka部署总结","date":"2017-10-16T10:16:34.000Z","_content":"\n\n### 部署准备\n\n配置日志收集系统(flume+kafka), 版本:\n```\napache-flume-1.8.0-bin.tar.gz\nkafka_2.11-0.10.2.0.tgz\n```\n假设部署在三个工作节点上:\n```\n192.168.0.2\n192.168.0.3\n192.168.0.4\n```\n\n### flume配置说明\n\n假设flume的工作目录在/usr/local/flume, \n监测某日志文件(如/tmp/testflume/chklogs/chk.log),\n则新增配置: /usr/local/flume/conf/flume-kafka.conf\n<!--more-->\n\n```\nFlume2KafkaAgent.sources=mysource\nFlume2KafkaAgent.channels=mychannel\nFlume2KafkaAgent.sinks=mysink\n\nFlume2KafkaAgent.sources.mysource.type=exec\nFlume2KafkaAgent.sources.mysource.channels=mychannel\nFlume2KafkaAgent.sources.mysource.command=tail -F /tmp/testflume/chklogs/chk.log\n\nFlume2KafkaAgent.sinks.mysink.channel=mychannel\nFlume2KafkaAgent.sinks.mysink.type=org.apache.flume.sink.kafka.KafkaSink\nFlume2KafkaAgent.sinks.mysink.kafka.bootstrap.servers=192.168.0.2:9092,192.168.0.3:9092,192.168.0.4:9092\nFlume2KafkaAgent.sinks.mysink.kafka.topic=apilog\nFlume2KafkaAgent.sinks.mysink.kafka.batchSize=20\nFlume2KafkaAgent.sinks.mysink.kafka.requiredAcks=1\n\nFlume2KafkaAgent.channels.mychannel.type=memory\nFlume2KafkaAgent.channels.mychannel.capacity=30000\nFlume2KafkaAgent.channels.mychannel.transactionCapacity=100\n\n```\n三个节点均执行启动命令:\n```shell\nhadoop@1:/usr/local/flume$ bin/flume-ng agent -c conf -f conf/flume-kafka.conf -n Flume2KafkaAgent\n```\n\n### kafka配置说明\n\n假设kafaka的工作目录在/usr/local/kafka,\n修改/usr/local/kafka/config/server.properties以下几项:\n```\nbroker.id=0   # broker id，每个节点必须不同， 比如三个节点分别为0, 1, 2\nport=9092\nadvertised.listeners=PLAINTEXT://your_local_ip:9092 #当前节点ip\nzookeeper.connect=192.168.0.2:2181,192.168.0.3:2181,192.168.0.4:2181\n```\n每个节点启动zookeeper:\n```shell\nhadoop@1:/usr/local/kafka$ bin/zookeeper-server-start.sh\n```\n每个节点启动kafka:\n```shell\nhadoop@1:/usr/local/kafka$ bin/kafka-server-start.sh\n```\n通过jps查看java进程:\n```shell\nhadoop@1:/usr/local/kafka$ jps\n20225 Jps\n13286 Kafka\n15421 QuorumPeerMain\n```\n\n### 验证测试\n\n- 模拟生成日志, 写入/tmp/testflume/chklogs/chk.log, 如:\n```bash\n#!/bin/bash\n\nchkdir=/tmp/testflume/chklogs/\nmkdir -p $chkdir\n\nfor((i=0; i<10000; i++));\ndo\n  dt=$(date '+%Y%m%d %H:%M:%S')\n  echo \"current datetime: $dt\" >> $chkdir/chk.log\n  sleep 0.5\ndone\n```\n- 启动kafka消费者， 查看数据接收记录:\n```shell\nhadoop@1:/usr/local/kafka$ bin/kafka-console-consumer.sh --bootstrap-server 192.168.0.2:9092,192.168.0.3:2181,192.168.0.4:9092 --from-beginning --topic apilog\ncurrent datetime: 20171012 17:42:05\ncurrent datetime: 20171012 17:42:06\ncurrent datetime: 20171012 17:42:07\ncurrent datetime: 20171012 17:42:08\ncurrent datetime: 20171012 17:42:09\ncurrent datetime: 20171012 17:42:10\ncurrent datetime: 20171012 17:42:11\ncurrent datetime: 20171012 17:42:12\ncurrent datetime: 20171012 17:42:13\n```\n由此可见, kafka已可以持续接收到日志数据。\n","source":"_posts/bigdata/flume-kafka-deploy.md","raw":"---\ntitle: flume-kafka部署总结\ndate: 2017-10-16 18:16:34\ntags: flume-kafka\n---\n\n\n### 部署准备\n\n配置日志收集系统(flume+kafka), 版本:\n```\napache-flume-1.8.0-bin.tar.gz\nkafka_2.11-0.10.2.0.tgz\n```\n假设部署在三个工作节点上:\n```\n192.168.0.2\n192.168.0.3\n192.168.0.4\n```\n\n### flume配置说明\n\n假设flume的工作目录在/usr/local/flume, \n监测某日志文件(如/tmp/testflume/chklogs/chk.log),\n则新增配置: /usr/local/flume/conf/flume-kafka.conf\n<!--more-->\n\n```\nFlume2KafkaAgent.sources=mysource\nFlume2KafkaAgent.channels=mychannel\nFlume2KafkaAgent.sinks=mysink\n\nFlume2KafkaAgent.sources.mysource.type=exec\nFlume2KafkaAgent.sources.mysource.channels=mychannel\nFlume2KafkaAgent.sources.mysource.command=tail -F /tmp/testflume/chklogs/chk.log\n\nFlume2KafkaAgent.sinks.mysink.channel=mychannel\nFlume2KafkaAgent.sinks.mysink.type=org.apache.flume.sink.kafka.KafkaSink\nFlume2KafkaAgent.sinks.mysink.kafka.bootstrap.servers=192.168.0.2:9092,192.168.0.3:9092,192.168.0.4:9092\nFlume2KafkaAgent.sinks.mysink.kafka.topic=apilog\nFlume2KafkaAgent.sinks.mysink.kafka.batchSize=20\nFlume2KafkaAgent.sinks.mysink.kafka.requiredAcks=1\n\nFlume2KafkaAgent.channels.mychannel.type=memory\nFlume2KafkaAgent.channels.mychannel.capacity=30000\nFlume2KafkaAgent.channels.mychannel.transactionCapacity=100\n\n```\n三个节点均执行启动命令:\n```shell\nhadoop@1:/usr/local/flume$ bin/flume-ng agent -c conf -f conf/flume-kafka.conf -n Flume2KafkaAgent\n```\n\n### kafka配置说明\n\n假设kafaka的工作目录在/usr/local/kafka,\n修改/usr/local/kafka/config/server.properties以下几项:\n```\nbroker.id=0   # broker id，每个节点必须不同， 比如三个节点分别为0, 1, 2\nport=9092\nadvertised.listeners=PLAINTEXT://your_local_ip:9092 #当前节点ip\nzookeeper.connect=192.168.0.2:2181,192.168.0.3:2181,192.168.0.4:2181\n```\n每个节点启动zookeeper:\n```shell\nhadoop@1:/usr/local/kafka$ bin/zookeeper-server-start.sh\n```\n每个节点启动kafka:\n```shell\nhadoop@1:/usr/local/kafka$ bin/kafka-server-start.sh\n```\n通过jps查看java进程:\n```shell\nhadoop@1:/usr/local/kafka$ jps\n20225 Jps\n13286 Kafka\n15421 QuorumPeerMain\n```\n\n### 验证测试\n\n- 模拟生成日志, 写入/tmp/testflume/chklogs/chk.log, 如:\n```bash\n#!/bin/bash\n\nchkdir=/tmp/testflume/chklogs/\nmkdir -p $chkdir\n\nfor((i=0; i<10000; i++));\ndo\n  dt=$(date '+%Y%m%d %H:%M:%S')\n  echo \"current datetime: $dt\" >> $chkdir/chk.log\n  sleep 0.5\ndone\n```\n- 启动kafka消费者， 查看数据接收记录:\n```shell\nhadoop@1:/usr/local/kafka$ bin/kafka-console-consumer.sh --bootstrap-server 192.168.0.2:9092,192.168.0.3:2181,192.168.0.4:9092 --from-beginning --topic apilog\ncurrent datetime: 20171012 17:42:05\ncurrent datetime: 20171012 17:42:06\ncurrent datetime: 20171012 17:42:07\ncurrent datetime: 20171012 17:42:08\ncurrent datetime: 20171012 17:42:09\ncurrent datetime: 20171012 17:42:10\ncurrent datetime: 20171012 17:42:11\ncurrent datetime: 20171012 17:42:12\ncurrent datetime: 20171012 17:42:13\n```\n由此可见, kafka已可以持续接收到日志数据。\n","slug":"bigdata/flume-kafka-deploy","published":1,"updated":"2017-10-16T10:17:45.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dux000a4j4d4e30q3fu","content":"<h3 id=\"部署准备\"><a href=\"#部署准备\" class=\"headerlink\" title=\"部署准备\"></a>部署准备</h3><p>配置日志收集系统(flume+kafka), 版本:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">apache-flume-1.8.0-bin.tar.gz</div><div class=\"line\">kafka_2.11-0.10.2.0.tgz</div></pre></td></tr></table></figure></p>\n<p>假设部署在三个工作节点上:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">192.168.0.2</div><div class=\"line\">192.168.0.3</div><div class=\"line\">192.168.0.4</div></pre></td></tr></table></figure></p>\n<h3 id=\"flume配置说明\"><a href=\"#flume配置说明\" class=\"headerlink\" title=\"flume配置说明\"></a>flume配置说明</h3><p>假设flume的工作目录在/usr/local/flume,<br>监测某日志文件(如/tmp/testflume/chklogs/chk.log),<br>则新增配置: /usr/local/flume/conf/flume-kafka.conf<br><a id=\"more\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">Flume2KafkaAgent.sources=mysource</div><div class=\"line\">Flume2KafkaAgent.channels=mychannel</div><div class=\"line\">Flume2KafkaAgent.sinks=mysink</div><div class=\"line\"></div><div class=\"line\">Flume2KafkaAgent.sources.mysource.type=exec</div><div class=\"line\">Flume2KafkaAgent.sources.mysource.channels=mychannel</div><div class=\"line\">Flume2KafkaAgent.sources.mysource.command=tail -F /tmp/testflume/chklogs/chk.log</div><div class=\"line\"></div><div class=\"line\">Flume2KafkaAgent.sinks.mysink.channel=mychannel</div><div class=\"line\">Flume2KafkaAgent.sinks.mysink.type=org.apache.flume.sink.kafka.KafkaSink</div><div class=\"line\">Flume2KafkaAgent.sinks.mysink.kafka.bootstrap.servers=192.168.0.2:9092,192.168.0.3:9092,192.168.0.4:9092</div><div class=\"line\">Flume2KafkaAgent.sinks.mysink.kafka.topic=apilog</div><div class=\"line\">Flume2KafkaAgent.sinks.mysink.kafka.batchSize=20</div><div class=\"line\">Flume2KafkaAgent.sinks.mysink.kafka.requiredAcks=1</div><div class=\"line\"></div><div class=\"line\">Flume2KafkaAgent.channels.mychannel.type=memory</div><div class=\"line\">Flume2KafkaAgent.channels.mychannel.capacity=30000</div><div class=\"line\">Flume2KafkaAgent.channels.mychannel.transactionCapacity=100</div></pre></td></tr></table></figure>\n<p>三个节点均执行启动命令:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/usr/local/flume$ bin/flume-ng agent -c conf -f conf/flume-kafka.conf -n Flume2KafkaAgent</div></pre></td></tr></table></figure></p>\n<h3 id=\"kafka配置说明\"><a href=\"#kafka配置说明\" class=\"headerlink\" title=\"kafka配置说明\"></a>kafka配置说明</h3><p>假设kafaka的工作目录在/usr/local/kafka,<br>修改/usr/local/kafka/config/server.properties以下几项:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">broker.id=0   # broker id，每个节点必须不同， 比如三个节点分别为0, 1, 2</div><div class=\"line\">port=9092</div><div class=\"line\">advertised.listeners=PLAINTEXT://your_local_ip:9092 #当前节点ip</div><div class=\"line\">zookeeper.connect=192.168.0.2:2181,192.168.0.3:2181,192.168.0.4:2181</div></pre></td></tr></table></figure></p>\n<p>每个节点启动zookeeper:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/usr/local/kafka$ bin/zookeeper-server-start.sh</div></pre></td></tr></table></figure></p>\n<p>每个节点启动kafka:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/usr/local/kafka$ bin/kafka-server-start.sh</div></pre></td></tr></table></figure></p>\n<p>通过jps查看java进程:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/usr/local/kafka$ jps</div><div class=\"line\">20225 Jps</div><div class=\"line\">13286 Kafka</div><div class=\"line\">15421 QuorumPeerMain</div></pre></td></tr></table></figure></p>\n<h3 id=\"验证测试\"><a href=\"#验证测试\" class=\"headerlink\" title=\"验证测试\"></a>验证测试</h3><ul>\n<li><p>模拟生成日志, 写入/tmp/testflume/chklogs/chk.log, 如:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\"></div><div class=\"line\">chkdir=/tmp/testflume/chklogs/</div><div class=\"line\">mkdir -p <span class=\"variable\">$chkdir</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span>((i=0; i&lt;10000; i++));</div><div class=\"line\"><span class=\"keyword\">do</span></div><div class=\"line\">  dt=$(date <span class=\"string\">'+%Y%m%d %H:%M:%S'</span>)</div><div class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">\"current datetime: <span class=\"variable\">$dt</span>\"</span> &gt;&gt; <span class=\"variable\">$chkdir</span>/chk.log</div><div class=\"line\">  sleep 0.5</div><div class=\"line\"><span class=\"keyword\">done</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>启动kafka消费者， 查看数据接收记录:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/usr/local/kafka$ bin/kafka-console-consumer.sh --bootstrap-server 192.168.0.2:9092,192.168.0.3:2181,192.168.0.4:9092 --from-beginning --topic apilog</div><div class=\"line\">current datetime: 20171012 17:42:05</div><div class=\"line\">current datetime: 20171012 17:42:06</div><div class=\"line\">current datetime: 20171012 17:42:07</div><div class=\"line\">current datetime: 20171012 17:42:08</div><div class=\"line\">current datetime: 20171012 17:42:09</div><div class=\"line\">current datetime: 20171012 17:42:10</div><div class=\"line\">current datetime: 20171012 17:42:11</div><div class=\"line\">current datetime: 20171012 17:42:12</div><div class=\"line\">current datetime: 20171012 17:42:13</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>由此可见, kafka已可以持续接收到日志数据。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"部署准备\"><a href=\"#部署准备\" class=\"headerlink\" title=\"部署准备\"></a>部署准备</h3><p>配置日志收集系统(flume+kafka), 版本:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">apache-flume-1.8.0-bin.tar.gz</div><div class=\"line\">kafka_2.11-0.10.2.0.tgz</div></pre></td></tr></table></figure></p>\n<p>假设部署在三个工作节点上:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">192.168.0.2</div><div class=\"line\">192.168.0.3</div><div class=\"line\">192.168.0.4</div></pre></td></tr></table></figure></p>\n<h3 id=\"flume配置说明\"><a href=\"#flume配置说明\" class=\"headerlink\" title=\"flume配置说明\"></a>flume配置说明</h3><p>假设flume的工作目录在/usr/local/flume,<br>监测某日志文件(如/tmp/testflume/chklogs/chk.log),<br>则新增配置: /usr/local/flume/conf/flume-kafka.conf<br>","more":"</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">Flume2KafkaAgent.sources=mysource</div><div class=\"line\">Flume2KafkaAgent.channels=mychannel</div><div class=\"line\">Flume2KafkaAgent.sinks=mysink</div><div class=\"line\"></div><div class=\"line\">Flume2KafkaAgent.sources.mysource.type=exec</div><div class=\"line\">Flume2KafkaAgent.sources.mysource.channels=mychannel</div><div class=\"line\">Flume2KafkaAgent.sources.mysource.command=tail -F /tmp/testflume/chklogs/chk.log</div><div class=\"line\"></div><div class=\"line\">Flume2KafkaAgent.sinks.mysink.channel=mychannel</div><div class=\"line\">Flume2KafkaAgent.sinks.mysink.type=org.apache.flume.sink.kafka.KafkaSink</div><div class=\"line\">Flume2KafkaAgent.sinks.mysink.kafka.bootstrap.servers=192.168.0.2:9092,192.168.0.3:9092,192.168.0.4:9092</div><div class=\"line\">Flume2KafkaAgent.sinks.mysink.kafka.topic=apilog</div><div class=\"line\">Flume2KafkaAgent.sinks.mysink.kafka.batchSize=20</div><div class=\"line\">Flume2KafkaAgent.sinks.mysink.kafka.requiredAcks=1</div><div class=\"line\"></div><div class=\"line\">Flume2KafkaAgent.channels.mychannel.type=memory</div><div class=\"line\">Flume2KafkaAgent.channels.mychannel.capacity=30000</div><div class=\"line\">Flume2KafkaAgent.channels.mychannel.transactionCapacity=100</div></pre></td></tr></table></figure>\n<p>三个节点均执行启动命令:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/usr/local/flume$ bin/flume-ng agent -c conf -f conf/flume-kafka.conf -n Flume2KafkaAgent</div></pre></td></tr></table></figure></p>\n<h3 id=\"kafka配置说明\"><a href=\"#kafka配置说明\" class=\"headerlink\" title=\"kafka配置说明\"></a>kafka配置说明</h3><p>假设kafaka的工作目录在/usr/local/kafka,<br>修改/usr/local/kafka/config/server.properties以下几项:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">broker.id=0   # broker id，每个节点必须不同， 比如三个节点分别为0, 1, 2</div><div class=\"line\">port=9092</div><div class=\"line\">advertised.listeners=PLAINTEXT://your_local_ip:9092 #当前节点ip</div><div class=\"line\">zookeeper.connect=192.168.0.2:2181,192.168.0.3:2181,192.168.0.4:2181</div></pre></td></tr></table></figure></p>\n<p>每个节点启动zookeeper:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/usr/local/kafka$ bin/zookeeper-server-start.sh</div></pre></td></tr></table></figure></p>\n<p>每个节点启动kafka:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/usr/local/kafka$ bin/kafka-server-start.sh</div></pre></td></tr></table></figure></p>\n<p>通过jps查看java进程:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/usr/local/kafka$ jps</div><div class=\"line\">20225 Jps</div><div class=\"line\">13286 Kafka</div><div class=\"line\">15421 QuorumPeerMain</div></pre></td></tr></table></figure></p>\n<h3 id=\"验证测试\"><a href=\"#验证测试\" class=\"headerlink\" title=\"验证测试\"></a>验证测试</h3><ul>\n<li><p>模拟生成日志, 写入/tmp/testflume/chklogs/chk.log, 如:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\"></div><div class=\"line\">chkdir=/tmp/testflume/chklogs/</div><div class=\"line\">mkdir -p <span class=\"variable\">$chkdir</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span>((i=0; i&lt;10000; i++));</div><div class=\"line\"><span class=\"keyword\">do</span></div><div class=\"line\">  dt=$(date <span class=\"string\">'+%Y%m%d %H:%M:%S'</span>)</div><div class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">\"current datetime: <span class=\"variable\">$dt</span>\"</span> &gt;&gt; <span class=\"variable\">$chkdir</span>/chk.log</div><div class=\"line\">  sleep 0.5</div><div class=\"line\"><span class=\"keyword\">done</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>启动kafka消费者， 查看数据接收记录:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/usr/local/kafka$ bin/kafka-console-consumer.sh --bootstrap-server 192.168.0.2:9092,192.168.0.3:2181,192.168.0.4:9092 --from-beginning --topic apilog</div><div class=\"line\">current datetime: 20171012 17:42:05</div><div class=\"line\">current datetime: 20171012 17:42:06</div><div class=\"line\">current datetime: 20171012 17:42:07</div><div class=\"line\">current datetime: 20171012 17:42:08</div><div class=\"line\">current datetime: 20171012 17:42:09</div><div class=\"line\">current datetime: 20171012 17:42:10</div><div class=\"line\">current datetime: 20171012 17:42:11</div><div class=\"line\">current datetime: 20171012 17:42:12</div><div class=\"line\">current datetime: 20171012 17:42:13</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>由此可见, kafka已可以持续接收到日志数据。</p>"},{"title":"ElasticSearch数据备份与恢复","date":"2017-10-31T03:26:17.000Z","_content":"\n本文主要是记录了(Ubuntu环境)通过sshfs共享文件系统来进行快照方式备份数据。\n假设ES集群有三个节点:\n```\n192.168.1.10\n192.168.1.11\n192.168.1.12\n```\n\n### 1. 创建共享目录\n\n- 每个节点安装sshfs, 创建相同目录用于挂载共享目录\n```\napt-get install fuse sshfs\nmkdir /mnt/backup\n```\n\n- 选取其中一个节点的目录(非系统盘)作为共享目录, 设置其他节点免密码登录到该节点\n假设选择的节点ip为192.168.1.10:\n<!--more-->\n```\n# 192.168.1.10上创建目录\nmkdir /data/es_backup\n# 每个节点挂载同样操作挂载/mnt/backup\nsshfs 192.168.1.10:/data/es_backup /mnt/backup -o allow_other\n# 如果修改了默认ssh端口, 比如23566, 则可以这样:\n# sshfs 192.168.1.10:/data/es_backup /mnt/backup -p 23566 -o allow_other\n```\n其中的参数`-o allow_other`允许了其他用户访问这个目录。\n\n- 测试运行ES的用户对共享目录是否有写权限\n```\nsudo -u elasticsearch touch /mnt/backup/test\n```\n\n### 2. 修改ES配置\n\n- 在elasticsearch.yml中加入一行:\n```\npath.repo:  /mnt/backup/\n```\n- 或者直接修改/etc/init.d/elasticsearch, \n\n将原来的`DAEMON_OPTS`选项\n```\nDAEMON_OPTS=\"-d -p $PID_FILE --default.path.home=$ES_HOME --default.path.logs=$LOG_DIR --default.path.data=$DATA_DIR --default.path.conf=$CONF_DIR\"\n```\n修改为:\n```\nREPO_DIR=/mnt/backup\nDAEMON_OPTS=\"-d -p $PID_FILE --default.path.home=$ES_HOME --default.path.logs=$LOG_DIR --default.path.data=$DATA_DIR --default.path.conf=$CONF_DIR --default.path.repo=$REPO_DIR\"\n```\n具体可能遇到的问题可参考这里: https://discuss.elastic.co/t/path-repo-is-empty/25166/4<br>\n修改后重启es集群。\n\n### 3. 创建备份仓库\n```\ncurl -XPUT 'http://192.168.1.10:9200/_snapshot/EsBackup_zip' -d '{\n\"type\": \"fs\",\n\"settings\": {\n    \"location\": \"/mnt/backup/compress_snapshot\",\n    \"compress\": true\n    }\n}'\n```\n成功后结果返回`{\"acknowledged\":true}`. 这时查看刚创建的仓库:\n```\ncurl -XGET 'http://192.168.1.10:9200/_snapshot?pretty'\n```\n正常结果返回:\n```\n{\n  \"EsBackup_zip\" : {\n    \"type\" : \"fs\",\n    \"settings\" : {\n      \"compress\" : \"true\",\n      \"location\" : \"/mnt/backup/compress_snapshot\"\n    }\n  }\n}\n```\n\n### 4. 备份指定索引数据\n假设要备份单个索引, 索引名为: user_behavior_201702\n```\ncurl -XPUT 'http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702' -d '{\"indices\": \"user_behavior_201702\"}'\n```\n提交备份快照请求后, 查看备份状态:\n```\ncurl -XGET 'http://192.168.1.12:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702?pretty'\n```\n-----\n假设要备份多个索引, 比如idx_1, idx_2, idx_3, 则可以:\n```\ncurl -XPUT 'http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_some_name' -d '{\"indices\": \"idx_1,idx_2,idx_3\"}'\n```\n假设要备份全部索引数据, 则可以:\n```\ncurl -XPUT 'http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_all'\n```\n\n### 5. 恢复备份索引\n\n删除已备份的索引:\n```\ncurl -XDELETE \"http://192.168.1.10:9200/user_behavior_201702\"\n```\n恢复单个索引:\n```\ncurl -XPOST 'http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702/_restore' -d '{\n    \"indices\": \"user_behavior_201702\", \n    \"rename_replacement\": \"restored_ub_201702\"\n}'\n```\n恢复整个快照索引:\n```\ncurl -XPOST 'http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_some_name/_restore'\n```\n提交请求成功后返回`{\"accepted\":true}`。<br>\n查看恢复状态:\n```\ncurl -XGET \"http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702/_status\"\n```\n","source":"_posts/bigdata/es-backup-restore-md.md","raw":"---\ntitle: 'ElasticSearch数据备份与恢复'\ndate: 2017-10-31 11:26:17\ntags: elasticsearch 备份恢复\n---\n\n本文主要是记录了(Ubuntu环境)通过sshfs共享文件系统来进行快照方式备份数据。\n假设ES集群有三个节点:\n```\n192.168.1.10\n192.168.1.11\n192.168.1.12\n```\n\n### 1. 创建共享目录\n\n- 每个节点安装sshfs, 创建相同目录用于挂载共享目录\n```\napt-get install fuse sshfs\nmkdir /mnt/backup\n```\n\n- 选取其中一个节点的目录(非系统盘)作为共享目录, 设置其他节点免密码登录到该节点\n假设选择的节点ip为192.168.1.10:\n<!--more-->\n```\n# 192.168.1.10上创建目录\nmkdir /data/es_backup\n# 每个节点挂载同样操作挂载/mnt/backup\nsshfs 192.168.1.10:/data/es_backup /mnt/backup -o allow_other\n# 如果修改了默认ssh端口, 比如23566, 则可以这样:\n# sshfs 192.168.1.10:/data/es_backup /mnt/backup -p 23566 -o allow_other\n```\n其中的参数`-o allow_other`允许了其他用户访问这个目录。\n\n- 测试运行ES的用户对共享目录是否有写权限\n```\nsudo -u elasticsearch touch /mnt/backup/test\n```\n\n### 2. 修改ES配置\n\n- 在elasticsearch.yml中加入一行:\n```\npath.repo:  /mnt/backup/\n```\n- 或者直接修改/etc/init.d/elasticsearch, \n\n将原来的`DAEMON_OPTS`选项\n```\nDAEMON_OPTS=\"-d -p $PID_FILE --default.path.home=$ES_HOME --default.path.logs=$LOG_DIR --default.path.data=$DATA_DIR --default.path.conf=$CONF_DIR\"\n```\n修改为:\n```\nREPO_DIR=/mnt/backup\nDAEMON_OPTS=\"-d -p $PID_FILE --default.path.home=$ES_HOME --default.path.logs=$LOG_DIR --default.path.data=$DATA_DIR --default.path.conf=$CONF_DIR --default.path.repo=$REPO_DIR\"\n```\n具体可能遇到的问题可参考这里: https://discuss.elastic.co/t/path-repo-is-empty/25166/4<br>\n修改后重启es集群。\n\n### 3. 创建备份仓库\n```\ncurl -XPUT 'http://192.168.1.10:9200/_snapshot/EsBackup_zip' -d '{\n\"type\": \"fs\",\n\"settings\": {\n    \"location\": \"/mnt/backup/compress_snapshot\",\n    \"compress\": true\n    }\n}'\n```\n成功后结果返回`{\"acknowledged\":true}`. 这时查看刚创建的仓库:\n```\ncurl -XGET 'http://192.168.1.10:9200/_snapshot?pretty'\n```\n正常结果返回:\n```\n{\n  \"EsBackup_zip\" : {\n    \"type\" : \"fs\",\n    \"settings\" : {\n      \"compress\" : \"true\",\n      \"location\" : \"/mnt/backup/compress_snapshot\"\n    }\n  }\n}\n```\n\n### 4. 备份指定索引数据\n假设要备份单个索引, 索引名为: user_behavior_201702\n```\ncurl -XPUT 'http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702' -d '{\"indices\": \"user_behavior_201702\"}'\n```\n提交备份快照请求后, 查看备份状态:\n```\ncurl -XGET 'http://192.168.1.12:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702?pretty'\n```\n-----\n假设要备份多个索引, 比如idx_1, idx_2, idx_3, 则可以:\n```\ncurl -XPUT 'http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_some_name' -d '{\"indices\": \"idx_1,idx_2,idx_3\"}'\n```\n假设要备份全部索引数据, 则可以:\n```\ncurl -XPUT 'http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_all'\n```\n\n### 5. 恢复备份索引\n\n删除已备份的索引:\n```\ncurl -XDELETE \"http://192.168.1.10:9200/user_behavior_201702\"\n```\n恢复单个索引:\n```\ncurl -XPOST 'http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702/_restore' -d '{\n    \"indices\": \"user_behavior_201702\", \n    \"rename_replacement\": \"restored_ub_201702\"\n}'\n```\n恢复整个快照索引:\n```\ncurl -XPOST 'http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_some_name/_restore'\n```\n提交请求成功后返回`{\"accepted\":true}`。<br>\n查看恢复状态:\n```\ncurl -XGET \"http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702/_status\"\n```\n","slug":"bigdata/es-backup-restore-md","published":1,"updated":"2017-10-31T03:27:34.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dv5000b4j4ddeu8rxen","content":"<p>本文主要是记录了(Ubuntu环境)通过sshfs共享文件系统来进行快照方式备份数据。<br>假设ES集群有三个节点:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">192.168.1.10</div><div class=\"line\">192.168.1.11</div><div class=\"line\">192.168.1.12</div></pre></td></tr></table></figure></p>\n<h3 id=\"1-创建共享目录\"><a href=\"#1-创建共享目录\" class=\"headerlink\" title=\"1. 创建共享目录\"></a>1. 创建共享目录</h3><ul>\n<li><p>每个节点安装sshfs, 创建相同目录用于挂载共享目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install fuse sshfs</div><div class=\"line\">mkdir /mnt/backup</div></pre></td></tr></table></figure>\n</li>\n<li><p>选取其中一个节点的目录(非系统盘)作为共享目录, 设置其他节点免密码登录到该节点<br>假设选择的节点ip为192.168.1.10:</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 192.168.1.10上创建目录</div><div class=\"line\">mkdir /data/es_backup</div><div class=\"line\"># 每个节点挂载同样操作挂载/mnt/backup</div><div class=\"line\">sshfs 192.168.1.10:/data/es_backup /mnt/backup -o allow_other</div><div class=\"line\"># 如果修改了默认ssh端口, 比如23566, 则可以这样:</div><div class=\"line\"># sshfs 192.168.1.10:/data/es_backup /mnt/backup -p 23566 -o allow_other</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其中的参数<code>-o allow_other</code>允许了其他用户访问这个目录。</p>\n<ul>\n<li>测试运行ES的用户对共享目录是否有写权限<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo -u elasticsearch touch /mnt/backup/test</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"2-修改ES配置\"><a href=\"#2-修改ES配置\" class=\"headerlink\" title=\"2. 修改ES配置\"></a>2. 修改ES配置</h3><ul>\n<li><p>在elasticsearch.yml中加入一行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">path.repo:  /mnt/backup/</div></pre></td></tr></table></figure>\n</li>\n<li><p>或者直接修改/etc/init.d/elasticsearch, </p>\n</li>\n</ul>\n<p>将原来的<code>DAEMON_OPTS</code>选项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DAEMON_OPTS=&quot;-d -p $PID_FILE --default.path.home=$ES_HOME --default.path.logs=$LOG_DIR --default.path.data=$DATA_DIR --default.path.conf=$CONF_DIR&quot;</div></pre></td></tr></table></figure></p>\n<p>修改为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">REPO_DIR=/mnt/backup</div><div class=\"line\">DAEMON_OPTS=&quot;-d -p $PID_FILE --default.path.home=$ES_HOME --default.path.logs=$LOG_DIR --default.path.data=$DATA_DIR --default.path.conf=$CONF_DIR --default.path.repo=$REPO_DIR&quot;</div></pre></td></tr></table></figure></p>\n<p>具体可能遇到的问题可参考这里: <a href=\"https://discuss.elastic.co/t/path-repo-is-empty/25166/4\" target=\"_blank\" rel=\"external\">https://discuss.elastic.co/t/path-repo-is-empty/25166/4</a><br><br>修改后重启es集群。</p>\n<h3 id=\"3-创建备份仓库\"><a href=\"#3-创建备份仓库\" class=\"headerlink\" title=\"3. 创建备份仓库\"></a>3. 创建备份仓库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XPUT &apos;http://192.168.1.10:9200/_snapshot/EsBackup_zip&apos; -d &apos;&#123;</div><div class=\"line\">&quot;type&quot;: &quot;fs&quot;,</div><div class=\"line\">&quot;settings&quot;: &#123;</div><div class=\"line\">    &quot;location&quot;: &quot;/mnt/backup/compress_snapshot&quot;,</div><div class=\"line\">    &quot;compress&quot;: true</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;&apos;</div></pre></td></tr></table></figure>\n<p>成功后结果返回<code>{&quot;acknowledged&quot;:true}</code>. 这时查看刚创建的仓库:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XGET &apos;http://192.168.1.10:9200/_snapshot?pretty&apos;</div></pre></td></tr></table></figure></p>\n<p>正常结果返回:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;EsBackup_zip&quot; : &#123;</div><div class=\"line\">    &quot;type&quot; : &quot;fs&quot;,</div><div class=\"line\">    &quot;settings&quot; : &#123;</div><div class=\"line\">      &quot;compress&quot; : &quot;true&quot;,</div><div class=\"line\">      &quot;location&quot; : &quot;/mnt/backup/compress_snapshot&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-备份指定索引数据\"><a href=\"#4-备份指定索引数据\" class=\"headerlink\" title=\"4. 备份指定索引数据\"></a>4. 备份指定索引数据</h3><p>假设要备份单个索引, 索引名为: user_behavior_201702<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XPUT &apos;http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702&apos; -d &apos;&#123;&quot;indices&quot;: &quot;user_behavior_201702&quot;&#125;&apos;</div></pre></td></tr></table></figure></p>\n<p>提交备份快照请求后, 查看备份状态:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XGET &apos;http://192.168.1.12:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702?pretty&apos;</div></pre></td></tr></table></figure></p>\n<hr>\n<p>假设要备份多个索引, 比如idx_1, idx_2, idx_3, 则可以:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XPUT &apos;http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_some_name&apos; -d &apos;&#123;&quot;indices&quot;: &quot;idx_1,idx_2,idx_3&quot;&#125;&apos;</div></pre></td></tr></table></figure></p>\n<p>假设要备份全部索引数据, 则可以:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XPUT &apos;http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_all&apos;</div></pre></td></tr></table></figure></p>\n<h3 id=\"5-恢复备份索引\"><a href=\"#5-恢复备份索引\" class=\"headerlink\" title=\"5. 恢复备份索引\"></a>5. 恢复备份索引</h3><p>删除已备份的索引:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XDELETE &quot;http://192.168.1.10:9200/user_behavior_201702&quot;</div></pre></td></tr></table></figure></p>\n<p>恢复单个索引:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XPOST &apos;http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702/_restore&apos; -d &apos;&#123;</div><div class=\"line\">    &quot;indices&quot;: &quot;user_behavior_201702&quot;, </div><div class=\"line\">    &quot;rename_replacement&quot;: &quot;restored_ub_201702&quot;</div><div class=\"line\">&#125;&apos;</div></pre></td></tr></table></figure></p>\n<p>恢复整个快照索引:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XPOST &apos;http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_some_name/_restore&apos;</div></pre></td></tr></table></figure></p>\n<p>提交请求成功后返回<code>{&quot;accepted&quot;:true}</code>。<br><br>查看恢复状态:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XGET &quot;http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702/_status&quot;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>本文主要是记录了(Ubuntu环境)通过sshfs共享文件系统来进行快照方式备份数据。<br>假设ES集群有三个节点:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">192.168.1.10</div><div class=\"line\">192.168.1.11</div><div class=\"line\">192.168.1.12</div></pre></td></tr></table></figure></p>\n<h3 id=\"1-创建共享目录\"><a href=\"#1-创建共享目录\" class=\"headerlink\" title=\"1. 创建共享目录\"></a>1. 创建共享目录</h3><ul>\n<li><p>每个节点安装sshfs, 创建相同目录用于挂载共享目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install fuse sshfs</div><div class=\"line\">mkdir /mnt/backup</div></pre></td></tr></table></figure>\n</li>\n<li><p>选取其中一个节点的目录(非系统盘)作为共享目录, 设置其他节点免密码登录到该节点<br>假设选择的节点ip为192.168.1.10:</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 192.168.1.10上创建目录</div><div class=\"line\">mkdir /data/es_backup</div><div class=\"line\"># 每个节点挂载同样操作挂载/mnt/backup</div><div class=\"line\">sshfs 192.168.1.10:/data/es_backup /mnt/backup -o allow_other</div><div class=\"line\"># 如果修改了默认ssh端口, 比如23566, 则可以这样:</div><div class=\"line\"># sshfs 192.168.1.10:/data/es_backup /mnt/backup -p 23566 -o allow_other</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其中的参数<code>-o allow_other</code>允许了其他用户访问这个目录。</p>\n<ul>\n<li>测试运行ES的用户对共享目录是否有写权限<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo -u elasticsearch touch /mnt/backup/test</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"2-修改ES配置\"><a href=\"#2-修改ES配置\" class=\"headerlink\" title=\"2. 修改ES配置\"></a>2. 修改ES配置</h3><ul>\n<li><p>在elasticsearch.yml中加入一行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">path.repo:  /mnt/backup/</div></pre></td></tr></table></figure>\n</li>\n<li><p>或者直接修改/etc/init.d/elasticsearch, </p>\n</li>\n</ul>\n<p>将原来的<code>DAEMON_OPTS</code>选项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DAEMON_OPTS=&quot;-d -p $PID_FILE --default.path.home=$ES_HOME --default.path.logs=$LOG_DIR --default.path.data=$DATA_DIR --default.path.conf=$CONF_DIR&quot;</div></pre></td></tr></table></figure></p>\n<p>修改为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">REPO_DIR=/mnt/backup</div><div class=\"line\">DAEMON_OPTS=&quot;-d -p $PID_FILE --default.path.home=$ES_HOME --default.path.logs=$LOG_DIR --default.path.data=$DATA_DIR --default.path.conf=$CONF_DIR --default.path.repo=$REPO_DIR&quot;</div></pre></td></tr></table></figure></p>\n<p>具体可能遇到的问题可参考这里: <a href=\"https://discuss.elastic.co/t/path-repo-is-empty/25166/4\" target=\"_blank\" rel=\"external\">https://discuss.elastic.co/t/path-repo-is-empty/25166/4</a><br><br>修改后重启es集群。</p>\n<h3 id=\"3-创建备份仓库\"><a href=\"#3-创建备份仓库\" class=\"headerlink\" title=\"3. 创建备份仓库\"></a>3. 创建备份仓库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XPUT &apos;http://192.168.1.10:9200/_snapshot/EsBackup_zip&apos; -d &apos;&#123;</div><div class=\"line\">&quot;type&quot;: &quot;fs&quot;,</div><div class=\"line\">&quot;settings&quot;: &#123;</div><div class=\"line\">    &quot;location&quot;: &quot;/mnt/backup/compress_snapshot&quot;,</div><div class=\"line\">    &quot;compress&quot;: true</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;&apos;</div></pre></td></tr></table></figure>\n<p>成功后结果返回<code>{&quot;acknowledged&quot;:true}</code>. 这时查看刚创建的仓库:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XGET &apos;http://192.168.1.10:9200/_snapshot?pretty&apos;</div></pre></td></tr></table></figure></p>\n<p>正常结果返回:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;EsBackup_zip&quot; : &#123;</div><div class=\"line\">    &quot;type&quot; : &quot;fs&quot;,</div><div class=\"line\">    &quot;settings&quot; : &#123;</div><div class=\"line\">      &quot;compress&quot; : &quot;true&quot;,</div><div class=\"line\">      &quot;location&quot; : &quot;/mnt/backup/compress_snapshot&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-备份指定索引数据\"><a href=\"#4-备份指定索引数据\" class=\"headerlink\" title=\"4. 备份指定索引数据\"></a>4. 备份指定索引数据</h3><p>假设要备份单个索引, 索引名为: user_behavior_201702<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XPUT &apos;http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702&apos; -d &apos;&#123;&quot;indices&quot;: &quot;user_behavior_201702&quot;&#125;&apos;</div></pre></td></tr></table></figure></p>\n<p>提交备份快照请求后, 查看备份状态:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XGET &apos;http://192.168.1.12:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702?pretty&apos;</div></pre></td></tr></table></figure></p>\n<hr>\n<p>假设要备份多个索引, 比如idx_1, idx_2, idx_3, 则可以:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XPUT &apos;http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_some_name&apos; -d &apos;&#123;&quot;indices&quot;: &quot;idx_1,idx_2,idx_3&quot;&#125;&apos;</div></pre></td></tr></table></figure></p>\n<p>假设要备份全部索引数据, 则可以:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XPUT &apos;http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_all&apos;</div></pre></td></tr></table></figure></p>\n<h3 id=\"5-恢复备份索引\"><a href=\"#5-恢复备份索引\" class=\"headerlink\" title=\"5. 恢复备份索引\"></a>5. 恢复备份索引</h3><p>删除已备份的索引:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XDELETE &quot;http://192.168.1.10:9200/user_behavior_201702&quot;</div></pre></td></tr></table></figure></p>\n<p>恢复单个索引:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XPOST &apos;http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702/_restore&apos; -d &apos;&#123;</div><div class=\"line\">    &quot;indices&quot;: &quot;user_behavior_201702&quot;, </div><div class=\"line\">    &quot;rename_replacement&quot;: &quot;restored_ub_201702&quot;</div><div class=\"line\">&#125;&apos;</div></pre></td></tr></table></figure></p>\n<p>恢复整个快照索引:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XPOST &apos;http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_some_name/_restore&apos;</div></pre></td></tr></table></figure></p>\n<p>提交请求成功后返回<code>{&quot;accepted&quot;:true}</code>。<br><br>查看恢复状态:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -XGET &quot;http://192.168.1.10:9200/_snapshot/EsBackup_zip/snapshot_user_behavior_201702/_status&quot;</div></pre></td></tr></table></figure></p>"},{"title":"Spark Streaming从Flume读取数据流(pull模式)","date":"2017-10-19T05:51:01.000Z","_content":"\n\n#### jar包准备\n\n参考官方文档： http://spark.apache.org/docs/latest/streaming-flume-integration.html\n\n当前测试flume使用到的jar包版本如下:\n```\nspark-streaming-flume-sink_2.11-2.2.0.jar\nscala-library-2.11.8.jar\ncommons-lang3-3.5.jar\n```\n这几个jar包下载后放到flume安装目录 `./flume/lib/` 中。\n\nspark streaming用到的jar版本如下:\n```\nspark-streaming-flume-assembly_2.11-2.2.0.jar\n```\n在 http://search.maven.org 下载后放到spark jar依赖目录。\n<!--more-->\n\n#### flume 配置启动\n\n假设flume数据源为本地日志文件: /tmp/log_source/src.log\n新增config文件, 如flume-spark.conf:\n```bash\na1.channels = c1\na1.sinks = spark\na1.sources = r1\n\na1.sinks.spark.type = org.apache.spark.streaming.flume.sink.SparkSink\na1.sinks.spark.hostname = your_hostname\na1.sinks.spark.port = 9999\na1.sinks.spark.channel = c1\n\na1.sources.r1.type=exec\na1.sources.r1.channels=c1\na1.sources.r1.command=tail -F /tmp/log_source/src.log\n\na1.channels.c1.type = file\na1.channels.c1.checkpointDir=/tmp/flume-spark/tmp/checkpoint\na1.channels.c1.dataDirs=/tmp/flume-spark/tmp/data\n```\n\n启动测试:\n```bash\nhadoop@1:/usr/local/flume$ bin/flume-ng agent -c conf -f conf/flume-spark.conf -n a1 -Dflume.root.logger=DEBUG,console\n```\n\n#### spark streaming 接收数据(python)\n\n词频统计逻辑实现test_streaming.py:\n```python\nfrom __future__ import print_function\nimport sys\nimport logging\n\nfrom pyspark import SparkContext\nfrom pyspark.streaming import StreamingContext\nfrom pyspark.streaming.flume import FlumeUtils\n\n\ndef flume_main():\n    sc = SparkContext(appName=\"streaming_analysis_wordcount\")\n    sc.setLogLevel(\"WARN\")\n    ssc = StreamingContext(sc, 1)\n\n    addrs = [(\"your_hostname\",  9999), ]\n    fps = FlumeUtils.createPollingStream(ssc, addrs)\n    lines = fps.map(lambda x: x[1])\n    counts = lines.flatMap(lambda line: line.split(\" \")) \\\n        .map(lambda word: (word, 1)) \\\n        .reduceByKey(lambda a, b: a+b)\n    counts.pprint()\n\n    ssc.start()\n    ssc.awaitTermination()    \n\n\nif __name__ == \"__main__\":\n    flume_main()\n```\n提交spark任务:\n```bash\nhadoop@1:/data/test$ /usr/local/spark/bin/spark-submit --master yarn --deploy-mode client test_streaming.py\n```\n运行后可看到统计输出如:\n```bash\n-------------------------------------------\nTime: 2017-10-19 11:49:00\n-------------------------------------------\n\n\n-------------------------------------------\nTime: 2017-10-19 11:49:01\n-------------------------------------------\n('current', 20)\n('20171019', 20)\n('11:48:58', 1)\n('11:48:59', 10)\n('5435854358', 1)\n('5435954359', 1)\n('5436354363', 1)\n('5436454364', 1)\n('5436954369', 1)\n('5435454354', 1)\n...\n```\n\n","source":"_posts/bigdata/flume-spark-streaming.md","raw":"---\ntitle: 'Spark Streaming从Flume读取数据流(pull模式)'\ndate: 2017-10-19 13:51:01\ntags: flume spark_streaming\n---\n\n\n#### jar包准备\n\n参考官方文档： http://spark.apache.org/docs/latest/streaming-flume-integration.html\n\n当前测试flume使用到的jar包版本如下:\n```\nspark-streaming-flume-sink_2.11-2.2.0.jar\nscala-library-2.11.8.jar\ncommons-lang3-3.5.jar\n```\n这几个jar包下载后放到flume安装目录 `./flume/lib/` 中。\n\nspark streaming用到的jar版本如下:\n```\nspark-streaming-flume-assembly_2.11-2.2.0.jar\n```\n在 http://search.maven.org 下载后放到spark jar依赖目录。\n<!--more-->\n\n#### flume 配置启动\n\n假设flume数据源为本地日志文件: /tmp/log_source/src.log\n新增config文件, 如flume-spark.conf:\n```bash\na1.channels = c1\na1.sinks = spark\na1.sources = r1\n\na1.sinks.spark.type = org.apache.spark.streaming.flume.sink.SparkSink\na1.sinks.spark.hostname = your_hostname\na1.sinks.spark.port = 9999\na1.sinks.spark.channel = c1\n\na1.sources.r1.type=exec\na1.sources.r1.channels=c1\na1.sources.r1.command=tail -F /tmp/log_source/src.log\n\na1.channels.c1.type = file\na1.channels.c1.checkpointDir=/tmp/flume-spark/tmp/checkpoint\na1.channels.c1.dataDirs=/tmp/flume-spark/tmp/data\n```\n\n启动测试:\n```bash\nhadoop@1:/usr/local/flume$ bin/flume-ng agent -c conf -f conf/flume-spark.conf -n a1 -Dflume.root.logger=DEBUG,console\n```\n\n#### spark streaming 接收数据(python)\n\n词频统计逻辑实现test_streaming.py:\n```python\nfrom __future__ import print_function\nimport sys\nimport logging\n\nfrom pyspark import SparkContext\nfrom pyspark.streaming import StreamingContext\nfrom pyspark.streaming.flume import FlumeUtils\n\n\ndef flume_main():\n    sc = SparkContext(appName=\"streaming_analysis_wordcount\")\n    sc.setLogLevel(\"WARN\")\n    ssc = StreamingContext(sc, 1)\n\n    addrs = [(\"your_hostname\",  9999), ]\n    fps = FlumeUtils.createPollingStream(ssc, addrs)\n    lines = fps.map(lambda x: x[1])\n    counts = lines.flatMap(lambda line: line.split(\" \")) \\\n        .map(lambda word: (word, 1)) \\\n        .reduceByKey(lambda a, b: a+b)\n    counts.pprint()\n\n    ssc.start()\n    ssc.awaitTermination()    \n\n\nif __name__ == \"__main__\":\n    flume_main()\n```\n提交spark任务:\n```bash\nhadoop@1:/data/test$ /usr/local/spark/bin/spark-submit --master yarn --deploy-mode client test_streaming.py\n```\n运行后可看到统计输出如:\n```bash\n-------------------------------------------\nTime: 2017-10-19 11:49:00\n-------------------------------------------\n\n\n-------------------------------------------\nTime: 2017-10-19 11:49:01\n-------------------------------------------\n('current', 20)\n('20171019', 20)\n('11:48:58', 1)\n('11:48:59', 10)\n('5435854358', 1)\n('5435954359', 1)\n('5436354363', 1)\n('5436454364', 1)\n('5436954369', 1)\n('5435454354', 1)\n...\n```\n\n","slug":"bigdata/flume-spark-streaming","published":1,"updated":"2017-10-19T05:58:03.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dv6000c4j4difiusvnh","content":"<h4 id=\"jar包准备\"><a href=\"#jar包准备\" class=\"headerlink\" title=\"jar包准备\"></a>jar包准备</h4><p>参考官方文档： <a href=\"http://spark.apache.org/docs/latest/streaming-flume-integration.html\" target=\"_blank\" rel=\"external\">http://spark.apache.org/docs/latest/streaming-flume-integration.html</a></p>\n<p>当前测试flume使用到的jar包版本如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">spark-streaming-flume-sink_2.11-2.2.0.jar</div><div class=\"line\">scala-library-2.11.8.jar</div><div class=\"line\">commons-lang3-3.5.jar</div></pre></td></tr></table></figure></p>\n<p>这几个jar包下载后放到flume安装目录 <code>./flume/lib/</code> 中。</p>\n<p>spark streaming用到的jar版本如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">spark-streaming-flume-assembly_2.11-2.2.0.jar</div></pre></td></tr></table></figure></p>\n<p>在 <a href=\"http://search.maven.org\" target=\"_blank\" rel=\"external\">http://search.maven.org</a> 下载后放到spark jar依赖目录。<br><a id=\"more\"></a></p>\n<h4 id=\"flume-配置启动\"><a href=\"#flume-配置启动\" class=\"headerlink\" title=\"flume 配置启动\"></a>flume 配置启动</h4><p>假设flume数据源为本地日志文件: /tmp/log_source/src.log<br>新增config文件, 如flume-spark.conf:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">a1.channels = c1</div><div class=\"line\">a1.sinks = spark</div><div class=\"line\">a1.sources = r1</div><div class=\"line\"></div><div class=\"line\">a1.sinks.spark.type = org.apache.spark.streaming.flume.sink.SparkSink</div><div class=\"line\">a1.sinks.spark.hostname = your_hostname</div><div class=\"line\">a1.sinks.spark.port = 9999</div><div class=\"line\">a1.sinks.spark.channel = c1</div><div class=\"line\"></div><div class=\"line\">a1.sources.r1.type=<span class=\"built_in\">exec</span></div><div class=\"line\">a1.sources.r1.channels=c1</div><div class=\"line\">a1.sources.r1.command=tail -F /tmp/log_source/src.log</div><div class=\"line\"></div><div class=\"line\">a1.channels.c1.type = file</div><div class=\"line\">a1.channels.c1.checkpointDir=/tmp/flume-spark/tmp/checkpoint</div><div class=\"line\">a1.channels.c1.dataDirs=/tmp/flume-spark/tmp/data</div></pre></td></tr></table></figure></p>\n<p>启动测试:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/usr/<span class=\"built_in\">local</span>/flume$ bin/flume-ng agent -c conf -f conf/flume-spark.conf -n a1 -Dflume.root.logger=DEBUG,console</div></pre></td></tr></table></figure></p>\n<h4 id=\"spark-streaming-接收数据-python\"><a href=\"#spark-streaming-接收数据-python\" class=\"headerlink\" title=\"spark streaming 接收数据(python)\"></a>spark streaming 接收数据(python)</h4><p>词频统计逻辑实现test_streaming.py:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> print_function</div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"keyword\">import</span> logging</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> pyspark <span class=\"keyword\">import</span> SparkContext</div><div class=\"line\"><span class=\"keyword\">from</span> pyspark.streaming <span class=\"keyword\">import</span> StreamingContext</div><div class=\"line\"><span class=\"keyword\">from</span> pyspark.streaming.flume <span class=\"keyword\">import</span> FlumeUtils</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flume_main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    sc = SparkContext(appName=<span class=\"string\">\"streaming_analysis_wordcount\"</span>)</div><div class=\"line\">    sc.setLogLevel(<span class=\"string\">\"WARN\"</span>)</div><div class=\"line\">    ssc = StreamingContext(sc, <span class=\"number\">1</span>)</div><div class=\"line\"></div><div class=\"line\">    addrs = [(<span class=\"string\">\"your_hostname\"</span>,  <span class=\"number\">9999</span>), ]</div><div class=\"line\">    fps = FlumeUtils.createPollingStream(ssc, addrs)</div><div class=\"line\">    lines = fps.map(<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>])</div><div class=\"line\">    counts = lines.flatMap(<span class=\"keyword\">lambda</span> line: line.split(<span class=\"string\">\" \"</span>)) \\</div><div class=\"line\">        .map(<span class=\"keyword\">lambda</span> word: (word, <span class=\"number\">1</span>)) \\</div><div class=\"line\">        .reduceByKey(<span class=\"keyword\">lambda</span> a, b: a+b)</div><div class=\"line\">    counts.pprint()</div><div class=\"line\"></div><div class=\"line\">    ssc.start()</div><div class=\"line\">    ssc.awaitTermination()    </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    flume_main()</div></pre></td></tr></table></figure></p>\n<p>提交spark任务:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/data/<span class=\"built_in\">test</span>$ /usr/<span class=\"built_in\">local</span>/spark/bin/spark-submit --master yarn --deploy-mode client test_streaming.py</div></pre></td></tr></table></figure></p>\n<p>运行后可看到统计输出如:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">-------------------------------------------</div><div class=\"line\">Time: 2017-10-19 11:49:00</div><div class=\"line\">-------------------------------------------</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-------------------------------------------</div><div class=\"line\">Time: 2017-10-19 11:49:01</div><div class=\"line\">-------------------------------------------</div><div class=\"line\">(<span class=\"string\">'current'</span>, 20)</div><div class=\"line\">(<span class=\"string\">'20171019'</span>, 20)</div><div class=\"line\">(<span class=\"string\">'11:48:58'</span>, 1)</div><div class=\"line\">(<span class=\"string\">'11:48:59'</span>, 10)</div><div class=\"line\">(<span class=\"string\">'5435854358'</span>, 1)</div><div class=\"line\">(<span class=\"string\">'5435954359'</span>, 1)</div><div class=\"line\">(<span class=\"string\">'5436354363'</span>, 1)</div><div class=\"line\">(<span class=\"string\">'5436454364'</span>, 1)</div><div class=\"line\">(<span class=\"string\">'5436954369'</span>, 1)</div><div class=\"line\">(<span class=\"string\">'5435454354'</span>, 1)</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"jar包准备\"><a href=\"#jar包准备\" class=\"headerlink\" title=\"jar包准备\"></a>jar包准备</h4><p>参考官方文档： <a href=\"http://spark.apache.org/docs/latest/streaming-flume-integration.html\" target=\"_blank\" rel=\"external\">http://spark.apache.org/docs/latest/streaming-flume-integration.html</a></p>\n<p>当前测试flume使用到的jar包版本如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">spark-streaming-flume-sink_2.11-2.2.0.jar</div><div class=\"line\">scala-library-2.11.8.jar</div><div class=\"line\">commons-lang3-3.5.jar</div></pre></td></tr></table></figure></p>\n<p>这几个jar包下载后放到flume安装目录 <code>./flume/lib/</code> 中。</p>\n<p>spark streaming用到的jar版本如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">spark-streaming-flume-assembly_2.11-2.2.0.jar</div></pre></td></tr></table></figure></p>\n<p>在 <a href=\"http://search.maven.org\" target=\"_blank\" rel=\"external\">http://search.maven.org</a> 下载后放到spark jar依赖目录。<br>","more":"</p>\n<h4 id=\"flume-配置启动\"><a href=\"#flume-配置启动\" class=\"headerlink\" title=\"flume 配置启动\"></a>flume 配置启动</h4><p>假设flume数据源为本地日志文件: /tmp/log_source/src.log<br>新增config文件, 如flume-spark.conf:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">a1.channels = c1</div><div class=\"line\">a1.sinks = spark</div><div class=\"line\">a1.sources = r1</div><div class=\"line\"></div><div class=\"line\">a1.sinks.spark.type = org.apache.spark.streaming.flume.sink.SparkSink</div><div class=\"line\">a1.sinks.spark.hostname = your_hostname</div><div class=\"line\">a1.sinks.spark.port = 9999</div><div class=\"line\">a1.sinks.spark.channel = c1</div><div class=\"line\"></div><div class=\"line\">a1.sources.r1.type=<span class=\"built_in\">exec</span></div><div class=\"line\">a1.sources.r1.channels=c1</div><div class=\"line\">a1.sources.r1.command=tail -F /tmp/log_source/src.log</div><div class=\"line\"></div><div class=\"line\">a1.channels.c1.type = file</div><div class=\"line\">a1.channels.c1.checkpointDir=/tmp/flume-spark/tmp/checkpoint</div><div class=\"line\">a1.channels.c1.dataDirs=/tmp/flume-spark/tmp/data</div></pre></td></tr></table></figure></p>\n<p>启动测试:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/usr/<span class=\"built_in\">local</span>/flume$ bin/flume-ng agent -c conf -f conf/flume-spark.conf -n a1 -Dflume.root.logger=DEBUG,console</div></pre></td></tr></table></figure></p>\n<h4 id=\"spark-streaming-接收数据-python\"><a href=\"#spark-streaming-接收数据-python\" class=\"headerlink\" title=\"spark streaming 接收数据(python)\"></a>spark streaming 接收数据(python)</h4><p>词频统计逻辑实现test_streaming.py:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> print_function</div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"keyword\">import</span> logging</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> pyspark <span class=\"keyword\">import</span> SparkContext</div><div class=\"line\"><span class=\"keyword\">from</span> pyspark.streaming <span class=\"keyword\">import</span> StreamingContext</div><div class=\"line\"><span class=\"keyword\">from</span> pyspark.streaming.flume <span class=\"keyword\">import</span> FlumeUtils</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flume_main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    sc = SparkContext(appName=<span class=\"string\">\"streaming_analysis_wordcount\"</span>)</div><div class=\"line\">    sc.setLogLevel(<span class=\"string\">\"WARN\"</span>)</div><div class=\"line\">    ssc = StreamingContext(sc, <span class=\"number\">1</span>)</div><div class=\"line\"></div><div class=\"line\">    addrs = [(<span class=\"string\">\"your_hostname\"</span>,  <span class=\"number\">9999</span>), ]</div><div class=\"line\">    fps = FlumeUtils.createPollingStream(ssc, addrs)</div><div class=\"line\">    lines = fps.map(<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>])</div><div class=\"line\">    counts = lines.flatMap(<span class=\"keyword\">lambda</span> line: line.split(<span class=\"string\">\" \"</span>)) \\</div><div class=\"line\">        .map(<span class=\"keyword\">lambda</span> word: (word, <span class=\"number\">1</span>)) \\</div><div class=\"line\">        .reduceByKey(<span class=\"keyword\">lambda</span> a, b: a+b)</div><div class=\"line\">    counts.pprint()</div><div class=\"line\"></div><div class=\"line\">    ssc.start()</div><div class=\"line\">    ssc.awaitTermination()    </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    flume_main()</div></pre></td></tr></table></figure></p>\n<p>提交spark任务:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/data/<span class=\"built_in\">test</span>$ /usr/<span class=\"built_in\">local</span>/spark/bin/spark-submit --master yarn --deploy-mode client test_streaming.py</div></pre></td></tr></table></figure></p>\n<p>运行后可看到统计输出如:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">-------------------------------------------</div><div class=\"line\">Time: 2017-10-19 11:49:00</div><div class=\"line\">-------------------------------------------</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-------------------------------------------</div><div class=\"line\">Time: 2017-10-19 11:49:01</div><div class=\"line\">-------------------------------------------</div><div class=\"line\">(<span class=\"string\">'current'</span>, 20)</div><div class=\"line\">(<span class=\"string\">'20171019'</span>, 20)</div><div class=\"line\">(<span class=\"string\">'11:48:58'</span>, 1)</div><div class=\"line\">(<span class=\"string\">'11:48:59'</span>, 10)</div><div class=\"line\">(<span class=\"string\">'5435854358'</span>, 1)</div><div class=\"line\">(<span class=\"string\">'5435954359'</span>, 1)</div><div class=\"line\">(<span class=\"string\">'5436354363'</span>, 1)</div><div class=\"line\">(<span class=\"string\">'5436454364'</span>, 1)</div><div class=\"line\">(<span class=\"string\">'5436954369'</span>, 1)</div><div class=\"line\">(<span class=\"string\">'5435454354'</span>, 1)</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>"},{"title":"分布式转码初步方案","date":"2017-11-29T04:16:07.000Z","_content":"\n#### 背景说明\n现有的转码方案是一个转码worker处理整个视频的不同清晰度的转码，如果一个视频很大，那这个视频转码将非常耗时。\n因此需要改进方案，要求对大多数格式的视频可以进行切片后并行转码，以此提高一个视频的转码效率。\n\n#### 技术预研\n目前搜到的参考资料，基本都是针对某几个特定格式的分布式转码方案。\n当前视频转码基本都依赖于ffmpeg， 目前存在一个问题：\n暂时没有找到一个合适的方法去无缝切割多种编码格式的视频，然后分别对切割出来的分片进行转码； 这个过程部分格式正常部分异常(请原谅我是非科班出身)。\n计划先用low一点的方案实现，ffmpeg可以在一个完整的视频上，指定视频区间来进行转码，暂时测试了大多数格式的效果都OK；\n那就每个worker的视频源都是同一个视频文件，然后并行对不同区间的视频段进行转码，所以就有了下面这个初步方案。\n\n<!--more-->\n\n#### 架构方案\n![video_convert.png](http://123.207.231.132/img/video_convert.png)\n\n#### 几点说明\n1. 利用ffmpeg、hadoop、RBMQ， ffmpeg作为分布式存储，ffmpeg作为转码工具，RBMQ作为任务队列， 来构建一个分布式转码服务；\n2. 关于方案中的几个问题：\n- 每个转码worker都需要操作整个视频， 中间涉及到的上传、下载开销比较大；\n- 多个过程都依赖于rbmq来完成异步转码，虽然解耦，但是会增加失败重转逻辑的复杂度；\n- 如何均衡分配worker是一个关键点，比如有些视频转码的优先级比较高，有些视频比较大可能又需要更多的worker去并行处理转码。\n\n#### 最后\n架构需要改进，但应该可以在编码实现和测试的过程中逐步改进；如果最后解决了大多数格式视频都可以先切割成单独视频分片后，再针对分片来进行转码及合并的问题，那么就可以减少更多传输和存储开销，提升性能。\n","source":"_posts/bigdata/distributed-video-convert.md","raw":"---\ntitle: '分布式转码初步方案'\ndate: 2017-11-29 12:16:07\ntags: 视频\n---\n\n#### 背景说明\n现有的转码方案是一个转码worker处理整个视频的不同清晰度的转码，如果一个视频很大，那这个视频转码将非常耗时。\n因此需要改进方案，要求对大多数格式的视频可以进行切片后并行转码，以此提高一个视频的转码效率。\n\n#### 技术预研\n目前搜到的参考资料，基本都是针对某几个特定格式的分布式转码方案。\n当前视频转码基本都依赖于ffmpeg， 目前存在一个问题：\n暂时没有找到一个合适的方法去无缝切割多种编码格式的视频，然后分别对切割出来的分片进行转码； 这个过程部分格式正常部分异常(请原谅我是非科班出身)。\n计划先用low一点的方案实现，ffmpeg可以在一个完整的视频上，指定视频区间来进行转码，暂时测试了大多数格式的效果都OK；\n那就每个worker的视频源都是同一个视频文件，然后并行对不同区间的视频段进行转码，所以就有了下面这个初步方案。\n\n<!--more-->\n\n#### 架构方案\n![video_convert.png](http://123.207.231.132/img/video_convert.png)\n\n#### 几点说明\n1. 利用ffmpeg、hadoop、RBMQ， ffmpeg作为分布式存储，ffmpeg作为转码工具，RBMQ作为任务队列， 来构建一个分布式转码服务；\n2. 关于方案中的几个问题：\n- 每个转码worker都需要操作整个视频， 中间涉及到的上传、下载开销比较大；\n- 多个过程都依赖于rbmq来完成异步转码，虽然解耦，但是会增加失败重转逻辑的复杂度；\n- 如何均衡分配worker是一个关键点，比如有些视频转码的优先级比较高，有些视频比较大可能又需要更多的worker去并行处理转码。\n\n#### 最后\n架构需要改进，但应该可以在编码实现和测试的过程中逐步改进；如果最后解决了大多数格式视频都可以先切割成单独视频分片后，再针对分片来进行转码及合并的问题，那么就可以减少更多传输和存储开销，提升性能。\n","slug":"bigdata/distributed-video-convert","published":1,"updated":"2017-11-29T04:17:58.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dva000f4j4dmtu4m2ro","content":"<h4 id=\"背景说明\"><a href=\"#背景说明\" class=\"headerlink\" title=\"背景说明\"></a>背景说明</h4><p>现有的转码方案是一个转码worker处理整个视频的不同清晰度的转码，如果一个视频很大，那这个视频转码将非常耗时。<br>因此需要改进方案，要求对大多数格式的视频可以进行切片后并行转码，以此提高一个视频的转码效率。</p>\n<h4 id=\"技术预研\"><a href=\"#技术预研\" class=\"headerlink\" title=\"技术预研\"></a>技术预研</h4><p>目前搜到的参考资料，基本都是针对某几个特定格式的分布式转码方案。<br>当前视频转码基本都依赖于ffmpeg， 目前存在一个问题：<br>暂时没有找到一个合适的方法去无缝切割多种编码格式的视频，然后分别对切割出来的分片进行转码； 这个过程部分格式正常部分异常(请原谅我是非科班出身)。<br>计划先用low一点的方案实现，ffmpeg可以在一个完整的视频上，指定视频区间来进行转码，暂时测试了大多数格式的效果都OK；<br>那就每个worker的视频源都是同一个视频文件，然后并行对不同区间的视频段进行转码，所以就有了下面这个初步方案。</p>\n<a id=\"more\"></a>\n<h4 id=\"架构方案\"><a href=\"#架构方案\" class=\"headerlink\" title=\"架构方案\"></a>架构方案</h4><p><img src=\"http://123.207.231.132/img/video_convert.png\" alt=\"video_convert.png\"></p>\n<h4 id=\"几点说明\"><a href=\"#几点说明\" class=\"headerlink\" title=\"几点说明\"></a>几点说明</h4><ol>\n<li>利用ffmpeg、hadoop、RBMQ， ffmpeg作为分布式存储，ffmpeg作为转码工具，RBMQ作为任务队列， 来构建一个分布式转码服务；</li>\n<li>关于方案中的几个问题：</li>\n</ol>\n<ul>\n<li>每个转码worker都需要操作整个视频， 中间涉及到的上传、下载开销比较大；</li>\n<li>多个过程都依赖于rbmq来完成异步转码，虽然解耦，但是会增加失败重转逻辑的复杂度；</li>\n<li>如何均衡分配worker是一个关键点，比如有些视频转码的优先级比较高，有些视频比较大可能又需要更多的worker去并行处理转码。</li>\n</ul>\n<h4 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h4><p>架构需要改进，但应该可以在编码实现和测试的过程中逐步改进；如果最后解决了大多数格式视频都可以先切割成单独视频分片后，再针对分片来进行转码及合并的问题，那么就可以减少更多传输和存储开销，提升性能。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"背景说明\"><a href=\"#背景说明\" class=\"headerlink\" title=\"背景说明\"></a>背景说明</h4><p>现有的转码方案是一个转码worker处理整个视频的不同清晰度的转码，如果一个视频很大，那这个视频转码将非常耗时。<br>因此需要改进方案，要求对大多数格式的视频可以进行切片后并行转码，以此提高一个视频的转码效率。</p>\n<h4 id=\"技术预研\"><a href=\"#技术预研\" class=\"headerlink\" title=\"技术预研\"></a>技术预研</h4><p>目前搜到的参考资料，基本都是针对某几个特定格式的分布式转码方案。<br>当前视频转码基本都依赖于ffmpeg， 目前存在一个问题：<br>暂时没有找到一个合适的方法去无缝切割多种编码格式的视频，然后分别对切割出来的分片进行转码； 这个过程部分格式正常部分异常(请原谅我是非科班出身)。<br>计划先用low一点的方案实现，ffmpeg可以在一个完整的视频上，指定视频区间来进行转码，暂时测试了大多数格式的效果都OK；<br>那就每个worker的视频源都是同一个视频文件，然后并行对不同区间的视频段进行转码，所以就有了下面这个初步方案。</p>","more":"<h4 id=\"架构方案\"><a href=\"#架构方案\" class=\"headerlink\" title=\"架构方案\"></a>架构方案</h4><p><img src=\"http://123.207.231.132/img/video_convert.png\" alt=\"video_convert.png\"></p>\n<h4 id=\"几点说明\"><a href=\"#几点说明\" class=\"headerlink\" title=\"几点说明\"></a>几点说明</h4><ol>\n<li>利用ffmpeg、hadoop、RBMQ， ffmpeg作为分布式存储，ffmpeg作为转码工具，RBMQ作为任务队列， 来构建一个分布式转码服务；</li>\n<li>关于方案中的几个问题：</li>\n</ol>\n<ul>\n<li>每个转码worker都需要操作整个视频， 中间涉及到的上传、下载开销比较大；</li>\n<li>多个过程都依赖于rbmq来完成异步转码，虽然解耦，但是会增加失败重转逻辑的复杂度；</li>\n<li>如何均衡分配worker是一个关键点，比如有些视频转码的优先级比较高，有些视频比较大可能又需要更多的worker去并行处理转码。</li>\n</ul>\n<h4 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h4><p>架构需要改进，但应该可以在编码实现和测试的过程中逐步改进；如果最后解决了大多数格式视频都可以先切割成单独视频分片后，再针对分片来进行转码及合并的问题，那么就可以减少更多传输和存储开销，提升性能。</p>"},{"title":"hadoop-spark错误问题总结","date":"2017-10-16T06:55:21.000Z","_content":"\n## hadoop-spark错误问题总结\n\n#### 1.Caused by: java.lang.NoClassDefFoundError: scala/collection/GenTraversableOnce$class\n\n具体错误日志:\n```\nCaused by: java.lang.NoClassDefFoundError: scala/collection/GenTraversableOnce$class\n    at org.elasticsearch.spark.rdd.AbstractEsRDDIterator.<init>(AbstractEsRDDIterator.scala:28)\n    at org.elasticsearch.spark.sql.ScalaEsRowRDDIterator.<init>(ScalaEsRowRDD.scala:49)\n    at org.elasticsearch.spark.sql.ScalaEsRowRDD.compute(ScalaEsRowRDD.scala:45)\n    at org.elasticsearch.spark.sql.ScalaEsRowRDD.compute(ScalaEsRowRDD.scala:38)\n    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)\n    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)\n    at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)\n    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)\n    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)\n    at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)\n    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)\n    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)\n    at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)\n    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)\n    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)\n    at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:70)\n    at org.apache.spark.scheduler.Task.run(Task.scala:86)\n    at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:274)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    ... 1 more\n```\n<!--more-->\n原因分析及解决方法:\n\n- spark所依赖的scala版本与系统安装的scala版本不一致<br>\n    通过检查, 系统安装了scala2.11.1, spark依赖的包为2.11.8; 统一之后， 问题依然存在\n- scala2.11.8中并不存在类GenTraversableOnce<br>\n    通过其API Reference可知, 该类是有定义的， 而且spark下关于sparkSQL的example运行测试通过;\n- 代码自身问题, 调用API方式或配置不当<br>\n原有代码(参照了官方scala示例):\n```python\nconf = SparkConf()\nconf.setMaster(\"spark://192.168.1.181:7077\").setAppName(\"es_spark\")\nconf.set(\"es.nodes\", \"192.168.1.181\")\nconf.set(\"es.port\", \"9200\")\nconf.set(\"es.resource\", \"web-2016.12.26/web\")\nsc = SparkContext(conf=conf)\nsqc = SQLContext(sc)\ndf = sqc.read.format(\"org.elasticsearch.spark.sql\"  ).load(\"web-2016.12.26/web\")\ndf.printSchema()\nprint df.first()   # 这里开始报错\n```\n改用根据rdd来创建view的方法, 修改后如下:\n```python\nconf = {\n    \"es.nodes\": \"192.168.1.181\",\n    \"es.port\": \"9200\",\n    \"es.resource\": \"web-2016.12.26/web\",\n    \"es.read.field.include\": \"city,uri,unique\",\n}\nquery = '''{\n      \"query\": {\n        \"match\": {\"city\":\"Guangzhou\"}\n      }\n  }'''\nconf['es.query'] = query\nrdd = sc.newAPIHadoopRDD(\n    \"org.elasticsearch.hadoop.mr.EsInputFormat\",\n    \"org.apache.hadoop.io.NullWritable\",\n    \"org.elasticsearch.hadoop.mr.LinkedMapWritable\",\n    conf=es_conf).map(lambda x: x[1])\nschemaUsers = ss.createDataFrame(rdd)\nschemaUsers.createOrReplaceTempView(\"users\")\nres = ss.sql(\"select uri from users\")\nprint (res.first())\n```\n\n#### 2. NativeCodeLoader: Unable to load native-hadoop library for your platform\n\n原因分析及解决方法:\n\n>主要是jre目录下缺少了libhadoop.so和libsnappy.so两个文件。具体是，spark-shell依赖的是scala，scala依赖的是JAVA_HOME下的jdk，libhadoop.so和libsnappy.so两个文件应该放到$JAVA_HOME/jre/lib/amd64下面。\n>这两个so：libhadoop.so和libsnappy.so。前一个so可以在HADOOP_HOME下找到，如hadoop\\lib\\native。第二个libsnappy.so需要下载一个snappy-1.1.0.tar.gz，然后./configure，make编译出来，编译成功之后在.libs文件夹下。\n>当这两个文件准备好后再次启动spark shell不会出现这个问题.\n参考自: https://www.zhihu.com/question/23974067/answer/26267153\n\n\n#### 3. Initial job has not accepted any resources; check your cluster UI to ensure that workers are registered and have sufficient memory\n\n原因分析及解决方法:<br>\n默认情况下spark.cores.max是不限制的， 运行第一个spark application时， 会分配所有的cpu来执行任务；<br>\n因此第二个application很可能就得不到足够的资源了。假设每个任务最多获取一半的cpu资源， 假设总共节点的core为8, 我们可以设置为spark.cores.max=4。\n\n#### 4. NoSuchMethodError: org.apache.hadoop.http.HttpConfig.isSecure()Z\n具体错误日志:\n```\nbtadmin@master:/usr/local/spark/$ bin/spark-submit --class org.apache.spark.examples.JavaSparkPi --master yarn --deploy-mode client examples/jars/spark-examples_2.11-2.0.2.jar\n16/12/30 10:00:06 WARN Utils: Your hostname, node1 resolves to a loopback address: 127.0.1.1; using 192.168.1.191 instead (on interface eth0)\n16/12/30 10:00:07 WARN Utils: Set SPARK_LOCAL_IP if you need to bind to another address\nException in thread \"main\" java.lang.NoSuchMethodError: org.apache.hadoop.http.HttpConfig.isSecure()Z\n at org.apache.hadoop.yarn.webapp.util.WebAppUtils.getResolvedRMWebAppURLWithoutScheme(WebAppUtils.java:101)\n at org.apache.hadoop.yarn.webapp.util.WebAppUtils.getProxyHostAndPort(WebAppUtils.java:90)\n at org.apache.spark.deploy.yarn.YarnRMClient.getAmIpFilterParams(YarnRMClient.scala:115)\n at org.apache.spark.deploy.yarn.ApplicationMaster.addAmIpFilter(ApplicationMaster.scala:582)\n at org.apache.spark.deploy.yarn.ApplicationMaster.runExecutorLauncher(ApplicationMaster.scala:406)\n at org.apache.spark.deploy.yarn.ApplicationMaster.run(ApplicationMaster.scala:247)\n at org.apache.spark.deploy.yarn.ApplicationMaster$$anonfun$main$1.apply$mcV$sp(ApplicationMaster.scala:749)\n at org.apache.spark.deploy.SparkHadoopUtil$$anon$1.run(SparkHadoopUtil.scala:71)\n at org.apache.spark.deploy.SparkHadoopUtil$$anon$1.run(SparkHadoopUtil.scala:70)\n at java.security.AccessController.doPrivileged(Native Method)\n at javax.security.auth.Subject.doAs(Subject.java:415)\n at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1698)\n at org.apache.spark.deploy.SparkHadoopUtil.runAsSparkUser(SparkHadoopUtil.scala:70)\n at org.apache.spark.deploy.yarn.ApplicationMaster$.main(ApplicationMaster.scala:747)\n at org.apache.spark.deploy.yarn.ExecutorLauncher$.main(ApplicationMaster.scala:774)\n at org.apache.spark.deploy.yarn.ExecutorLauncher.main(ApplicationMaster.scala)\n```\n\n原因分析及解决方法:\nspark中部分jar文件与hadoop的不兼容, 当前spark-defaults.conf中设置:\n```\nspark.yarn.jars hdfs:///sparkjars/*   # jar文件从${SPARK_HOME}/jars/中已上传到hdfs\n```\n使用另一种方法代替jar库引用:\n```\nspark.yarn.archive hdfs://master:9000/user/btadmin/.sparkStaging/application_1483167145424_0004/__spark_libs__8967711398799981387.zip\n```\n\n#### 5.Could not find or load main class org.apache.spark.deploy.yarn.ExecutorLauncher\n\nspark-defaults.conf的参数spark.yarn.jars配置错了， 参考:\nhttp://blog.csdn.net/dax1n/article/details/53001884\n\n需要将以下配置项(假设jar库都放在了hdfs)\n> spark.yarn.jars hdfs://your.hdfs.host:port/sparkjars/\n\n修改为\n> spark.yarn.jars hdfs://your.hdfs.hos:port/sparkjars/*\n\n#### 6.java.nio.channels.ClosedChannelException\n\n具体错误日志:\n```\njava.nio.channels.ClosedChannelException\n    at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source)\n```\n\n参考博客: http://www.bijishequ.com/detail/203655?p=58<br>\n目测是给节点分配的内存太小, yarn直接kill了task。\n\n解决方案：\n\n修改yarn-site.xml，添加下列property\n```\n<property>\n    <name>yarn.nodemanager.pmem-check-enabled</name>\n    <value>false</value>\n</property>\n\n<property>\n    <name>yarn.nodemanager.vmem-check-enabled</name>\n    <value>false</value>\n</property>\n```\n\n#### 7.提交spark作业时, 一直卡在yarn.Client: Application report for application_xxx (state: ACCEPTED)\n\n具体错误日志:\n```\n17/10/13 15:14:49 INFO impl.YarnClientImpl: Application submission is not finished, submitted application application_1507620566574_0010 is still in NEW\n17/10/13 15:14:51 INFO impl.YarnClientImpl: Application submission is not finished, submitted application application_1507620566574_0010 is still in NEW\n17/10/13 15:14:52 INFO impl.YarnClientImpl: Submitted application application_1507620566574_0010\n17/10/13 15:14:53 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:14:53 INFO yarn.Client: \n\t client token: N/A\n\t diagnostics: N/A\n\t ApplicationMaster host: N/A\n\t ApplicationMaster RPC port: -1\n\t queue: default\n\t start time: 1507878873743\n\t final status: UNDEFINED\n\t tracking URL: http://1.downlog-es.10.220.2.233.fs.115cdn.net:8088/proxy/application_1507620566574_0010/\n\t user: hadoop\n17/10/13 15:14:54 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:14:55 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:14:56 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:14:57 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:14:58 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:14:59 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:00 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:01 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:02 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:03 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:04 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:05 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:06 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:07 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n\n```\n\n检查查yarn配置时, 发现\tyarn.resourcemanager.address 的值不正常。\n\n比如节点hostname为: 1.test.10.220.2.233.mycdn.net, 则yarn中参数值为:\n```\n<property>\n    <name>yarn.resourcemanager.address</name>\n    <value>1.1.test.10.220.2.233.mycdn.net:8032</value>\n    <source>programatically</source>\n</property>\n```\n同时在执行stop-dfs.sh时, 发现namenode和datanode的hostname对不上:\n```\nStopping namenodes on [1.1.test.10.220.2.233.mycdn.net]\n1.1.test.10.220.2.233.mycdn.net: stopping namenode\n1.test.10.220.2.233.mycdn.net: stopping datanode\n2.test.10.220.2.234.mycdn.net: stopping datanode\nStopping secondary namenodes [0.0.0.0]\n0.0.0.0: stopping secondarynamenode\n```\n查看/etc/hosts时， 发现多了一个域名映射:\n```\n10.220.2.233 1.1.test.10.220.2.233.mycdn.net 1\n```\n注释掉之后， 重启hadoop集群, spark on yarn任务可以正常执行。\n\n#### 8.java.lang.NoClassDefFoundError: kafka/common/TopicAndPartition\n具体错误日志:\n```\nException in thread \"Thread-3\" java.lang.NoClassDefFoundError: kafka/common/TopicAndPartition\n\tat java.lang.Class.getDeclaredMethods0(Native Method)\n\tat java.lang.Class.privateGetDeclaredMethods(Class.java:2701)\n\tat java.lang.Class.privateGetPublicMethods(Class.java:2902)\n\tat java.lang.Class.getMethods(Class.java:1615)\n\tat py4j.reflection.ReflectionEngine.getMethodsByNameAndLength(ReflectionEngine.java:345)\n\tat py4j.reflection.ReflectionEngine.getMethod(ReflectionEngine.java:305)\n\tat py4j.reflection.ReflectionEngine.getMethod(ReflectionEngine.java:326)\n\tat py4j.Gateway.invoke(Gateway.java:272)\n\tat py4j.commands.AbstractCommand.invokeMethod(AbstractCommand.java:132)\n\tat py4j.commands.CallCommand.execute(CallCommand.java:79)\n\tat py4j.GatewayConnection.run(GatewayConnection.java:214)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.ClassNotFoundException: kafka.common.TopicAndPartition\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 12 more\nERROR:root:Exception while sending command.\nTraceback (most recent call last):\n  File \"/usr/local/spark/python/lib/py4j-0.10.4-src.zip/py4j/java_gateway.py\", line 883, in send_command\n    response = connection.send_command(command)\n  File \"/usr/local/spark/python/lib/py4j-0.10.4-src.zip/py4j/java_gateway.py\", line 1040, in send_command\n    \"Error while receiving\", e, proto.ERROR_ON_RECEIVE)\nPy4JNetworkError: Error while receiving\n```\n原因及解决方法:\n使用的spark-stream-kafka jar包版本不对, spark2.2(python)具体看这里:\nhttps://spark.apache.org/docs/latest/streaming-kafka-integration.html\n\n同时在maven上面下载正确的版本(spark-streaming-kafka-0-8-assembly_2.11):\nhttp://search.maven.org/#search%7Cga%7C1%7Cspark-streaming-kafka\n\n检查jar是否包含该类:\n```\nhadoop@1:/data/test$ jar -tvf spark-streaming-kafka-0-8-assembly_2.11-2.2.0.jar | grep -i Topicandpartition\n  1959 Fri Jun 30 17:08:54 CST 2017 kafka/common/TopicAndPartition$.class\n  6136 Fri Jun 30 17:08:54 CST 2017 kafka/common/TopicAndPartition.class\nhadoop@1:/data/test$ \n```\n\n#### 9.java.io.IOException: There appears to be a gap in the edit log.  We expected txid 1, but got txid 3.\n\n```\nnamenode进程中出现如下报错信息:\njava.io.IOException: There appears to be a gap in the edit log.  We expected txid 1, but got txid 3\n\n原因：namenode元数据被破坏，需要修复\n解决：恢复一下namenode\nhadoop namenode -recover\n一路选择c，一般就OK了\n```\n\n#### 10.java.io.IOException: Incompatible clusterIDs\n\n```\nnamenode和datanode的clusterID不一致，手动修改成一致的即可；\n/xxx/name/current/VERSION -> 拷贝clusterID字段值 -> /xxx/data/current/VERSION\n```\n","source":"_posts/bigdata/hadoop-spark-errors.md","raw":"---\ntitle: hadoop-spark错误问题总结\ndate: 2017-10-16 14:55:21\ntags: bigdata\n---\n\n## hadoop-spark错误问题总结\n\n#### 1.Caused by: java.lang.NoClassDefFoundError: scala/collection/GenTraversableOnce$class\n\n具体错误日志:\n```\nCaused by: java.lang.NoClassDefFoundError: scala/collection/GenTraversableOnce$class\n    at org.elasticsearch.spark.rdd.AbstractEsRDDIterator.<init>(AbstractEsRDDIterator.scala:28)\n    at org.elasticsearch.spark.sql.ScalaEsRowRDDIterator.<init>(ScalaEsRowRDD.scala:49)\n    at org.elasticsearch.spark.sql.ScalaEsRowRDD.compute(ScalaEsRowRDD.scala:45)\n    at org.elasticsearch.spark.sql.ScalaEsRowRDD.compute(ScalaEsRowRDD.scala:38)\n    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)\n    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)\n    at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)\n    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)\n    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)\n    at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)\n    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)\n    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)\n    at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)\n    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)\n    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)\n    at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:70)\n    at org.apache.spark.scheduler.Task.run(Task.scala:86)\n    at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:274)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    ... 1 more\n```\n<!--more-->\n原因分析及解决方法:\n\n- spark所依赖的scala版本与系统安装的scala版本不一致<br>\n    通过检查, 系统安装了scala2.11.1, spark依赖的包为2.11.8; 统一之后， 问题依然存在\n- scala2.11.8中并不存在类GenTraversableOnce<br>\n    通过其API Reference可知, 该类是有定义的， 而且spark下关于sparkSQL的example运行测试通过;\n- 代码自身问题, 调用API方式或配置不当<br>\n原有代码(参照了官方scala示例):\n```python\nconf = SparkConf()\nconf.setMaster(\"spark://192.168.1.181:7077\").setAppName(\"es_spark\")\nconf.set(\"es.nodes\", \"192.168.1.181\")\nconf.set(\"es.port\", \"9200\")\nconf.set(\"es.resource\", \"web-2016.12.26/web\")\nsc = SparkContext(conf=conf)\nsqc = SQLContext(sc)\ndf = sqc.read.format(\"org.elasticsearch.spark.sql\"  ).load(\"web-2016.12.26/web\")\ndf.printSchema()\nprint df.first()   # 这里开始报错\n```\n改用根据rdd来创建view的方法, 修改后如下:\n```python\nconf = {\n    \"es.nodes\": \"192.168.1.181\",\n    \"es.port\": \"9200\",\n    \"es.resource\": \"web-2016.12.26/web\",\n    \"es.read.field.include\": \"city,uri,unique\",\n}\nquery = '''{\n      \"query\": {\n        \"match\": {\"city\":\"Guangzhou\"}\n      }\n  }'''\nconf['es.query'] = query\nrdd = sc.newAPIHadoopRDD(\n    \"org.elasticsearch.hadoop.mr.EsInputFormat\",\n    \"org.apache.hadoop.io.NullWritable\",\n    \"org.elasticsearch.hadoop.mr.LinkedMapWritable\",\n    conf=es_conf).map(lambda x: x[1])\nschemaUsers = ss.createDataFrame(rdd)\nschemaUsers.createOrReplaceTempView(\"users\")\nres = ss.sql(\"select uri from users\")\nprint (res.first())\n```\n\n#### 2. NativeCodeLoader: Unable to load native-hadoop library for your platform\n\n原因分析及解决方法:\n\n>主要是jre目录下缺少了libhadoop.so和libsnappy.so两个文件。具体是，spark-shell依赖的是scala，scala依赖的是JAVA_HOME下的jdk，libhadoop.so和libsnappy.so两个文件应该放到$JAVA_HOME/jre/lib/amd64下面。\n>这两个so：libhadoop.so和libsnappy.so。前一个so可以在HADOOP_HOME下找到，如hadoop\\lib\\native。第二个libsnappy.so需要下载一个snappy-1.1.0.tar.gz，然后./configure，make编译出来，编译成功之后在.libs文件夹下。\n>当这两个文件准备好后再次启动spark shell不会出现这个问题.\n参考自: https://www.zhihu.com/question/23974067/answer/26267153\n\n\n#### 3. Initial job has not accepted any resources; check your cluster UI to ensure that workers are registered and have sufficient memory\n\n原因分析及解决方法:<br>\n默认情况下spark.cores.max是不限制的， 运行第一个spark application时， 会分配所有的cpu来执行任务；<br>\n因此第二个application很可能就得不到足够的资源了。假设每个任务最多获取一半的cpu资源， 假设总共节点的core为8, 我们可以设置为spark.cores.max=4。\n\n#### 4. NoSuchMethodError: org.apache.hadoop.http.HttpConfig.isSecure()Z\n具体错误日志:\n```\nbtadmin@master:/usr/local/spark/$ bin/spark-submit --class org.apache.spark.examples.JavaSparkPi --master yarn --deploy-mode client examples/jars/spark-examples_2.11-2.0.2.jar\n16/12/30 10:00:06 WARN Utils: Your hostname, node1 resolves to a loopback address: 127.0.1.1; using 192.168.1.191 instead (on interface eth0)\n16/12/30 10:00:07 WARN Utils: Set SPARK_LOCAL_IP if you need to bind to another address\nException in thread \"main\" java.lang.NoSuchMethodError: org.apache.hadoop.http.HttpConfig.isSecure()Z\n at org.apache.hadoop.yarn.webapp.util.WebAppUtils.getResolvedRMWebAppURLWithoutScheme(WebAppUtils.java:101)\n at org.apache.hadoop.yarn.webapp.util.WebAppUtils.getProxyHostAndPort(WebAppUtils.java:90)\n at org.apache.spark.deploy.yarn.YarnRMClient.getAmIpFilterParams(YarnRMClient.scala:115)\n at org.apache.spark.deploy.yarn.ApplicationMaster.addAmIpFilter(ApplicationMaster.scala:582)\n at org.apache.spark.deploy.yarn.ApplicationMaster.runExecutorLauncher(ApplicationMaster.scala:406)\n at org.apache.spark.deploy.yarn.ApplicationMaster.run(ApplicationMaster.scala:247)\n at org.apache.spark.deploy.yarn.ApplicationMaster$$anonfun$main$1.apply$mcV$sp(ApplicationMaster.scala:749)\n at org.apache.spark.deploy.SparkHadoopUtil$$anon$1.run(SparkHadoopUtil.scala:71)\n at org.apache.spark.deploy.SparkHadoopUtil$$anon$1.run(SparkHadoopUtil.scala:70)\n at java.security.AccessController.doPrivileged(Native Method)\n at javax.security.auth.Subject.doAs(Subject.java:415)\n at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1698)\n at org.apache.spark.deploy.SparkHadoopUtil.runAsSparkUser(SparkHadoopUtil.scala:70)\n at org.apache.spark.deploy.yarn.ApplicationMaster$.main(ApplicationMaster.scala:747)\n at org.apache.spark.deploy.yarn.ExecutorLauncher$.main(ApplicationMaster.scala:774)\n at org.apache.spark.deploy.yarn.ExecutorLauncher.main(ApplicationMaster.scala)\n```\n\n原因分析及解决方法:\nspark中部分jar文件与hadoop的不兼容, 当前spark-defaults.conf中设置:\n```\nspark.yarn.jars hdfs:///sparkjars/*   # jar文件从${SPARK_HOME}/jars/中已上传到hdfs\n```\n使用另一种方法代替jar库引用:\n```\nspark.yarn.archive hdfs://master:9000/user/btadmin/.sparkStaging/application_1483167145424_0004/__spark_libs__8967711398799981387.zip\n```\n\n#### 5.Could not find or load main class org.apache.spark.deploy.yarn.ExecutorLauncher\n\nspark-defaults.conf的参数spark.yarn.jars配置错了， 参考:\nhttp://blog.csdn.net/dax1n/article/details/53001884\n\n需要将以下配置项(假设jar库都放在了hdfs)\n> spark.yarn.jars hdfs://your.hdfs.host:port/sparkjars/\n\n修改为\n> spark.yarn.jars hdfs://your.hdfs.hos:port/sparkjars/*\n\n#### 6.java.nio.channels.ClosedChannelException\n\n具体错误日志:\n```\njava.nio.channels.ClosedChannelException\n    at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source)\n```\n\n参考博客: http://www.bijishequ.com/detail/203655?p=58<br>\n目测是给节点分配的内存太小, yarn直接kill了task。\n\n解决方案：\n\n修改yarn-site.xml，添加下列property\n```\n<property>\n    <name>yarn.nodemanager.pmem-check-enabled</name>\n    <value>false</value>\n</property>\n\n<property>\n    <name>yarn.nodemanager.vmem-check-enabled</name>\n    <value>false</value>\n</property>\n```\n\n#### 7.提交spark作业时, 一直卡在yarn.Client: Application report for application_xxx (state: ACCEPTED)\n\n具体错误日志:\n```\n17/10/13 15:14:49 INFO impl.YarnClientImpl: Application submission is not finished, submitted application application_1507620566574_0010 is still in NEW\n17/10/13 15:14:51 INFO impl.YarnClientImpl: Application submission is not finished, submitted application application_1507620566574_0010 is still in NEW\n17/10/13 15:14:52 INFO impl.YarnClientImpl: Submitted application application_1507620566574_0010\n17/10/13 15:14:53 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:14:53 INFO yarn.Client: \n\t client token: N/A\n\t diagnostics: N/A\n\t ApplicationMaster host: N/A\n\t ApplicationMaster RPC port: -1\n\t queue: default\n\t start time: 1507878873743\n\t final status: UNDEFINED\n\t tracking URL: http://1.downlog-es.10.220.2.233.fs.115cdn.net:8088/proxy/application_1507620566574_0010/\n\t user: hadoop\n17/10/13 15:14:54 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:14:55 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:14:56 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:14:57 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:14:58 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:14:59 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:00 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:01 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:02 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:03 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:04 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:05 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:06 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n17/10/13 15:15:07 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)\n\n```\n\n检查查yarn配置时, 发现\tyarn.resourcemanager.address 的值不正常。\n\n比如节点hostname为: 1.test.10.220.2.233.mycdn.net, 则yarn中参数值为:\n```\n<property>\n    <name>yarn.resourcemanager.address</name>\n    <value>1.1.test.10.220.2.233.mycdn.net:8032</value>\n    <source>programatically</source>\n</property>\n```\n同时在执行stop-dfs.sh时, 发现namenode和datanode的hostname对不上:\n```\nStopping namenodes on [1.1.test.10.220.2.233.mycdn.net]\n1.1.test.10.220.2.233.mycdn.net: stopping namenode\n1.test.10.220.2.233.mycdn.net: stopping datanode\n2.test.10.220.2.234.mycdn.net: stopping datanode\nStopping secondary namenodes [0.0.0.0]\n0.0.0.0: stopping secondarynamenode\n```\n查看/etc/hosts时， 发现多了一个域名映射:\n```\n10.220.2.233 1.1.test.10.220.2.233.mycdn.net 1\n```\n注释掉之后， 重启hadoop集群, spark on yarn任务可以正常执行。\n\n#### 8.java.lang.NoClassDefFoundError: kafka/common/TopicAndPartition\n具体错误日志:\n```\nException in thread \"Thread-3\" java.lang.NoClassDefFoundError: kafka/common/TopicAndPartition\n\tat java.lang.Class.getDeclaredMethods0(Native Method)\n\tat java.lang.Class.privateGetDeclaredMethods(Class.java:2701)\n\tat java.lang.Class.privateGetPublicMethods(Class.java:2902)\n\tat java.lang.Class.getMethods(Class.java:1615)\n\tat py4j.reflection.ReflectionEngine.getMethodsByNameAndLength(ReflectionEngine.java:345)\n\tat py4j.reflection.ReflectionEngine.getMethod(ReflectionEngine.java:305)\n\tat py4j.reflection.ReflectionEngine.getMethod(ReflectionEngine.java:326)\n\tat py4j.Gateway.invoke(Gateway.java:272)\n\tat py4j.commands.AbstractCommand.invokeMethod(AbstractCommand.java:132)\n\tat py4j.commands.CallCommand.execute(CallCommand.java:79)\n\tat py4j.GatewayConnection.run(GatewayConnection.java:214)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.ClassNotFoundException: kafka.common.TopicAndPartition\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 12 more\nERROR:root:Exception while sending command.\nTraceback (most recent call last):\n  File \"/usr/local/spark/python/lib/py4j-0.10.4-src.zip/py4j/java_gateway.py\", line 883, in send_command\n    response = connection.send_command(command)\n  File \"/usr/local/spark/python/lib/py4j-0.10.4-src.zip/py4j/java_gateway.py\", line 1040, in send_command\n    \"Error while receiving\", e, proto.ERROR_ON_RECEIVE)\nPy4JNetworkError: Error while receiving\n```\n原因及解决方法:\n使用的spark-stream-kafka jar包版本不对, spark2.2(python)具体看这里:\nhttps://spark.apache.org/docs/latest/streaming-kafka-integration.html\n\n同时在maven上面下载正确的版本(spark-streaming-kafka-0-8-assembly_2.11):\nhttp://search.maven.org/#search%7Cga%7C1%7Cspark-streaming-kafka\n\n检查jar是否包含该类:\n```\nhadoop@1:/data/test$ jar -tvf spark-streaming-kafka-0-8-assembly_2.11-2.2.0.jar | grep -i Topicandpartition\n  1959 Fri Jun 30 17:08:54 CST 2017 kafka/common/TopicAndPartition$.class\n  6136 Fri Jun 30 17:08:54 CST 2017 kafka/common/TopicAndPartition.class\nhadoop@1:/data/test$ \n```\n\n#### 9.java.io.IOException: There appears to be a gap in the edit log.  We expected txid 1, but got txid 3.\n\n```\nnamenode进程中出现如下报错信息:\njava.io.IOException: There appears to be a gap in the edit log.  We expected txid 1, but got txid 3\n\n原因：namenode元数据被破坏，需要修复\n解决：恢复一下namenode\nhadoop namenode -recover\n一路选择c，一般就OK了\n```\n\n#### 10.java.io.IOException: Incompatible clusterIDs\n\n```\nnamenode和datanode的clusterID不一致，手动修改成一致的即可；\n/xxx/name/current/VERSION -> 拷贝clusterID字段值 -> /xxx/data/current/VERSION\n```\n","slug":"bigdata/hadoop-spark-errors","published":1,"updated":"2018-06-05T06:41:33.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dvc000g4j4d59iwncg7","content":"<h2 id=\"hadoop-spark错误问题总结\"><a href=\"#hadoop-spark错误问题总结\" class=\"headerlink\" title=\"hadoop-spark错误问题总结\"></a>hadoop-spark错误问题总结</h2><h4 id=\"1-Caused-by-java-lang-NoClassDefFoundError-scala-collection-GenTraversableOnce-class\"><a href=\"#1-Caused-by-java-lang-NoClassDefFoundError-scala-collection-GenTraversableOnce-class\" class=\"headerlink\" title=\"1.Caused by: java.lang.NoClassDefFoundError: scala/collection/GenTraversableOnce$class\"></a>1.Caused by: java.lang.NoClassDefFoundError: scala/collection/GenTraversableOnce$class</h4><p>具体错误日志:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">Caused by: java.lang.NoClassDefFoundError: scala/collection/GenTraversableOnce$class</div><div class=\"line\">    at org.elasticsearch.spark.rdd.AbstractEsRDDIterator.&lt;init&gt;(AbstractEsRDDIterator.scala:28)</div><div class=\"line\">    at org.elasticsearch.spark.sql.ScalaEsRowRDDIterator.&lt;init&gt;(ScalaEsRowRDD.scala:49)</div><div class=\"line\">    at org.elasticsearch.spark.sql.ScalaEsRowRDD.compute(ScalaEsRowRDD.scala:45)</div><div class=\"line\">    at org.elasticsearch.spark.sql.ScalaEsRowRDD.compute(ScalaEsRowRDD.scala:38)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)</div><div class=\"line\">    at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)</div><div class=\"line\">    at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)</div><div class=\"line\">    at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)</div><div class=\"line\">    at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:70)</div><div class=\"line\">    at org.apache.spark.scheduler.Task.run(Task.scala:86)</div><div class=\"line\">    at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:274)</div><div class=\"line\">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)</div><div class=\"line\">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)</div><div class=\"line\">    ... 1 more</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>原因分析及解决方法:</p>\n<ul>\n<li>spark所依赖的scala版本与系统安装的scala版本不一致<br><br>  通过检查, 系统安装了scala2.11.1, spark依赖的包为2.11.8; 统一之后， 问题依然存在</li>\n<li>scala2.11.8中并不存在类GenTraversableOnce<br><br>  通过其API Reference可知, 该类是有定义的， 而且spark下关于sparkSQL的example运行测试通过;</li>\n<li>代码自身问题, 调用API方式或配置不当<br><br>原有代码(参照了官方scala示例):<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">conf = SparkConf()</div><div class=\"line\">conf.setMaster(<span class=\"string\">\"spark://192.168.1.181:7077\"</span>).setAppName(<span class=\"string\">\"es_spark\"</span>)</div><div class=\"line\">conf.set(<span class=\"string\">\"es.nodes\"</span>, <span class=\"string\">\"192.168.1.181\"</span>)</div><div class=\"line\">conf.set(<span class=\"string\">\"es.port\"</span>, <span class=\"string\">\"9200\"</span>)</div><div class=\"line\">conf.set(<span class=\"string\">\"es.resource\"</span>, <span class=\"string\">\"web-2016.12.26/web\"</span>)</div><div class=\"line\">sc = SparkContext(conf=conf)</div><div class=\"line\">sqc = SQLContext(sc)</div><div class=\"line\">df = sqc.read.format(<span class=\"string\">\"org.elasticsearch.spark.sql\"</span>  ).load(<span class=\"string\">\"web-2016.12.26/web\"</span>)</div><div class=\"line\">df.printSchema()</div><div class=\"line\"><span class=\"keyword\">print</span> df.first()   <span class=\"comment\"># 这里开始报错</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>改用根据rdd来创建view的方法, 修改后如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">conf = &#123;</div><div class=\"line\">    <span class=\"string\">\"es.nodes\"</span>: <span class=\"string\">\"192.168.1.181\"</span>,</div><div class=\"line\">    <span class=\"string\">\"es.port\"</span>: <span class=\"string\">\"9200\"</span>,</div><div class=\"line\">    <span class=\"string\">\"es.resource\"</span>: <span class=\"string\">\"web-2016.12.26/web\"</span>,</div><div class=\"line\">    <span class=\"string\">\"es.read.field.include\"</span>: <span class=\"string\">\"city,uri,unique\"</span>,</div><div class=\"line\">&#125;</div><div class=\"line\">query = <span class=\"string\">'''&#123;</span></div><div class=\"line\">      \"query\": &#123;</div><div class=\"line\">        \"match\": &#123;\"city\":\"Guangzhou\"&#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;'''</div><div class=\"line\">conf[<span class=\"string\">'es.query'</span>] = query</div><div class=\"line\">rdd = sc.newAPIHadoopRDD(</div><div class=\"line\">    <span class=\"string\">\"org.elasticsearch.hadoop.mr.EsInputFormat\"</span>,</div><div class=\"line\">    <span class=\"string\">\"org.apache.hadoop.io.NullWritable\"</span>,</div><div class=\"line\">    <span class=\"string\">\"org.elasticsearch.hadoop.mr.LinkedMapWritable\"</span>,</div><div class=\"line\">    conf=es_conf).map(<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>])</div><div class=\"line\">schemaUsers = ss.createDataFrame(rdd)</div><div class=\"line\">schemaUsers.createOrReplaceTempView(<span class=\"string\">\"users\"</span>)</div><div class=\"line\">res = ss.sql(<span class=\"string\">\"select uri from users\"</span>)</div><div class=\"line\"><span class=\"keyword\">print</span> (res.first())</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-NativeCodeLoader-Unable-to-load-native-hadoop-library-for-your-platform\"><a href=\"#2-NativeCodeLoader-Unable-to-load-native-hadoop-library-for-your-platform\" class=\"headerlink\" title=\"2. NativeCodeLoader: Unable to load native-hadoop library for your platform\"></a>2. NativeCodeLoader: Unable to load native-hadoop library for your platform</h4><p>原因分析及解决方法:</p>\n<blockquote>\n<p>主要是jre目录下缺少了libhadoop.so和libsnappy.so两个文件。具体是，spark-shell依赖的是scala，scala依赖的是JAVA_HOME下的jdk，libhadoop.so和libsnappy.so两个文件应该放到$JAVA_HOME/jre/lib/amd64下面。<br>这两个so：libhadoop.so和libsnappy.so。前一个so可以在HADOOP_HOME下找到，如hadoop\\lib\\native。第二个libsnappy.so需要下载一个snappy-1.1.0.tar.gz，然后./configure，make编译出来，编译成功之后在.libs文件夹下。<br>当这两个文件准备好后再次启动spark shell不会出现这个问题.<br>参考自: <a href=\"https://www.zhihu.com/question/23974067/answer/26267153\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/23974067/answer/26267153</a></p>\n</blockquote>\n<h4 id=\"3-Initial-job-has-not-accepted-any-resources-check-your-cluster-UI-to-ensure-that-workers-are-registered-and-have-sufficient-memory\"><a href=\"#3-Initial-job-has-not-accepted-any-resources-check-your-cluster-UI-to-ensure-that-workers-are-registered-and-have-sufficient-memory\" class=\"headerlink\" title=\"3. Initial job has not accepted any resources; check your cluster UI to ensure that workers are registered and have sufficient memory\"></a>3. Initial job has not accepted any resources; check your cluster UI to ensure that workers are registered and have sufficient memory</h4><p>原因分析及解决方法:<br><br>默认情况下spark.cores.max是不限制的， 运行第一个spark application时， 会分配所有的cpu来执行任务；<br><br>因此第二个application很可能就得不到足够的资源了。假设每个任务最多获取一半的cpu资源， 假设总共节点的core为8, 我们可以设置为spark.cores.max=4。</p>\n<h4 id=\"4-NoSuchMethodError-org-apache-hadoop-http-HttpConfig-isSecure-Z\"><a href=\"#4-NoSuchMethodError-org-apache-hadoop-http-HttpConfig-isSecure-Z\" class=\"headerlink\" title=\"4. NoSuchMethodError: org.apache.hadoop.http.HttpConfig.isSecure()Z\"></a>4. NoSuchMethodError: org.apache.hadoop.http.HttpConfig.isSecure()Z</h4><p>具体错误日志:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">btadmin@master:/usr/local/spark/$ bin/spark-submit --class org.apache.spark.examples.JavaSparkPi --master yarn --deploy-mode client examples/jars/spark-examples_2.11-2.0.2.jar</div><div class=\"line\">16/12/30 10:00:06 WARN Utils: Your hostname, node1 resolves to a loopback address: 127.0.1.1; using 192.168.1.191 instead (on interface eth0)</div><div class=\"line\">16/12/30 10:00:07 WARN Utils: Set SPARK_LOCAL_IP if you need to bind to another address</div><div class=\"line\">Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: org.apache.hadoop.http.HttpConfig.isSecure()Z</div><div class=\"line\"> at org.apache.hadoop.yarn.webapp.util.WebAppUtils.getResolvedRMWebAppURLWithoutScheme(WebAppUtils.java:101)</div><div class=\"line\"> at org.apache.hadoop.yarn.webapp.util.WebAppUtils.getProxyHostAndPort(WebAppUtils.java:90)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.YarnRMClient.getAmIpFilterParams(YarnRMClient.scala:115)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ApplicationMaster.addAmIpFilter(ApplicationMaster.scala:582)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ApplicationMaster.runExecutorLauncher(ApplicationMaster.scala:406)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ApplicationMaster.run(ApplicationMaster.scala:247)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ApplicationMaster$$anonfun$main$1.apply$mcV$sp(ApplicationMaster.scala:749)</div><div class=\"line\"> at org.apache.spark.deploy.SparkHadoopUtil$$anon$1.run(SparkHadoopUtil.scala:71)</div><div class=\"line\"> at org.apache.spark.deploy.SparkHadoopUtil$$anon$1.run(SparkHadoopUtil.scala:70)</div><div class=\"line\"> at java.security.AccessController.doPrivileged(Native Method)</div><div class=\"line\"> at javax.security.auth.Subject.doAs(Subject.java:415)</div><div class=\"line\"> at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1698)</div><div class=\"line\"> at org.apache.spark.deploy.SparkHadoopUtil.runAsSparkUser(SparkHadoopUtil.scala:70)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ApplicationMaster$.main(ApplicationMaster.scala:747)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ExecutorLauncher$.main(ApplicationMaster.scala:774)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ExecutorLauncher.main(ApplicationMaster.scala)</div></pre></td></tr></table></figure></p>\n<p>原因分析及解决方法:<br>spark中部分jar文件与hadoop的不兼容, 当前spark-defaults.conf中设置:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">spark.yarn.jars hdfs:///sparkjars/*   # jar文件从$&#123;SPARK_HOME&#125;/jars/中已上传到hdfs</div></pre></td></tr></table></figure></p>\n<p>使用另一种方法代替jar库引用:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">spark.yarn.archive hdfs://master:9000/user/btadmin/.sparkStaging/application_1483167145424_0004/__spark_libs__8967711398799981387.zip</div></pre></td></tr></table></figure></p>\n<h4 id=\"5-Could-not-find-or-load-main-class-org-apache-spark-deploy-yarn-ExecutorLauncher\"><a href=\"#5-Could-not-find-or-load-main-class-org-apache-spark-deploy-yarn-ExecutorLauncher\" class=\"headerlink\" title=\"5.Could not find or load main class org.apache.spark.deploy.yarn.ExecutorLauncher\"></a>5.Could not find or load main class org.apache.spark.deploy.yarn.ExecutorLauncher</h4><p>spark-defaults.conf的参数spark.yarn.jars配置错了， 参考:<br><a href=\"http://blog.csdn.net/dax1n/article/details/53001884\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/dax1n/article/details/53001884</a></p>\n<p>需要将以下配置项(假设jar库都放在了hdfs)</p>\n<blockquote>\n<p>spark.yarn.jars hdfs://your.hdfs.host:port/sparkjars/</p>\n</blockquote>\n<p>修改为</p>\n<blockquote>\n<p>spark.yarn.jars hdfs://your.hdfs.hos:port/sparkjars/*</p>\n</blockquote>\n<h4 id=\"6-java-nio-channels-ClosedChannelException\"><a href=\"#6-java-nio-channels-ClosedChannelException\" class=\"headerlink\" title=\"6.java.nio.channels.ClosedChannelException\"></a>6.java.nio.channels.ClosedChannelException</h4><p>具体错误日志:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.channels.ClosedChannelException</div><div class=\"line\">    at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source)</div></pre></td></tr></table></figure></p>\n<p>参考博客: <a href=\"http://www.bijishequ.com/detail/203655?p=58\" target=\"_blank\" rel=\"external\">http://www.bijishequ.com/detail/203655?p=58</a><br><br>目测是给节点分配的内存太小, yarn直接kill了task。</p>\n<p>解决方案：</p>\n<p>修改yarn-site.xml，添加下列property<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;false&lt;/value&gt;</div><div class=\"line\">&lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;false&lt;/value&gt;</div><div class=\"line\">&lt;/property&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"7-提交spark作业时-一直卡在yarn-Client-Application-report-for-application-xxx-state-ACCEPTED\"><a href=\"#7-提交spark作业时-一直卡在yarn-Client-Application-report-for-application-xxx-state-ACCEPTED\" class=\"headerlink\" title=\"7.提交spark作业时, 一直卡在yarn.Client: Application report for application_xxx (state: ACCEPTED)\"></a>7.提交spark作业时, 一直卡在yarn.Client: Application report for application_xxx (state: ACCEPTED)</h4><p>具体错误日志:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">17/10/13 15:14:49 INFO impl.YarnClientImpl: Application submission is not finished, submitted application application_1507620566574_0010 is still in NEW</div><div class=\"line\">17/10/13 15:14:51 INFO impl.YarnClientImpl: Application submission is not finished, submitted application application_1507620566574_0010 is still in NEW</div><div class=\"line\">17/10/13 15:14:52 INFO impl.YarnClientImpl: Submitted application application_1507620566574_0010</div><div class=\"line\">17/10/13 15:14:53 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:14:53 INFO yarn.Client: </div><div class=\"line\">\t client token: N/A</div><div class=\"line\">\t diagnostics: N/A</div><div class=\"line\">\t ApplicationMaster host: N/A</div><div class=\"line\">\t ApplicationMaster RPC port: -1</div><div class=\"line\">\t queue: default</div><div class=\"line\">\t start time: 1507878873743</div><div class=\"line\">\t final status: UNDEFINED</div><div class=\"line\">\t tracking URL: http://1.downlog-es.10.220.2.233.fs.115cdn.net:8088/proxy/application_1507620566574_0010/</div><div class=\"line\">\t user: hadoop</div><div class=\"line\">17/10/13 15:14:54 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:14:55 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:14:56 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:14:57 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:14:58 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:14:59 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:00 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:01 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:02 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:03 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:04 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:05 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:06 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:07 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div></pre></td></tr></table></figure></p>\n<p>检查查yarn配置时, 发现    yarn.resourcemanager.address 的值不正常。</p>\n<p>比如节点hostname为: 1.test.10.220.2.233.mycdn.net, 则yarn中参数值为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;1.1.test.10.220.2.233.mycdn.net:8032&lt;/value&gt;</div><div class=\"line\">    &lt;source&gt;programatically&lt;/source&gt;</div><div class=\"line\">&lt;/property&gt;</div></pre></td></tr></table></figure></p>\n<p>同时在执行stop-dfs.sh时, 发现namenode和datanode的hostname对不上:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Stopping namenodes on [1.1.test.10.220.2.233.mycdn.net]</div><div class=\"line\">1.1.test.10.220.2.233.mycdn.net: stopping namenode</div><div class=\"line\">1.test.10.220.2.233.mycdn.net: stopping datanode</div><div class=\"line\">2.test.10.220.2.234.mycdn.net: stopping datanode</div><div class=\"line\">Stopping secondary namenodes [0.0.0.0]</div><div class=\"line\">0.0.0.0: stopping secondarynamenode</div></pre></td></tr></table></figure></p>\n<p>查看/etc/hosts时， 发现多了一个域名映射:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">10.220.2.233 1.1.test.10.220.2.233.mycdn.net 1</div></pre></td></tr></table></figure></p>\n<p>注释掉之后， 重启hadoop集群, spark on yarn任务可以正常执行。</p>\n<h4 id=\"8-java-lang-NoClassDefFoundError-kafka-common-TopicAndPartition\"><a href=\"#8-java-lang-NoClassDefFoundError-kafka-common-TopicAndPartition\" class=\"headerlink\" title=\"8.java.lang.NoClassDefFoundError: kafka/common/TopicAndPartition\"></a>8.java.lang.NoClassDefFoundError: kafka/common/TopicAndPartition</h4><p>具体错误日志:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">Exception in thread &quot;Thread-3&quot; java.lang.NoClassDefFoundError: kafka/common/TopicAndPartition</div><div class=\"line\">\tat java.lang.Class.getDeclaredMethods0(Native Method)</div><div class=\"line\">\tat java.lang.Class.privateGetDeclaredMethods(Class.java:2701)</div><div class=\"line\">\tat java.lang.Class.privateGetPublicMethods(Class.java:2902)</div><div class=\"line\">\tat java.lang.Class.getMethods(Class.java:1615)</div><div class=\"line\">\tat py4j.reflection.ReflectionEngine.getMethodsByNameAndLength(ReflectionEngine.java:345)</div><div class=\"line\">\tat py4j.reflection.ReflectionEngine.getMethod(ReflectionEngine.java:305)</div><div class=\"line\">\tat py4j.reflection.ReflectionEngine.getMethod(ReflectionEngine.java:326)</div><div class=\"line\">\tat py4j.Gateway.invoke(Gateway.java:272)</div><div class=\"line\">\tat py4j.commands.AbstractCommand.invokeMethod(AbstractCommand.java:132)</div><div class=\"line\">\tat py4j.commands.CallCommand.execute(CallCommand.java:79)</div><div class=\"line\">\tat py4j.GatewayConnection.run(GatewayConnection.java:214)</div><div class=\"line\">\tat java.lang.Thread.run(Thread.java:745)</div><div class=\"line\">Caused by: java.lang.ClassNotFoundException: kafka.common.TopicAndPartition</div><div class=\"line\">\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)</div><div class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)</div><div class=\"line\">\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)</div><div class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)</div><div class=\"line\">\t... 12 more</div><div class=\"line\">ERROR:root:Exception while sending command.</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File &quot;/usr/local/spark/python/lib/py4j-0.10.4-src.zip/py4j/java_gateway.py&quot;, line 883, in send_command</div><div class=\"line\">    response = connection.send_command(command)</div><div class=\"line\">  File &quot;/usr/local/spark/python/lib/py4j-0.10.4-src.zip/py4j/java_gateway.py&quot;, line 1040, in send_command</div><div class=\"line\">    &quot;Error while receiving&quot;, e, proto.ERROR_ON_RECEIVE)</div><div class=\"line\">Py4JNetworkError: Error while receiving</div></pre></td></tr></table></figure></p>\n<p>原因及解决方法:<br>使用的spark-stream-kafka jar包版本不对, spark2.2(python)具体看这里:<br><a href=\"https://spark.apache.org/docs/latest/streaming-kafka-integration.html\" target=\"_blank\" rel=\"external\">https://spark.apache.org/docs/latest/streaming-kafka-integration.html</a></p>\n<p>同时在maven上面下载正确的版本(spark-streaming-kafka-0-8-assembly_2.11):<br><a href=\"http://search.maven.org/#search%7Cga%7C1%7Cspark-streaming-kafka\" target=\"_blank\" rel=\"external\">http://search.maven.org/#search%7Cga%7C1%7Cspark-streaming-kafka</a></p>\n<p>检查jar是否包含该类:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/data/test$ jar -tvf spark-streaming-kafka-0-8-assembly_2.11-2.2.0.jar | grep -i Topicandpartition</div><div class=\"line\">  1959 Fri Jun 30 17:08:54 CST 2017 kafka/common/TopicAndPartition$.class</div><div class=\"line\">  6136 Fri Jun 30 17:08:54 CST 2017 kafka/common/TopicAndPartition.class</div><div class=\"line\">hadoop@1:/data/test$</div></pre></td></tr></table></figure></p>\n<h4 id=\"9-java-io-IOException-There-appears-to-be-a-gap-in-the-edit-log-We-expected-txid-1-but-got-txid-3\"><a href=\"#9-java-io-IOException-There-appears-to-be-a-gap-in-the-edit-log-We-expected-txid-1-but-got-txid-3\" class=\"headerlink\" title=\"9.java.io.IOException: There appears to be a gap in the edit log.  We expected txid 1, but got txid 3.\"></a>9.java.io.IOException: There appears to be a gap in the edit log.  We expected txid 1, but got txid 3.</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">namenode进程中出现如下报错信息:</div><div class=\"line\">java.io.IOException: There appears to be a gap in the edit log.  We expected txid 1, but got txid 3</div><div class=\"line\"></div><div class=\"line\">原因：namenode元数据被破坏，需要修复</div><div class=\"line\">解决：恢复一下namenode</div><div class=\"line\">hadoop namenode -recover</div><div class=\"line\">一路选择c，一般就OK了</div></pre></td></tr></table></figure>\n<h4 id=\"10-java-io-IOException-Incompatible-clusterIDs\"><a href=\"#10-java-io-IOException-Incompatible-clusterIDs\" class=\"headerlink\" title=\"10.java.io.IOException: Incompatible clusterIDs\"></a>10.java.io.IOException: Incompatible clusterIDs</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">namenode和datanode的clusterID不一致，手动修改成一致的即可；</div><div class=\"line\">/xxx/name/current/VERSION -&gt; 拷贝clusterID字段值 -&gt; /xxx/data/current/VERSION</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"hadoop-spark错误问题总结\"><a href=\"#hadoop-spark错误问题总结\" class=\"headerlink\" title=\"hadoop-spark错误问题总结\"></a>hadoop-spark错误问题总结</h2><h4 id=\"1-Caused-by-java-lang-NoClassDefFoundError-scala-collection-GenTraversableOnce-class\"><a href=\"#1-Caused-by-java-lang-NoClassDefFoundError-scala-collection-GenTraversableOnce-class\" class=\"headerlink\" title=\"1.Caused by: java.lang.NoClassDefFoundError: scala/collection/GenTraversableOnce$class\"></a>1.Caused by: java.lang.NoClassDefFoundError: scala/collection/GenTraversableOnce$class</h4><p>具体错误日志:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">Caused by: java.lang.NoClassDefFoundError: scala/collection/GenTraversableOnce$class</div><div class=\"line\">    at org.elasticsearch.spark.rdd.AbstractEsRDDIterator.&lt;init&gt;(AbstractEsRDDIterator.scala:28)</div><div class=\"line\">    at org.elasticsearch.spark.sql.ScalaEsRowRDDIterator.&lt;init&gt;(ScalaEsRowRDD.scala:49)</div><div class=\"line\">    at org.elasticsearch.spark.sql.ScalaEsRowRDD.compute(ScalaEsRowRDD.scala:45)</div><div class=\"line\">    at org.elasticsearch.spark.sql.ScalaEsRowRDD.compute(ScalaEsRowRDD.scala:38)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)</div><div class=\"line\">    at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)</div><div class=\"line\">    at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)</div><div class=\"line\">    at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:319)</div><div class=\"line\">    at org.apache.spark.rdd.RDD.iterator(RDD.scala:283)</div><div class=\"line\">    at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:70)</div><div class=\"line\">    at org.apache.spark.scheduler.Task.run(Task.scala:86)</div><div class=\"line\">    at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:274)</div><div class=\"line\">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)</div><div class=\"line\">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)</div><div class=\"line\">    ... 1 more</div></pre></td></tr></table></figure></p>","more":"<p>原因分析及解决方法:</p>\n<ul>\n<li>spark所依赖的scala版本与系统安装的scala版本不一致<br><br>  通过检查, 系统安装了scala2.11.1, spark依赖的包为2.11.8; 统一之后， 问题依然存在</li>\n<li>scala2.11.8中并不存在类GenTraversableOnce<br><br>  通过其API Reference可知, 该类是有定义的， 而且spark下关于sparkSQL的example运行测试通过;</li>\n<li>代码自身问题, 调用API方式或配置不当<br><br>原有代码(参照了官方scala示例):<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">conf = SparkConf()</div><div class=\"line\">conf.setMaster(<span class=\"string\">\"spark://192.168.1.181:7077\"</span>).setAppName(<span class=\"string\">\"es_spark\"</span>)</div><div class=\"line\">conf.set(<span class=\"string\">\"es.nodes\"</span>, <span class=\"string\">\"192.168.1.181\"</span>)</div><div class=\"line\">conf.set(<span class=\"string\">\"es.port\"</span>, <span class=\"string\">\"9200\"</span>)</div><div class=\"line\">conf.set(<span class=\"string\">\"es.resource\"</span>, <span class=\"string\">\"web-2016.12.26/web\"</span>)</div><div class=\"line\">sc = SparkContext(conf=conf)</div><div class=\"line\">sqc = SQLContext(sc)</div><div class=\"line\">df = sqc.read.format(<span class=\"string\">\"org.elasticsearch.spark.sql\"</span>  ).load(<span class=\"string\">\"web-2016.12.26/web\"</span>)</div><div class=\"line\">df.printSchema()</div><div class=\"line\"><span class=\"keyword\">print</span> df.first()   <span class=\"comment\"># 这里开始报错</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>改用根据rdd来创建view的方法, 修改后如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">conf = &#123;</div><div class=\"line\">    <span class=\"string\">\"es.nodes\"</span>: <span class=\"string\">\"192.168.1.181\"</span>,</div><div class=\"line\">    <span class=\"string\">\"es.port\"</span>: <span class=\"string\">\"9200\"</span>,</div><div class=\"line\">    <span class=\"string\">\"es.resource\"</span>: <span class=\"string\">\"web-2016.12.26/web\"</span>,</div><div class=\"line\">    <span class=\"string\">\"es.read.field.include\"</span>: <span class=\"string\">\"city,uri,unique\"</span>,</div><div class=\"line\">&#125;</div><div class=\"line\">query = <span class=\"string\">'''&#123;</span></div><div class=\"line\">      \"query\": &#123;</div><div class=\"line\">        \"match\": &#123;\"city\":\"Guangzhou\"&#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;'''</div><div class=\"line\">conf[<span class=\"string\">'es.query'</span>] = query</div><div class=\"line\">rdd = sc.newAPIHadoopRDD(</div><div class=\"line\">    <span class=\"string\">\"org.elasticsearch.hadoop.mr.EsInputFormat\"</span>,</div><div class=\"line\">    <span class=\"string\">\"org.apache.hadoop.io.NullWritable\"</span>,</div><div class=\"line\">    <span class=\"string\">\"org.elasticsearch.hadoop.mr.LinkedMapWritable\"</span>,</div><div class=\"line\">    conf=es_conf).map(<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>])</div><div class=\"line\">schemaUsers = ss.createDataFrame(rdd)</div><div class=\"line\">schemaUsers.createOrReplaceTempView(<span class=\"string\">\"users\"</span>)</div><div class=\"line\">res = ss.sql(<span class=\"string\">\"select uri from users\"</span>)</div><div class=\"line\"><span class=\"keyword\">print</span> (res.first())</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-NativeCodeLoader-Unable-to-load-native-hadoop-library-for-your-platform\"><a href=\"#2-NativeCodeLoader-Unable-to-load-native-hadoop-library-for-your-platform\" class=\"headerlink\" title=\"2. NativeCodeLoader: Unable to load native-hadoop library for your platform\"></a>2. NativeCodeLoader: Unable to load native-hadoop library for your platform</h4><p>原因分析及解决方法:</p>\n<blockquote>\n<p>主要是jre目录下缺少了libhadoop.so和libsnappy.so两个文件。具体是，spark-shell依赖的是scala，scala依赖的是JAVA_HOME下的jdk，libhadoop.so和libsnappy.so两个文件应该放到$JAVA_HOME/jre/lib/amd64下面。<br>这两个so：libhadoop.so和libsnappy.so。前一个so可以在HADOOP_HOME下找到，如hadoop\\lib\\native。第二个libsnappy.so需要下载一个snappy-1.1.0.tar.gz，然后./configure，make编译出来，编译成功之后在.libs文件夹下。<br>当这两个文件准备好后再次启动spark shell不会出现这个问题.<br>参考自: <a href=\"https://www.zhihu.com/question/23974067/answer/26267153\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/23974067/answer/26267153</a></p>\n</blockquote>\n<h4 id=\"3-Initial-job-has-not-accepted-any-resources-check-your-cluster-UI-to-ensure-that-workers-are-registered-and-have-sufficient-memory\"><a href=\"#3-Initial-job-has-not-accepted-any-resources-check-your-cluster-UI-to-ensure-that-workers-are-registered-and-have-sufficient-memory\" class=\"headerlink\" title=\"3. Initial job has not accepted any resources; check your cluster UI to ensure that workers are registered and have sufficient memory\"></a>3. Initial job has not accepted any resources; check your cluster UI to ensure that workers are registered and have sufficient memory</h4><p>原因分析及解决方法:<br><br>默认情况下spark.cores.max是不限制的， 运行第一个spark application时， 会分配所有的cpu来执行任务；<br><br>因此第二个application很可能就得不到足够的资源了。假设每个任务最多获取一半的cpu资源， 假设总共节点的core为8, 我们可以设置为spark.cores.max=4。</p>\n<h4 id=\"4-NoSuchMethodError-org-apache-hadoop-http-HttpConfig-isSecure-Z\"><a href=\"#4-NoSuchMethodError-org-apache-hadoop-http-HttpConfig-isSecure-Z\" class=\"headerlink\" title=\"4. NoSuchMethodError: org.apache.hadoop.http.HttpConfig.isSecure()Z\"></a>4. NoSuchMethodError: org.apache.hadoop.http.HttpConfig.isSecure()Z</h4><p>具体错误日志:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">btadmin@master:/usr/local/spark/$ bin/spark-submit --class org.apache.spark.examples.JavaSparkPi --master yarn --deploy-mode client examples/jars/spark-examples_2.11-2.0.2.jar</div><div class=\"line\">16/12/30 10:00:06 WARN Utils: Your hostname, node1 resolves to a loopback address: 127.0.1.1; using 192.168.1.191 instead (on interface eth0)</div><div class=\"line\">16/12/30 10:00:07 WARN Utils: Set SPARK_LOCAL_IP if you need to bind to another address</div><div class=\"line\">Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: org.apache.hadoop.http.HttpConfig.isSecure()Z</div><div class=\"line\"> at org.apache.hadoop.yarn.webapp.util.WebAppUtils.getResolvedRMWebAppURLWithoutScheme(WebAppUtils.java:101)</div><div class=\"line\"> at org.apache.hadoop.yarn.webapp.util.WebAppUtils.getProxyHostAndPort(WebAppUtils.java:90)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.YarnRMClient.getAmIpFilterParams(YarnRMClient.scala:115)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ApplicationMaster.addAmIpFilter(ApplicationMaster.scala:582)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ApplicationMaster.runExecutorLauncher(ApplicationMaster.scala:406)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ApplicationMaster.run(ApplicationMaster.scala:247)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ApplicationMaster$$anonfun$main$1.apply$mcV$sp(ApplicationMaster.scala:749)</div><div class=\"line\"> at org.apache.spark.deploy.SparkHadoopUtil$$anon$1.run(SparkHadoopUtil.scala:71)</div><div class=\"line\"> at org.apache.spark.deploy.SparkHadoopUtil$$anon$1.run(SparkHadoopUtil.scala:70)</div><div class=\"line\"> at java.security.AccessController.doPrivileged(Native Method)</div><div class=\"line\"> at javax.security.auth.Subject.doAs(Subject.java:415)</div><div class=\"line\"> at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1698)</div><div class=\"line\"> at org.apache.spark.deploy.SparkHadoopUtil.runAsSparkUser(SparkHadoopUtil.scala:70)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ApplicationMaster$.main(ApplicationMaster.scala:747)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ExecutorLauncher$.main(ApplicationMaster.scala:774)</div><div class=\"line\"> at org.apache.spark.deploy.yarn.ExecutorLauncher.main(ApplicationMaster.scala)</div></pre></td></tr></table></figure></p>\n<p>原因分析及解决方法:<br>spark中部分jar文件与hadoop的不兼容, 当前spark-defaults.conf中设置:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">spark.yarn.jars hdfs:///sparkjars/*   # jar文件从$&#123;SPARK_HOME&#125;/jars/中已上传到hdfs</div></pre></td></tr></table></figure></p>\n<p>使用另一种方法代替jar库引用:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">spark.yarn.archive hdfs://master:9000/user/btadmin/.sparkStaging/application_1483167145424_0004/__spark_libs__8967711398799981387.zip</div></pre></td></tr></table></figure></p>\n<h4 id=\"5-Could-not-find-or-load-main-class-org-apache-spark-deploy-yarn-ExecutorLauncher\"><a href=\"#5-Could-not-find-or-load-main-class-org-apache-spark-deploy-yarn-ExecutorLauncher\" class=\"headerlink\" title=\"5.Could not find or load main class org.apache.spark.deploy.yarn.ExecutorLauncher\"></a>5.Could not find or load main class org.apache.spark.deploy.yarn.ExecutorLauncher</h4><p>spark-defaults.conf的参数spark.yarn.jars配置错了， 参考:<br><a href=\"http://blog.csdn.net/dax1n/article/details/53001884\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/dax1n/article/details/53001884</a></p>\n<p>需要将以下配置项(假设jar库都放在了hdfs)</p>\n<blockquote>\n<p>spark.yarn.jars hdfs://your.hdfs.host:port/sparkjars/</p>\n</blockquote>\n<p>修改为</p>\n<blockquote>\n<p>spark.yarn.jars hdfs://your.hdfs.hos:port/sparkjars/*</p>\n</blockquote>\n<h4 id=\"6-java-nio-channels-ClosedChannelException\"><a href=\"#6-java-nio-channels-ClosedChannelException\" class=\"headerlink\" title=\"6.java.nio.channels.ClosedChannelException\"></a>6.java.nio.channels.ClosedChannelException</h4><p>具体错误日志:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.nio.channels.ClosedChannelException</div><div class=\"line\">    at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source)</div></pre></td></tr></table></figure></p>\n<p>参考博客: <a href=\"http://www.bijishequ.com/detail/203655?p=58\" target=\"_blank\" rel=\"external\">http://www.bijishequ.com/detail/203655?p=58</a><br><br>目测是给节点分配的内存太小, yarn直接kill了task。</p>\n<p>解决方案：</p>\n<p>修改yarn-site.xml，添加下列property<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;false&lt;/value&gt;</div><div class=\"line\">&lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;false&lt;/value&gt;</div><div class=\"line\">&lt;/property&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"7-提交spark作业时-一直卡在yarn-Client-Application-report-for-application-xxx-state-ACCEPTED\"><a href=\"#7-提交spark作业时-一直卡在yarn-Client-Application-report-for-application-xxx-state-ACCEPTED\" class=\"headerlink\" title=\"7.提交spark作业时, 一直卡在yarn.Client: Application report for application_xxx (state: ACCEPTED)\"></a>7.提交spark作业时, 一直卡在yarn.Client: Application report for application_xxx (state: ACCEPTED)</h4><p>具体错误日志:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">17/10/13 15:14:49 INFO impl.YarnClientImpl: Application submission is not finished, submitted application application_1507620566574_0010 is still in NEW</div><div class=\"line\">17/10/13 15:14:51 INFO impl.YarnClientImpl: Application submission is not finished, submitted application application_1507620566574_0010 is still in NEW</div><div class=\"line\">17/10/13 15:14:52 INFO impl.YarnClientImpl: Submitted application application_1507620566574_0010</div><div class=\"line\">17/10/13 15:14:53 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:14:53 INFO yarn.Client: </div><div class=\"line\">\t client token: N/A</div><div class=\"line\">\t diagnostics: N/A</div><div class=\"line\">\t ApplicationMaster host: N/A</div><div class=\"line\">\t ApplicationMaster RPC port: -1</div><div class=\"line\">\t queue: default</div><div class=\"line\">\t start time: 1507878873743</div><div class=\"line\">\t final status: UNDEFINED</div><div class=\"line\">\t tracking URL: http://1.downlog-es.10.220.2.233.fs.115cdn.net:8088/proxy/application_1507620566574_0010/</div><div class=\"line\">\t user: hadoop</div><div class=\"line\">17/10/13 15:14:54 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:14:55 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:14:56 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:14:57 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:14:58 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:14:59 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:00 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:01 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:02 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:03 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:04 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:05 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:06 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div><div class=\"line\">17/10/13 15:15:07 INFO yarn.Client: Application report for application_1507620566574_0010 (state: ACCEPTED)</div></pre></td></tr></table></figure></p>\n<p>检查查yarn配置时, 发现    yarn.resourcemanager.address 的值不正常。</p>\n<p>比如节点hostname为: 1.test.10.220.2.233.mycdn.net, 则yarn中参数值为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;1.1.test.10.220.2.233.mycdn.net:8032&lt;/value&gt;</div><div class=\"line\">    &lt;source&gt;programatically&lt;/source&gt;</div><div class=\"line\">&lt;/property&gt;</div></pre></td></tr></table></figure></p>\n<p>同时在执行stop-dfs.sh时, 发现namenode和datanode的hostname对不上:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Stopping namenodes on [1.1.test.10.220.2.233.mycdn.net]</div><div class=\"line\">1.1.test.10.220.2.233.mycdn.net: stopping namenode</div><div class=\"line\">1.test.10.220.2.233.mycdn.net: stopping datanode</div><div class=\"line\">2.test.10.220.2.234.mycdn.net: stopping datanode</div><div class=\"line\">Stopping secondary namenodes [0.0.0.0]</div><div class=\"line\">0.0.0.0: stopping secondarynamenode</div></pre></td></tr></table></figure></p>\n<p>查看/etc/hosts时， 发现多了一个域名映射:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">10.220.2.233 1.1.test.10.220.2.233.mycdn.net 1</div></pre></td></tr></table></figure></p>\n<p>注释掉之后， 重启hadoop集群, spark on yarn任务可以正常执行。</p>\n<h4 id=\"8-java-lang-NoClassDefFoundError-kafka-common-TopicAndPartition\"><a href=\"#8-java-lang-NoClassDefFoundError-kafka-common-TopicAndPartition\" class=\"headerlink\" title=\"8.java.lang.NoClassDefFoundError: kafka/common/TopicAndPartition\"></a>8.java.lang.NoClassDefFoundError: kafka/common/TopicAndPartition</h4><p>具体错误日志:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">Exception in thread &quot;Thread-3&quot; java.lang.NoClassDefFoundError: kafka/common/TopicAndPartition</div><div class=\"line\">\tat java.lang.Class.getDeclaredMethods0(Native Method)</div><div class=\"line\">\tat java.lang.Class.privateGetDeclaredMethods(Class.java:2701)</div><div class=\"line\">\tat java.lang.Class.privateGetPublicMethods(Class.java:2902)</div><div class=\"line\">\tat java.lang.Class.getMethods(Class.java:1615)</div><div class=\"line\">\tat py4j.reflection.ReflectionEngine.getMethodsByNameAndLength(ReflectionEngine.java:345)</div><div class=\"line\">\tat py4j.reflection.ReflectionEngine.getMethod(ReflectionEngine.java:305)</div><div class=\"line\">\tat py4j.reflection.ReflectionEngine.getMethod(ReflectionEngine.java:326)</div><div class=\"line\">\tat py4j.Gateway.invoke(Gateway.java:272)</div><div class=\"line\">\tat py4j.commands.AbstractCommand.invokeMethod(AbstractCommand.java:132)</div><div class=\"line\">\tat py4j.commands.CallCommand.execute(CallCommand.java:79)</div><div class=\"line\">\tat py4j.GatewayConnection.run(GatewayConnection.java:214)</div><div class=\"line\">\tat java.lang.Thread.run(Thread.java:745)</div><div class=\"line\">Caused by: java.lang.ClassNotFoundException: kafka.common.TopicAndPartition</div><div class=\"line\">\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)</div><div class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)</div><div class=\"line\">\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)</div><div class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)</div><div class=\"line\">\t... 12 more</div><div class=\"line\">ERROR:root:Exception while sending command.</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File &quot;/usr/local/spark/python/lib/py4j-0.10.4-src.zip/py4j/java_gateway.py&quot;, line 883, in send_command</div><div class=\"line\">    response = connection.send_command(command)</div><div class=\"line\">  File &quot;/usr/local/spark/python/lib/py4j-0.10.4-src.zip/py4j/java_gateway.py&quot;, line 1040, in send_command</div><div class=\"line\">    &quot;Error while receiving&quot;, e, proto.ERROR_ON_RECEIVE)</div><div class=\"line\">Py4JNetworkError: Error while receiving</div></pre></td></tr></table></figure></p>\n<p>原因及解决方法:<br>使用的spark-stream-kafka jar包版本不对, spark2.2(python)具体看这里:<br><a href=\"https://spark.apache.org/docs/latest/streaming-kafka-integration.html\" target=\"_blank\" rel=\"external\">https://spark.apache.org/docs/latest/streaming-kafka-integration.html</a></p>\n<p>同时在maven上面下载正确的版本(spark-streaming-kafka-0-8-assembly_2.11):<br><a href=\"http://search.maven.org/#search%7Cga%7C1%7Cspark-streaming-kafka\" target=\"_blank\" rel=\"external\">http://search.maven.org/#search%7Cga%7C1%7Cspark-streaming-kafka</a></p>\n<p>检查jar是否包含该类:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:/data/test$ jar -tvf spark-streaming-kafka-0-8-assembly_2.11-2.2.0.jar | grep -i Topicandpartition</div><div class=\"line\">  1959 Fri Jun 30 17:08:54 CST 2017 kafka/common/TopicAndPartition$.class</div><div class=\"line\">  6136 Fri Jun 30 17:08:54 CST 2017 kafka/common/TopicAndPartition.class</div><div class=\"line\">hadoop@1:/data/test$</div></pre></td></tr></table></figure></p>\n<h4 id=\"9-java-io-IOException-There-appears-to-be-a-gap-in-the-edit-log-We-expected-txid-1-but-got-txid-3\"><a href=\"#9-java-io-IOException-There-appears-to-be-a-gap-in-the-edit-log-We-expected-txid-1-but-got-txid-3\" class=\"headerlink\" title=\"9.java.io.IOException: There appears to be a gap in the edit log.  We expected txid 1, but got txid 3.\"></a>9.java.io.IOException: There appears to be a gap in the edit log.  We expected txid 1, but got txid 3.</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">namenode进程中出现如下报错信息:</div><div class=\"line\">java.io.IOException: There appears to be a gap in the edit log.  We expected txid 1, but got txid 3</div><div class=\"line\"></div><div class=\"line\">原因：namenode元数据被破坏，需要修复</div><div class=\"line\">解决：恢复一下namenode</div><div class=\"line\">hadoop namenode -recover</div><div class=\"line\">一路选择c，一般就OK了</div></pre></td></tr></table></figure>\n<h4 id=\"10-java-io-IOException-Incompatible-clusterIDs\"><a href=\"#10-java-io-IOException-Incompatible-clusterIDs\" class=\"headerlink\" title=\"10.java.io.IOException: Incompatible clusterIDs\"></a>10.java.io.IOException: Incompatible clusterIDs</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">namenode和datanode的clusterID不一致，手动修改成一致的即可；</div><div class=\"line\">/xxx/name/current/VERSION -&gt; 拷贝clusterID字段值 -&gt; /xxx/data/current/VERSION</div></pre></td></tr></table></figure>"},{"title":"关于ionic3升级到ionic4","date":"2019-01-04T00:36:24.000Z","_content":"\n## 参考资料\n\n```\nhttps://moduscreate.com/blog/upgrading-an-ionic-3-application-to-ionic-4/\nhttps://www.joshmorony.com/my-method-for-upgrading-from-ionic-3-to-ionic-4/\nhttps://www.joshmorony.com/the-ionic-4-migration-survival-guide/\n```\n\n## 库导入方面的差异\n\n| ionic3| ionic4 | 备注 |\n| ------ | ------ | ------ |\n| ionic-angular | @ionic/angular |  |\n| import { Observable } from 'rxjs/Observable';| import { Observable } from 'rxjs'; |  |\n| import 'rxjs/add/operator/map';<br>import 'rxjs/add/operator/catch';<br>import 'rxjs/add/operator/do';<br>import 'rxjs/add/operator/finally';<br> |无||\n|import {IonicPage} from \"ionic-angular\";|无|可直接去掉IonicPage|\n|import {IonicPageModule} from \"ionic-angular\";|import { RouterModule } from '@angular/router';|ionic4使用RouterModule管理路由规则|\n|`import { Network } from '@ionic-native/network';`|`import { Network } from '@ionic-native/network/ngx';`||\n|`import { SplashScreen } from \"@ionic-native/splash-screen\";`|`import { SplashScreen } from \"@ionic-native/splash-screen/ngx\";`||\n|import { StatusBar } from '@ionic-native/status-bar';|import { StatusBar } from '@ionic-native/status-bar/ngx';||\n|import { AppMinimize } from '@ionic-native/app-minimize';|import { AppMinimize } from '@ionic-native/app-minimize/ngx';||\n\n\n| echarts3| echarts4 | 备注 |\n| ------ | ------ | ------ |\n|`import ECharts from \"echarts\";`|`import * as ECharts from \"echarts\";`||\n\n## 一些坑\n\n- 关于*router.navigate* 和 *router.navigateByUrl*的区别\n\n```\nhttps://stackoverflow.com/questions/45025334/how-to-use-router-navigatebyurl-and-router-navigate-in-angular\nhttps://angular.io/api/router/Router\n```\n\n- 关于*HttpInterceptor*的使用\n\nionic4中通过`import { HttpClient } from '@angular/common/http';`的请求才会被拦截器拦截；\n\n通过`import { Http } from '@angular/http';`发起的请求不会触发拦截器。\n","source":"_posts/app/关于ionic3升级到ionic4.md","raw":"---\ntitle: 关于ionic3升级到ionic4\ndate: 2019-01-04 08:36:24\ntags: ionic\n---\n\n## 参考资料\n\n```\nhttps://moduscreate.com/blog/upgrading-an-ionic-3-application-to-ionic-4/\nhttps://www.joshmorony.com/my-method-for-upgrading-from-ionic-3-to-ionic-4/\nhttps://www.joshmorony.com/the-ionic-4-migration-survival-guide/\n```\n\n## 库导入方面的差异\n\n| ionic3| ionic4 | 备注 |\n| ------ | ------ | ------ |\n| ionic-angular | @ionic/angular |  |\n| import { Observable } from 'rxjs/Observable';| import { Observable } from 'rxjs'; |  |\n| import 'rxjs/add/operator/map';<br>import 'rxjs/add/operator/catch';<br>import 'rxjs/add/operator/do';<br>import 'rxjs/add/operator/finally';<br> |无||\n|import {IonicPage} from \"ionic-angular\";|无|可直接去掉IonicPage|\n|import {IonicPageModule} from \"ionic-angular\";|import { RouterModule } from '@angular/router';|ionic4使用RouterModule管理路由规则|\n|`import { Network } from '@ionic-native/network';`|`import { Network } from '@ionic-native/network/ngx';`||\n|`import { SplashScreen } from \"@ionic-native/splash-screen\";`|`import { SplashScreen } from \"@ionic-native/splash-screen/ngx\";`||\n|import { StatusBar } from '@ionic-native/status-bar';|import { StatusBar } from '@ionic-native/status-bar/ngx';||\n|import { AppMinimize } from '@ionic-native/app-minimize';|import { AppMinimize } from '@ionic-native/app-minimize/ngx';||\n\n\n| echarts3| echarts4 | 备注 |\n| ------ | ------ | ------ |\n|`import ECharts from \"echarts\";`|`import * as ECharts from \"echarts\";`||\n\n## 一些坑\n\n- 关于*router.navigate* 和 *router.navigateByUrl*的区别\n\n```\nhttps://stackoverflow.com/questions/45025334/how-to-use-router-navigatebyurl-and-router-navigate-in-angular\nhttps://angular.io/api/router/Router\n```\n\n- 关于*HttpInterceptor*的使用\n\nionic4中通过`import { HttpClient } from '@angular/common/http';`的请求才会被拦截器拦截；\n\n通过`import { Http } from '@angular/http';`发起的请求不会触发拦截器。\n","slug":"app/关于ionic3升级到ionic4","published":1,"updated":"2019-01-04T00:38:29.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dvd000j4j4dd584ppbb","content":"<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://moduscreate.com/blog/upgrading-an-ionic-3-application-to-ionic-4/</div><div class=\"line\">https://www.joshmorony.com/my-method-for-upgrading-from-ionic-3-to-ionic-4/</div><div class=\"line\">https://www.joshmorony.com/the-ionic-4-migration-survival-guide/</div></pre></td></tr></table></figure>\n<h2 id=\"库导入方面的差异\"><a href=\"#库导入方面的差异\" class=\"headerlink\" title=\"库导入方面的差异\"></a>库导入方面的差异</h2><table>\n<thead>\n<tr>\n<th>ionic3</th>\n<th>ionic4</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ionic-angular</td>\n<td>@ionic/angular</td>\n<td></td>\n</tr>\n<tr>\n<td>import { Observable } from ‘rxjs/Observable’;</td>\n<td>import { Observable } from ‘rxjs’;</td>\n<td></td>\n</tr>\n<tr>\n<td>import ‘rxjs/add/operator/map’;<br>import ‘rxjs/add/operator/catch’;<br>import ‘rxjs/add/operator/do’;<br>import ‘rxjs/add/operator/finally’;<br></td>\n<td>无</td>\n<td></td>\n</tr>\n<tr>\n<td>import {IonicPage} from “ionic-angular”;</td>\n<td>无</td>\n<td>可直接去掉IonicPage</td>\n</tr>\n<tr>\n<td>import {IonicPageModule} from “ionic-angular”;</td>\n<td>import { RouterModule } from ‘@angular/router’;</td>\n<td>ionic4使用RouterModule管理路由规则</td>\n</tr>\n<tr>\n<td><code>import { Network } from &#39;@ionic-native/network&#39;;</code></td>\n<td><code>import { Network } from &#39;@ionic-native/network/ngx&#39;;</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>import { SplashScreen } from &quot;@ionic-native/splash-screen&quot;;</code></td>\n<td><code>import { SplashScreen } from &quot;@ionic-native/splash-screen/ngx&quot;;</code></td>\n<td></td>\n</tr>\n<tr>\n<td>import { StatusBar } from ‘@ionic-native/status-bar’;</td>\n<td>import { StatusBar } from ‘@ionic-native/status-bar/ngx’;</td>\n<td></td>\n</tr>\n<tr>\n<td>import { AppMinimize } from ‘@ionic-native/app-minimize’;</td>\n<td>import { AppMinimize } from ‘@ionic-native/app-minimize/ngx’;</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>echarts3</th>\n<th>echarts4</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>import ECharts from &quot;echarts&quot;;</code></td>\n<td><code>import * as ECharts from &quot;echarts&quot;;</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"一些坑\"><a href=\"#一些坑\" class=\"headerlink\" title=\"一些坑\"></a>一些坑</h2><ul>\n<li>关于<em>router.navigate</em> 和 <em>router.navigateByUrl</em>的区别</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://stackoverflow.com/questions/45025334/how-to-use-router-navigatebyurl-and-router-navigate-in-angular</div><div class=\"line\">https://angular.io/api/router/Router</div></pre></td></tr></table></figure>\n<ul>\n<li>关于<em>HttpInterceptor</em>的使用</li>\n</ul>\n<p>ionic4中通过<code>import { HttpClient } from &#39;@angular/common/http&#39;;</code>的请求才会被拦截器拦截；</p>\n<p>通过<code>import { Http } from &#39;@angular/http&#39;;</code>发起的请求不会触发拦截器。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://moduscreate.com/blog/upgrading-an-ionic-3-application-to-ionic-4/</div><div class=\"line\">https://www.joshmorony.com/my-method-for-upgrading-from-ionic-3-to-ionic-4/</div><div class=\"line\">https://www.joshmorony.com/the-ionic-4-migration-survival-guide/</div></pre></td></tr></table></figure>\n<h2 id=\"库导入方面的差异\"><a href=\"#库导入方面的差异\" class=\"headerlink\" title=\"库导入方面的差异\"></a>库导入方面的差异</h2><table>\n<thead>\n<tr>\n<th>ionic3</th>\n<th>ionic4</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ionic-angular</td>\n<td>@ionic/angular</td>\n<td></td>\n</tr>\n<tr>\n<td>import { Observable } from ‘rxjs/Observable’;</td>\n<td>import { Observable } from ‘rxjs’;</td>\n<td></td>\n</tr>\n<tr>\n<td>import ‘rxjs/add/operator/map’;<br>import ‘rxjs/add/operator/catch’;<br>import ‘rxjs/add/operator/do’;<br>import ‘rxjs/add/operator/finally’;<br></td>\n<td>无</td>\n<td></td>\n</tr>\n<tr>\n<td>import {IonicPage} from “ionic-angular”;</td>\n<td>无</td>\n<td>可直接去掉IonicPage</td>\n</tr>\n<tr>\n<td>import {IonicPageModule} from “ionic-angular”;</td>\n<td>import { RouterModule } from ‘@angular/router’;</td>\n<td>ionic4使用RouterModule管理路由规则</td>\n</tr>\n<tr>\n<td><code>import { Network } from &#39;@ionic-native/network&#39;;</code></td>\n<td><code>import { Network } from &#39;@ionic-native/network/ngx&#39;;</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>import { SplashScreen } from &quot;@ionic-native/splash-screen&quot;;</code></td>\n<td><code>import { SplashScreen } from &quot;@ionic-native/splash-screen/ngx&quot;;</code></td>\n<td></td>\n</tr>\n<tr>\n<td>import { StatusBar } from ‘@ionic-native/status-bar’;</td>\n<td>import { StatusBar } from ‘@ionic-native/status-bar/ngx’;</td>\n<td></td>\n</tr>\n<tr>\n<td>import { AppMinimize } from ‘@ionic-native/app-minimize’;</td>\n<td>import { AppMinimize } from ‘@ionic-native/app-minimize/ngx’;</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>echarts3</th>\n<th>echarts4</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>import ECharts from &quot;echarts&quot;;</code></td>\n<td><code>import * as ECharts from &quot;echarts&quot;;</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"一些坑\"><a href=\"#一些坑\" class=\"headerlink\" title=\"一些坑\"></a>一些坑</h2><ul>\n<li>关于<em>router.navigate</em> 和 <em>router.navigateByUrl</em>的区别</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://stackoverflow.com/questions/45025334/how-to-use-router-navigatebyurl-and-router-navigate-in-angular</div><div class=\"line\">https://angular.io/api/router/Router</div></pre></td></tr></table></figure>\n<ul>\n<li>关于<em>HttpInterceptor</em>的使用</li>\n</ul>\n<p>ionic4中通过<code>import { HttpClient } from &#39;@angular/common/http&#39;;</code>的请求才会被拦截器拦截；</p>\n<p>通过<code>import { Http } from &#39;@angular/http&#39;;</code>发起的请求不会触发拦截器。</p>\n"},{"title":"CAS单点登录前后端分离","date":"2018-07-31T13:56:20.000Z","_content":"\n## 关于单点登录(SSO)\n\n假设用户X需同时登录站点A和站点B，这两个站点之间其实是有关联性的，但是如果用户认证数据不通用，那将需要注册或登录两次。\n\n单点登录系统就是为了解决这种场景的问题，建立一种用户认证中心，只要经过这个中心注册或登录了某一站点服务的用户，总是能够认证登录这个中心所授权的其他所有服务。\n\n<!--more-->\n\n## 关于CAS(Central Authentication Service)\n\nCAS是一种单点登录开源框架，遵循apache2.0协议，代码托管在github.com/apereo/cas上。\n\nCAS作为一种单点登录框架，后端可配置不同的用户数据库，支持自定义验证或加密逻辑，并提供不同的协议用于与业务server(cas-client)间的通信。\n\nCAS的源码是由java写的，因此对于java的web项目天生友好。当然只要实现CAS相关协议的client，无论是哪种语言实现的，都能集成到CAS认证框架中。\n\n## 关于CAS前后端分离\n\nCAS5.x版默认的注册登录相关UI是以html形式内嵌在CAS-web项目中的，其中结合thymeleaf模板库来渲染html。\n\n我们也可以通过前后端分离的方式来自定义我们的认证UI，我这里采取了spring+vuejs架构进行了测试一下，基本能跑通认证流程，大概过程用一张时序图来说明：\n![图片描述][1]\n\n## 前后端分离所涉及到的restAPI\n\n因为CAS由原来的结构改为了springboot+vuejs, 原有访问CAS页面的url要修改成访问vuejs所构建的前端页面，而这些url则由这些自定义的前端页面代理去访问调用。这些api包括:\n\n+ 通过（用户名|密码|当前service名)获取TGT票据, 如：\n\n```shell\n\ncurl -v -X POST \"https://svr.sso.com/cas/v1/tickets\" -d \"username=testuser&password=testpwd&service=http://xxx/xx\"\n\n```\n\n响应的TGT信息存储在Location中。\n\n+ 通过TGT获取ST，如：\n\n```shell\n// 参数service需要进行urlencode\ncurl -X POST -v \"https://svr.sso.com/cas/v1/tickets/TGT-4-xxxxxxx\" -d \"service=http%3a%2f%2fxxx%3a%2fxx\"\n```\n\n这时直接能从响应结果中得到ST字符串。\n\n+ 通过ST访问service，正常下可完成登录:\n\n```\nhttp://xxx/xx?ticket=ST-3-BGJBL1wWjRw-prwoSYiyQaYzUNkAppledeMacBook-Pro\n```\n\n+ 注销登录(清除TGT)，单点登出，如：\n\n```shell\ncurl -X DELETE -v \"https://svr.sso.com/cas/v1/tickets/TGT-94-xxxxx\"\n```\n\n正常情况下会返回已被清理的TGT字段。\n\n  [1]: //img.mukewang.com/5b6028770001f6f214361182.png\n","source":"_posts/archi/CAS单点登录前后端分离.md","raw":"---\ntitle: CAS单点登录前后端分离\ndate: 2018-07-31 21:56:20\ntags: spring\n---\n\n## 关于单点登录(SSO)\n\n假设用户X需同时登录站点A和站点B，这两个站点之间其实是有关联性的，但是如果用户认证数据不通用，那将需要注册或登录两次。\n\n单点登录系统就是为了解决这种场景的问题，建立一种用户认证中心，只要经过这个中心注册或登录了某一站点服务的用户，总是能够认证登录这个中心所授权的其他所有服务。\n\n<!--more-->\n\n## 关于CAS(Central Authentication Service)\n\nCAS是一种单点登录开源框架，遵循apache2.0协议，代码托管在github.com/apereo/cas上。\n\nCAS作为一种单点登录框架，后端可配置不同的用户数据库，支持自定义验证或加密逻辑，并提供不同的协议用于与业务server(cas-client)间的通信。\n\nCAS的源码是由java写的，因此对于java的web项目天生友好。当然只要实现CAS相关协议的client，无论是哪种语言实现的，都能集成到CAS认证框架中。\n\n## 关于CAS前后端分离\n\nCAS5.x版默认的注册登录相关UI是以html形式内嵌在CAS-web项目中的，其中结合thymeleaf模板库来渲染html。\n\n我们也可以通过前后端分离的方式来自定义我们的认证UI，我这里采取了spring+vuejs架构进行了测试一下，基本能跑通认证流程，大概过程用一张时序图来说明：\n![图片描述][1]\n\n## 前后端分离所涉及到的restAPI\n\n因为CAS由原来的结构改为了springboot+vuejs, 原有访问CAS页面的url要修改成访问vuejs所构建的前端页面，而这些url则由这些自定义的前端页面代理去访问调用。这些api包括:\n\n+ 通过（用户名|密码|当前service名)获取TGT票据, 如：\n\n```shell\n\ncurl -v -X POST \"https://svr.sso.com/cas/v1/tickets\" -d \"username=testuser&password=testpwd&service=http://xxx/xx\"\n\n```\n\n响应的TGT信息存储在Location中。\n\n+ 通过TGT获取ST，如：\n\n```shell\n// 参数service需要进行urlencode\ncurl -X POST -v \"https://svr.sso.com/cas/v1/tickets/TGT-4-xxxxxxx\" -d \"service=http%3a%2f%2fxxx%3a%2fxx\"\n```\n\n这时直接能从响应结果中得到ST字符串。\n\n+ 通过ST访问service，正常下可完成登录:\n\n```\nhttp://xxx/xx?ticket=ST-3-BGJBL1wWjRw-prwoSYiyQaYzUNkAppledeMacBook-Pro\n```\n\n+ 注销登录(清除TGT)，单点登出，如：\n\n```shell\ncurl -X DELETE -v \"https://svr.sso.com/cas/v1/tickets/TGT-94-xxxxx\"\n```\n\n正常情况下会返回已被清理的TGT字段。\n\n  [1]: //img.mukewang.com/5b6028770001f6f214361182.png\n","slug":"archi/CAS单点登录前后端分离","published":1,"updated":"2018-07-31T15:03:45.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dvq000l4j4dju02hmj8","content":"<h2 id=\"关于单点登录-SSO\"><a href=\"#关于单点登录-SSO\" class=\"headerlink\" title=\"关于单点登录(SSO)\"></a>关于单点登录(SSO)</h2><p>假设用户X需同时登录站点A和站点B，这两个站点之间其实是有关联性的，但是如果用户认证数据不通用，那将需要注册或登录两次。</p>\n<p>单点登录系统就是为了解决这种场景的问题，建立一种用户认证中心，只要经过这个中心注册或登录了某一站点服务的用户，总是能够认证登录这个中心所授权的其他所有服务。</p>\n<a id=\"more\"></a>\n<h2 id=\"关于CAS-Central-Authentication-Service\"><a href=\"#关于CAS-Central-Authentication-Service\" class=\"headerlink\" title=\"关于CAS(Central Authentication Service)\"></a>关于CAS(Central Authentication Service)</h2><p>CAS是一种单点登录开源框架，遵循apache2.0协议，代码托管在github.com/apereo/cas上。</p>\n<p>CAS作为一种单点登录框架，后端可配置不同的用户数据库，支持自定义验证或加密逻辑，并提供不同的协议用于与业务server(cas-client)间的通信。</p>\n<p>CAS的源码是由java写的，因此对于java的web项目天生友好。当然只要实现CAS相关协议的client，无论是哪种语言实现的，都能集成到CAS认证框架中。</p>\n<h2 id=\"关于CAS前后端分离\"><a href=\"#关于CAS前后端分离\" class=\"headerlink\" title=\"关于CAS前后端分离\"></a>关于CAS前后端分离</h2><p>CAS5.x版默认的注册登录相关UI是以html形式内嵌在CAS-web项目中的，其中结合thymeleaf模板库来渲染html。</p>\n<p>我们也可以通过前后端分离的方式来自定义我们的认证UI，我这里采取了spring+vuejs架构进行了测试一下，基本能跑通认证流程，大概过程用一张时序图来说明：<br><img src=\"//img.mukewang.com/5b6028770001f6f214361182.png\" alt=\"图片描述\"></p>\n<h2 id=\"前后端分离所涉及到的restAPI\"><a href=\"#前后端分离所涉及到的restAPI\" class=\"headerlink\" title=\"前后端分离所涉及到的restAPI\"></a>前后端分离所涉及到的restAPI</h2><p>因为CAS由原来的结构改为了springboot+vuejs, 原有访问CAS页面的url要修改成访问vuejs所构建的前端页面，而这些url则由这些自定义的前端页面代理去访问调用。这些api包括:</p>\n<ul>\n<li>通过（用户名|密码|当前service名)获取TGT票据, 如：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">curl -v -X POST \"https://svr.sso.com/cas/v1/tickets\" -d \"username=testuser&amp;password=testpwd&amp;service=http://xxx/xx\"</div></pre></td></tr></table></figure>\n<p>响应的TGT信息存储在Location中。</p>\n<ul>\n<li>通过TGT获取ST，如：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 参数service需要进行urlencode</div><div class=\"line\">curl -X POST -v \"https://svr.sso.com/cas/v1/tickets/TGT-4-xxxxxxx\" -d \"service=http%3a%2f%2fxxx%3a%2fxx\"</div></pre></td></tr></table></figure>\n<p>这时直接能从响应结果中得到ST字符串。</p>\n<ul>\n<li>通过ST访问service，正常下可完成登录:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://xxx/xx?ticket=ST-3-BGJBL1wWjRw-prwoSYiyQaYzUNkAppledeMacBook-Pro</div></pre></td></tr></table></figure>\n<ul>\n<li>注销登录(清除TGT)，单点登出，如：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -X DELETE -v \"https://svr.sso.com/cas/v1/tickets/TGT-94-xxxxx\"</div></pre></td></tr></table></figure>\n<p>正常情况下会返回已被清理的TGT字段。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"关于单点登录-SSO\"><a href=\"#关于单点登录-SSO\" class=\"headerlink\" title=\"关于单点登录(SSO)\"></a>关于单点登录(SSO)</h2><p>假设用户X需同时登录站点A和站点B，这两个站点之间其实是有关联性的，但是如果用户认证数据不通用，那将需要注册或登录两次。</p>\n<p>单点登录系统就是为了解决这种场景的问题，建立一种用户认证中心，只要经过这个中心注册或登录了某一站点服务的用户，总是能够认证登录这个中心所授权的其他所有服务。</p>","more":"<h2 id=\"关于CAS-Central-Authentication-Service\"><a href=\"#关于CAS-Central-Authentication-Service\" class=\"headerlink\" title=\"关于CAS(Central Authentication Service)\"></a>关于CAS(Central Authentication Service)</h2><p>CAS是一种单点登录开源框架，遵循apache2.0协议，代码托管在github.com/apereo/cas上。</p>\n<p>CAS作为一种单点登录框架，后端可配置不同的用户数据库，支持自定义验证或加密逻辑，并提供不同的协议用于与业务server(cas-client)间的通信。</p>\n<p>CAS的源码是由java写的，因此对于java的web项目天生友好。当然只要实现CAS相关协议的client，无论是哪种语言实现的，都能集成到CAS认证框架中。</p>\n<h2 id=\"关于CAS前后端分离\"><a href=\"#关于CAS前后端分离\" class=\"headerlink\" title=\"关于CAS前后端分离\"></a>关于CAS前后端分离</h2><p>CAS5.x版默认的注册登录相关UI是以html形式内嵌在CAS-web项目中的，其中结合thymeleaf模板库来渲染html。</p>\n<p>我们也可以通过前后端分离的方式来自定义我们的认证UI，我这里采取了spring+vuejs架构进行了测试一下，基本能跑通认证流程，大概过程用一张时序图来说明：<br><img src=\"//img.mukewang.com/5b6028770001f6f214361182.png\" alt=\"图片描述\"></p>\n<h2 id=\"前后端分离所涉及到的restAPI\"><a href=\"#前后端分离所涉及到的restAPI\" class=\"headerlink\" title=\"前后端分离所涉及到的restAPI\"></a>前后端分离所涉及到的restAPI</h2><p>因为CAS由原来的结构改为了springboot+vuejs, 原有访问CAS页面的url要修改成访问vuejs所构建的前端页面，而这些url则由这些自定义的前端页面代理去访问调用。这些api包括:</p>\n<ul>\n<li>通过（用户名|密码|当前service名)获取TGT票据, 如：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">curl -v -X POST \"https://svr.sso.com/cas/v1/tickets\" -d \"username=testuser&amp;password=testpwd&amp;service=http://xxx/xx\"</div></pre></td></tr></table></figure>\n<p>响应的TGT信息存储在Location中。</p>\n<ul>\n<li>通过TGT获取ST，如：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 参数service需要进行urlencode</div><div class=\"line\">curl -X POST -v \"https://svr.sso.com/cas/v1/tickets/TGT-4-xxxxxxx\" -d \"service=http%3a%2f%2fxxx%3a%2fxx\"</div></pre></td></tr></table></figure>\n<p>这时直接能从响应结果中得到ST字符串。</p>\n<ul>\n<li>通过ST访问service，正常下可完成登录:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://xxx/xx?ticket=ST-3-BGJBL1wWjRw-prwoSYiyQaYzUNkAppledeMacBook-Pro</div></pre></td></tr></table></figure>\n<ul>\n<li>注销登录(清除TGT)，单点登出，如：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -X DELETE -v \"https://svr.sso.com/cas/v1/tickets/TGT-94-xxxxx\"</div></pre></td></tr></table></figure>\n<p>正常情况下会返回已被清理的TGT字段。</p>"},{"layout":"consul","title":"基于Docker的Consul(官方镜像)集群部署指南","date":"2017-07-31T03:47:23.000Z","_content":"\n\n### 关于Consul\n\nConsul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件.<br>\nConsul 由 HashiCorp公司用Go语言开发, 基于Mozilla Public License 2.0的协议进行开源. <br>\nConsul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对.<br>\n命令行超级好用的虚拟机管理软件 vgrant 也是 HashiCorp 公司开发的产品.<br>\n一致性协议采用 Raft 算法,用来保证服务的高可用. 使用 GOSSIP 协议管理成员和广播消息, 并且支持 ACL 访问控制.<br>\n\n<!--more-->\n\n### 关于官方consul镜像\n\n关于官方consul镜像，三点说明:\n+ 想对于其他版本镜像，其stars和pull数量是最多的, pull达到10M+;\n+ 官方文档可读性相对不够好, 有些绕;\n+ 目前官方镜像更新进度基本与consul最新版本保持一致。\n\n### 多机部署consul:0.8.5版本操作参考\n\n##### 部分参数说明\n  - ***--net=host*** docker参数, 使得docker容器越过了net namespace的隔离，免去手动指定端口映射的步骤\n  - ***-server*** consul支持以server或client的模式运行, server是服务发现模块的核心, client主要用于转发请求\n  - ***-advertise*** 将本机私有IP传递到consul\n  - ***-bootstrap-expect*** 指定consul将等待几个节点连通，成为一个完整的集群\n  - ***-retry-join*** 指定要加入的consul节点地址，失败会重试, 可多次指定不同的地址\n  - ***-client*** consul绑定在哪个client地址上，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1\n  - ***-bind*** 该地址用来在集群内部的通讯，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0\n  - ***allow_stale*** 设置为true, 表明可以从consul集群的任一server节点获取dns信息, false则表明每次请求都会经过consul server leader\n\n\n##### 集群的多机部署参考\n\n  * 多中心部署结构图\n  \n  <img src=\"/img/consul_archi.png\" width=\"700\" height=\"700\" alt=\"consul部署模式\" align=center/><br>\n  生产环境下, 一般一个宿主host一个consul节点；<br>\n  server节点建议一个数据中心部署3-5个, client节点可部署任意节点。\n\n  * 启动consul server节点, 在对应的机器上root权限下执行以下脚本(需修改节点列表: nodes=(...) ):\n\n```bash\n#!/bin/bash\n\nconf_dir=/opt/consul/conf\nmkdir -p ${conf_dir}\n\nnodes=(\n10.220.16.133\n10.220.16.134\n10.220.16.163\n)\nconsul_ver=0.8.5\nretry_interval=15s\ncontain_svr_name=consul_server\n\nprivIP=$(/sbin/ifconfig eth0 | sed -n 's/.*inet \\(addr:\\)\\?\\([0-9.]\\{7,15\\}\\) .*/\\2/p')\nif [[ !(\"${nodes[@]}\" =~ $privIP) ]];\nthen\n    echo -e \"Current node:${privIP} not in configured server nodes.\\n\"\n    exit\nfi\n\nsvr_runing=$(docker ps -a | grep \"${contain_svr_name}\" | egrep \"Up [About]|[0-9]{1,}\")\nif [[ ${svr_runing} != \"\" ]];\nthen\n    echo -e \"Current container of consul server has been running.\\n\"\n    exit\nelse\n    svr_exists=$(docker ps -a | grep \"${contain_svr_name}\")\n    if [[ ${svr_exists} != \"\" ]];\n    then\n        echo -e \"Now try to start the container as it stopped...\\n\"\n        docker start ${svr_exists}\n        sleep 2\n        docker ps -a grep \"${contain_svr_name}\"\n        exit\n    fi\nfi\n\necho -e \"To start a new container for consul...\\n\"\necho -e \"To initialize configuration...\\n\"\n\nnodels=\"\"\nfor host in ${nodes[*]}\ndo\n    if [[ $nodels != \"\" ]];\n    then\n        nodels=$nodels,\n    fi\n    nodels=$nodels\"\\\"$host\\\"\"\ndone\n\nconfig=\"{\\n\n\\\"datacenter\\\": \\\"dc_dl\\\",\\n\n\\\"retry_join\\\": [${nodels}],\\n\n\\\"retry_interval\\\": \\\"${retry_interval}\\\",\\n\n\\\"rejoin_after_leave\\\": true,\\n\n\\\"start_join\\\": [${nodels}],\\n\n\\\"bootstrap_expect\\\": 1,\\n\n\\\"server\\\": true,\\n\n\\\"ui\\\": true,\\n\n\\\"dns_config\\\": {\\\"allow_stale\\\": true, \\\"max_stale\\\": \\\"5s\\\"},\\n\n\\\"node_name\\\": \\\"$HOSTNAME\\\"\\n\n}\\n\"\n\necho $config\necho -e ${config} > ${conf_dir}/server.json\necho -e ${config}\n\ndocker run -d -v ${conf_dir}:${conf_dir} \\\n    --name ${contain_svr_name} \\\n    --net=host consul:${consul_ver} agent \\\n    -config-dir=${conf_dir} \\\n    -client=0.0.0.0 \\\n    -bind=${privIP} \\\n    -advertise=${privIP}\n\nsleep 2\n\nsvr_runing=$(docker ps -a | grep \"${contain_svr_name}\" | egrep \"Up [About]|[0-9]{1,}\")\nif [[ ${svr_runing} == \"\" ]];\nthen\n    echo -e \"\\nError: docker-consul failed to start...\\n\"\n    exit\nfi\necho -e \"\\nOK: docker-consul has started as background server.\\n\"\n```\n\n  * 启动consul client节点(任意数量或不部署), 在需要部署的机器上执行(需修改svrnodes列表):\n\n```bash\n#!/bin/bash\n\nconf_dir=/opt/consul/conf\nmkdir -p ${conf_dir}\n\nsvrnodes=(\n10.220.16.133\n10.220.16.134\n10.220.16.163\n)\nprivIP=$(/sbin/ifconfig eth0 | sed -n 's/.*inet \\(addr:\\)\\?\\([0-9.]\\{7,15\\}\\) .*/\\2/p')\nconsul_ver=0.8.5\nretry_interval=15s\ncontain_cli_name=consul_client\n\nif [[ \"${svrnodes[@]}\" =~ $privIP ]];\nthen\n    echo -e \"Current node:${privIP} is configured for server consul, not to run client mode.\\n\"\n    exit\nfi\n\nsvr_runing=$(docker ps -a | grep \"${contain_cli_name}\" | egrep \"Up [About]|[0-9]{1,}\")\nif [[ ${svr_runing} != \"\" ]];\nthen\n    echo -e \"Current container of consul client has been running.\\n\"\n    exit\nelse\n    svr_exists=$(docker ps -a | grep \"${contain_cli_name}\")\n    if [[ ${svr_exists} != \"\" ]];\n    then\n        echo -e \"Now try to start the container as it stopped...\\n\"\n        docker start ${svr_exists}\n        sleep 2\n        docker ps -a grep \"${contain_cli_name}\"\n        exit\n    fi\nfi\n\necho -e \"To start a new container for consul...\\n\"\necho -e \"To initialize configuration...\\n\"\n\nnodels=\"\"\nfor host in ${svrnodes[*]}\ndo\n    if [[ $nodels != \"\" ]];\n    then\n        nodels=$nodels,\n    fi\n    nodels=$nodels\"\\\"$host\\\"\"\ndone\n\nconfig=\"{\\n\n\\\"retry_join\\\": [${nodels}],\\n\n\\\"retry_interval\\\": \\\"${retry_interval}\\\",\\n\n\\\"rejoin_after_leave\\\": true,\\n\n\\\"start_join\\\": [${nodels}],\\n\n\\\"server\\\": false,\\n\n\\\"ui\\\": true,\\n\n\\\"node_name\\\": \\\"$HOSTNAME\\\"\\n\n}\\n\"\n\necho $config\necho -e ${config} > ${conf_dir}/client.json\necho -e ${config}\n\ndocker run -d -v ${conf_dir}:${conf_dir} \\\n    --name ${contain_cli_name} \\\n    --net=host consul:${consul_ver} agent \\\n    -config-dir=${conf_dir} \\\n    -client=0.0.0.0 \\\n    -advertise=${privIP}\n\nsleep 2\n\nsvr_runing=$(docker ps -a | grep \"${contain_cli_name}\" | egrep \"Up [About]|[0-9]{1,}\")\nif [[ ${svr_runing} == \"\" ]];\nthen\n    echo -e \"\\nError: docker-consul client node failed to start...\\n\"\n    exit\nfi\necho -e \"\\nOK: docker-consul has started as a client node.\\n\"\n```\n\n  * 检查集群的状态\n\n    通过webUI地址: ***http://<其中一个节点ip>:8500/ui/***可查看集群状态，正常情况下会显示***3 passing***。<br>\n    通过docker命令行:<br>\n\n```bash\nroot@hadoop:~# docker exec -it consul_server consul members\nNode                          Address             Status  Type    Build  Protocol  DC\nhadoop.slave01.fs.115cdn.net  10.220.16.133:8301  alive   server  0.8.5  2         dc1\nhadoop.slave02.fs.115cdn.net  10.220.16.134:8301  alive   server  0.8.5  2         dc1\nhadoop.slave03.fs.115cdn.net  10.220.16.163:8301  alive   server  0.8.5  2         dc1\nhadoop.slave04.fs.115cdn.net  10.220.16.125:8301  alive   client  0.8.5  2         dc1\n```\n","source":"_posts/bigdata/基于Docker的Consul-官方镜像-集群部署指南.md","raw":"---\nlayout: consul\ntitle: 基于Docker的Consul(官方镜像)集群部署指南\ndate: 2017-07-31 11:47:23\ntags: consul\n---\n\n\n### 关于Consul\n\nConsul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件.<br>\nConsul 由 HashiCorp公司用Go语言开发, 基于Mozilla Public License 2.0的协议进行开源. <br>\nConsul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对.<br>\n命令行超级好用的虚拟机管理软件 vgrant 也是 HashiCorp 公司开发的产品.<br>\n一致性协议采用 Raft 算法,用来保证服务的高可用. 使用 GOSSIP 协议管理成员和广播消息, 并且支持 ACL 访问控制.<br>\n\n<!--more-->\n\n### 关于官方consul镜像\n\n关于官方consul镜像，三点说明:\n+ 想对于其他版本镜像，其stars和pull数量是最多的, pull达到10M+;\n+ 官方文档可读性相对不够好, 有些绕;\n+ 目前官方镜像更新进度基本与consul最新版本保持一致。\n\n### 多机部署consul:0.8.5版本操作参考\n\n##### 部分参数说明\n  - ***--net=host*** docker参数, 使得docker容器越过了net namespace的隔离，免去手动指定端口映射的步骤\n  - ***-server*** consul支持以server或client的模式运行, server是服务发现模块的核心, client主要用于转发请求\n  - ***-advertise*** 将本机私有IP传递到consul\n  - ***-bootstrap-expect*** 指定consul将等待几个节点连通，成为一个完整的集群\n  - ***-retry-join*** 指定要加入的consul节点地址，失败会重试, 可多次指定不同的地址\n  - ***-client*** consul绑定在哪个client地址上，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1\n  - ***-bind*** 该地址用来在集群内部的通讯，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0\n  - ***allow_stale*** 设置为true, 表明可以从consul集群的任一server节点获取dns信息, false则表明每次请求都会经过consul server leader\n\n\n##### 集群的多机部署参考\n\n  * 多中心部署结构图\n  \n  <img src=\"/img/consul_archi.png\" width=\"700\" height=\"700\" alt=\"consul部署模式\" align=center/><br>\n  生产环境下, 一般一个宿主host一个consul节点；<br>\n  server节点建议一个数据中心部署3-5个, client节点可部署任意节点。\n\n  * 启动consul server节点, 在对应的机器上root权限下执行以下脚本(需修改节点列表: nodes=(...) ):\n\n```bash\n#!/bin/bash\n\nconf_dir=/opt/consul/conf\nmkdir -p ${conf_dir}\n\nnodes=(\n10.220.16.133\n10.220.16.134\n10.220.16.163\n)\nconsul_ver=0.8.5\nretry_interval=15s\ncontain_svr_name=consul_server\n\nprivIP=$(/sbin/ifconfig eth0 | sed -n 's/.*inet \\(addr:\\)\\?\\([0-9.]\\{7,15\\}\\) .*/\\2/p')\nif [[ !(\"${nodes[@]}\" =~ $privIP) ]];\nthen\n    echo -e \"Current node:${privIP} not in configured server nodes.\\n\"\n    exit\nfi\n\nsvr_runing=$(docker ps -a | grep \"${contain_svr_name}\" | egrep \"Up [About]|[0-9]{1,}\")\nif [[ ${svr_runing} != \"\" ]];\nthen\n    echo -e \"Current container of consul server has been running.\\n\"\n    exit\nelse\n    svr_exists=$(docker ps -a | grep \"${contain_svr_name}\")\n    if [[ ${svr_exists} != \"\" ]];\n    then\n        echo -e \"Now try to start the container as it stopped...\\n\"\n        docker start ${svr_exists}\n        sleep 2\n        docker ps -a grep \"${contain_svr_name}\"\n        exit\n    fi\nfi\n\necho -e \"To start a new container for consul...\\n\"\necho -e \"To initialize configuration...\\n\"\n\nnodels=\"\"\nfor host in ${nodes[*]}\ndo\n    if [[ $nodels != \"\" ]];\n    then\n        nodels=$nodels,\n    fi\n    nodels=$nodels\"\\\"$host\\\"\"\ndone\n\nconfig=\"{\\n\n\\\"datacenter\\\": \\\"dc_dl\\\",\\n\n\\\"retry_join\\\": [${nodels}],\\n\n\\\"retry_interval\\\": \\\"${retry_interval}\\\",\\n\n\\\"rejoin_after_leave\\\": true,\\n\n\\\"start_join\\\": [${nodels}],\\n\n\\\"bootstrap_expect\\\": 1,\\n\n\\\"server\\\": true,\\n\n\\\"ui\\\": true,\\n\n\\\"dns_config\\\": {\\\"allow_stale\\\": true, \\\"max_stale\\\": \\\"5s\\\"},\\n\n\\\"node_name\\\": \\\"$HOSTNAME\\\"\\n\n}\\n\"\n\necho $config\necho -e ${config} > ${conf_dir}/server.json\necho -e ${config}\n\ndocker run -d -v ${conf_dir}:${conf_dir} \\\n    --name ${contain_svr_name} \\\n    --net=host consul:${consul_ver} agent \\\n    -config-dir=${conf_dir} \\\n    -client=0.0.0.0 \\\n    -bind=${privIP} \\\n    -advertise=${privIP}\n\nsleep 2\n\nsvr_runing=$(docker ps -a | grep \"${contain_svr_name}\" | egrep \"Up [About]|[0-9]{1,}\")\nif [[ ${svr_runing} == \"\" ]];\nthen\n    echo -e \"\\nError: docker-consul failed to start...\\n\"\n    exit\nfi\necho -e \"\\nOK: docker-consul has started as background server.\\n\"\n```\n\n  * 启动consul client节点(任意数量或不部署), 在需要部署的机器上执行(需修改svrnodes列表):\n\n```bash\n#!/bin/bash\n\nconf_dir=/opt/consul/conf\nmkdir -p ${conf_dir}\n\nsvrnodes=(\n10.220.16.133\n10.220.16.134\n10.220.16.163\n)\nprivIP=$(/sbin/ifconfig eth0 | sed -n 's/.*inet \\(addr:\\)\\?\\([0-9.]\\{7,15\\}\\) .*/\\2/p')\nconsul_ver=0.8.5\nretry_interval=15s\ncontain_cli_name=consul_client\n\nif [[ \"${svrnodes[@]}\" =~ $privIP ]];\nthen\n    echo -e \"Current node:${privIP} is configured for server consul, not to run client mode.\\n\"\n    exit\nfi\n\nsvr_runing=$(docker ps -a | grep \"${contain_cli_name}\" | egrep \"Up [About]|[0-9]{1,}\")\nif [[ ${svr_runing} != \"\" ]];\nthen\n    echo -e \"Current container of consul client has been running.\\n\"\n    exit\nelse\n    svr_exists=$(docker ps -a | grep \"${contain_cli_name}\")\n    if [[ ${svr_exists} != \"\" ]];\n    then\n        echo -e \"Now try to start the container as it stopped...\\n\"\n        docker start ${svr_exists}\n        sleep 2\n        docker ps -a grep \"${contain_cli_name}\"\n        exit\n    fi\nfi\n\necho -e \"To start a new container for consul...\\n\"\necho -e \"To initialize configuration...\\n\"\n\nnodels=\"\"\nfor host in ${svrnodes[*]}\ndo\n    if [[ $nodels != \"\" ]];\n    then\n        nodels=$nodels,\n    fi\n    nodels=$nodels\"\\\"$host\\\"\"\ndone\n\nconfig=\"{\\n\n\\\"retry_join\\\": [${nodels}],\\n\n\\\"retry_interval\\\": \\\"${retry_interval}\\\",\\n\n\\\"rejoin_after_leave\\\": true,\\n\n\\\"start_join\\\": [${nodels}],\\n\n\\\"server\\\": false,\\n\n\\\"ui\\\": true,\\n\n\\\"node_name\\\": \\\"$HOSTNAME\\\"\\n\n}\\n\"\n\necho $config\necho -e ${config} > ${conf_dir}/client.json\necho -e ${config}\n\ndocker run -d -v ${conf_dir}:${conf_dir} \\\n    --name ${contain_cli_name} \\\n    --net=host consul:${consul_ver} agent \\\n    -config-dir=${conf_dir} \\\n    -client=0.0.0.0 \\\n    -advertise=${privIP}\n\nsleep 2\n\nsvr_runing=$(docker ps -a | grep \"${contain_cli_name}\" | egrep \"Up [About]|[0-9]{1,}\")\nif [[ ${svr_runing} == \"\" ]];\nthen\n    echo -e \"\\nError: docker-consul client node failed to start...\\n\"\n    exit\nfi\necho -e \"\\nOK: docker-consul has started as a client node.\\n\"\n```\n\n  * 检查集群的状态\n\n    通过webUI地址: ***http://<其中一个节点ip>:8500/ui/***可查看集群状态，正常情况下会显示***3 passing***。<br>\n    通过docker命令行:<br>\n\n```bash\nroot@hadoop:~# docker exec -it consul_server consul members\nNode                          Address             Status  Type    Build  Protocol  DC\nhadoop.slave01.fs.115cdn.net  10.220.16.133:8301  alive   server  0.8.5  2         dc1\nhadoop.slave02.fs.115cdn.net  10.220.16.134:8301  alive   server  0.8.5  2         dc1\nhadoop.slave03.fs.115cdn.net  10.220.16.163:8301  alive   server  0.8.5  2         dc1\nhadoop.slave04.fs.115cdn.net  10.220.16.125:8301  alive   client  0.8.5  2         dc1\n```\n","slug":"bigdata/基于Docker的Consul-官方镜像-集群部署指南","published":1,"updated":"2017-08-07T02:13:38.394Z","comments":1,"photos":[],"link":"","_id":"ck2c00dvr000n4j4dg87c15ra","content":"<h3 id=\"关于Consul\"><a href=\"#关于Consul\" class=\"headerlink\" title=\"关于Consul\"></a>关于Consul</h3><p>Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件.<br><br>Consul 由 HashiCorp公司用Go语言开发, 基于Mozilla Public License 2.0的协议进行开源. <br><br>Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对.<br><br>命令行超级好用的虚拟机管理软件 vgrant 也是 HashiCorp 公司开发的产品.<br><br>一致性协议采用 Raft 算法,用来保证服务的高可用. 使用 GOSSIP 协议管理成员和广播消息, 并且支持 ACL 访问控制.<br></p>\n<a id=\"more\"></a>\n<h3 id=\"关于官方consul镜像\"><a href=\"#关于官方consul镜像\" class=\"headerlink\" title=\"关于官方consul镜像\"></a>关于官方consul镜像</h3><p>关于官方consul镜像，三点说明:</p>\n<ul>\n<li>想对于其他版本镜像，其stars和pull数量是最多的, pull达到10M+;</li>\n<li>官方文档可读性相对不够好, 有些绕;</li>\n<li>目前官方镜像更新进度基本与consul最新版本保持一致。</li>\n</ul>\n<h3 id=\"多机部署consul-0-8-5版本操作参考\"><a href=\"#多机部署consul-0-8-5版本操作参考\" class=\"headerlink\" title=\"多机部署consul:0.8.5版本操作参考\"></a>多机部署consul:0.8.5版本操作参考</h3><h5 id=\"部分参数说明\"><a href=\"#部分参数说明\" class=\"headerlink\" title=\"部分参数说明\"></a>部分参数说明</h5><ul>\n<li><strong><em>–net=host</em></strong> docker参数, 使得docker容器越过了net namespace的隔离，免去手动指定端口映射的步骤</li>\n<li><strong><em>-server</em></strong> consul支持以server或client的模式运行, server是服务发现模块的核心, client主要用于转发请求</li>\n<li><strong><em>-advertise</em></strong> 将本机私有IP传递到consul</li>\n<li><strong><em>-bootstrap-expect</em></strong> 指定consul将等待几个节点连通，成为一个完整的集群</li>\n<li><strong><em>-retry-join</em></strong> 指定要加入的consul节点地址，失败会重试, 可多次指定不同的地址</li>\n<li><strong><em>-client</em></strong> consul绑定在哪个client地址上，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1</li>\n<li><strong><em>-bind</em></strong> 该地址用来在集群内部的通讯，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0</li>\n<li><strong><em>allow_stale</em></strong> 设置为true, 表明可以从consul集群的任一server节点获取dns信息, false则表明每次请求都会经过consul server leader</li>\n</ul>\n<h5 id=\"集群的多机部署参考\"><a href=\"#集群的多机部署参考\" class=\"headerlink\" title=\"集群的多机部署参考\"></a>集群的多机部署参考</h5><ul>\n<li><p>多中心部署结构图</p>\n<p><img src=\"/img/consul_archi.png\" width=\"700\" height=\"700\" alt=\"consul部署模式\" align=\"center/\"><br><br>生产环境下, 一般一个宿主host一个consul节点；<br><br>server节点建议一个数据中心部署3-5个, client节点可部署任意节点。</p>\n</li>\n<li><p>启动consul server节点, 在对应的机器上root权限下执行以下脚本(需修改节点列表: nodes=(…) ):</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\"></div><div class=\"line\">conf_dir=/opt/consul/conf</div><div class=\"line\">mkdir -p <span class=\"variable\">$&#123;conf_dir&#125;</span></div><div class=\"line\"></div><div class=\"line\">nodes=(</div><div class=\"line\">10.220.16.133</div><div class=\"line\">10.220.16.134</div><div class=\"line\">10.220.16.163</div><div class=\"line\">)</div><div class=\"line\">consul_ver=0.8.5</div><div class=\"line\">retry_interval=15s</div><div class=\"line\">contain_svr_name=consul_server</div><div class=\"line\"></div><div class=\"line\">privIP=$(/sbin/ifconfig eth0 | sed -n <span class=\"string\">'s/.*inet \\(addr:\\)\\?\\([0-9.]\\&#123;7,15\\&#125;\\) .*/\\2/p'</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> [[ !(<span class=\"string\">\"<span class=\"variable\">$&#123;nodes[@]&#125;</span>\"</span> =~ <span class=\"variable\">$privIP</span>) ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> -e <span class=\"string\">\"Current node:<span class=\"variable\">$&#123;privIP&#125;</span> not in configured server nodes.\\n\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\">svr_runing=$(docker ps -a | grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_svr_name&#125;</span>\"</span> | egrep <span class=\"string\">\"Up [About]|[0-9]&#123;1,&#125;\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;svr_runing&#125;</span> != <span class=\"string\">\"\"</span> ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> -e <span class=\"string\">\"Current container of consul server has been running.\\n\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">    svr_exists=$(docker ps -a | grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_svr_name&#125;</span>\"</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;svr_exists&#125;</span> != <span class=\"string\">\"\"</span> ]];</div><div class=\"line\">    <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> -e <span class=\"string\">\"Now try to start the container as it stopped...\\n\"</span></div><div class=\"line\">        docker start <span class=\"variable\">$&#123;svr_exists&#125;</span></div><div class=\"line\">        sleep 2</div><div class=\"line\">        docker ps -a grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_svr_name&#125;</span>\"</span></div><div class=\"line\">        <span class=\"built_in\">exit</span></div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"To start a new container for consul...\\n\"</span></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"To initialize configuration...\\n\"</span></div><div class=\"line\"></div><div class=\"line\">nodels=<span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"keyword\">for</span> host <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;nodes[*]&#125;</span></div><div class=\"line\"><span class=\"keyword\">do</span></div><div class=\"line\">    <span class=\"keyword\">if</span> [[ <span class=\"variable\">$nodels</span> != <span class=\"string\">\"\"</span> ]];</div><div class=\"line\">    <span class=\"keyword\">then</span></div><div class=\"line\">        nodels=<span class=\"variable\">$nodels</span>,</div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\">    nodels=<span class=\"variable\">$nodels</span><span class=\"string\">\"\\\"<span class=\"variable\">$host</span>\\\"\"</span></div><div class=\"line\"><span class=\"keyword\">done</span></div><div class=\"line\"></div><div class=\"line\">config=<span class=\"string\">\"&#123;\\n</span></div><div class=\"line\">\\\"datacenter\\\": \\\"dc_dl\\\",\\n</div><div class=\"line\">\\\"retry_join\\\": [<span class=\"variable\">$&#123;nodels&#125;</span>],\\n</div><div class=\"line\">\\\"retry_interval\\\": \\\"<span class=\"variable\">$&#123;retry_interval&#125;</span>\\\",\\n</div><div class=\"line\">\\\"rejoin_after_leave\\\": true,\\n</div><div class=\"line\">\\\"start_join\\\": [<span class=\"variable\">$&#123;nodels&#125;</span>],\\n</div><div class=\"line\">\\\"bootstrap_expect\\\": 1,\\n</div><div class=\"line\">\\\"server\\\": true,\\n</div><div class=\"line\">\\\"ui\\\": true,\\n</div><div class=\"line\">\\\"dns_config\\\": &#123;\\\"allow_stale\\\": true, \\\"max_stale\\\": \\\"5s\\\"&#125;,\\n</div><div class=\"line\">\\\"node_name\\\": \\\"<span class=\"variable\">$HOSTNAME</span>\\\"\\n</div><div class=\"line\">&#125;\\n\"</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$config</span></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"variable\">$&#123;config&#125;</span> &gt; <span class=\"variable\">$&#123;conf_dir&#125;</span>/server.json</div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"variable\">$&#123;config&#125;</span></div><div class=\"line\"></div><div class=\"line\">docker run -d -v <span class=\"variable\">$&#123;conf_dir&#125;</span>:<span class=\"variable\">$&#123;conf_dir&#125;</span> \\</div><div class=\"line\">    --name <span class=\"variable\">$&#123;contain_svr_name&#125;</span> \\</div><div class=\"line\">    --net=host consul:<span class=\"variable\">$&#123;consul_ver&#125;</span> agent \\</div><div class=\"line\">    -config-dir=<span class=\"variable\">$&#123;conf_dir&#125;</span> \\</div><div class=\"line\">    -client=0.0.0.0 \\</div><div class=\"line\">    -<span class=\"built_in\">bind</span>=<span class=\"variable\">$&#123;privIP&#125;</span> \\</div><div class=\"line\">    -advertise=<span class=\"variable\">$&#123;privIP&#125;</span></div><div class=\"line\"></div><div class=\"line\">sleep 2</div><div class=\"line\"></div><div class=\"line\">svr_runing=$(docker ps -a | grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_svr_name&#125;</span>\"</span> | egrep <span class=\"string\">\"Up [About]|[0-9]&#123;1,&#125;\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;svr_runing&#125;</span> == <span class=\"string\">\"\"</span> ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\nError: docker-consul failed to start...\\n\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\nOK: docker-consul has started as background server.\\n\"</span></div></pre></td></tr></table></figure>\n<ul>\n<li>启动consul client节点(任意数量或不部署), 在需要部署的机器上执行(需修改svrnodes列表):</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\"></div><div class=\"line\">conf_dir=/opt/consul/conf</div><div class=\"line\">mkdir -p <span class=\"variable\">$&#123;conf_dir&#125;</span></div><div class=\"line\"></div><div class=\"line\">svrnodes=(</div><div class=\"line\">10.220.16.133</div><div class=\"line\">10.220.16.134</div><div class=\"line\">10.220.16.163</div><div class=\"line\">)</div><div class=\"line\">privIP=$(/sbin/ifconfig eth0 | sed -n <span class=\"string\">'s/.*inet \\(addr:\\)\\?\\([0-9.]\\&#123;7,15\\&#125;\\) .*/\\2/p'</span>)</div><div class=\"line\">consul_ver=0.8.5</div><div class=\"line\">retry_interval=15s</div><div class=\"line\">contain_cli_name=consul_client</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"string\">\"<span class=\"variable\">$&#123;svrnodes[@]&#125;</span>\"</span> =~ <span class=\"variable\">$privIP</span> ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> -e <span class=\"string\">\"Current node:<span class=\"variable\">$&#123;privIP&#125;</span> is configured for server consul, not to run client mode.\\n\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\">svr_runing=$(docker ps -a | grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_cli_name&#125;</span>\"</span> | egrep <span class=\"string\">\"Up [About]|[0-9]&#123;1,&#125;\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;svr_runing&#125;</span> != <span class=\"string\">\"\"</span> ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> -e <span class=\"string\">\"Current container of consul client has been running.\\n\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">    svr_exists=$(docker ps -a | grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_cli_name&#125;</span>\"</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;svr_exists&#125;</span> != <span class=\"string\">\"\"</span> ]];</div><div class=\"line\">    <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> -e <span class=\"string\">\"Now try to start the container as it stopped...\\n\"</span></div><div class=\"line\">        docker start <span class=\"variable\">$&#123;svr_exists&#125;</span></div><div class=\"line\">        sleep 2</div><div class=\"line\">        docker ps -a grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_cli_name&#125;</span>\"</span></div><div class=\"line\">        <span class=\"built_in\">exit</span></div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"To start a new container for consul...\\n\"</span></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"To initialize configuration...\\n\"</span></div><div class=\"line\"></div><div class=\"line\">nodels=<span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"keyword\">for</span> host <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;svrnodes[*]&#125;</span></div><div class=\"line\"><span class=\"keyword\">do</span></div><div class=\"line\">    <span class=\"keyword\">if</span> [[ <span class=\"variable\">$nodels</span> != <span class=\"string\">\"\"</span> ]];</div><div class=\"line\">    <span class=\"keyword\">then</span></div><div class=\"line\">        nodels=<span class=\"variable\">$nodels</span>,</div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\">    nodels=<span class=\"variable\">$nodels</span><span class=\"string\">\"\\\"<span class=\"variable\">$host</span>\\\"\"</span></div><div class=\"line\"><span class=\"keyword\">done</span></div><div class=\"line\"></div><div class=\"line\">config=<span class=\"string\">\"&#123;\\n</span></div><div class=\"line\">\\\"retry_join\\\": [<span class=\"variable\">$&#123;nodels&#125;</span>],\\n</div><div class=\"line\">\\\"retry_interval\\\": \\\"<span class=\"variable\">$&#123;retry_interval&#125;</span>\\\",\\n</div><div class=\"line\">\\\"rejoin_after_leave\\\": true,\\n</div><div class=\"line\">\\\"start_join\\\": [<span class=\"variable\">$&#123;nodels&#125;</span>],\\n</div><div class=\"line\">\\\"server\\\": false,\\n</div><div class=\"line\">\\\"ui\\\": true,\\n</div><div class=\"line\">\\\"node_name\\\": \\\"<span class=\"variable\">$HOSTNAME</span>\\\"\\n</div><div class=\"line\">&#125;\\n\"</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$config</span></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"variable\">$&#123;config&#125;</span> &gt; <span class=\"variable\">$&#123;conf_dir&#125;</span>/client.json</div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"variable\">$&#123;config&#125;</span></div><div class=\"line\"></div><div class=\"line\">docker run -d -v <span class=\"variable\">$&#123;conf_dir&#125;</span>:<span class=\"variable\">$&#123;conf_dir&#125;</span> \\</div><div class=\"line\">    --name <span class=\"variable\">$&#123;contain_cli_name&#125;</span> \\</div><div class=\"line\">    --net=host consul:<span class=\"variable\">$&#123;consul_ver&#125;</span> agent \\</div><div class=\"line\">    -config-dir=<span class=\"variable\">$&#123;conf_dir&#125;</span> \\</div><div class=\"line\">    -client=0.0.0.0 \\</div><div class=\"line\">    -advertise=<span class=\"variable\">$&#123;privIP&#125;</span></div><div class=\"line\"></div><div class=\"line\">sleep 2</div><div class=\"line\"></div><div class=\"line\">svr_runing=$(docker ps -a | grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_cli_name&#125;</span>\"</span> | egrep <span class=\"string\">\"Up [About]|[0-9]&#123;1,&#125;\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;svr_runing&#125;</span> == <span class=\"string\">\"\"</span> ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\nError: docker-consul client node failed to start...\\n\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\nOK: docker-consul has started as a client node.\\n\"</span></div></pre></td></tr></table></figure>\n<ul>\n<li><p>检查集群的状态</p>\n<p>通过webUI地址: <strong><em>http://&lt;其中一个节点ip&gt;:8500/ui/</em></strong>可查看集群状态，正常情况下会显示<strong><em>3 passing</em></strong>。<br><br>通过docker命令行:<br></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@hadoop:~<span class=\"comment\"># docker exec -it consul_server consul members</span></div><div class=\"line\">Node                          Address             Status  Type    Build  Protocol  DC</div><div class=\"line\">hadoop.slave01.fs.115cdn.net  10.220.16.133:8301  alive   server  0.8.5  2         dc1</div><div class=\"line\">hadoop.slave02.fs.115cdn.net  10.220.16.134:8301  alive   server  0.8.5  2         dc1</div><div class=\"line\">hadoop.slave03.fs.115cdn.net  10.220.16.163:8301  alive   server  0.8.5  2         dc1</div><div class=\"line\">hadoop.slave04.fs.115cdn.net  10.220.16.125:8301  alive   client  0.8.5  2         dc1</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"关于Consul\"><a href=\"#关于Consul\" class=\"headerlink\" title=\"关于Consul\"></a>关于Consul</h3><p>Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件.<br><br>Consul 由 HashiCorp公司用Go语言开发, 基于Mozilla Public License 2.0的协议进行开源. <br><br>Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对.<br><br>命令行超级好用的虚拟机管理软件 vgrant 也是 HashiCorp 公司开发的产品.<br><br>一致性协议采用 Raft 算法,用来保证服务的高可用. 使用 GOSSIP 协议管理成员和广播消息, 并且支持 ACL 访问控制.<br></p>","more":"<h3 id=\"关于官方consul镜像\"><a href=\"#关于官方consul镜像\" class=\"headerlink\" title=\"关于官方consul镜像\"></a>关于官方consul镜像</h3><p>关于官方consul镜像，三点说明:</p>\n<ul>\n<li>想对于其他版本镜像，其stars和pull数量是最多的, pull达到10M+;</li>\n<li>官方文档可读性相对不够好, 有些绕;</li>\n<li>目前官方镜像更新进度基本与consul最新版本保持一致。</li>\n</ul>\n<h3 id=\"多机部署consul-0-8-5版本操作参考\"><a href=\"#多机部署consul-0-8-5版本操作参考\" class=\"headerlink\" title=\"多机部署consul:0.8.5版本操作参考\"></a>多机部署consul:0.8.5版本操作参考</h3><h5 id=\"部分参数说明\"><a href=\"#部分参数说明\" class=\"headerlink\" title=\"部分参数说明\"></a>部分参数说明</h5><ul>\n<li><strong><em>–net=host</em></strong> docker参数, 使得docker容器越过了net namespace的隔离，免去手动指定端口映射的步骤</li>\n<li><strong><em>-server</em></strong> consul支持以server或client的模式运行, server是服务发现模块的核心, client主要用于转发请求</li>\n<li><strong><em>-advertise</em></strong> 将本机私有IP传递到consul</li>\n<li><strong><em>-bootstrap-expect</em></strong> 指定consul将等待几个节点连通，成为一个完整的集群</li>\n<li><strong><em>-retry-join</em></strong> 指定要加入的consul节点地址，失败会重试, 可多次指定不同的地址</li>\n<li><strong><em>-client</em></strong> consul绑定在哪个client地址上，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1</li>\n<li><strong><em>-bind</em></strong> 该地址用来在集群内部的通讯，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0</li>\n<li><strong><em>allow_stale</em></strong> 设置为true, 表明可以从consul集群的任一server节点获取dns信息, false则表明每次请求都会经过consul server leader</li>\n</ul>\n<h5 id=\"集群的多机部署参考\"><a href=\"#集群的多机部署参考\" class=\"headerlink\" title=\"集群的多机部署参考\"></a>集群的多机部署参考</h5><ul>\n<li><p>多中心部署结构图</p>\n<p><img src=\"/img/consul_archi.png\" width=\"700\" height=\"700\" alt=\"consul部署模式\" align=\"center/\"><br><br>生产环境下, 一般一个宿主host一个consul节点；<br><br>server节点建议一个数据中心部署3-5个, client节点可部署任意节点。</p>\n</li>\n<li><p>启动consul server节点, 在对应的机器上root权限下执行以下脚本(需修改节点列表: nodes=(…) ):</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\"></div><div class=\"line\">conf_dir=/opt/consul/conf</div><div class=\"line\">mkdir -p <span class=\"variable\">$&#123;conf_dir&#125;</span></div><div class=\"line\"></div><div class=\"line\">nodes=(</div><div class=\"line\">10.220.16.133</div><div class=\"line\">10.220.16.134</div><div class=\"line\">10.220.16.163</div><div class=\"line\">)</div><div class=\"line\">consul_ver=0.8.5</div><div class=\"line\">retry_interval=15s</div><div class=\"line\">contain_svr_name=consul_server</div><div class=\"line\"></div><div class=\"line\">privIP=$(/sbin/ifconfig eth0 | sed -n <span class=\"string\">'s/.*inet \\(addr:\\)\\?\\([0-9.]\\&#123;7,15\\&#125;\\) .*/\\2/p'</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> [[ !(<span class=\"string\">\"<span class=\"variable\">$&#123;nodes[@]&#125;</span>\"</span> =~ <span class=\"variable\">$privIP</span>) ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> -e <span class=\"string\">\"Current node:<span class=\"variable\">$&#123;privIP&#125;</span> not in configured server nodes.\\n\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\">svr_runing=$(docker ps -a | grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_svr_name&#125;</span>\"</span> | egrep <span class=\"string\">\"Up [About]|[0-9]&#123;1,&#125;\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;svr_runing&#125;</span> != <span class=\"string\">\"\"</span> ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> -e <span class=\"string\">\"Current container of consul server has been running.\\n\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">    svr_exists=$(docker ps -a | grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_svr_name&#125;</span>\"</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;svr_exists&#125;</span> != <span class=\"string\">\"\"</span> ]];</div><div class=\"line\">    <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> -e <span class=\"string\">\"Now try to start the container as it stopped...\\n\"</span></div><div class=\"line\">        docker start <span class=\"variable\">$&#123;svr_exists&#125;</span></div><div class=\"line\">        sleep 2</div><div class=\"line\">        docker ps -a grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_svr_name&#125;</span>\"</span></div><div class=\"line\">        <span class=\"built_in\">exit</span></div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"To start a new container for consul...\\n\"</span></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"To initialize configuration...\\n\"</span></div><div class=\"line\"></div><div class=\"line\">nodels=<span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"keyword\">for</span> host <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;nodes[*]&#125;</span></div><div class=\"line\"><span class=\"keyword\">do</span></div><div class=\"line\">    <span class=\"keyword\">if</span> [[ <span class=\"variable\">$nodels</span> != <span class=\"string\">\"\"</span> ]];</div><div class=\"line\">    <span class=\"keyword\">then</span></div><div class=\"line\">        nodels=<span class=\"variable\">$nodels</span>,</div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\">    nodels=<span class=\"variable\">$nodels</span><span class=\"string\">\"\\\"<span class=\"variable\">$host</span>\\\"\"</span></div><div class=\"line\"><span class=\"keyword\">done</span></div><div class=\"line\"></div><div class=\"line\">config=<span class=\"string\">\"&#123;\\n</span></div><div class=\"line\">\\\"datacenter\\\": \\\"dc_dl\\\",\\n</div><div class=\"line\">\\\"retry_join\\\": [<span class=\"variable\">$&#123;nodels&#125;</span>],\\n</div><div class=\"line\">\\\"retry_interval\\\": \\\"<span class=\"variable\">$&#123;retry_interval&#125;</span>\\\",\\n</div><div class=\"line\">\\\"rejoin_after_leave\\\": true,\\n</div><div class=\"line\">\\\"start_join\\\": [<span class=\"variable\">$&#123;nodels&#125;</span>],\\n</div><div class=\"line\">\\\"bootstrap_expect\\\": 1,\\n</div><div class=\"line\">\\\"server\\\": true,\\n</div><div class=\"line\">\\\"ui\\\": true,\\n</div><div class=\"line\">\\\"dns_config\\\": &#123;\\\"allow_stale\\\": true, \\\"max_stale\\\": \\\"5s\\\"&#125;,\\n</div><div class=\"line\">\\\"node_name\\\": \\\"<span class=\"variable\">$HOSTNAME</span>\\\"\\n</div><div class=\"line\">&#125;\\n\"</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$config</span></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"variable\">$&#123;config&#125;</span> &gt; <span class=\"variable\">$&#123;conf_dir&#125;</span>/server.json</div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"variable\">$&#123;config&#125;</span></div><div class=\"line\"></div><div class=\"line\">docker run -d -v <span class=\"variable\">$&#123;conf_dir&#125;</span>:<span class=\"variable\">$&#123;conf_dir&#125;</span> \\</div><div class=\"line\">    --name <span class=\"variable\">$&#123;contain_svr_name&#125;</span> \\</div><div class=\"line\">    --net=host consul:<span class=\"variable\">$&#123;consul_ver&#125;</span> agent \\</div><div class=\"line\">    -config-dir=<span class=\"variable\">$&#123;conf_dir&#125;</span> \\</div><div class=\"line\">    -client=0.0.0.0 \\</div><div class=\"line\">    -<span class=\"built_in\">bind</span>=<span class=\"variable\">$&#123;privIP&#125;</span> \\</div><div class=\"line\">    -advertise=<span class=\"variable\">$&#123;privIP&#125;</span></div><div class=\"line\"></div><div class=\"line\">sleep 2</div><div class=\"line\"></div><div class=\"line\">svr_runing=$(docker ps -a | grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_svr_name&#125;</span>\"</span> | egrep <span class=\"string\">\"Up [About]|[0-9]&#123;1,&#125;\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;svr_runing&#125;</span> == <span class=\"string\">\"\"</span> ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\nError: docker-consul failed to start...\\n\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\nOK: docker-consul has started as background server.\\n\"</span></div></pre></td></tr></table></figure>\n<ul>\n<li>启动consul client节点(任意数量或不部署), 在需要部署的机器上执行(需修改svrnodes列表):</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\"></div><div class=\"line\">conf_dir=/opt/consul/conf</div><div class=\"line\">mkdir -p <span class=\"variable\">$&#123;conf_dir&#125;</span></div><div class=\"line\"></div><div class=\"line\">svrnodes=(</div><div class=\"line\">10.220.16.133</div><div class=\"line\">10.220.16.134</div><div class=\"line\">10.220.16.163</div><div class=\"line\">)</div><div class=\"line\">privIP=$(/sbin/ifconfig eth0 | sed -n <span class=\"string\">'s/.*inet \\(addr:\\)\\?\\([0-9.]\\&#123;7,15\\&#125;\\) .*/\\2/p'</span>)</div><div class=\"line\">consul_ver=0.8.5</div><div class=\"line\">retry_interval=15s</div><div class=\"line\">contain_cli_name=consul_client</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"string\">\"<span class=\"variable\">$&#123;svrnodes[@]&#125;</span>\"</span> =~ <span class=\"variable\">$privIP</span> ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> -e <span class=\"string\">\"Current node:<span class=\"variable\">$&#123;privIP&#125;</span> is configured for server consul, not to run client mode.\\n\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\">svr_runing=$(docker ps -a | grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_cli_name&#125;</span>\"</span> | egrep <span class=\"string\">\"Up [About]|[0-9]&#123;1,&#125;\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;svr_runing&#125;</span> != <span class=\"string\">\"\"</span> ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> -e <span class=\"string\">\"Current container of consul client has been running.\\n\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">    svr_exists=$(docker ps -a | grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_cli_name&#125;</span>\"</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;svr_exists&#125;</span> != <span class=\"string\">\"\"</span> ]];</div><div class=\"line\">    <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> -e <span class=\"string\">\"Now try to start the container as it stopped...\\n\"</span></div><div class=\"line\">        docker start <span class=\"variable\">$&#123;svr_exists&#125;</span></div><div class=\"line\">        sleep 2</div><div class=\"line\">        docker ps -a grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_cli_name&#125;</span>\"</span></div><div class=\"line\">        <span class=\"built_in\">exit</span></div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"To start a new container for consul...\\n\"</span></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"To initialize configuration...\\n\"</span></div><div class=\"line\"></div><div class=\"line\">nodels=<span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"keyword\">for</span> host <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;svrnodes[*]&#125;</span></div><div class=\"line\"><span class=\"keyword\">do</span></div><div class=\"line\">    <span class=\"keyword\">if</span> [[ <span class=\"variable\">$nodels</span> != <span class=\"string\">\"\"</span> ]];</div><div class=\"line\">    <span class=\"keyword\">then</span></div><div class=\"line\">        nodels=<span class=\"variable\">$nodels</span>,</div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\">    nodels=<span class=\"variable\">$nodels</span><span class=\"string\">\"\\\"<span class=\"variable\">$host</span>\\\"\"</span></div><div class=\"line\"><span class=\"keyword\">done</span></div><div class=\"line\"></div><div class=\"line\">config=<span class=\"string\">\"&#123;\\n</span></div><div class=\"line\">\\\"retry_join\\\": [<span class=\"variable\">$&#123;nodels&#125;</span>],\\n</div><div class=\"line\">\\\"retry_interval\\\": \\\"<span class=\"variable\">$&#123;retry_interval&#125;</span>\\\",\\n</div><div class=\"line\">\\\"rejoin_after_leave\\\": true,\\n</div><div class=\"line\">\\\"start_join\\\": [<span class=\"variable\">$&#123;nodels&#125;</span>],\\n</div><div class=\"line\">\\\"server\\\": false,\\n</div><div class=\"line\">\\\"ui\\\": true,\\n</div><div class=\"line\">\\\"node_name\\\": \\\"<span class=\"variable\">$HOSTNAME</span>\\\"\\n</div><div class=\"line\">&#125;\\n\"</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$config</span></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"variable\">$&#123;config&#125;</span> &gt; <span class=\"variable\">$&#123;conf_dir&#125;</span>/client.json</div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"variable\">$&#123;config&#125;</span></div><div class=\"line\"></div><div class=\"line\">docker run -d -v <span class=\"variable\">$&#123;conf_dir&#125;</span>:<span class=\"variable\">$&#123;conf_dir&#125;</span> \\</div><div class=\"line\">    --name <span class=\"variable\">$&#123;contain_cli_name&#125;</span> \\</div><div class=\"line\">    --net=host consul:<span class=\"variable\">$&#123;consul_ver&#125;</span> agent \\</div><div class=\"line\">    -config-dir=<span class=\"variable\">$&#123;conf_dir&#125;</span> \\</div><div class=\"line\">    -client=0.0.0.0 \\</div><div class=\"line\">    -advertise=<span class=\"variable\">$&#123;privIP&#125;</span></div><div class=\"line\"></div><div class=\"line\">sleep 2</div><div class=\"line\"></div><div class=\"line\">svr_runing=$(docker ps -a | grep <span class=\"string\">\"<span class=\"variable\">$&#123;contain_cli_name&#125;</span>\"</span> | egrep <span class=\"string\">\"Up [About]|[0-9]&#123;1,&#125;\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;svr_runing&#125;</span> == <span class=\"string\">\"\"</span> ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\nError: docker-consul client node failed to start...\\n\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\nOK: docker-consul has started as a client node.\\n\"</span></div></pre></td></tr></table></figure>\n<ul>\n<li><p>检查集群的状态</p>\n<p>通过webUI地址: <strong><em>http://&lt;其中一个节点ip&gt;:8500/ui/</em></strong>可查看集群状态，正常情况下会显示<strong><em>3 passing</em></strong>。<br><br>通过docker命令行:<br></p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@hadoop:~<span class=\"comment\"># docker exec -it consul_server consul members</span></div><div class=\"line\">Node                          Address             Status  Type    Build  Protocol  DC</div><div class=\"line\">hadoop.slave01.fs.115cdn.net  10.220.16.133:8301  alive   server  0.8.5  2         dc1</div><div class=\"line\">hadoop.slave02.fs.115cdn.net  10.220.16.134:8301  alive   server  0.8.5  2         dc1</div><div class=\"line\">hadoop.slave03.fs.115cdn.net  10.220.16.163:8301  alive   server  0.8.5  2         dc1</div><div class=\"line\">hadoop.slave04.fs.115cdn.net  10.220.16.125:8301  alive   client  0.8.5  2         dc1</div></pre></td></tr></table></figure>"},{"title":"[分布式trace]在Ubuntu17.10上部署jaeger","date":"2018-06-18T08:56:24.000Z","_content":"\n## 关于Jaeger\n\nJaeger是由Uber发布的一种分布式调用链跟踪系统，主要用于集成到微服务调用追踪，和Zipkin作用类似。通过调用链跟踪系统，可以快速了解各节点的响应状况，方便定位问题。\n\n## Jaeger关键组件\n\nJaeger本身是一种可单独部署运行的服务，主要有以下几个关键组件：\n\n- 数据存储Cassandra\n- 数据收集jaeger-collector\n- 客户端代理jaeger-agent\n- 客户端库jaeger-client\n- 数据库代理jaeger-query\n- UI查询jaeger-ui\n\n<!--more-->\n\n## 部署cassandra\n\n首先通过`docker pull`的方式将cassandra镜像拉取下来：\n\n```shell\n$docker pull docker.io/cassandra\n```\n\n假设这里要部署的cassandra集群为两个节点，利用docker-compose来进行服务编排。\n接着是创建一个`docker-compose.yml`文件，并设置好编排内容：\n\n```yml\nversion: '2'\nservices:\n\n###############################\n   cassandra0:\n    image: cassandra\n    container_name: cassandra0\n    ports:\n     - 9042:9042\n     - 7199:7199\n    mem_limit: 1024M\n\n###############################\n   cassandra1:\n    image: cassandra\n    container_name: cassandra1\n    ports:\n     - 9142:9042\n    links:\n     - cassandra0:seed\n    environment:\n     - CASSANDRA_SEEDS=seed\n    mem_limit: 1024M\n```\n\nyml文件设置好后在docker中启动canssandra的两个节点：\n\n```shell\n$docker-compose up -d\nCreating cassandra0 ...\nCreating cassandra0 done\nCreating cassandra1 ...\nCreating cassandra1 done\n```\n\n容器节点起来后，检查一下cassandra的运行状态：\n\n```shell\n$docker exec cassandra0 nodetool status\nDatacenter: datacenter1\n=======================\nStatus=Up/Down\n|/ State=Normal/Leaving/Joining/Moving\n--  Address     Load       Tokens       Owns (effective)  Host ID                               Rack\nUN  172.18.0.2  204.5 KiB  256          100.0%            d7363c7e-6365-4f43-9f0d-cb75797954f7  rack1\nUN  172.18.0.3  226.09 KiB  256          100.0%            0ef2f23d-8dbf-4bf0-a73e-f3cf0b65ff1b  rack1\n```\n可以看到两个节点的状态都是`UN`, UP-Normal, 运行正常。\n\n## 在Cassandra中创建Jaeger相关表\n\n这一步主要是先找到jaegertracing项目中用来初始化表的v001.cql.templ及create.sh脚本，\n然后通过cqlsh命令来执行相关初始化操作：\n\n```shell\n$pip install cqlsh\n$cd $GOPATH/src/github.com/jaegertracing/jaeger/plugin/storage/cassandra/schema/\n$DATACENTER=dc1 REPLICATION_FACTOR=1 MODE=prod ./create.sh v001.cql.templ | cqlsh --cqlversion=3.4.4\nUsing template file v001.cql.templ with parameters:\n    mode = prod\n    datacenter = dc1\n    keyspace = jaeger_v1_dc1\n    replication = {'class': 'NetworkTopologyStrategy', 'dc1': '1' }\n    trace_ttl = 172800\n    dependencies_ttl = 0\n```\n\n## 部署Jaeger\n\n有了存储服务后，最后一步我们来部署Jaeger相关的服务组件。\n\n### 1. 下载 [Jaeger安装包](https://github.com/jaegertracing/jaeger/releases/download/v1.5.0/jaeger-1.5.0-linux-amd64.tar.gz)\n\n```bash\n$tar -zxvf jaeger-1.5.0-linux-amd64.tar.gz -C /your_path/\n$cd /your_path/\n$mv jaeger-1.5.0-linux-amd64 jaeger\n$cd jaeger\n```\n\n### 2. 部署Collector,Agent,Query\n\n```bash\n$mkdir log\n$nohup ./jaeger-collector --cassandra.keyspace=jaeger_v1_dc1  --cassandra.servers=127.0.0.1 --collector.zipkin.http-port=9411 >> log/collector.log 2>&1 &\n$nohup ./jaeger-agent  --collector.host-port=127.0.0.1:14267 >> log/agent.log 2>&1 &\n$nohup ./jaeger-query --cassandra.keyspace jaeger_v1_dc1  --cassandra.servers 127.0.0.1 --query.static-files=./jaeger-ui-build/build >> log/query.log 2>&1 &\n```\n\n### 3. 打开UI查询页\n\n所有组件都运行起来后，可以这样来访问查询页面， 如打开`http://yourIP:16686/`即可看到主界面：\n![JaegerUI](https://img-blog.csdn.net/20180618132747474?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n","source":"_posts/archi/jaeger-deploy-on-ubuntu.md","raw":"---\ntitle: '[分布式trace]在Ubuntu17.10上部署jaeger'\ndate: 2018-06-18 16:56:24\ntags: [\"tracing\",\"docker\"]\n---\n\n## 关于Jaeger\n\nJaeger是由Uber发布的一种分布式调用链跟踪系统，主要用于集成到微服务调用追踪，和Zipkin作用类似。通过调用链跟踪系统，可以快速了解各节点的响应状况，方便定位问题。\n\n## Jaeger关键组件\n\nJaeger本身是一种可单独部署运行的服务，主要有以下几个关键组件：\n\n- 数据存储Cassandra\n- 数据收集jaeger-collector\n- 客户端代理jaeger-agent\n- 客户端库jaeger-client\n- 数据库代理jaeger-query\n- UI查询jaeger-ui\n\n<!--more-->\n\n## 部署cassandra\n\n首先通过`docker pull`的方式将cassandra镜像拉取下来：\n\n```shell\n$docker pull docker.io/cassandra\n```\n\n假设这里要部署的cassandra集群为两个节点，利用docker-compose来进行服务编排。\n接着是创建一个`docker-compose.yml`文件，并设置好编排内容：\n\n```yml\nversion: '2'\nservices:\n\n###############################\n   cassandra0:\n    image: cassandra\n    container_name: cassandra0\n    ports:\n     - 9042:9042\n     - 7199:7199\n    mem_limit: 1024M\n\n###############################\n   cassandra1:\n    image: cassandra\n    container_name: cassandra1\n    ports:\n     - 9142:9042\n    links:\n     - cassandra0:seed\n    environment:\n     - CASSANDRA_SEEDS=seed\n    mem_limit: 1024M\n```\n\nyml文件设置好后在docker中启动canssandra的两个节点：\n\n```shell\n$docker-compose up -d\nCreating cassandra0 ...\nCreating cassandra0 done\nCreating cassandra1 ...\nCreating cassandra1 done\n```\n\n容器节点起来后，检查一下cassandra的运行状态：\n\n```shell\n$docker exec cassandra0 nodetool status\nDatacenter: datacenter1\n=======================\nStatus=Up/Down\n|/ State=Normal/Leaving/Joining/Moving\n--  Address     Load       Tokens       Owns (effective)  Host ID                               Rack\nUN  172.18.0.2  204.5 KiB  256          100.0%            d7363c7e-6365-4f43-9f0d-cb75797954f7  rack1\nUN  172.18.0.3  226.09 KiB  256          100.0%            0ef2f23d-8dbf-4bf0-a73e-f3cf0b65ff1b  rack1\n```\n可以看到两个节点的状态都是`UN`, UP-Normal, 运行正常。\n\n## 在Cassandra中创建Jaeger相关表\n\n这一步主要是先找到jaegertracing项目中用来初始化表的v001.cql.templ及create.sh脚本，\n然后通过cqlsh命令来执行相关初始化操作：\n\n```shell\n$pip install cqlsh\n$cd $GOPATH/src/github.com/jaegertracing/jaeger/plugin/storage/cassandra/schema/\n$DATACENTER=dc1 REPLICATION_FACTOR=1 MODE=prod ./create.sh v001.cql.templ | cqlsh --cqlversion=3.4.4\nUsing template file v001.cql.templ with parameters:\n    mode = prod\n    datacenter = dc1\n    keyspace = jaeger_v1_dc1\n    replication = {'class': 'NetworkTopologyStrategy', 'dc1': '1' }\n    trace_ttl = 172800\n    dependencies_ttl = 0\n```\n\n## 部署Jaeger\n\n有了存储服务后，最后一步我们来部署Jaeger相关的服务组件。\n\n### 1. 下载 [Jaeger安装包](https://github.com/jaegertracing/jaeger/releases/download/v1.5.0/jaeger-1.5.0-linux-amd64.tar.gz)\n\n```bash\n$tar -zxvf jaeger-1.5.0-linux-amd64.tar.gz -C /your_path/\n$cd /your_path/\n$mv jaeger-1.5.0-linux-amd64 jaeger\n$cd jaeger\n```\n\n### 2. 部署Collector,Agent,Query\n\n```bash\n$mkdir log\n$nohup ./jaeger-collector --cassandra.keyspace=jaeger_v1_dc1  --cassandra.servers=127.0.0.1 --collector.zipkin.http-port=9411 >> log/collector.log 2>&1 &\n$nohup ./jaeger-agent  --collector.host-port=127.0.0.1:14267 >> log/agent.log 2>&1 &\n$nohup ./jaeger-query --cassandra.keyspace jaeger_v1_dc1  --cassandra.servers 127.0.0.1 --query.static-files=./jaeger-ui-build/build >> log/query.log 2>&1 &\n```\n\n### 3. 打开UI查询页\n\n所有组件都运行起来后，可以这样来访问查询页面， 如打开`http://yourIP:16686/`即可看到主界面：\n![JaegerUI](https://img-blog.csdn.net/20180618132747474?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n","slug":"archi/jaeger-deploy-on-ubuntu","published":1,"updated":"2018-06-18T09:06:26.603Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dvt000p4j4d1feaqinl","content":"<h2 id=\"关于Jaeger\"><a href=\"#关于Jaeger\" class=\"headerlink\" title=\"关于Jaeger\"></a>关于Jaeger</h2><p>Jaeger是由Uber发布的一种分布式调用链跟踪系统，主要用于集成到微服务调用追踪，和Zipkin作用类似。通过调用链跟踪系统，可以快速了解各节点的响应状况，方便定位问题。</p>\n<h2 id=\"Jaeger关键组件\"><a href=\"#Jaeger关键组件\" class=\"headerlink\" title=\"Jaeger关键组件\"></a>Jaeger关键组件</h2><p>Jaeger本身是一种可单独部署运行的服务，主要有以下几个关键组件：</p>\n<ul>\n<li>数据存储Cassandra</li>\n<li>数据收集jaeger-collector</li>\n<li>客户端代理jaeger-agent</li>\n<li>客户端库jaeger-client</li>\n<li>数据库代理jaeger-query</li>\n<li>UI查询jaeger-ui</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"部署cassandra\"><a href=\"#部署cassandra\" class=\"headerlink\" title=\"部署cassandra\"></a>部署cassandra</h2><p>首先通过<code>docker pull</code>的方式将cassandra镜像拉取下来：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">docker pull docker.io/cassandra</span></div></pre></td></tr></table></figure>\n<p>假设这里要部署的cassandra集群为两个节点，利用docker-compose来进行服务编排。<br>接着是创建一个<code>docker-compose.yml</code>文件，并设置好编排内容：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'2'</span></div><div class=\"line\"><span class=\"attr\">services:</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">###############################</span></div><div class=\"line\"><span class=\"attr\">   cassandra0:</span></div><div class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">cassandra</span></div><div class=\"line\"><span class=\"attr\">    container_name:</span> <span class=\"string\">cassandra0</span></div><div class=\"line\"><span class=\"attr\">    ports:</span></div><div class=\"line\"><span class=\"bullet\">     -</span> <span class=\"number\">9042</span><span class=\"string\">:9042</span></div><div class=\"line\"><span class=\"bullet\">     -</span> <span class=\"number\">7199</span><span class=\"string\">:7199</span></div><div class=\"line\"><span class=\"attr\">    mem_limit:</span> <span class=\"number\">1024</span><span class=\"string\">M</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">###############################</span></div><div class=\"line\"><span class=\"attr\">   cassandra1:</span></div><div class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">cassandra</span></div><div class=\"line\"><span class=\"attr\">    container_name:</span> <span class=\"string\">cassandra1</span></div><div class=\"line\"><span class=\"attr\">    ports:</span></div><div class=\"line\"><span class=\"bullet\">     -</span> <span class=\"number\">9142</span><span class=\"string\">:9042</span></div><div class=\"line\"><span class=\"attr\">    links:</span></div><div class=\"line\"><span class=\"attr\">     - cassandra0:</span><span class=\"string\">seed</span></div><div class=\"line\"><span class=\"attr\">    environment:</span></div><div class=\"line\"><span class=\"bullet\">     -</span> <span class=\"string\">CASSANDRA_SEEDS=seed</span></div><div class=\"line\"><span class=\"attr\">    mem_limit:</span> <span class=\"number\">1024</span><span class=\"string\">M</span></div></pre></td></tr></table></figure>\n<p>yml文件设置好后在docker中启动canssandra的两个节点：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">docker-compose up -d</span></div><div class=\"line\">Creating cassandra0 ...</div><div class=\"line\">Creating cassandra0 done</div><div class=\"line\">Creating cassandra1 ...</div><div class=\"line\">Creating cassandra1 done</div></pre></td></tr></table></figure>\n<p>容器节点起来后，检查一下cassandra的运行状态：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">docker <span class=\"built_in\">exec</span> cassandra0 nodetool status</span></div><div class=\"line\">Datacenter: datacenter1</div><div class=\"line\">=======================</div><div class=\"line\">Status=Up/Down</div><div class=\"line\">|/ State=Normal/Leaving/Joining/Moving</div><div class=\"line\">--  Address     Load       Tokens       Owns (effective)  Host ID                               Rack</div><div class=\"line\">UN  172.18.0.2  204.5 KiB  256          100.0%            d7363c7e-6365-4f43-9f0d-cb75797954f7  rack1</div><div class=\"line\">UN  172.18.0.3  226.09 KiB  256          100.0%            0ef2f23d-8dbf-4bf0-a73e-f3cf0b65ff1b  rack1</div></pre></td></tr></table></figure>\n<p>可以看到两个节点的状态都是<code>UN</code>, UP-Normal, 运行正常。</p>\n<h2 id=\"在Cassandra中创建Jaeger相关表\"><a href=\"#在Cassandra中创建Jaeger相关表\" class=\"headerlink\" title=\"在Cassandra中创建Jaeger相关表\"></a>在Cassandra中创建Jaeger相关表</h2><p>这一步主要是先找到jaegertracing项目中用来初始化表的v001.cql.templ及create.sh脚本，<br>然后通过cqlsh命令来执行相关初始化操作：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">pip install cqlsh</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"><span class=\"built_in\">cd</span> <span class=\"variable\">$GOPATH</span>/src/github.com/jaegertracing/jaeger/plugin/storage/cassandra/schema/</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">DATACENTER=dc1 REPLICATION_FACTOR=1 MODE=prod ./create.sh v001.cql.templ | cqlsh --cqlversion=3.4.4</span></div><div class=\"line\">Using template file v001.cql.templ with parameters:</div><div class=\"line\">    mode = prod</div><div class=\"line\">    datacenter = dc1</div><div class=\"line\">    keyspace = jaeger_v1_dc1</div><div class=\"line\">    replication = &#123;'class': 'NetworkTopologyStrategy', 'dc1': '1' &#125;</div><div class=\"line\">    trace_ttl = 172800</div><div class=\"line\">    dependencies_ttl = 0</div></pre></td></tr></table></figure>\n<h2 id=\"部署Jaeger\"><a href=\"#部署Jaeger\" class=\"headerlink\" title=\"部署Jaeger\"></a>部署Jaeger</h2><p>有了存储服务后，最后一步我们来部署Jaeger相关的服务组件。</p>\n<h3 id=\"1-下载-Jaeger安装包\"><a href=\"#1-下载-Jaeger安装包\" class=\"headerlink\" title=\"1. 下载 Jaeger安装包\"></a>1. 下载 <a href=\"https://github.com/jaegertracing/jaeger/releases/download/v1.5.0/jaeger-1.5.0-linux-amd64.tar.gz\" target=\"_blank\" rel=\"external\">Jaeger安装包</a></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$tar</span> -zxvf jaeger-1.5.0-linux-amd64.tar.gz -C /your_path/</div><div class=\"line\"><span class=\"variable\">$cd</span> /your_path/</div><div class=\"line\"><span class=\"variable\">$mv</span> jaeger-1.5.0-linux-amd64 jaeger</div><div class=\"line\"><span class=\"variable\">$cd</span> jaeger</div></pre></td></tr></table></figure>\n<h3 id=\"2-部署Collector-Agent-Query\"><a href=\"#2-部署Collector-Agent-Query\" class=\"headerlink\" title=\"2. 部署Collector,Agent,Query\"></a>2. 部署Collector,Agent,Query</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$mkdir</span> <span class=\"built_in\">log</span></div><div class=\"line\"><span class=\"variable\">$nohup</span> ./jaeger-collector --cassandra.keyspace=jaeger_v1_dc1  --cassandra.servers=127.0.0.1 --collector.zipkin.http-port=9411 &gt;&gt; <span class=\"built_in\">log</span>/collector.log 2&gt;&amp;1 &amp;</div><div class=\"line\"><span class=\"variable\">$nohup</span> ./jaeger-agent  --collector.host-port=127.0.0.1:14267 &gt;&gt; <span class=\"built_in\">log</span>/agent.log 2&gt;&amp;1 &amp;</div><div class=\"line\"><span class=\"variable\">$nohup</span> ./jaeger-query --cassandra.keyspace jaeger_v1_dc1  --cassandra.servers 127.0.0.1 --query.static-files=./jaeger-ui-build/build &gt;&gt; <span class=\"built_in\">log</span>/query.log 2&gt;&amp;1 &amp;</div></pre></td></tr></table></figure>\n<h3 id=\"3-打开UI查询页\"><a href=\"#3-打开UI查询页\" class=\"headerlink\" title=\"3. 打开UI查询页\"></a>3. 打开UI查询页</h3><p>所有组件都运行起来后，可以这样来访问查询页面， 如打开<code>http://yourIP:16686/</code>即可看到主界面：<br><img src=\"https://img-blog.csdn.net/20180618132747474?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"JaegerUI\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"关于Jaeger\"><a href=\"#关于Jaeger\" class=\"headerlink\" title=\"关于Jaeger\"></a>关于Jaeger</h2><p>Jaeger是由Uber发布的一种分布式调用链跟踪系统，主要用于集成到微服务调用追踪，和Zipkin作用类似。通过调用链跟踪系统，可以快速了解各节点的响应状况，方便定位问题。</p>\n<h2 id=\"Jaeger关键组件\"><a href=\"#Jaeger关键组件\" class=\"headerlink\" title=\"Jaeger关键组件\"></a>Jaeger关键组件</h2><p>Jaeger本身是一种可单独部署运行的服务，主要有以下几个关键组件：</p>\n<ul>\n<li>数据存储Cassandra</li>\n<li>数据收集jaeger-collector</li>\n<li>客户端代理jaeger-agent</li>\n<li>客户端库jaeger-client</li>\n<li>数据库代理jaeger-query</li>\n<li>UI查询jaeger-ui</li>\n</ul>","more":"<h2 id=\"部署cassandra\"><a href=\"#部署cassandra\" class=\"headerlink\" title=\"部署cassandra\"></a>部署cassandra</h2><p>首先通过<code>docker pull</code>的方式将cassandra镜像拉取下来：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">docker pull docker.io/cassandra</span></div></pre></td></tr></table></figure>\n<p>假设这里要部署的cassandra集群为两个节点，利用docker-compose来进行服务编排。<br>接着是创建一个<code>docker-compose.yml</code>文件，并设置好编排内容：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'2'</span></div><div class=\"line\"><span class=\"attr\">services:</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">###############################</span></div><div class=\"line\"><span class=\"attr\">   cassandra0:</span></div><div class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">cassandra</span></div><div class=\"line\"><span class=\"attr\">    container_name:</span> <span class=\"string\">cassandra0</span></div><div class=\"line\"><span class=\"attr\">    ports:</span></div><div class=\"line\"><span class=\"bullet\">     -</span> <span class=\"number\">9042</span><span class=\"string\">:9042</span></div><div class=\"line\"><span class=\"bullet\">     -</span> <span class=\"number\">7199</span><span class=\"string\">:7199</span></div><div class=\"line\"><span class=\"attr\">    mem_limit:</span> <span class=\"number\">1024</span><span class=\"string\">M</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">###############################</span></div><div class=\"line\"><span class=\"attr\">   cassandra1:</span></div><div class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">cassandra</span></div><div class=\"line\"><span class=\"attr\">    container_name:</span> <span class=\"string\">cassandra1</span></div><div class=\"line\"><span class=\"attr\">    ports:</span></div><div class=\"line\"><span class=\"bullet\">     -</span> <span class=\"number\">9142</span><span class=\"string\">:9042</span></div><div class=\"line\"><span class=\"attr\">    links:</span></div><div class=\"line\"><span class=\"attr\">     - cassandra0:</span><span class=\"string\">seed</span></div><div class=\"line\"><span class=\"attr\">    environment:</span></div><div class=\"line\"><span class=\"bullet\">     -</span> <span class=\"string\">CASSANDRA_SEEDS=seed</span></div><div class=\"line\"><span class=\"attr\">    mem_limit:</span> <span class=\"number\">1024</span><span class=\"string\">M</span></div></pre></td></tr></table></figure>\n<p>yml文件设置好后在docker中启动canssandra的两个节点：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">docker-compose up -d</span></div><div class=\"line\">Creating cassandra0 ...</div><div class=\"line\">Creating cassandra0 done</div><div class=\"line\">Creating cassandra1 ...</div><div class=\"line\">Creating cassandra1 done</div></pre></td></tr></table></figure>\n<p>容器节点起来后，检查一下cassandra的运行状态：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">docker <span class=\"built_in\">exec</span> cassandra0 nodetool status</span></div><div class=\"line\">Datacenter: datacenter1</div><div class=\"line\">=======================</div><div class=\"line\">Status=Up/Down</div><div class=\"line\">|/ State=Normal/Leaving/Joining/Moving</div><div class=\"line\">--  Address     Load       Tokens       Owns (effective)  Host ID                               Rack</div><div class=\"line\">UN  172.18.0.2  204.5 KiB  256          100.0%            d7363c7e-6365-4f43-9f0d-cb75797954f7  rack1</div><div class=\"line\">UN  172.18.0.3  226.09 KiB  256          100.0%            0ef2f23d-8dbf-4bf0-a73e-f3cf0b65ff1b  rack1</div></pre></td></tr></table></figure>\n<p>可以看到两个节点的状态都是<code>UN</code>, UP-Normal, 运行正常。</p>\n<h2 id=\"在Cassandra中创建Jaeger相关表\"><a href=\"#在Cassandra中创建Jaeger相关表\" class=\"headerlink\" title=\"在Cassandra中创建Jaeger相关表\"></a>在Cassandra中创建Jaeger相关表</h2><p>这一步主要是先找到jaegertracing项目中用来初始化表的v001.cql.templ及create.sh脚本，<br>然后通过cqlsh命令来执行相关初始化操作：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">pip install cqlsh</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"><span class=\"built_in\">cd</span> <span class=\"variable\">$GOPATH</span>/src/github.com/jaegertracing/jaeger/plugin/storage/cassandra/schema/</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">DATACENTER=dc1 REPLICATION_FACTOR=1 MODE=prod ./create.sh v001.cql.templ | cqlsh --cqlversion=3.4.4</span></div><div class=\"line\">Using template file v001.cql.templ with parameters:</div><div class=\"line\">    mode = prod</div><div class=\"line\">    datacenter = dc1</div><div class=\"line\">    keyspace = jaeger_v1_dc1</div><div class=\"line\">    replication = &#123;'class': 'NetworkTopologyStrategy', 'dc1': '1' &#125;</div><div class=\"line\">    trace_ttl = 172800</div><div class=\"line\">    dependencies_ttl = 0</div></pre></td></tr></table></figure>\n<h2 id=\"部署Jaeger\"><a href=\"#部署Jaeger\" class=\"headerlink\" title=\"部署Jaeger\"></a>部署Jaeger</h2><p>有了存储服务后，最后一步我们来部署Jaeger相关的服务组件。</p>\n<h3 id=\"1-下载-Jaeger安装包\"><a href=\"#1-下载-Jaeger安装包\" class=\"headerlink\" title=\"1. 下载 Jaeger安装包\"></a>1. 下载 <a href=\"https://github.com/jaegertracing/jaeger/releases/download/v1.5.0/jaeger-1.5.0-linux-amd64.tar.gz\" target=\"_blank\" rel=\"external\">Jaeger安装包</a></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$tar</span> -zxvf jaeger-1.5.0-linux-amd64.tar.gz -C /your_path/</div><div class=\"line\"><span class=\"variable\">$cd</span> /your_path/</div><div class=\"line\"><span class=\"variable\">$mv</span> jaeger-1.5.0-linux-amd64 jaeger</div><div class=\"line\"><span class=\"variable\">$cd</span> jaeger</div></pre></td></tr></table></figure>\n<h3 id=\"2-部署Collector-Agent-Query\"><a href=\"#2-部署Collector-Agent-Query\" class=\"headerlink\" title=\"2. 部署Collector,Agent,Query\"></a>2. 部署Collector,Agent,Query</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$mkdir</span> <span class=\"built_in\">log</span></div><div class=\"line\"><span class=\"variable\">$nohup</span> ./jaeger-collector --cassandra.keyspace=jaeger_v1_dc1  --cassandra.servers=127.0.0.1 --collector.zipkin.http-port=9411 &gt;&gt; <span class=\"built_in\">log</span>/collector.log 2&gt;&amp;1 &amp;</div><div class=\"line\"><span class=\"variable\">$nohup</span> ./jaeger-agent  --collector.host-port=127.0.0.1:14267 &gt;&gt; <span class=\"built_in\">log</span>/agent.log 2&gt;&amp;1 &amp;</div><div class=\"line\"><span class=\"variable\">$nohup</span> ./jaeger-query --cassandra.keyspace jaeger_v1_dc1  --cassandra.servers 127.0.0.1 --query.static-files=./jaeger-ui-build/build &gt;&gt; <span class=\"built_in\">log</span>/query.log 2&gt;&amp;1 &amp;</div></pre></td></tr></table></figure>\n<h3 id=\"3-打开UI查询页\"><a href=\"#3-打开UI查询页\" class=\"headerlink\" title=\"3. 打开UI查询页\"></a>3. 打开UI查询页</h3><p>所有组件都运行起来后，可以这样来访问查询页面， 如打开<code>http://yourIP:16686/</code>即可看到主界面：<br><img src=\"https://img-blog.csdn.net/20180618132747474?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"JaegerUI\"></p>"},{"title":"微服务开发之单点登录","date":"2018-07-18T12:07:05.000Z","_content":"\n### 关于CAS\n\nCAS是一种单点登录开源框架，遵循apache2.0协议，代码托管在[github.com/apereo/cas](https://github.com/apereo/cas)上。<br>\n而单点登录(SSO, Single Sign On)可简单理解为当用户在一个应用上登录了，其他被授权信任的关联应用不用再登录。<br>\n比如在同一个浏览器中登录了天猫，再打开淘宝网站时会自动登录，无需单独输用户名密码或扫二维码。以下简单说明下CAS的部署与测试结果。\n<!--more-->\n### 本地测试环境\n\n```\njdk8\ntomcat8.5\ngradle-4.3.1\ncas4.2.7\n```\n\n### 下载及编译cas\n\n```shell\n$wget \"https://github.com/apereo/cas/archive/v4.2.7.tar.gz\"\n$tar -zxf v4.2.7.tar.gz\n$cd cas-4.2.7/cas-server-webapp\n$gradle build\n```\n\n编译完成后可在当前路径的`build/libs/`找到编译打包出来的war文件`cas-server-webapp-4.2.7.war`；将其重命名为`cas.war`后，复制到tomcat的web工作目录`webapps/`下。\n\n### tomcat ssl证书配置\n\n具体流程可参考网上资料，这里暂不展开讨论。配置好ssl证书后，在tomcat目录下的`conf/server.xml`增加类似如下配置：\n\n```xml\n    <Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\n            maxThreads=\"150\" SSLEnabled=\"true\" scheme=\"https\" secure=\"true\"\n            clientAuth=\"false\" sslProtocol=\"TLS\"\n            keystoreFile=\"/Users/apple/Documents/cas/castestkey\"\n            keystorePass=\"xxxx\"/>\n```\n\n### 修改hosts\n\n假设测试环境为本机，我们除了启动一个cas server，还将启动启动两个application server用于单点登录测试。以下为这三个节点的本地host配置：\n```\n127.0.0.1 sso.cas.com\n127.0.0.1 app1.cas.com\n127.0.0.1 app2.cas.com\n```\n\n### 访问cas服务\n\ntomcat起来后，我们可以这样访问cas服务:`https://sso.cas.com:8443/cas/login`<br>\n登录界面如下所示：\n![这里写图片描述](https://img-blog.csdn.net/2018071608483387?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n### 编译并运行测试服务\n\n我的测试代码基于这源码项目进行了部分修改:[https://github.com/willwu1984/springboot-cas-shiro](https://github.com/willwu1984/springboot-cas-shiro)。\n对项目通过`mvn package`命令完成打包后, 在`》/target`下找到可执行文件`cas-0.0.1-SNAPSHOT.jar`。\n启动测试服务：\n```shell\n$java -jar target/cas-0.0.1-SNAPSHOT.jar\n// ...\n2018-07-13 15:32:04.542  INFO 72755 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 18091 (http)\n2018-07-13 15:32:04.547  INFO 72755 --- [           main] cas.Application                          : Started Application in 5.087 seconds (JVM running for 5.65)\n```\n\n这时我们浏览器访问 `http://app1.cas.com:18091/` , 会发现页面首先被重定向到cas登录认证页面：\n\n```\nhttps://sso.cas.com:8443/cas/login?service=http://app1.cas.com:18091/shiro-cas\n```\n\n因为当前并没真正接入数据库，可输入默认用户名:密码(casuser:Mellon)进行测试, 这时会跳转回到测试服务的主页：\n![这里写图片描述](https://img-blog.csdn.net/20180716085032483?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n这时我们运行另外一个测试应用服务，假设地址为 `http://app2.cas.com:18092/`。\n在同一个浏览器中访问该地址时，会发现已经自动完成登录并进入主界面。\n","source":"_posts/archi/microservice-SSO.md","raw":"---\ntitle: 微服务开发之单点登录\ndate: 2018-07-18 20:07:05\ntags: microservice\n---\n\n### 关于CAS\n\nCAS是一种单点登录开源框架，遵循apache2.0协议，代码托管在[github.com/apereo/cas](https://github.com/apereo/cas)上。<br>\n而单点登录(SSO, Single Sign On)可简单理解为当用户在一个应用上登录了，其他被授权信任的关联应用不用再登录。<br>\n比如在同一个浏览器中登录了天猫，再打开淘宝网站时会自动登录，无需单独输用户名密码或扫二维码。以下简单说明下CAS的部署与测试结果。\n<!--more-->\n### 本地测试环境\n\n```\njdk8\ntomcat8.5\ngradle-4.3.1\ncas4.2.7\n```\n\n### 下载及编译cas\n\n```shell\n$wget \"https://github.com/apereo/cas/archive/v4.2.7.tar.gz\"\n$tar -zxf v4.2.7.tar.gz\n$cd cas-4.2.7/cas-server-webapp\n$gradle build\n```\n\n编译完成后可在当前路径的`build/libs/`找到编译打包出来的war文件`cas-server-webapp-4.2.7.war`；将其重命名为`cas.war`后，复制到tomcat的web工作目录`webapps/`下。\n\n### tomcat ssl证书配置\n\n具体流程可参考网上资料，这里暂不展开讨论。配置好ssl证书后，在tomcat目录下的`conf/server.xml`增加类似如下配置：\n\n```xml\n    <Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\n            maxThreads=\"150\" SSLEnabled=\"true\" scheme=\"https\" secure=\"true\"\n            clientAuth=\"false\" sslProtocol=\"TLS\"\n            keystoreFile=\"/Users/apple/Documents/cas/castestkey\"\n            keystorePass=\"xxxx\"/>\n```\n\n### 修改hosts\n\n假设测试环境为本机，我们除了启动一个cas server，还将启动启动两个application server用于单点登录测试。以下为这三个节点的本地host配置：\n```\n127.0.0.1 sso.cas.com\n127.0.0.1 app1.cas.com\n127.0.0.1 app2.cas.com\n```\n\n### 访问cas服务\n\ntomcat起来后，我们可以这样访问cas服务:`https://sso.cas.com:8443/cas/login`<br>\n登录界面如下所示：\n![这里写图片描述](https://img-blog.csdn.net/2018071608483387?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n### 编译并运行测试服务\n\n我的测试代码基于这源码项目进行了部分修改:[https://github.com/willwu1984/springboot-cas-shiro](https://github.com/willwu1984/springboot-cas-shiro)。\n对项目通过`mvn package`命令完成打包后, 在`》/target`下找到可执行文件`cas-0.0.1-SNAPSHOT.jar`。\n启动测试服务：\n```shell\n$java -jar target/cas-0.0.1-SNAPSHOT.jar\n// ...\n2018-07-13 15:32:04.542  INFO 72755 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 18091 (http)\n2018-07-13 15:32:04.547  INFO 72755 --- [           main] cas.Application                          : Started Application in 5.087 seconds (JVM running for 5.65)\n```\n\n这时我们浏览器访问 `http://app1.cas.com:18091/` , 会发现页面首先被重定向到cas登录认证页面：\n\n```\nhttps://sso.cas.com:8443/cas/login?service=http://app1.cas.com:18091/shiro-cas\n```\n\n因为当前并没真正接入数据库，可输入默认用户名:密码(casuser:Mellon)进行测试, 这时会跳转回到测试服务的主页：\n![这里写图片描述](https://img-blog.csdn.net/20180716085032483?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n这时我们运行另外一个测试应用服务，假设地址为 `http://app2.cas.com:18092/`。\n在同一个浏览器中访问该地址时，会发现已经自动完成登录并进入主界面。\n","slug":"archi/microservice-SSO","published":1,"updated":"2018-07-18T12:08:00.683Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dvu000r4j4d6g0y3nr0","content":"<h3 id=\"关于CAS\"><a href=\"#关于CAS\" class=\"headerlink\" title=\"关于CAS\"></a>关于CAS</h3><p>CAS是一种单点登录开源框架，遵循apache2.0协议，代码托管在<a href=\"https://github.com/apereo/cas\" target=\"_blank\" rel=\"external\">github.com/apereo/cas</a>上。<br><br>而单点登录(SSO, Single Sign On)可简单理解为当用户在一个应用上登录了，其他被授权信任的关联应用不用再登录。<br><br>比如在同一个浏览器中登录了天猫，再打开淘宝网站时会自动登录，无需单独输用户名密码或扫二维码。以下简单说明下CAS的部署与测试结果。<br><a id=\"more\"></a></p>\n<h3 id=\"本地测试环境\"><a href=\"#本地测试环境\" class=\"headerlink\" title=\"本地测试环境\"></a>本地测试环境</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">jdk8</div><div class=\"line\">tomcat8.5</div><div class=\"line\">gradle-4.3.1</div><div class=\"line\">cas4.2.7</div></pre></td></tr></table></figure>\n<h3 id=\"下载及编译cas\"><a href=\"#下载及编译cas\" class=\"headerlink\" title=\"下载及编译cas\"></a>下载及编译cas</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">wget <span class=\"string\">\"https://github.com/apereo/cas/archive/v4.2.7.tar.gz\"</span></span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">tar -zxf v4.2.7.tar.gz</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"><span class=\"built_in\">cd</span> cas-4.2.7/cas-server-webapp</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">gradle build</span></div></pre></td></tr></table></figure>\n<p>编译完成后可在当前路径的<code>build/libs/</code>找到编译打包出来的war文件<code>cas-server-webapp-4.2.7.war</code>；将其重命名为<code>cas.war</code>后，复制到tomcat的web工作目录<code>webapps/</code>下。</p>\n<h3 id=\"tomcat-ssl证书配置\"><a href=\"#tomcat-ssl证书配置\" class=\"headerlink\" title=\"tomcat ssl证书配置\"></a>tomcat ssl证书配置</h3><p>具体流程可参考网上资料，这里暂不展开讨论。配置好ssl证书后，在tomcat目录下的<code>conf/server.xml</code>增加类似如下配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">port</span>=<span class=\"string\">\"8443\"</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"org.apache.coyote.http11.Http11NioProtocol\"</span></span></div><div class=\"line\">        <span class=\"attr\">maxThreads</span>=<span class=\"string\">\"150\"</span> <span class=\"attr\">SSLEnabled</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">scheme</span>=<span class=\"string\">\"https\"</span> <span class=\"attr\">secure</span>=<span class=\"string\">\"true\"</span></div><div class=\"line\">        <span class=\"attr\">clientAuth</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">sslProtocol</span>=<span class=\"string\">\"TLS\"</span></div><div class=\"line\">        <span class=\"attr\">keystoreFile</span>=<span class=\"string\">\"/Users/apple/Documents/cas/castestkey\"</span></div><div class=\"line\">        <span class=\"attr\">keystorePass</span>=<span class=\"string\">\"xxxx\"</span>/&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"修改hosts\"><a href=\"#修改hosts\" class=\"headerlink\" title=\"修改hosts\"></a>修改hosts</h3><p>假设测试环境为本机，我们除了启动一个cas server，还将启动启动两个application server用于单点登录测试。以下为这三个节点的本地host配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">127.0.0.1 sso.cas.com</div><div class=\"line\">127.0.0.1 app1.cas.com</div><div class=\"line\">127.0.0.1 app2.cas.com</div></pre></td></tr></table></figure></p>\n<h3 id=\"访问cas服务\"><a href=\"#访问cas服务\" class=\"headerlink\" title=\"访问cas服务\"></a>访问cas服务</h3><p>tomcat起来后，我们可以这样访问cas服务:<code>https://sso.cas.com:8443/cas/login</code><br><br>登录界面如下所示：<br><img src=\"https://img-blog.csdn.net/2018071608483387?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<h3 id=\"编译并运行测试服务\"><a href=\"#编译并运行测试服务\" class=\"headerlink\" title=\"编译并运行测试服务\"></a>编译并运行测试服务</h3><p>我的测试代码基于这源码项目进行了部分修改:<a href=\"https://github.com/willwu1984/springboot-cas-shiro\" target=\"_blank\" rel=\"external\">https://github.com/willwu1984/springboot-cas-shiro</a>。<br>对项目通过<code>mvn package</code>命令完成打包后, 在<code>》/target</code>下找到可执行文件<code>cas-0.0.1-SNAPSHOT.jar</code>。<br>启动测试服务：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">java -jar target/cas-0.0.1-SNAPSHOT.jar</span></div><div class=\"line\">// ...</div><div class=\"line\">2018-07-13 15:32:04.542  INFO 72755 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 18091 (http)</div><div class=\"line\">2018-07-13 15:32:04.547  INFO 72755 --- [           main] cas.Application                          : Started Application in 5.087 seconds (JVM running for 5.65)</div></pre></td></tr></table></figure></p>\n<p>这时我们浏览器访问 <code>http://app1.cas.com:18091/</code> , 会发现页面首先被重定向到cas登录认证页面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://sso.cas.com:8443/cas/login?service=http://app1.cas.com:18091/shiro-cas</div></pre></td></tr></table></figure>\n<p>因为当前并没真正接入数据库，可输入默认用户名:密码(casuser:Mellon)进行测试, 这时会跳转回到测试服务的主页：<br><img src=\"https://img-blog.csdn.net/20180716085032483?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<p>这时我们运行另外一个测试应用服务，假设地址为 <code>http://app2.cas.com:18092/</code>。<br>在同一个浏览器中访问该地址时，会发现已经自动完成登录并进入主界面。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"关于CAS\"><a href=\"#关于CAS\" class=\"headerlink\" title=\"关于CAS\"></a>关于CAS</h3><p>CAS是一种单点登录开源框架，遵循apache2.0协议，代码托管在<a href=\"https://github.com/apereo/cas\" target=\"_blank\" rel=\"external\">github.com/apereo/cas</a>上。<br><br>而单点登录(SSO, Single Sign On)可简单理解为当用户在一个应用上登录了，其他被授权信任的关联应用不用再登录。<br><br>比如在同一个浏览器中登录了天猫，再打开淘宝网站时会自动登录，无需单独输用户名密码或扫二维码。以下简单说明下CAS的部署与测试结果。<br>","more":"</p>\n<h3 id=\"本地测试环境\"><a href=\"#本地测试环境\" class=\"headerlink\" title=\"本地测试环境\"></a>本地测试环境</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">jdk8</div><div class=\"line\">tomcat8.5</div><div class=\"line\">gradle-4.3.1</div><div class=\"line\">cas4.2.7</div></pre></td></tr></table></figure>\n<h3 id=\"下载及编译cas\"><a href=\"#下载及编译cas\" class=\"headerlink\" title=\"下载及编译cas\"></a>下载及编译cas</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">wget <span class=\"string\">\"https://github.com/apereo/cas/archive/v4.2.7.tar.gz\"</span></span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">tar -zxf v4.2.7.tar.gz</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"><span class=\"built_in\">cd</span> cas-4.2.7/cas-server-webapp</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">gradle build</span></div></pre></td></tr></table></figure>\n<p>编译完成后可在当前路径的<code>build/libs/</code>找到编译打包出来的war文件<code>cas-server-webapp-4.2.7.war</code>；将其重命名为<code>cas.war</code>后，复制到tomcat的web工作目录<code>webapps/</code>下。</p>\n<h3 id=\"tomcat-ssl证书配置\"><a href=\"#tomcat-ssl证书配置\" class=\"headerlink\" title=\"tomcat ssl证书配置\"></a>tomcat ssl证书配置</h3><p>具体流程可参考网上资料，这里暂不展开讨论。配置好ssl证书后，在tomcat目录下的<code>conf/server.xml</code>增加类似如下配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">port</span>=<span class=\"string\">\"8443\"</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"org.apache.coyote.http11.Http11NioProtocol\"</span></span></div><div class=\"line\">        <span class=\"attr\">maxThreads</span>=<span class=\"string\">\"150\"</span> <span class=\"attr\">SSLEnabled</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">scheme</span>=<span class=\"string\">\"https\"</span> <span class=\"attr\">secure</span>=<span class=\"string\">\"true\"</span></div><div class=\"line\">        <span class=\"attr\">clientAuth</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">sslProtocol</span>=<span class=\"string\">\"TLS\"</span></div><div class=\"line\">        <span class=\"attr\">keystoreFile</span>=<span class=\"string\">\"/Users/apple/Documents/cas/castestkey\"</span></div><div class=\"line\">        <span class=\"attr\">keystorePass</span>=<span class=\"string\">\"xxxx\"</span>/&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"修改hosts\"><a href=\"#修改hosts\" class=\"headerlink\" title=\"修改hosts\"></a>修改hosts</h3><p>假设测试环境为本机，我们除了启动一个cas server，还将启动启动两个application server用于单点登录测试。以下为这三个节点的本地host配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">127.0.0.1 sso.cas.com</div><div class=\"line\">127.0.0.1 app1.cas.com</div><div class=\"line\">127.0.0.1 app2.cas.com</div></pre></td></tr></table></figure></p>\n<h3 id=\"访问cas服务\"><a href=\"#访问cas服务\" class=\"headerlink\" title=\"访问cas服务\"></a>访问cas服务</h3><p>tomcat起来后，我们可以这样访问cas服务:<code>https://sso.cas.com:8443/cas/login</code><br><br>登录界面如下所示：<br><img src=\"https://img-blog.csdn.net/2018071608483387?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<h3 id=\"编译并运行测试服务\"><a href=\"#编译并运行测试服务\" class=\"headerlink\" title=\"编译并运行测试服务\"></a>编译并运行测试服务</h3><p>我的测试代码基于这源码项目进行了部分修改:<a href=\"https://github.com/willwu1984/springboot-cas-shiro\" target=\"_blank\" rel=\"external\">https://github.com/willwu1984/springboot-cas-shiro</a>。<br>对项目通过<code>mvn package</code>命令完成打包后, 在<code>》/target</code>下找到可执行文件<code>cas-0.0.1-SNAPSHOT.jar</code>。<br>启动测试服务：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">java -jar target/cas-0.0.1-SNAPSHOT.jar</span></div><div class=\"line\">// ...</div><div class=\"line\">2018-07-13 15:32:04.542  INFO 72755 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 18091 (http)</div><div class=\"line\">2018-07-13 15:32:04.547  INFO 72755 --- [           main] cas.Application                          : Started Application in 5.087 seconds (JVM running for 5.65)</div></pre></td></tr></table></figure></p>\n<p>这时我们浏览器访问 <code>http://app1.cas.com:18091/</code> , 会发现页面首先被重定向到cas登录认证页面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://sso.cas.com:8443/cas/login?service=http://app1.cas.com:18091/shiro-cas</div></pre></td></tr></table></figure>\n<p>因为当前并没真正接入数据库，可输入默认用户名:密码(casuser:Mellon)进行测试, 这时会跳转回到测试服务的主页：<br><img src=\"https://img-blog.csdn.net/20180716085032483?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<p>这时我们运行另外一个测试应用服务，假设地址为 <code>http://app2.cas.com:18092/</code>。<br>在同一个浏览器中访问该地址时，会发现已经自动完成登录并进入主界面。</p>"},{"title":"微服务开发之熔断器","date":"2018-06-22T09:57:12.000Z","_content":"\n一般在微服架构中，有一个组件角色叫熔断器。顾名思义，熔断器起的作用就是在特定的场景下关掉当前的通路，从而起到保护整个系统的效果。\n在微服务架构中，一般我们的独立服务是比较多的，每个独立服务之间划分责任边界，并通过约定协议接口来进行通信。当我们的调用链路复杂依赖多时，很可能会发生雪崩效应。\n假设有这么一个场景，有A, B, C, D四个独立服务，A会依赖B，C，D；当D发生负载过高或网络异常等导致响应过慢或超时时，很可能A会因此堆积过多的等待链接，从而导致A的状态也转为异常，后面依赖到A的其他服务跟着发生链式反应，这将会导致大面积的服务不可用，即使本来是一些没有依赖到B，C，D的服务。如下图所示：\n<!--more-->\n![circuitbreaker](/img/state1.png)\n这是我们不希望看到的结果，所以这个时候熔断器可以派上用场。最简单的做法，我们为每个依赖服务配置一个熔断器开关，正常情况下是关闭的，也就是可以正常发起请求；当请求失败(超时或者其他异常)次数超过预设值时，熔断器自动打开，这时所有经过这个熔断器的请求都会直接返回失败，并没有真正到达所依赖的服务上。这时服务A本身仍然是能正常服务的， 如下图所示：\n![circuitbreaker](/img/state2.png)\n那么熔断器具体又是怎么工作的呢？来看下，一个拥有基本功能的熔断器的状态机大体是这样子的：\n![circuitbreaker](/img/circuitbreaker2.png)\n主要在三种状态中转换：\n\n- 关闭状态\n当熔断器处于关闭状态时，请求是可以被放行的；\n当熔断器统计的失败次数触发开关时，转为打开状态。\n- 打开状态\n当熔断器处于打开状态时，所有请求都是不被放行的，直接返回失败；\n只有在经过一个设定的时间窗口周期后，熔断器才会转换到半开状态\n- 半开状态\n当熔断器处于半开状态时，当前只能有一个请求被放行；\n这个被放行的请求获得远端服务的响应后，假如是成功的，熔断器转换为关闭状态，否则转换到打开状态。\n\n基于这个状态机，我用Golang实现了一个只包含最基本功能的熔断器：[`github.com/moxiaomomo/circuitbreaker`](https://github.com/moxiaomomo/circuitbreaker)， 有兴趣可以参考一下，也欢迎指正。\n\n主要用法如下：\n\n```golang\n// 创建一个熔断器实例，指定熔断时间窗口和失败触发开关阈值等\ncbs := NewCirucuitBreaker(time.Second, 150, 20)\n// 向熔断器注册command(可以理解为对应的服务请求id)\ntestcmd := \"call_serviceB\"\nsuc := cbs.RegisterCommandAsDefault(testcmd)\n\n// 向熔断器报告当前command的执行结果(成功或失败)\ncbs.Report(testcmd, false)\ncbs.Report(testcmd, true)\n// ...\n\n// 向熔断器询问当前该command是否能被执行\nexecAllow := cbs.AllowExec(testcmd)\n```\n","source":"_posts/archi/microservice-circuitbreaker.md","raw":"---\ntitle: 微服务开发之熔断器\ndate: 2018-06-22 17:57:12\ntags: ['microservice','golang']\n---\n\n一般在微服架构中，有一个组件角色叫熔断器。顾名思义，熔断器起的作用就是在特定的场景下关掉当前的通路，从而起到保护整个系统的效果。\n在微服务架构中，一般我们的独立服务是比较多的，每个独立服务之间划分责任边界，并通过约定协议接口来进行通信。当我们的调用链路复杂依赖多时，很可能会发生雪崩效应。\n假设有这么一个场景，有A, B, C, D四个独立服务，A会依赖B，C，D；当D发生负载过高或网络异常等导致响应过慢或超时时，很可能A会因此堆积过多的等待链接，从而导致A的状态也转为异常，后面依赖到A的其他服务跟着发生链式反应，这将会导致大面积的服务不可用，即使本来是一些没有依赖到B，C，D的服务。如下图所示：\n<!--more-->\n![circuitbreaker](/img/state1.png)\n这是我们不希望看到的结果，所以这个时候熔断器可以派上用场。最简单的做法，我们为每个依赖服务配置一个熔断器开关，正常情况下是关闭的，也就是可以正常发起请求；当请求失败(超时或者其他异常)次数超过预设值时，熔断器自动打开，这时所有经过这个熔断器的请求都会直接返回失败，并没有真正到达所依赖的服务上。这时服务A本身仍然是能正常服务的， 如下图所示：\n![circuitbreaker](/img/state2.png)\n那么熔断器具体又是怎么工作的呢？来看下，一个拥有基本功能的熔断器的状态机大体是这样子的：\n![circuitbreaker](/img/circuitbreaker2.png)\n主要在三种状态中转换：\n\n- 关闭状态\n当熔断器处于关闭状态时，请求是可以被放行的；\n当熔断器统计的失败次数触发开关时，转为打开状态。\n- 打开状态\n当熔断器处于打开状态时，所有请求都是不被放行的，直接返回失败；\n只有在经过一个设定的时间窗口周期后，熔断器才会转换到半开状态\n- 半开状态\n当熔断器处于半开状态时，当前只能有一个请求被放行；\n这个被放行的请求获得远端服务的响应后，假如是成功的，熔断器转换为关闭状态，否则转换到打开状态。\n\n基于这个状态机，我用Golang实现了一个只包含最基本功能的熔断器：[`github.com/moxiaomomo/circuitbreaker`](https://github.com/moxiaomomo/circuitbreaker)， 有兴趣可以参考一下，也欢迎指正。\n\n主要用法如下：\n\n```golang\n// 创建一个熔断器实例，指定熔断时间窗口和失败触发开关阈值等\ncbs := NewCirucuitBreaker(time.Second, 150, 20)\n// 向熔断器注册command(可以理解为对应的服务请求id)\ntestcmd := \"call_serviceB\"\nsuc := cbs.RegisterCommandAsDefault(testcmd)\n\n// 向熔断器报告当前command的执行结果(成功或失败)\ncbs.Report(testcmd, false)\ncbs.Report(testcmd, true)\n// ...\n\n// 向熔断器询问当前该command是否能被执行\nexecAllow := cbs.AllowExec(testcmd)\n```\n","slug":"archi/microservice-circuitbreaker","published":1,"updated":"2018-06-22T10:04:51.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dvv000t4j4d2pqykzrz","content":"<p>一般在微服架构中，有一个组件角色叫熔断器。顾名思义，熔断器起的作用就是在特定的场景下关掉当前的通路，从而起到保护整个系统的效果。<br>在微服务架构中，一般我们的独立服务是比较多的，每个独立服务之间划分责任边界，并通过约定协议接口来进行通信。当我们的调用链路复杂依赖多时，很可能会发生雪崩效应。<br>假设有这么一个场景，有A, B, C, D四个独立服务，A会依赖B，C，D；当D发生负载过高或网络异常等导致响应过慢或超时时，很可能A会因此堆积过多的等待链接，从而导致A的状态也转为异常，后面依赖到A的其他服务跟着发生链式反应，这将会导致大面积的服务不可用，即使本来是一些没有依赖到B，C，D的服务。如下图所示：<br><a id=\"more\"></a><br><img src=\"/img/state1.png\" alt=\"circuitbreaker\"><br>这是我们不希望看到的结果，所以这个时候熔断器可以派上用场。最简单的做法，我们为每个依赖服务配置一个熔断器开关，正常情况下是关闭的，也就是可以正常发起请求；当请求失败(超时或者其他异常)次数超过预设值时，熔断器自动打开，这时所有经过这个熔断器的请求都会直接返回失败，并没有真正到达所依赖的服务上。这时服务A本身仍然是能正常服务的， 如下图所示：<br><img src=\"/img/state2.png\" alt=\"circuitbreaker\"><br>那么熔断器具体又是怎么工作的呢？来看下，一个拥有基本功能的熔断器的状态机大体是这样子的：<br><img src=\"/img/circuitbreaker2.png\" alt=\"circuitbreaker\"><br>主要在三种状态中转换：</p>\n<ul>\n<li>关闭状态<br>当熔断器处于关闭状态时，请求是可以被放行的；<br>当熔断器统计的失败次数触发开关时，转为打开状态。</li>\n<li>打开状态<br>当熔断器处于打开状态时，所有请求都是不被放行的，直接返回失败；<br>只有在经过一个设定的时间窗口周期后，熔断器才会转换到半开状态</li>\n<li>半开状态<br>当熔断器处于半开状态时，当前只能有一个请求被放行；<br>这个被放行的请求获得远端服务的响应后，假如是成功的，熔断器转换为关闭状态，否则转换到打开状态。</li>\n</ul>\n<p>基于这个状态机，我用Golang实现了一个只包含最基本功能的熔断器：<a href=\"https://github.com/moxiaomomo/circuitbreaker\" target=\"_blank\" rel=\"external\"><code>github.com/moxiaomomo/circuitbreaker</code></a>， 有兴趣可以参考一下，也欢迎指正。</p>\n<p>主要用法如下：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建一个熔断器实例，指定熔断时间窗口和失败触发开关阈值等</span></div><div class=\"line\">cbs := NewCirucuitBreaker(time.Second, <span class=\"number\">150</span>, <span class=\"number\">20</span>)</div><div class=\"line\"><span class=\"comment\">// 向熔断器注册command(可以理解为对应的服务请求id)</span></div><div class=\"line\">testcmd := <span class=\"string\">\"call_serviceB\"</span></div><div class=\"line\">suc := cbs.RegisterCommandAsDefault(testcmd)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 向熔断器报告当前command的执行结果(成功或失败)</span></div><div class=\"line\">cbs.Report(testcmd, <span class=\"literal\">false</span>)</div><div class=\"line\">cbs.Report(testcmd, <span class=\"literal\">true</span>)</div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 向熔断器询问当前该command是否能被执行</span></div><div class=\"line\">execAllow := cbs.AllowExec(testcmd)</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>一般在微服架构中，有一个组件角色叫熔断器。顾名思义，熔断器起的作用就是在特定的场景下关掉当前的通路，从而起到保护整个系统的效果。<br>在微服务架构中，一般我们的独立服务是比较多的，每个独立服务之间划分责任边界，并通过约定协议接口来进行通信。当我们的调用链路复杂依赖多时，很可能会发生雪崩效应。<br>假设有这么一个场景，有A, B, C, D四个独立服务，A会依赖B，C，D；当D发生负载过高或网络异常等导致响应过慢或超时时，很可能A会因此堆积过多的等待链接，从而导致A的状态也转为异常，后面依赖到A的其他服务跟着发生链式反应，这将会导致大面积的服务不可用，即使本来是一些没有依赖到B，C，D的服务。如下图所示：<br>","more":"<br><img src=\"/img/state1.png\" alt=\"circuitbreaker\"><br>这是我们不希望看到的结果，所以这个时候熔断器可以派上用场。最简单的做法，我们为每个依赖服务配置一个熔断器开关，正常情况下是关闭的，也就是可以正常发起请求；当请求失败(超时或者其他异常)次数超过预设值时，熔断器自动打开，这时所有经过这个熔断器的请求都会直接返回失败，并没有真正到达所依赖的服务上。这时服务A本身仍然是能正常服务的， 如下图所示：<br><img src=\"/img/state2.png\" alt=\"circuitbreaker\"><br>那么熔断器具体又是怎么工作的呢？来看下，一个拥有基本功能的熔断器的状态机大体是这样子的：<br><img src=\"/img/circuitbreaker2.png\" alt=\"circuitbreaker\"><br>主要在三种状态中转换：</p>\n<ul>\n<li>关闭状态<br>当熔断器处于关闭状态时，请求是可以被放行的；<br>当熔断器统计的失败次数触发开关时，转为打开状态。</li>\n<li>打开状态<br>当熔断器处于打开状态时，所有请求都是不被放行的，直接返回失败；<br>只有在经过一个设定的时间窗口周期后，熔断器才会转换到半开状态</li>\n<li>半开状态<br>当熔断器处于半开状态时，当前只能有一个请求被放行；<br>这个被放行的请求获得远端服务的响应后，假如是成功的，熔断器转换为关闭状态，否则转换到打开状态。</li>\n</ul>\n<p>基于这个状态机，我用Golang实现了一个只包含最基本功能的熔断器：<a href=\"https://github.com/moxiaomomo/circuitbreaker\" target=\"_blank\" rel=\"external\"><code>github.com/moxiaomomo/circuitbreaker</code></a>， 有兴趣可以参考一下，也欢迎指正。</p>\n<p>主要用法如下：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建一个熔断器实例，指定熔断时间窗口和失败触发开关阈值等</span></div><div class=\"line\">cbs := NewCirucuitBreaker(time.Second, <span class=\"number\">150</span>, <span class=\"number\">20</span>)</div><div class=\"line\"><span class=\"comment\">// 向熔断器注册command(可以理解为对应的服务请求id)</span></div><div class=\"line\">testcmd := <span class=\"string\">\"call_serviceB\"</span></div><div class=\"line\">suc := cbs.RegisterCommandAsDefault(testcmd)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 向熔断器报告当前command的执行结果(成功或失败)</span></div><div class=\"line\">cbs.Report(testcmd, <span class=\"literal\">false</span>)</div><div class=\"line\">cbs.Report(testcmd, <span class=\"literal\">true</span>)</div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 向熔断器询问当前该command是否能被执行</span></div><div class=\"line\">execAllow := cbs.AllowExec(testcmd)</div></pre></td></tr></table></figure>"},{"title":"[mysql]python3并发访问分布式mysql表","date":"2017-08-06T07:22:43.000Z","_content":"\n### 场景说明\n假设有一个mysql表被水平切分，分散到多个host中，每个host拥有n个切分表。\n如果需要并发去访问这些表，快速得到查询结果， 应该怎么做呢？\n这里提供一种方案，利用python3的asyncio异步io库及aiomysql异步库去实现这个需求。\n<!--more-->\n\n### 代码演示\n```python\nimport logging\nimport random\nimport asyncio\nfrom aiomysql import create_pool\n\n# 假设mysql表分散在8个host, 每个host有16张子表\nTBLES = {\n    \"192.168.1.01\": \"table_000-015\", # 000-015表示该ip下的表明从table_000一直连续到table_015\n    \"192.168.1.02\": \"table_016-031\",\n    \"192.168.1.03\": \"table_032-047\",\n    \"192.168.1.04\": \"table_048-063\",\n    \"192.168.1.05\": \"table_064-079\",\n    \"192.168.1.06\": \"table_080-095\",\n    \"192.168.1.07\": \"table_096-0111\",\n    \"192.168.1.08\": \"table_112-0127\",\n}\nUSER = \"xxx\"\nPASSWD = \"xxxx\"\n\n# wrapper函数，用于捕捉异常\ndef query_wrapper(func):\n    async def wrapper(*args, **kwargs):\n        try:\n            await func(*args, **kwargs)\n        except Exception as e:\n            print(e)\n    return wrapper\n\n\n# 实际的sql访问处理函数，通过aiomysql实现异步非阻塞请求\n@query_wrapper\nasync def query_do_something(ip, db, table):\n    async with create_pool(host=ip, db=db, user=USER, password=PASSWD) as pool:\n        async with pool.get() as conn:\n            async with conn.cursor() as cur:\n                sql = (\"select xxx from {} where xxxx\")\n                await cur.execute(sql.format(table))\n                res = await cur.fetchall()\n                # then do something...\n\n\n# 生成sql访问队列, 队列的每个元素包含要对某个表进行访问的函数及参数\ndef gen_tasks():\n    tasks = []\n    for ip, tbls in TBLES.items():\n        cols = re.split('_|-', tbls)\n        tblpre = \"_\".join(cols[:-2])\n        min_num = int(cols[-2])\n        max_num = int(cols[-1])\n        for num in range(min_num, max_num+1):\n            tasks.append(\n               (query_do_something, ip, 'your_dbname', '{}_{}'.format(tblpre, num))\n            )\n\n    random.shuffle(tasks)\n    return tasks\n\n# 按批量运行sql访问请求队列\ndef run_tasks(tasks, batch_len):\n    try:\n        for idx in range(0, len(tasks), batch_len):\n            batch_tasks = tasks[idx:idx+batch_len]\n            logging.info(\"current batch, start_idx:%s len:%s\" % (idx, len(batch_tasks)))\n            for i in range(0, len(batch_tasks)):\n                l = batch_tasks[i]\n                batch_tasks[i] = asyncio.ensure_future(\n                    l[0](*l[1:])\n                )\n            loop.run_until_complete(asyncio.gather(*batch_tasks))\n    except Exception as e:\n        logging.warn(e)\n\n# main方法, 通过asyncio实现函数异步调用\ndef main():\n    loop = asyncio.get_event_loop()\n\n    tasks = gen_tasks()\n    batch_len = len(TBLES.keys()) * 5   # all up to you\n    run_tasks(tasks, batch_len)\n\n    loop.close()\n```","source":"_posts/mysql/mysql_concurrent_query.md","raw":"\n---\ntitle: '[mysql]python3并发访问分布式mysql表'\ndate: 2017-08-06 15:22:43\ntags: mysql\n---\n\n### 场景说明\n假设有一个mysql表被水平切分，分散到多个host中，每个host拥有n个切分表。\n如果需要并发去访问这些表，快速得到查询结果， 应该怎么做呢？\n这里提供一种方案，利用python3的asyncio异步io库及aiomysql异步库去实现这个需求。\n<!--more-->\n\n### 代码演示\n```python\nimport logging\nimport random\nimport asyncio\nfrom aiomysql import create_pool\n\n# 假设mysql表分散在8个host, 每个host有16张子表\nTBLES = {\n    \"192.168.1.01\": \"table_000-015\", # 000-015表示该ip下的表明从table_000一直连续到table_015\n    \"192.168.1.02\": \"table_016-031\",\n    \"192.168.1.03\": \"table_032-047\",\n    \"192.168.1.04\": \"table_048-063\",\n    \"192.168.1.05\": \"table_064-079\",\n    \"192.168.1.06\": \"table_080-095\",\n    \"192.168.1.07\": \"table_096-0111\",\n    \"192.168.1.08\": \"table_112-0127\",\n}\nUSER = \"xxx\"\nPASSWD = \"xxxx\"\n\n# wrapper函数，用于捕捉异常\ndef query_wrapper(func):\n    async def wrapper(*args, **kwargs):\n        try:\n            await func(*args, **kwargs)\n        except Exception as e:\n            print(e)\n    return wrapper\n\n\n# 实际的sql访问处理函数，通过aiomysql实现异步非阻塞请求\n@query_wrapper\nasync def query_do_something(ip, db, table):\n    async with create_pool(host=ip, db=db, user=USER, password=PASSWD) as pool:\n        async with pool.get() as conn:\n            async with conn.cursor() as cur:\n                sql = (\"select xxx from {} where xxxx\")\n                await cur.execute(sql.format(table))\n                res = await cur.fetchall()\n                # then do something...\n\n\n# 生成sql访问队列, 队列的每个元素包含要对某个表进行访问的函数及参数\ndef gen_tasks():\n    tasks = []\n    for ip, tbls in TBLES.items():\n        cols = re.split('_|-', tbls)\n        tblpre = \"_\".join(cols[:-2])\n        min_num = int(cols[-2])\n        max_num = int(cols[-1])\n        for num in range(min_num, max_num+1):\n            tasks.append(\n               (query_do_something, ip, 'your_dbname', '{}_{}'.format(tblpre, num))\n            )\n\n    random.shuffle(tasks)\n    return tasks\n\n# 按批量运行sql访问请求队列\ndef run_tasks(tasks, batch_len):\n    try:\n        for idx in range(0, len(tasks), batch_len):\n            batch_tasks = tasks[idx:idx+batch_len]\n            logging.info(\"current batch, start_idx:%s len:%s\" % (idx, len(batch_tasks)))\n            for i in range(0, len(batch_tasks)):\n                l = batch_tasks[i]\n                batch_tasks[i] = asyncio.ensure_future(\n                    l[0](*l[1:])\n                )\n            loop.run_until_complete(asyncio.gather(*batch_tasks))\n    except Exception as e:\n        logging.warn(e)\n\n# main方法, 通过asyncio实现函数异步调用\ndef main():\n    loop = asyncio.get_event_loop()\n\n    tasks = gen_tasks()\n    batch_len = len(TBLES.keys()) * 5   # all up to you\n    run_tasks(tasks, batch_len)\n\n    loop.close()\n```","slug":"mysql/mysql_concurrent_query","published":1,"updated":"2017-08-07T05:47:10.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dvw000v4j4da37txzlk","content":"<h3 id=\"场景说明\"><a href=\"#场景说明\" class=\"headerlink\" title=\"场景说明\"></a>场景说明</h3><p>假设有一个mysql表被水平切分，分散到多个host中，每个host拥有n个切分表。<br>如果需要并发去访问这些表，快速得到查询结果， 应该怎么做呢？<br>这里提供一种方案，利用python3的asyncio异步io库及aiomysql异步库去实现这个需求。<br><a id=\"more\"></a></p>\n<h3 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> logging</div><div class=\"line\"><span class=\"keyword\">import</span> random</div><div class=\"line\"><span class=\"keyword\">import</span> asyncio</div><div class=\"line\"><span class=\"keyword\">from</span> aiomysql <span class=\"keyword\">import</span> create_pool</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 假设mysql表分散在8个host, 每个host有16张子表</span></div><div class=\"line\">TBLES = &#123;</div><div class=\"line\">    <span class=\"string\">\"192.168.1.01\"</span>: <span class=\"string\">\"table_000-015\"</span>, <span class=\"comment\"># 000-015表示该ip下的表明从table_000一直连续到table_015</span></div><div class=\"line\">    <span class=\"string\">\"192.168.1.02\"</span>: <span class=\"string\">\"table_016-031\"</span>,</div><div class=\"line\">    <span class=\"string\">\"192.168.1.03\"</span>: <span class=\"string\">\"table_032-047\"</span>,</div><div class=\"line\">    <span class=\"string\">\"192.168.1.04\"</span>: <span class=\"string\">\"table_048-063\"</span>,</div><div class=\"line\">    <span class=\"string\">\"192.168.1.05\"</span>: <span class=\"string\">\"table_064-079\"</span>,</div><div class=\"line\">    <span class=\"string\">\"192.168.1.06\"</span>: <span class=\"string\">\"table_080-095\"</span>,</div><div class=\"line\">    <span class=\"string\">\"192.168.1.07\"</span>: <span class=\"string\">\"table_096-0111\"</span>,</div><div class=\"line\">    <span class=\"string\">\"192.168.1.08\"</span>: <span class=\"string\">\"table_112-0127\"</span>,</div><div class=\"line\">&#125;</div><div class=\"line\">USER = <span class=\"string\">\"xxx\"</span></div><div class=\"line\">PASSWD = <span class=\"string\">\"xxxx\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># wrapper函数，用于捕捉异常</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">query_wrapper</span><span class=\"params\">(func)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"keyword\">await</span> func(*args, **kwargs)</div><div class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</div><div class=\"line\">            print(e)</div><div class=\"line\">    <span class=\"keyword\">return</span> wrapper</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 实际的sql访问处理函数，通过aiomysql实现异步非阻塞请求</span></div><div class=\"line\"><span class=\"meta\">@query_wrapper</span></div><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">query_do_something</span><span class=\"params\">(ip, db, table)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> create_pool(host=ip, db=db, user=USER, password=PASSWD) <span class=\"keyword\">as</span> pool:</div><div class=\"line\">        <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> pool.get() <span class=\"keyword\">as</span> conn:</div><div class=\"line\">            <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> conn.cursor() <span class=\"keyword\">as</span> cur:</div><div class=\"line\">                sql = (<span class=\"string\">\"select xxx from &#123;&#125; where xxxx\"</span>)</div><div class=\"line\">                <span class=\"keyword\">await</span> cur.execute(sql.format(table))</div><div class=\"line\">                res = <span class=\"keyword\">await</span> cur.fetchall()</div><div class=\"line\">                <span class=\"comment\"># then do something...</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 生成sql访问队列, 队列的每个元素包含要对某个表进行访问的函数及参数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_tasks</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    tasks = []</div><div class=\"line\">    <span class=\"keyword\">for</span> ip, tbls <span class=\"keyword\">in</span> TBLES.items():</div><div class=\"line\">        cols = re.split(<span class=\"string\">'_|-'</span>, tbls)</div><div class=\"line\">        tblpre = <span class=\"string\">\"_\"</span>.join(cols[:<span class=\"number\">-2</span>])</div><div class=\"line\">        min_num = int(cols[<span class=\"number\">-2</span>])</div><div class=\"line\">        max_num = int(cols[<span class=\"number\">-1</span>])</div><div class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> range(min_num, max_num+<span class=\"number\">1</span>):</div><div class=\"line\">            tasks.append(</div><div class=\"line\">               (query_do_something, ip, <span class=\"string\">'your_dbname'</span>, <span class=\"string\">'&#123;&#125;_&#123;&#125;'</span>.format(tblpre, num))</div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\">    random.shuffle(tasks)</div><div class=\"line\">    <span class=\"keyword\">return</span> tasks</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 按批量运行sql访问请求队列</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_tasks</span><span class=\"params\">(tasks, batch_len)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        <span class=\"keyword\">for</span> idx <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(tasks), batch_len):</div><div class=\"line\">            batch_tasks = tasks[idx:idx+batch_len]</div><div class=\"line\">            logging.info(<span class=\"string\">\"current batch, start_idx:%s len:%s\"</span> % (idx, len(batch_tasks)))</div><div class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(batch_tasks)):</div><div class=\"line\">                l = batch_tasks[i]</div><div class=\"line\">                batch_tasks[i] = asyncio.ensure_future(</div><div class=\"line\">                    l[<span class=\"number\">0</span>](*l[<span class=\"number\">1</span>:])</div><div class=\"line\">                )</div><div class=\"line\">            loop.run_until_complete(asyncio.gather(*batch_tasks))</div><div class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</div><div class=\"line\">        logging.warn(e)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># main方法, 通过asyncio实现函数异步调用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\"></div><div class=\"line\">    tasks = gen_tasks()</div><div class=\"line\">    batch_len = len(TBLES.keys()) * <span class=\"number\">5</span>   <span class=\"comment\"># all up to you</span></div><div class=\"line\">    run_tasks(tasks, batch_len)</div><div class=\"line\"></div><div class=\"line\">    loop.close()</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"场景说明\"><a href=\"#场景说明\" class=\"headerlink\" title=\"场景说明\"></a>场景说明</h3><p>假设有一个mysql表被水平切分，分散到多个host中，每个host拥有n个切分表。<br>如果需要并发去访问这些表，快速得到查询结果， 应该怎么做呢？<br>这里提供一种方案，利用python3的asyncio异步io库及aiomysql异步库去实现这个需求。<br>","more":"</p>\n<h3 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> logging</div><div class=\"line\"><span class=\"keyword\">import</span> random</div><div class=\"line\"><span class=\"keyword\">import</span> asyncio</div><div class=\"line\"><span class=\"keyword\">from</span> aiomysql <span class=\"keyword\">import</span> create_pool</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 假设mysql表分散在8个host, 每个host有16张子表</span></div><div class=\"line\">TBLES = &#123;</div><div class=\"line\">    <span class=\"string\">\"192.168.1.01\"</span>: <span class=\"string\">\"table_000-015\"</span>, <span class=\"comment\"># 000-015表示该ip下的表明从table_000一直连续到table_015</span></div><div class=\"line\">    <span class=\"string\">\"192.168.1.02\"</span>: <span class=\"string\">\"table_016-031\"</span>,</div><div class=\"line\">    <span class=\"string\">\"192.168.1.03\"</span>: <span class=\"string\">\"table_032-047\"</span>,</div><div class=\"line\">    <span class=\"string\">\"192.168.1.04\"</span>: <span class=\"string\">\"table_048-063\"</span>,</div><div class=\"line\">    <span class=\"string\">\"192.168.1.05\"</span>: <span class=\"string\">\"table_064-079\"</span>,</div><div class=\"line\">    <span class=\"string\">\"192.168.1.06\"</span>: <span class=\"string\">\"table_080-095\"</span>,</div><div class=\"line\">    <span class=\"string\">\"192.168.1.07\"</span>: <span class=\"string\">\"table_096-0111\"</span>,</div><div class=\"line\">    <span class=\"string\">\"192.168.1.08\"</span>: <span class=\"string\">\"table_112-0127\"</span>,</div><div class=\"line\">&#125;</div><div class=\"line\">USER = <span class=\"string\">\"xxx\"</span></div><div class=\"line\">PASSWD = <span class=\"string\">\"xxxx\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># wrapper函数，用于捕捉异常</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">query_wrapper</span><span class=\"params\">(func)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"keyword\">await</span> func(*args, **kwargs)</div><div class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</div><div class=\"line\">            print(e)</div><div class=\"line\">    <span class=\"keyword\">return</span> wrapper</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 实际的sql访问处理函数，通过aiomysql实现异步非阻塞请求</span></div><div class=\"line\"><span class=\"meta\">@query_wrapper</span></div><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">query_do_something</span><span class=\"params\">(ip, db, table)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> create_pool(host=ip, db=db, user=USER, password=PASSWD) <span class=\"keyword\">as</span> pool:</div><div class=\"line\">        <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> pool.get() <span class=\"keyword\">as</span> conn:</div><div class=\"line\">            <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> conn.cursor() <span class=\"keyword\">as</span> cur:</div><div class=\"line\">                sql = (<span class=\"string\">\"select xxx from &#123;&#125; where xxxx\"</span>)</div><div class=\"line\">                <span class=\"keyword\">await</span> cur.execute(sql.format(table))</div><div class=\"line\">                res = <span class=\"keyword\">await</span> cur.fetchall()</div><div class=\"line\">                <span class=\"comment\"># then do something...</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 生成sql访问队列, 队列的每个元素包含要对某个表进行访问的函数及参数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_tasks</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    tasks = []</div><div class=\"line\">    <span class=\"keyword\">for</span> ip, tbls <span class=\"keyword\">in</span> TBLES.items():</div><div class=\"line\">        cols = re.split(<span class=\"string\">'_|-'</span>, tbls)</div><div class=\"line\">        tblpre = <span class=\"string\">\"_\"</span>.join(cols[:<span class=\"number\">-2</span>])</div><div class=\"line\">        min_num = int(cols[<span class=\"number\">-2</span>])</div><div class=\"line\">        max_num = int(cols[<span class=\"number\">-1</span>])</div><div class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> range(min_num, max_num+<span class=\"number\">1</span>):</div><div class=\"line\">            tasks.append(</div><div class=\"line\">               (query_do_something, ip, <span class=\"string\">'your_dbname'</span>, <span class=\"string\">'&#123;&#125;_&#123;&#125;'</span>.format(tblpre, num))</div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\">    random.shuffle(tasks)</div><div class=\"line\">    <span class=\"keyword\">return</span> tasks</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 按批量运行sql访问请求队列</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_tasks</span><span class=\"params\">(tasks, batch_len)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        <span class=\"keyword\">for</span> idx <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(tasks), batch_len):</div><div class=\"line\">            batch_tasks = tasks[idx:idx+batch_len]</div><div class=\"line\">            logging.info(<span class=\"string\">\"current batch, start_idx:%s len:%s\"</span> % (idx, len(batch_tasks)))</div><div class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(batch_tasks)):</div><div class=\"line\">                l = batch_tasks[i]</div><div class=\"line\">                batch_tasks[i] = asyncio.ensure_future(</div><div class=\"line\">                    l[<span class=\"number\">0</span>](*l[<span class=\"number\">1</span>:])</div><div class=\"line\">                )</div><div class=\"line\">            loop.run_until_complete(asyncio.gather(*batch_tasks))</div><div class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</div><div class=\"line\">        logging.warn(e)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># main方法, 通过asyncio实现函数异步调用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\"></div><div class=\"line\">    tasks = gen_tasks()</div><div class=\"line\">    batch_len = len(TBLES.keys()) * <span class=\"number\">5</span>   <span class=\"comment\"># all up to you</span></div><div class=\"line\">    run_tasks(tasks, batch_len)</div><div class=\"line\"></div><div class=\"line\">    loop.close()</div></pre></td></tr></table></figure>"},{"title":"Centos7快速搭建FTP服务","date":"2018-08-16T02:02:57.000Z","_content":"\n\n## 通过`yum`安装vsftpd\n\n```shell\nyum install -y vsftpd\n```\n\n## 修改配置文件`/etc/vsftpd/vsftpd.conf`\n\n增加了一些自定义配置，全部配置详细如下：\n\n<!--more-->\n\n```\n# 原有初始配置\nlocal_umask=022\ndirmessage_enable=YES\nxferlog_enable=YES\nconnect_from_port_20=YES\nxferlog_std_format=YES\ntcp_wrappers=YES\nlocal_enable=YES\nwrite_enable=YES\npam_service_name=vsftpd\n\n# 不支持匿名访问\nanonymous_enable=NO\n\n# 所有用户都被限制在其主目录下\nchroot_local_user=YES\nchroot_list_enable=NO\nallow_writeable_chroot=YES\n\n# 支持IPv4及IPv6, 监听端口8021\nlisten=NO\nlisten_ipv6=YES\nlisten_port=8021\n\n# 只允许userlist_file文件中的用户可访问ftp\nuserlist_enable=YES\nuserlist_deny=NO\nuserlist_file=/etc/vsftpd/user_list\n\n# ftp用户主目录\nlocal_root=/data/ftp\n\n# passive模式，数据端口范围自定义(6000-6010)，要确保这些端口已开放给外网访问\npasv_enable=YES\npasv_min_port=6000\npasv_max_port=6010\n```\n\n## 配置允许登录的用户`/etc/vsftpd/user_list`\n\n```\n# vsftpd userlist\n# If userlist_deny=NO, only allow users in this file\n# If userlist_deny=YES (default), never allow users in this file, and\n# do not even prompt for a password.\n# Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers\n# for users that are denied.\n# 这里为允许登录的用户名，一行一个\nftpUser\n```\n\n## 创建ftp登录用户\n\n```\ngroupadd ftpGroup\nuseradd -d /opt/reconciliation -s /sbin/nologin -g ftpGroup -G root ftpUser\npasswd ftpUser\n```\n\n## 创建ftp文件存放目录\n\n```\nmkdir -p /data/ftp\nchown -R ftpUser /data/ftp\n```\n\n## 启动ftp服务\n\n```\nservice vsftpd start\n```\n\n## ftp访问测试\n\n使用filezilla工具进行连接测试，正常情况如下所示：\n\n![这里写图片描述](https://img-blog.csdn.net/20180816094528643?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n","source":"_posts/linux/Centos7快速搭建FTP服务.md","raw":"---\ntitle: Centos7快速搭建FTP服务\ndate: 2018-08-16 10:02:57\ntags: Centos, DevOps\n---\n\n\n## 通过`yum`安装vsftpd\n\n```shell\nyum install -y vsftpd\n```\n\n## 修改配置文件`/etc/vsftpd/vsftpd.conf`\n\n增加了一些自定义配置，全部配置详细如下：\n\n<!--more-->\n\n```\n# 原有初始配置\nlocal_umask=022\ndirmessage_enable=YES\nxferlog_enable=YES\nconnect_from_port_20=YES\nxferlog_std_format=YES\ntcp_wrappers=YES\nlocal_enable=YES\nwrite_enable=YES\npam_service_name=vsftpd\n\n# 不支持匿名访问\nanonymous_enable=NO\n\n# 所有用户都被限制在其主目录下\nchroot_local_user=YES\nchroot_list_enable=NO\nallow_writeable_chroot=YES\n\n# 支持IPv4及IPv6, 监听端口8021\nlisten=NO\nlisten_ipv6=YES\nlisten_port=8021\n\n# 只允许userlist_file文件中的用户可访问ftp\nuserlist_enable=YES\nuserlist_deny=NO\nuserlist_file=/etc/vsftpd/user_list\n\n# ftp用户主目录\nlocal_root=/data/ftp\n\n# passive模式，数据端口范围自定义(6000-6010)，要确保这些端口已开放给外网访问\npasv_enable=YES\npasv_min_port=6000\npasv_max_port=6010\n```\n\n## 配置允许登录的用户`/etc/vsftpd/user_list`\n\n```\n# vsftpd userlist\n# If userlist_deny=NO, only allow users in this file\n# If userlist_deny=YES (default), never allow users in this file, and\n# do not even prompt for a password.\n# Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers\n# for users that are denied.\n# 这里为允许登录的用户名，一行一个\nftpUser\n```\n\n## 创建ftp登录用户\n\n```\ngroupadd ftpGroup\nuseradd -d /opt/reconciliation -s /sbin/nologin -g ftpGroup -G root ftpUser\npasswd ftpUser\n```\n\n## 创建ftp文件存放目录\n\n```\nmkdir -p /data/ftp\nchown -R ftpUser /data/ftp\n```\n\n## 启动ftp服务\n\n```\nservice vsftpd start\n```\n\n## ftp访问测试\n\n使用filezilla工具进行连接测试，正常情况如下所示：\n\n![这里写图片描述](https://img-blog.csdn.net/20180816094528643?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n","slug":"linux/Centos7快速搭建FTP服务","published":1,"updated":"2018-08-16T02:11:01.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dvx000x4j4daydtgc3h","content":"<h2 id=\"通过yum安装vsftpd\"><a href=\"#通过yum安装vsftpd\" class=\"headerlink\" title=\"通过yum安装vsftpd\"></a>通过<code>yum</code>安装vsftpd</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install -y vsftpd</div></pre></td></tr></table></figure>\n<h2 id=\"修改配置文件-etc-vsftpd-vsftpd-conf\"><a href=\"#修改配置文件-etc-vsftpd-vsftpd-conf\" class=\"headerlink\" title=\"修改配置文件/etc/vsftpd/vsftpd.conf\"></a>修改配置文件<code>/etc/vsftpd/vsftpd.conf</code></h2><p>增加了一些自定义配置，全部配置详细如下：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 原有初始配置</div><div class=\"line\">local_umask=022</div><div class=\"line\">dirmessage_enable=YES</div><div class=\"line\">xferlog_enable=YES</div><div class=\"line\">connect_from_port_20=YES</div><div class=\"line\">xferlog_std_format=YES</div><div class=\"line\">tcp_wrappers=YES</div><div class=\"line\">local_enable=YES</div><div class=\"line\">write_enable=YES</div><div class=\"line\">pam_service_name=vsftpd</div><div class=\"line\"></div><div class=\"line\"># 不支持匿名访问</div><div class=\"line\">anonymous_enable=NO</div><div class=\"line\"></div><div class=\"line\"># 所有用户都被限制在其主目录下</div><div class=\"line\">chroot_local_user=YES</div><div class=\"line\">chroot_list_enable=NO</div><div class=\"line\">allow_writeable_chroot=YES</div><div class=\"line\"></div><div class=\"line\"># 支持IPv4及IPv6, 监听端口8021</div><div class=\"line\">listen=NO</div><div class=\"line\">listen_ipv6=YES</div><div class=\"line\">listen_port=8021</div><div class=\"line\"></div><div class=\"line\"># 只允许userlist_file文件中的用户可访问ftp</div><div class=\"line\">userlist_enable=YES</div><div class=\"line\">userlist_deny=NO</div><div class=\"line\">userlist_file=/etc/vsftpd/user_list</div><div class=\"line\"></div><div class=\"line\"># ftp用户主目录</div><div class=\"line\">local_root=/data/ftp</div><div class=\"line\"></div><div class=\"line\"># passive模式，数据端口范围自定义(6000-6010)，要确保这些端口已开放给外网访问</div><div class=\"line\">pasv_enable=YES</div><div class=\"line\">pasv_min_port=6000</div><div class=\"line\">pasv_max_port=6010</div></pre></td></tr></table></figure>\n<h2 id=\"配置允许登录的用户-etc-vsftpd-user-list\"><a href=\"#配置允许登录的用户-etc-vsftpd-user-list\" class=\"headerlink\" title=\"配置允许登录的用户/etc/vsftpd/user_list\"></a>配置允许登录的用户<code>/etc/vsftpd/user_list</code></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"># vsftpd userlist</div><div class=\"line\"># If userlist_deny=NO, only allow users in this file</div><div class=\"line\"># If userlist_deny=YES (default), never allow users in this file, and</div><div class=\"line\"># do not even prompt for a password.</div><div class=\"line\"># Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers</div><div class=\"line\"># for users that are denied.</div><div class=\"line\"># 这里为允许登录的用户名，一行一个</div><div class=\"line\">ftpUser</div></pre></td></tr></table></figure>\n<h2 id=\"创建ftp登录用户\"><a href=\"#创建ftp登录用户\" class=\"headerlink\" title=\"创建ftp登录用户\"></a>创建ftp登录用户</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">groupadd ftpGroup</div><div class=\"line\">useradd -d /opt/reconciliation -s /sbin/nologin -g ftpGroup -G root ftpUser</div><div class=\"line\">passwd ftpUser</div></pre></td></tr></table></figure>\n<h2 id=\"创建ftp文件存放目录\"><a href=\"#创建ftp文件存放目录\" class=\"headerlink\" title=\"创建ftp文件存放目录\"></a>创建ftp文件存放目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir -p /data/ftp</div><div class=\"line\">chown -R ftpUser /data/ftp</div></pre></td></tr></table></figure>\n<h2 id=\"启动ftp服务\"><a href=\"#启动ftp服务\" class=\"headerlink\" title=\"启动ftp服务\"></a>启动ftp服务</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service vsftpd start</div></pre></td></tr></table></figure>\n<h2 id=\"ftp访问测试\"><a href=\"#ftp访问测试\" class=\"headerlink\" title=\"ftp访问测试\"></a>ftp访问测试</h2><p>使用filezilla工具进行连接测试，正常情况如下所示：</p>\n<p><img src=\"https://img-blog.csdn.net/20180816094528643?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"通过yum安装vsftpd\"><a href=\"#通过yum安装vsftpd\" class=\"headerlink\" title=\"通过yum安装vsftpd\"></a>通过<code>yum</code>安装vsftpd</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install -y vsftpd</div></pre></td></tr></table></figure>\n<h2 id=\"修改配置文件-etc-vsftpd-vsftpd-conf\"><a href=\"#修改配置文件-etc-vsftpd-vsftpd-conf\" class=\"headerlink\" title=\"修改配置文件/etc/vsftpd/vsftpd.conf\"></a>修改配置文件<code>/etc/vsftpd/vsftpd.conf</code></h2><p>增加了一些自定义配置，全部配置详细如下：</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 原有初始配置</div><div class=\"line\">local_umask=022</div><div class=\"line\">dirmessage_enable=YES</div><div class=\"line\">xferlog_enable=YES</div><div class=\"line\">connect_from_port_20=YES</div><div class=\"line\">xferlog_std_format=YES</div><div class=\"line\">tcp_wrappers=YES</div><div class=\"line\">local_enable=YES</div><div class=\"line\">write_enable=YES</div><div class=\"line\">pam_service_name=vsftpd</div><div class=\"line\"></div><div class=\"line\"># 不支持匿名访问</div><div class=\"line\">anonymous_enable=NO</div><div class=\"line\"></div><div class=\"line\"># 所有用户都被限制在其主目录下</div><div class=\"line\">chroot_local_user=YES</div><div class=\"line\">chroot_list_enable=NO</div><div class=\"line\">allow_writeable_chroot=YES</div><div class=\"line\"></div><div class=\"line\"># 支持IPv4及IPv6, 监听端口8021</div><div class=\"line\">listen=NO</div><div class=\"line\">listen_ipv6=YES</div><div class=\"line\">listen_port=8021</div><div class=\"line\"></div><div class=\"line\"># 只允许userlist_file文件中的用户可访问ftp</div><div class=\"line\">userlist_enable=YES</div><div class=\"line\">userlist_deny=NO</div><div class=\"line\">userlist_file=/etc/vsftpd/user_list</div><div class=\"line\"></div><div class=\"line\"># ftp用户主目录</div><div class=\"line\">local_root=/data/ftp</div><div class=\"line\"></div><div class=\"line\"># passive模式，数据端口范围自定义(6000-6010)，要确保这些端口已开放给外网访问</div><div class=\"line\">pasv_enable=YES</div><div class=\"line\">pasv_min_port=6000</div><div class=\"line\">pasv_max_port=6010</div></pre></td></tr></table></figure>\n<h2 id=\"配置允许登录的用户-etc-vsftpd-user-list\"><a href=\"#配置允许登录的用户-etc-vsftpd-user-list\" class=\"headerlink\" title=\"配置允许登录的用户/etc/vsftpd/user_list\"></a>配置允许登录的用户<code>/etc/vsftpd/user_list</code></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"># vsftpd userlist</div><div class=\"line\"># If userlist_deny=NO, only allow users in this file</div><div class=\"line\"># If userlist_deny=YES (default), never allow users in this file, and</div><div class=\"line\"># do not even prompt for a password.</div><div class=\"line\"># Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers</div><div class=\"line\"># for users that are denied.</div><div class=\"line\"># 这里为允许登录的用户名，一行一个</div><div class=\"line\">ftpUser</div></pre></td></tr></table></figure>\n<h2 id=\"创建ftp登录用户\"><a href=\"#创建ftp登录用户\" class=\"headerlink\" title=\"创建ftp登录用户\"></a>创建ftp登录用户</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">groupadd ftpGroup</div><div class=\"line\">useradd -d /opt/reconciliation -s /sbin/nologin -g ftpGroup -G root ftpUser</div><div class=\"line\">passwd ftpUser</div></pre></td></tr></table></figure>\n<h2 id=\"创建ftp文件存放目录\"><a href=\"#创建ftp文件存放目录\" class=\"headerlink\" title=\"创建ftp文件存放目录\"></a>创建ftp文件存放目录</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir -p /data/ftp</div><div class=\"line\">chown -R ftpUser /data/ftp</div></pre></td></tr></table></figure>\n<h2 id=\"启动ftp服务\"><a href=\"#启动ftp服务\" class=\"headerlink\" title=\"启动ftp服务\"></a>启动ftp服务</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service vsftpd start</div></pre></td></tr></table></figure>\n<h2 id=\"ftp访问测试\"><a href=\"#ftp访问测试\" class=\"headerlink\" title=\"ftp访问测试\"></a>ftp访问测试</h2><p>使用filezilla工具进行连接测试，正常情况如下所示：</p>\n<p><img src=\"https://img-blog.csdn.net/20180816094528643?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21veGlhb21vbW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>"},{"title":"操作系统与网络知识整理(持续更新)","date":"2017-11-03T05:54:12.000Z","_content":"\n### 操作系统\n\n#### 基础概念\n\n- 操作系统的四个特性\n```\n1. 并发: 同一时间间隔内支持执行多个任务, 对于一个核则是交替执行；\n2. 共享: 硬件资源或数据资源支持多个进程共享；\n3. 异步: 并发情况下， 一个程序会陆陆续续被执行，完成时间不可预知；\n4. 虚拟: 物理实体转化为逻辑实体，如虚拟内存。\n```\n- 操作系统的基本功能\n```\n1. CPU管理, 作业调度\n2. 存储管理, 数据存取\n3. 设备管理, 与外围设备交互\n4. 接口管理, 向应用程序/用户提供交互接口\n```\n<!--more-->\n- 软中断与硬中断\n```\n系统在执行某个任务程序时收到中断信号， 需要让出当前CPU来执行中断处理。中断处理完成后，CPU再继续执行之前的任务程序。\n1. 软中断：\n>当前运行的程序产生的中断信号，通常是I/O请求；\n>不会直接中断CPU，需要内核去为当前进程完成一些类似I/O的请求；\n>中断过程: 进程->内核设备驱动程序。\n2. 硬中断:\n>由硬件产生，比如磁盘，网卡，时钟，键盘等；\n>直接中断CPU，通常一个中断只中断一个CPU；\n>中断过程: 硬件->CPU->内核设备驱动程序。\n3. 中断优先级:\n硬件错误>时钟>磁盘>网络设备>其他终端设备>软件中断\n```\n- 动态链接及静态链接\n```\n动态链接: 在程序运行期间, 所依赖的模块来自于程序外部，在内存中动态加载/卸载，按需加载可节省内存；\n静态链接: 在程序运行期间, 所依赖的模块来自于程序内部，即编译时已打包好，程序启动时便会载入内存。\n```\n\n#### 进程管理\n\n- 进程的状态类型与转换\n5个状态模型:\n![process_state](http://blog.moguang.me/img/process_state.jpg)\n- 进程与线程的区别\n```\n概念区别：\n1. 进程： 一个程序的动态执行过程， 分配资源的基本单位；\n2. 线程： 一个进程内调度的基本单位，一个进程包含一个或多个线程。\n执行区别：\n1. 进程：拥有独立内存空间，支持内部多个线程共享；\n2. 线程：必须依赖于进程来运行，每个线程有独立入口/执行序列/出口。\n应用意义区别：\n一个应用运行时对应一个或多个进程， 而线程在进程的基础上提供了可以执行不同调度逻辑的入口，易于实现任务的并发执行。\n```\n- 进程间通信的几种方式\n```\n1. 管道pipe\n管道是独立的文件系统，有自己的数据结构。实际上是只存在于内存中的文件，需要通过两个打开的文件句柄来进行操作，他们分别表示管道的两端。管道分为无名管道和有名管道。\n2. 共享内存\n共享内存由一个进程创建， 能被其他进程访问， 最快的IPC方式。\n3. 消息队列\n消息的链表， 存放于内核并由队列标识符标识；克服了缓冲区大小受限，信号信息有限，管道无格式字节流等缺点。\n4. 信号\n用于通知某个进程某个事件已经发生，可触发进程已注册的处理函数。\n5. 信号量\n一种计数器，用来控制多个进程对共享资源的访问， 通常作为一种锁机制， 常应用于进程间或进程内多个线程的同步。\n6. Socket\n通过套接字通信，也可用于不同host之间的进程见通信。\n```\n- 进程同步，线程同步的几种方式\n```\n1. 临界区（CriticalSection）（进程内线程同步）\n一次只能被一个进程所占用的资源为临界资源；进程内访问临界资源的代码就是临界区。\n进入区/临界区/退出区/剩余区\n2. 事件\n基于事件机制， 一个进程/线程主动唤醒另一个进程/线程；比如监听通信端口A。\n3. 互斥量（Mutex）\n类似临界区，但是能在进程间使用。Futex由一块能被多个进程共享的内存空间(对齐后的整型变量)组成, 保存在用户空间的共享内存中，通过原子操作进行操作。操作基本在用户空间内进行(需要仲裁时使用系统内核调用), 减少了系统调用次数， 提供系统性能。\n4. 信号量(Semphore)\n信号量建立在原子操作上，使用信号量可以用来限制共享资源的线程数目。\n```\n- 线程的实现方式\n```\n用户级线程（也可看作协程）：进程内的线程切换不用切换到内核进行， 内核并没有感知进程内的线程存在， 所以即使多线程并不能利用多核来进行操作。一个线程如果调用了阻塞系统调用， 那整个进程都会被阻塞。\n内核级线程（通常所说的线程）：也即内核管理的所有线程， 内核头既包含进程表， 也包含线程表。多线程可以利用到多核，多核下微观和宏观下都能做到并行。\n混合模式： 内核线程可以在用户空间完成创建，应用的多个用户级线程可以被映射到内核线程中，提高并发效率。\n```\n- 用户态与内核态的区别\n```\n用户态：执行用户级别的代码，权限受限，由CPU标志flag来控制；\n内核态：执行内核模块代码，比如执行磁盘IO，网络IO处理等。\n应用进程可通过系统调用由用户态进入内核态，在缺页错误或中断发生时进入内核态。\n```\n- 用户栈与内核栈的区别\n```\n用户栈： 进程在用户空间时创建的栈，比如函数调用时压栈出栈， 保存了函数互相调用的参数/返回值等；\n内核栈： 中断进入内核态时，用内核栈来保存用户态进程的状态信息，返回用户钛再将这些信息出栈；内核栈位置在内核的一块固定区域，保存中断现场，进程调用数据等。\n```\n- 内存池，进程池，线程池\n```\n所谓池的概念， 一般是指应用提前向内核批量申请资源，用于接下来的使用和回收再利用， 减少资源的初始化和销毁次数等开销， 以达到提高系统性能的目标。\n内存池：真正使用前申请一片内存区域，有新需求时取出其中一部分使用，不够用时再重新申请新内存。\n进程池：\n>应用预先创建一组子进程，所有子进程运行相同代码，拥有相同属性，比如PGID和优先级等；\n>常见两种工作方式：\n1. 主进程通过随机或round robin算法来选择子进程作为新任务的服务进程；\n2. 通过一个共享队列来进行同步，所有子进程从该队列中获取任务，不过同时只能有一个子进程能成功获得新任务处理权。\n线程池：\n主要应用于任务小而多，处理时间短的场景，比如简单网页请求等。\n```\n- 死锁的概念，产生条件及处理策略\n```\n死锁：一组竞争同一系统资源或通信的进程由于互相等待而造成的永久阻塞。\n产生死锁的四个条件：\n1. 互斥： 一次只能有一个进程使用一个资源。\n2. 占有并等待： 一个进程等待另一个资源的同时占有一个已分配的资源。\n3. 不可抢占： 一个已被某个进程占有的资源不可被其他进程抢夺。\n4. 循环等待： 在一个封闭进程链中，每个进程至少占有下一个进程所等待的资源。\n处理死锁几种方式：预防/避免/检测，比如一次性申请所需资源，银行家算法。\n```\n- 进程调度算法\n```\n调度种类：\n1. 高级调度： 作业调度，决定把后备作业调入内存运行；\n2. 中级调度： 内存，外存交换区进行进程对换；\n3. 低级调度： 进程调度，决定把就绪状态的进程获得CPU。\nCPU任务种类： 交互式任务和批处理任务。\n调度算法：\n1. FIFO(FCFS)： 公平简单，不利于交互式，不利于IO密集型作业；\n2. SJF：短作业优先调度，可以保证整体的最小等待时间，但不利于长作业；\n3. 优先权调度：拥有高优先权的作业优先处理， 有可能出现优先权低的任务“饥饿”情况；\n4. Round-Robin：按时间片进行轮转调度，让每个任务定时有响应但是上下文切换次数可能会过多。\n5. 多级优先级队列：按不同规则创建多个进程队列，不同队列拥有不同的优先级以及可以分配不同的时间片/调度策略。但是也存在”饥饿“可能性。\n6. 多级反馈队列：在多级优先级队列基础上，长期得不到运行的队列优先级会被提高。\n```\n\n#### 内存管理\n\n- 内存管理的技术发展\n```\n1. 固定分区：系统初始化阶段，内存被固定划分成多个静态分区，进程可以一次性被装载到大于或等于自身空间的分区；\n2. 动态分区：动态创建分区，进程可以被装载到与自身相等大小的分区中；\n3. 虚拟内存分页：系统初始化阶段，内存被划分为多个大小一致的页框；每个进程被划分成多个与页框相等的页；根据实时需要加载一定数量的页。\n4. 虚拟内存分段：每个进程维护一个段表，系统维护一个空闲的块表，按需加载段。\n5. 段页式： 单按页加载的调度粒度太细，单按段加载的调度粒度太粗， 结合使用可有效提高系统性能。应用地址空间可划分成多个段，每个段又划分为多个固定大小的页，段偏移量在系统角度可看作是指定段中的一个页好和页偏移。\n```\n- 物理内存与虚拟内存\n```\n物理地址：实际物理内存中的存储地址；\n虚拟地址： 编码时将代码或数据分成若干段，每条代码或数据对应的地址由段号加段内偏移地址构成。\nMMU: 实现将虚拟地址映射到物理地址的CPU中的硬件电路。\n```\n- 几种页面置换算法\n```\nFIFIO： 淘汰最早调入的页面；\nOPT： 理想化的最佳置换算法，将标记为下次最迟才会被访问的页面淘汰；\nLRU： 将最近一段时间内最久没有被使用的页置换出去。\n```\n- DMA定义及工作流程\n```\nDMA指外部设备不经过CPU而直接与内存交换数据的技术。\n主要通过DMA控制器来实现： 控制器向CPU请求系统总线并获得控制权后， 与存储器直接进行数据交换， 完成后向CPU发送结束信号并交还控制权。\n```\n- 外存分配的几种方式\n```\n外存：CPU缓存及内存以外的存储器， 如硬盘/光盘等。\n分配方式：\n1. 连续分配：创建文件时，分配一组连续的块， FAT中每个文件只需要一项，用以说明起始块及文件大小。\n2. 链式分配： 文件存放在若干不连续的物理块，各块之间通过指针连接。\n3. 索引分配： 每个文件在FAT中有一个一级索引， 包含文件各个分区的入口；这个索引信息保存在单独个一个块当中， 作为文件的访问入口。\n```\n- CPU中的缓存及OS中的缓存\n```\nCPU缓存： 介于CPU与内存之间的临时存储器， 有一级/二级/三级缓存之分；\n系统缓存： 如块表，用于存放当前访问最频繁的少量活动页，提高数据存取速度。通过需要存取的数据所在逻辑地址，在块表中找到其对应的内存块地址， 结合其页偏移地址获得物理地址；如果块表中没有该逻辑页号，则通过查询空闲块来更新块空闲区信息；如果块表没有空闲区，则通过算法来淘汰块表中某一行，并填入新的空闲区。\n```\n\n#### 垃圾回收\n- 垃圾回收的几种算法\n\n### 网络知识\n\n- 7层模型及4层模型的具体定义\n- 常见的网络协议及所处的TCP/IP模型层次\n- TCP建立及关闭连接过程\n- TCP滑动窗口及拥塞控制\n- TCP的快速重传与快速恢复算法\n- 网络差错检测CRC\n\n### 数据结构与算法\n\n- 堆，栈，链表， 树， hashmap等结构\n- 常见的搜索/排序算法\n- 经典的分治算法\n- 分布式一致性hash\n- 分布式同步算法\n\n### 数据库知识\n\n- 事务与锁的概念\n- 视图与游标的概念\n- 对索引的认识（索引的结构、对dml影响、对查询影响、为什么提高查询性能）\n- 冷备份和热备份的不同点以及各自的优点\n- mysql, redis, couchbase, mongodb的应用场景等\n","source":"_posts/linux/devtech-overview.md","raw":"---\ntitle: '操作系统与网络知识整理(持续更新)'\ndate: 2017-11-03 13:54:12\ntags: OS kernel\n---\n\n### 操作系统\n\n#### 基础概念\n\n- 操作系统的四个特性\n```\n1. 并发: 同一时间间隔内支持执行多个任务, 对于一个核则是交替执行；\n2. 共享: 硬件资源或数据资源支持多个进程共享；\n3. 异步: 并发情况下， 一个程序会陆陆续续被执行，完成时间不可预知；\n4. 虚拟: 物理实体转化为逻辑实体，如虚拟内存。\n```\n- 操作系统的基本功能\n```\n1. CPU管理, 作业调度\n2. 存储管理, 数据存取\n3. 设备管理, 与外围设备交互\n4. 接口管理, 向应用程序/用户提供交互接口\n```\n<!--more-->\n- 软中断与硬中断\n```\n系统在执行某个任务程序时收到中断信号， 需要让出当前CPU来执行中断处理。中断处理完成后，CPU再继续执行之前的任务程序。\n1. 软中断：\n>当前运行的程序产生的中断信号，通常是I/O请求；\n>不会直接中断CPU，需要内核去为当前进程完成一些类似I/O的请求；\n>中断过程: 进程->内核设备驱动程序。\n2. 硬中断:\n>由硬件产生，比如磁盘，网卡，时钟，键盘等；\n>直接中断CPU，通常一个中断只中断一个CPU；\n>中断过程: 硬件->CPU->内核设备驱动程序。\n3. 中断优先级:\n硬件错误>时钟>磁盘>网络设备>其他终端设备>软件中断\n```\n- 动态链接及静态链接\n```\n动态链接: 在程序运行期间, 所依赖的模块来自于程序外部，在内存中动态加载/卸载，按需加载可节省内存；\n静态链接: 在程序运行期间, 所依赖的模块来自于程序内部，即编译时已打包好，程序启动时便会载入内存。\n```\n\n#### 进程管理\n\n- 进程的状态类型与转换\n5个状态模型:\n![process_state](http://blog.moguang.me/img/process_state.jpg)\n- 进程与线程的区别\n```\n概念区别：\n1. 进程： 一个程序的动态执行过程， 分配资源的基本单位；\n2. 线程： 一个进程内调度的基本单位，一个进程包含一个或多个线程。\n执行区别：\n1. 进程：拥有独立内存空间，支持内部多个线程共享；\n2. 线程：必须依赖于进程来运行，每个线程有独立入口/执行序列/出口。\n应用意义区别：\n一个应用运行时对应一个或多个进程， 而线程在进程的基础上提供了可以执行不同调度逻辑的入口，易于实现任务的并发执行。\n```\n- 进程间通信的几种方式\n```\n1. 管道pipe\n管道是独立的文件系统，有自己的数据结构。实际上是只存在于内存中的文件，需要通过两个打开的文件句柄来进行操作，他们分别表示管道的两端。管道分为无名管道和有名管道。\n2. 共享内存\n共享内存由一个进程创建， 能被其他进程访问， 最快的IPC方式。\n3. 消息队列\n消息的链表， 存放于内核并由队列标识符标识；克服了缓冲区大小受限，信号信息有限，管道无格式字节流等缺点。\n4. 信号\n用于通知某个进程某个事件已经发生，可触发进程已注册的处理函数。\n5. 信号量\n一种计数器，用来控制多个进程对共享资源的访问， 通常作为一种锁机制， 常应用于进程间或进程内多个线程的同步。\n6. Socket\n通过套接字通信，也可用于不同host之间的进程见通信。\n```\n- 进程同步，线程同步的几种方式\n```\n1. 临界区（CriticalSection）（进程内线程同步）\n一次只能被一个进程所占用的资源为临界资源；进程内访问临界资源的代码就是临界区。\n进入区/临界区/退出区/剩余区\n2. 事件\n基于事件机制， 一个进程/线程主动唤醒另一个进程/线程；比如监听通信端口A。\n3. 互斥量（Mutex）\n类似临界区，但是能在进程间使用。Futex由一块能被多个进程共享的内存空间(对齐后的整型变量)组成, 保存在用户空间的共享内存中，通过原子操作进行操作。操作基本在用户空间内进行(需要仲裁时使用系统内核调用), 减少了系统调用次数， 提供系统性能。\n4. 信号量(Semphore)\n信号量建立在原子操作上，使用信号量可以用来限制共享资源的线程数目。\n```\n- 线程的实现方式\n```\n用户级线程（也可看作协程）：进程内的线程切换不用切换到内核进行， 内核并没有感知进程内的线程存在， 所以即使多线程并不能利用多核来进行操作。一个线程如果调用了阻塞系统调用， 那整个进程都会被阻塞。\n内核级线程（通常所说的线程）：也即内核管理的所有线程， 内核头既包含进程表， 也包含线程表。多线程可以利用到多核，多核下微观和宏观下都能做到并行。\n混合模式： 内核线程可以在用户空间完成创建，应用的多个用户级线程可以被映射到内核线程中，提高并发效率。\n```\n- 用户态与内核态的区别\n```\n用户态：执行用户级别的代码，权限受限，由CPU标志flag来控制；\n内核态：执行内核模块代码，比如执行磁盘IO，网络IO处理等。\n应用进程可通过系统调用由用户态进入内核态，在缺页错误或中断发生时进入内核态。\n```\n- 用户栈与内核栈的区别\n```\n用户栈： 进程在用户空间时创建的栈，比如函数调用时压栈出栈， 保存了函数互相调用的参数/返回值等；\n内核栈： 中断进入内核态时，用内核栈来保存用户态进程的状态信息，返回用户钛再将这些信息出栈；内核栈位置在内核的一块固定区域，保存中断现场，进程调用数据等。\n```\n- 内存池，进程池，线程池\n```\n所谓池的概念， 一般是指应用提前向内核批量申请资源，用于接下来的使用和回收再利用， 减少资源的初始化和销毁次数等开销， 以达到提高系统性能的目标。\n内存池：真正使用前申请一片内存区域，有新需求时取出其中一部分使用，不够用时再重新申请新内存。\n进程池：\n>应用预先创建一组子进程，所有子进程运行相同代码，拥有相同属性，比如PGID和优先级等；\n>常见两种工作方式：\n1. 主进程通过随机或round robin算法来选择子进程作为新任务的服务进程；\n2. 通过一个共享队列来进行同步，所有子进程从该队列中获取任务，不过同时只能有一个子进程能成功获得新任务处理权。\n线程池：\n主要应用于任务小而多，处理时间短的场景，比如简单网页请求等。\n```\n- 死锁的概念，产生条件及处理策略\n```\n死锁：一组竞争同一系统资源或通信的进程由于互相等待而造成的永久阻塞。\n产生死锁的四个条件：\n1. 互斥： 一次只能有一个进程使用一个资源。\n2. 占有并等待： 一个进程等待另一个资源的同时占有一个已分配的资源。\n3. 不可抢占： 一个已被某个进程占有的资源不可被其他进程抢夺。\n4. 循环等待： 在一个封闭进程链中，每个进程至少占有下一个进程所等待的资源。\n处理死锁几种方式：预防/避免/检测，比如一次性申请所需资源，银行家算法。\n```\n- 进程调度算法\n```\n调度种类：\n1. 高级调度： 作业调度，决定把后备作业调入内存运行；\n2. 中级调度： 内存，外存交换区进行进程对换；\n3. 低级调度： 进程调度，决定把就绪状态的进程获得CPU。\nCPU任务种类： 交互式任务和批处理任务。\n调度算法：\n1. FIFO(FCFS)： 公平简单，不利于交互式，不利于IO密集型作业；\n2. SJF：短作业优先调度，可以保证整体的最小等待时间，但不利于长作业；\n3. 优先权调度：拥有高优先权的作业优先处理， 有可能出现优先权低的任务“饥饿”情况；\n4. Round-Robin：按时间片进行轮转调度，让每个任务定时有响应但是上下文切换次数可能会过多。\n5. 多级优先级队列：按不同规则创建多个进程队列，不同队列拥有不同的优先级以及可以分配不同的时间片/调度策略。但是也存在”饥饿“可能性。\n6. 多级反馈队列：在多级优先级队列基础上，长期得不到运行的队列优先级会被提高。\n```\n\n#### 内存管理\n\n- 内存管理的技术发展\n```\n1. 固定分区：系统初始化阶段，内存被固定划分成多个静态分区，进程可以一次性被装载到大于或等于自身空间的分区；\n2. 动态分区：动态创建分区，进程可以被装载到与自身相等大小的分区中；\n3. 虚拟内存分页：系统初始化阶段，内存被划分为多个大小一致的页框；每个进程被划分成多个与页框相等的页；根据实时需要加载一定数量的页。\n4. 虚拟内存分段：每个进程维护一个段表，系统维护一个空闲的块表，按需加载段。\n5. 段页式： 单按页加载的调度粒度太细，单按段加载的调度粒度太粗， 结合使用可有效提高系统性能。应用地址空间可划分成多个段，每个段又划分为多个固定大小的页，段偏移量在系统角度可看作是指定段中的一个页好和页偏移。\n```\n- 物理内存与虚拟内存\n```\n物理地址：实际物理内存中的存储地址；\n虚拟地址： 编码时将代码或数据分成若干段，每条代码或数据对应的地址由段号加段内偏移地址构成。\nMMU: 实现将虚拟地址映射到物理地址的CPU中的硬件电路。\n```\n- 几种页面置换算法\n```\nFIFIO： 淘汰最早调入的页面；\nOPT： 理想化的最佳置换算法，将标记为下次最迟才会被访问的页面淘汰；\nLRU： 将最近一段时间内最久没有被使用的页置换出去。\n```\n- DMA定义及工作流程\n```\nDMA指外部设备不经过CPU而直接与内存交换数据的技术。\n主要通过DMA控制器来实现： 控制器向CPU请求系统总线并获得控制权后， 与存储器直接进行数据交换， 完成后向CPU发送结束信号并交还控制权。\n```\n- 外存分配的几种方式\n```\n外存：CPU缓存及内存以外的存储器， 如硬盘/光盘等。\n分配方式：\n1. 连续分配：创建文件时，分配一组连续的块， FAT中每个文件只需要一项，用以说明起始块及文件大小。\n2. 链式分配： 文件存放在若干不连续的物理块，各块之间通过指针连接。\n3. 索引分配： 每个文件在FAT中有一个一级索引， 包含文件各个分区的入口；这个索引信息保存在单独个一个块当中， 作为文件的访问入口。\n```\n- CPU中的缓存及OS中的缓存\n```\nCPU缓存： 介于CPU与内存之间的临时存储器， 有一级/二级/三级缓存之分；\n系统缓存： 如块表，用于存放当前访问最频繁的少量活动页，提高数据存取速度。通过需要存取的数据所在逻辑地址，在块表中找到其对应的内存块地址， 结合其页偏移地址获得物理地址；如果块表中没有该逻辑页号，则通过查询空闲块来更新块空闲区信息；如果块表没有空闲区，则通过算法来淘汰块表中某一行，并填入新的空闲区。\n```\n\n#### 垃圾回收\n- 垃圾回收的几种算法\n\n### 网络知识\n\n- 7层模型及4层模型的具体定义\n- 常见的网络协议及所处的TCP/IP模型层次\n- TCP建立及关闭连接过程\n- TCP滑动窗口及拥塞控制\n- TCP的快速重传与快速恢复算法\n- 网络差错检测CRC\n\n### 数据结构与算法\n\n- 堆，栈，链表， 树， hashmap等结构\n- 常见的搜索/排序算法\n- 经典的分治算法\n- 分布式一致性hash\n- 分布式同步算法\n\n### 数据库知识\n\n- 事务与锁的概念\n- 视图与游标的概念\n- 对索引的认识（索引的结构、对dml影响、对查询影响、为什么提高查询性能）\n- 冷备份和热备份的不同点以及各自的优点\n- mysql, redis, couchbase, mongodb的应用场景等\n","slug":"linux/devtech-overview","published":1,"updated":"2017-11-06T06:00:32.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dw0000y4j4doa30vpju","content":"<h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><h4 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h4><ul>\n<li><p>操作系统的四个特性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 并发: 同一时间间隔内支持执行多个任务, 对于一个核则是交替执行；</div><div class=\"line\">2. 共享: 硬件资源或数据资源支持多个进程共享；</div><div class=\"line\">3. 异步: 并发情况下， 一个程序会陆陆续续被执行，完成时间不可预知；</div><div class=\"line\">4. 虚拟: 物理实体转化为逻辑实体，如虚拟内存。</div></pre></td></tr></table></figure>\n</li>\n<li><p>操作系统的基本功能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. CPU管理, 作业调度</div><div class=\"line\">2. 存储管理, 数据存取</div><div class=\"line\">3. 设备管理, 与外围设备交互</div><div class=\"line\">4. 接口管理, 向应用程序/用户提供交互接口</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>软中断与硬中断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">系统在执行某个任务程序时收到中断信号， 需要让出当前CPU来执行中断处理。中断处理完成后，CPU再继续执行之前的任务程序。</div><div class=\"line\">1. 软中断：</div><div class=\"line\">&gt;当前运行的程序产生的中断信号，通常是I/O请求；</div><div class=\"line\">&gt;不会直接中断CPU，需要内核去为当前进程完成一些类似I/O的请求；</div><div class=\"line\">&gt;中断过程: 进程-&gt;内核设备驱动程序。</div><div class=\"line\">2. 硬中断:</div><div class=\"line\">&gt;由硬件产生，比如磁盘，网卡，时钟，键盘等；</div><div class=\"line\">&gt;直接中断CPU，通常一个中断只中断一个CPU；</div><div class=\"line\">&gt;中断过程: 硬件-&gt;CPU-&gt;内核设备驱动程序。</div><div class=\"line\">3. 中断优先级:</div><div class=\"line\">硬件错误&gt;时钟&gt;磁盘&gt;网络设备&gt;其他终端设备&gt;软件中断</div></pre></td></tr></table></figure>\n</li>\n<li><p>动态链接及静态链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">动态链接: 在程序运行期间, 所依赖的模块来自于程序外部，在内存中动态加载/卸载，按需加载可节省内存；</div><div class=\"line\">静态链接: 在程序运行期间, 所依赖的模块来自于程序内部，即编译时已打包好，程序启动时便会载入内存。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h4><ul>\n<li>进程的状态类型与转换<br>5个状态模型:<br><img src=\"http://blog.moguang.me/img/process_state.jpg\" alt=\"process_state\"></li>\n<li><p>进程与线程的区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">概念区别：</div><div class=\"line\">1. 进程： 一个程序的动态执行过程， 分配资源的基本单位；</div><div class=\"line\">2. 线程： 一个进程内调度的基本单位，一个进程包含一个或多个线程。</div><div class=\"line\">执行区别：</div><div class=\"line\">1. 进程：拥有独立内存空间，支持内部多个线程共享；</div><div class=\"line\">2. 线程：必须依赖于进程来运行，每个线程有独立入口/执行序列/出口。</div><div class=\"line\">应用意义区别：</div><div class=\"line\">一个应用运行时对应一个或多个进程， 而线程在进程的基础上提供了可以执行不同调度逻辑的入口，易于实现任务的并发执行。</div></pre></td></tr></table></figure>\n</li>\n<li><p>进程间通信的几种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 管道pipe</div><div class=\"line\">管道是独立的文件系统，有自己的数据结构。实际上是只存在于内存中的文件，需要通过两个打开的文件句柄来进行操作，他们分别表示管道的两端。管道分为无名管道和有名管道。</div><div class=\"line\">2. 共享内存</div><div class=\"line\">共享内存由一个进程创建， 能被其他进程访问， 最快的IPC方式。</div><div class=\"line\">3. 消息队列</div><div class=\"line\">消息的链表， 存放于内核并由队列标识符标识；克服了缓冲区大小受限，信号信息有限，管道无格式字节流等缺点。</div><div class=\"line\">4. 信号</div><div class=\"line\">用于通知某个进程某个事件已经发生，可触发进程已注册的处理函数。</div><div class=\"line\">5. 信号量</div><div class=\"line\">一种计数器，用来控制多个进程对共享资源的访问， 通常作为一种锁机制， 常应用于进程间或进程内多个线程的同步。</div><div class=\"line\">6. Socket</div><div class=\"line\">通过套接字通信，也可用于不同host之间的进程见通信。</div></pre></td></tr></table></figure>\n</li>\n<li><p>进程同步，线程同步的几种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 临界区（CriticalSection）（进程内线程同步）</div><div class=\"line\">一次只能被一个进程所占用的资源为临界资源；进程内访问临界资源的代码就是临界区。</div><div class=\"line\">进入区/临界区/退出区/剩余区</div><div class=\"line\">2. 事件</div><div class=\"line\">基于事件机制， 一个进程/线程主动唤醒另一个进程/线程；比如监听通信端口A。</div><div class=\"line\">3. 互斥量（Mutex）</div><div class=\"line\">类似临界区，但是能在进程间使用。Futex由一块能被多个进程共享的内存空间(对齐后的整型变量)组成, 保存在用户空间的共享内存中，通过原子操作进行操作。操作基本在用户空间内进行(需要仲裁时使用系统内核调用), 减少了系统调用次数， 提供系统性能。</div><div class=\"line\">4. 信号量(Semphore)</div><div class=\"line\">信号量建立在原子操作上，使用信号量可以用来限制共享资源的线程数目。</div></pre></td></tr></table></figure>\n</li>\n<li><p>线程的实现方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">用户级线程（也可看作协程）：进程内的线程切换不用切换到内核进行， 内核并没有感知进程内的线程存在， 所以即使多线程并不能利用多核来进行操作。一个线程如果调用了阻塞系统调用， 那整个进程都会被阻塞。</div><div class=\"line\">内核级线程（通常所说的线程）：也即内核管理的所有线程， 内核头既包含进程表， 也包含线程表。多线程可以利用到多核，多核下微观和宏观下都能做到并行。</div><div class=\"line\">混合模式： 内核线程可以在用户空间完成创建，应用的多个用户级线程可以被映射到内核线程中，提高并发效率。</div></pre></td></tr></table></figure>\n</li>\n<li><p>用户态与内核态的区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">用户态：执行用户级别的代码，权限受限，由CPU标志flag来控制；</div><div class=\"line\">内核态：执行内核模块代码，比如执行磁盘IO，网络IO处理等。</div><div class=\"line\">应用进程可通过系统调用由用户态进入内核态，在缺页错误或中断发生时进入内核态。</div></pre></td></tr></table></figure>\n</li>\n<li><p>用户栈与内核栈的区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">用户栈： 进程在用户空间时创建的栈，比如函数调用时压栈出栈， 保存了函数互相调用的参数/返回值等；</div><div class=\"line\">内核栈： 中断进入内核态时，用内核栈来保存用户态进程的状态信息，返回用户钛再将这些信息出栈；内核栈位置在内核的一块固定区域，保存中断现场，进程调用数据等。</div></pre></td></tr></table></figure>\n</li>\n<li><p>内存池，进程池，线程池</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">所谓池的概念， 一般是指应用提前向内核批量申请资源，用于接下来的使用和回收再利用， 减少资源的初始化和销毁次数等开销， 以达到提高系统性能的目标。</div><div class=\"line\">内存池：真正使用前申请一片内存区域，有新需求时取出其中一部分使用，不够用时再重新申请新内存。</div><div class=\"line\">进程池：</div><div class=\"line\">&gt;应用预先创建一组子进程，所有子进程运行相同代码，拥有相同属性，比如PGID和优先级等；</div><div class=\"line\">&gt;常见两种工作方式：</div><div class=\"line\">1. 主进程通过随机或round robin算法来选择子进程作为新任务的服务进程；</div><div class=\"line\">2. 通过一个共享队列来进行同步，所有子进程从该队列中获取任务，不过同时只能有一个子进程能成功获得新任务处理权。</div><div class=\"line\">线程池：</div><div class=\"line\">主要应用于任务小而多，处理时间短的场景，比如简单网页请求等。</div></pre></td></tr></table></figure>\n</li>\n<li><p>死锁的概念，产生条件及处理策略</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">死锁：一组竞争同一系统资源或通信的进程由于互相等待而造成的永久阻塞。</div><div class=\"line\">产生死锁的四个条件：</div><div class=\"line\">1. 互斥： 一次只能有一个进程使用一个资源。</div><div class=\"line\">2. 占有并等待： 一个进程等待另一个资源的同时占有一个已分配的资源。</div><div class=\"line\">3. 不可抢占： 一个已被某个进程占有的资源不可被其他进程抢夺。</div><div class=\"line\">4. 循环等待： 在一个封闭进程链中，每个进程至少占有下一个进程所等待的资源。</div><div class=\"line\">处理死锁几种方式：预防/避免/检测，比如一次性申请所需资源，银行家算法。</div></pre></td></tr></table></figure>\n</li>\n<li><p>进程调度算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">调度种类：</div><div class=\"line\">1. 高级调度： 作业调度，决定把后备作业调入内存运行；</div><div class=\"line\">2. 中级调度： 内存，外存交换区进行进程对换；</div><div class=\"line\">3. 低级调度： 进程调度，决定把就绪状态的进程获得CPU。</div><div class=\"line\">CPU任务种类： 交互式任务和批处理任务。</div><div class=\"line\">调度算法：</div><div class=\"line\">1. FIFO(FCFS)： 公平简单，不利于交互式，不利于IO密集型作业；</div><div class=\"line\">2. SJF：短作业优先调度，可以保证整体的最小等待时间，但不利于长作业；</div><div class=\"line\">3. 优先权调度：拥有高优先权的作业优先处理， 有可能出现优先权低的任务“饥饿”情况；</div><div class=\"line\">4. Round-Robin：按时间片进行轮转调度，让每个任务定时有响应但是上下文切换次数可能会过多。</div><div class=\"line\">5. 多级优先级队列：按不同规则创建多个进程队列，不同队列拥有不同的优先级以及可以分配不同的时间片/调度策略。但是也存在”饥饿“可能性。</div><div class=\"line\">6. 多级反馈队列：在多级优先级队列基础上，长期得不到运行的队列优先级会被提高。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h4><ul>\n<li><p>内存管理的技术发展</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 固定分区：系统初始化阶段，内存被固定划分成多个静态分区，进程可以一次性被装载到大于或等于自身空间的分区；</div><div class=\"line\">2. 动态分区：动态创建分区，进程可以被装载到与自身相等大小的分区中；</div><div class=\"line\">3. 虚拟内存分页：系统初始化阶段，内存被划分为多个大小一致的页框；每个进程被划分成多个与页框相等的页；根据实时需要加载一定数量的页。</div><div class=\"line\">4. 虚拟内存分段：每个进程维护一个段表，系统维护一个空闲的块表，按需加载段。</div><div class=\"line\">5. 段页式： 单按页加载的调度粒度太细，单按段加载的调度粒度太粗， 结合使用可有效提高系统性能。应用地址空间可划分成多个段，每个段又划分为多个固定大小的页，段偏移量在系统角度可看作是指定段中的一个页好和页偏移。</div></pre></td></tr></table></figure>\n</li>\n<li><p>物理内存与虚拟内存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">物理地址：实际物理内存中的存储地址；</div><div class=\"line\">虚拟地址： 编码时将代码或数据分成若干段，每条代码或数据对应的地址由段号加段内偏移地址构成。</div><div class=\"line\">MMU: 实现将虚拟地址映射到物理地址的CPU中的硬件电路。</div></pre></td></tr></table></figure>\n</li>\n<li><p>几种页面置换算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">FIFIO： 淘汰最早调入的页面；</div><div class=\"line\">OPT： 理想化的最佳置换算法，将标记为下次最迟才会被访问的页面淘汰；</div><div class=\"line\">LRU： 将最近一段时间内最久没有被使用的页置换出去。</div></pre></td></tr></table></figure>\n</li>\n<li><p>DMA定义及工作流程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">DMA指外部设备不经过CPU而直接与内存交换数据的技术。</div><div class=\"line\">主要通过DMA控制器来实现： 控制器向CPU请求系统总线并获得控制权后， 与存储器直接进行数据交换， 完成后向CPU发送结束信号并交还控制权。</div></pre></td></tr></table></figure>\n</li>\n<li><p>外存分配的几种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">外存：CPU缓存及内存以外的存储器， 如硬盘/光盘等。</div><div class=\"line\">分配方式：</div><div class=\"line\">1. 连续分配：创建文件时，分配一组连续的块， FAT中每个文件只需要一项，用以说明起始块及文件大小。</div><div class=\"line\">2. 链式分配： 文件存放在若干不连续的物理块，各块之间通过指针连接。</div><div class=\"line\">3. 索引分配： 每个文件在FAT中有一个一级索引， 包含文件各个分区的入口；这个索引信息保存在单独个一个块当中， 作为文件的访问入口。</div></pre></td></tr></table></figure>\n</li>\n<li><p>CPU中的缓存及OS中的缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CPU缓存： 介于CPU与内存之间的临时存储器， 有一级/二级/三级缓存之分；</div><div class=\"line\">系统缓存： 如块表，用于存放当前访问最频繁的少量活动页，提高数据存取速度。通过需要存取的数据所在逻辑地址，在块表中找到其对应的内存块地址， 结合其页偏移地址获得物理地址；如果块表中没有该逻辑页号，则通过查询空闲块来更新块空闲区信息；如果块表没有空闲区，则通过算法来淘汰块表中某一行，并填入新的空闲区。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h4><ul>\n<li>垃圾回收的几种算法</li>\n</ul>\n<h3 id=\"网络知识\"><a href=\"#网络知识\" class=\"headerlink\" title=\"网络知识\"></a>网络知识</h3><ul>\n<li>7层模型及4层模型的具体定义</li>\n<li>常见的网络协议及所处的TCP/IP模型层次</li>\n<li>TCP建立及关闭连接过程</li>\n<li>TCP滑动窗口及拥塞控制</li>\n<li>TCP的快速重传与快速恢复算法</li>\n<li>网络差错检测CRC</li>\n</ul>\n<h3 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h3><ul>\n<li>堆，栈，链表， 树， hashmap等结构</li>\n<li>常见的搜索/排序算法</li>\n<li>经典的分治算法</li>\n<li>分布式一致性hash</li>\n<li>分布式同步算法</li>\n</ul>\n<h3 id=\"数据库知识\"><a href=\"#数据库知识\" class=\"headerlink\" title=\"数据库知识\"></a>数据库知识</h3><ul>\n<li>事务与锁的概念</li>\n<li>视图与游标的概念</li>\n<li>对索引的认识（索引的结构、对dml影响、对查询影响、为什么提高查询性能）</li>\n<li>冷备份和热备份的不同点以及各自的优点</li>\n<li>mysql, redis, couchbase, mongodb的应用场景等</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><h4 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h4><ul>\n<li><p>操作系统的四个特性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 并发: 同一时间间隔内支持执行多个任务, 对于一个核则是交替执行；</div><div class=\"line\">2. 共享: 硬件资源或数据资源支持多个进程共享；</div><div class=\"line\">3. 异步: 并发情况下， 一个程序会陆陆续续被执行，完成时间不可预知；</div><div class=\"line\">4. 虚拟: 物理实体转化为逻辑实体，如虚拟内存。</div></pre></td></tr></table></figure>\n</li>\n<li><p>操作系统的基本功能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. CPU管理, 作业调度</div><div class=\"line\">2. 存储管理, 数据存取</div><div class=\"line\">3. 设备管理, 与外围设备交互</div><div class=\"line\">4. 接口管理, 向应用程序/用户提供交互接口</div></pre></td></tr></table></figure>\n</li>\n</ul>","more":"<ul>\n<li><p>软中断与硬中断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">系统在执行某个任务程序时收到中断信号， 需要让出当前CPU来执行中断处理。中断处理完成后，CPU再继续执行之前的任务程序。</div><div class=\"line\">1. 软中断：</div><div class=\"line\">&gt;当前运行的程序产生的中断信号，通常是I/O请求；</div><div class=\"line\">&gt;不会直接中断CPU，需要内核去为当前进程完成一些类似I/O的请求；</div><div class=\"line\">&gt;中断过程: 进程-&gt;内核设备驱动程序。</div><div class=\"line\">2. 硬中断:</div><div class=\"line\">&gt;由硬件产生，比如磁盘，网卡，时钟，键盘等；</div><div class=\"line\">&gt;直接中断CPU，通常一个中断只中断一个CPU；</div><div class=\"line\">&gt;中断过程: 硬件-&gt;CPU-&gt;内核设备驱动程序。</div><div class=\"line\">3. 中断优先级:</div><div class=\"line\">硬件错误&gt;时钟&gt;磁盘&gt;网络设备&gt;其他终端设备&gt;软件中断</div></pre></td></tr></table></figure>\n</li>\n<li><p>动态链接及静态链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">动态链接: 在程序运行期间, 所依赖的模块来自于程序外部，在内存中动态加载/卸载，按需加载可节省内存；</div><div class=\"line\">静态链接: 在程序运行期间, 所依赖的模块来自于程序内部，即编译时已打包好，程序启动时便会载入内存。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h4><ul>\n<li>进程的状态类型与转换<br>5个状态模型:<br><img src=\"http://blog.moguang.me/img/process_state.jpg\" alt=\"process_state\"></li>\n<li><p>进程与线程的区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">概念区别：</div><div class=\"line\">1. 进程： 一个程序的动态执行过程， 分配资源的基本单位；</div><div class=\"line\">2. 线程： 一个进程内调度的基本单位，一个进程包含一个或多个线程。</div><div class=\"line\">执行区别：</div><div class=\"line\">1. 进程：拥有独立内存空间，支持内部多个线程共享；</div><div class=\"line\">2. 线程：必须依赖于进程来运行，每个线程有独立入口/执行序列/出口。</div><div class=\"line\">应用意义区别：</div><div class=\"line\">一个应用运行时对应一个或多个进程， 而线程在进程的基础上提供了可以执行不同调度逻辑的入口，易于实现任务的并发执行。</div></pre></td></tr></table></figure>\n</li>\n<li><p>进程间通信的几种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 管道pipe</div><div class=\"line\">管道是独立的文件系统，有自己的数据结构。实际上是只存在于内存中的文件，需要通过两个打开的文件句柄来进行操作，他们分别表示管道的两端。管道分为无名管道和有名管道。</div><div class=\"line\">2. 共享内存</div><div class=\"line\">共享内存由一个进程创建， 能被其他进程访问， 最快的IPC方式。</div><div class=\"line\">3. 消息队列</div><div class=\"line\">消息的链表， 存放于内核并由队列标识符标识；克服了缓冲区大小受限，信号信息有限，管道无格式字节流等缺点。</div><div class=\"line\">4. 信号</div><div class=\"line\">用于通知某个进程某个事件已经发生，可触发进程已注册的处理函数。</div><div class=\"line\">5. 信号量</div><div class=\"line\">一种计数器，用来控制多个进程对共享资源的访问， 通常作为一种锁机制， 常应用于进程间或进程内多个线程的同步。</div><div class=\"line\">6. Socket</div><div class=\"line\">通过套接字通信，也可用于不同host之间的进程见通信。</div></pre></td></tr></table></figure>\n</li>\n<li><p>进程同步，线程同步的几种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 临界区（CriticalSection）（进程内线程同步）</div><div class=\"line\">一次只能被一个进程所占用的资源为临界资源；进程内访问临界资源的代码就是临界区。</div><div class=\"line\">进入区/临界区/退出区/剩余区</div><div class=\"line\">2. 事件</div><div class=\"line\">基于事件机制， 一个进程/线程主动唤醒另一个进程/线程；比如监听通信端口A。</div><div class=\"line\">3. 互斥量（Mutex）</div><div class=\"line\">类似临界区，但是能在进程间使用。Futex由一块能被多个进程共享的内存空间(对齐后的整型变量)组成, 保存在用户空间的共享内存中，通过原子操作进行操作。操作基本在用户空间内进行(需要仲裁时使用系统内核调用), 减少了系统调用次数， 提供系统性能。</div><div class=\"line\">4. 信号量(Semphore)</div><div class=\"line\">信号量建立在原子操作上，使用信号量可以用来限制共享资源的线程数目。</div></pre></td></tr></table></figure>\n</li>\n<li><p>线程的实现方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">用户级线程（也可看作协程）：进程内的线程切换不用切换到内核进行， 内核并没有感知进程内的线程存在， 所以即使多线程并不能利用多核来进行操作。一个线程如果调用了阻塞系统调用， 那整个进程都会被阻塞。</div><div class=\"line\">内核级线程（通常所说的线程）：也即内核管理的所有线程， 内核头既包含进程表， 也包含线程表。多线程可以利用到多核，多核下微观和宏观下都能做到并行。</div><div class=\"line\">混合模式： 内核线程可以在用户空间完成创建，应用的多个用户级线程可以被映射到内核线程中，提高并发效率。</div></pre></td></tr></table></figure>\n</li>\n<li><p>用户态与内核态的区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">用户态：执行用户级别的代码，权限受限，由CPU标志flag来控制；</div><div class=\"line\">内核态：执行内核模块代码，比如执行磁盘IO，网络IO处理等。</div><div class=\"line\">应用进程可通过系统调用由用户态进入内核态，在缺页错误或中断发生时进入内核态。</div></pre></td></tr></table></figure>\n</li>\n<li><p>用户栈与内核栈的区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">用户栈： 进程在用户空间时创建的栈，比如函数调用时压栈出栈， 保存了函数互相调用的参数/返回值等；</div><div class=\"line\">内核栈： 中断进入内核态时，用内核栈来保存用户态进程的状态信息，返回用户钛再将这些信息出栈；内核栈位置在内核的一块固定区域，保存中断现场，进程调用数据等。</div></pre></td></tr></table></figure>\n</li>\n<li><p>内存池，进程池，线程池</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">所谓池的概念， 一般是指应用提前向内核批量申请资源，用于接下来的使用和回收再利用， 减少资源的初始化和销毁次数等开销， 以达到提高系统性能的目标。</div><div class=\"line\">内存池：真正使用前申请一片内存区域，有新需求时取出其中一部分使用，不够用时再重新申请新内存。</div><div class=\"line\">进程池：</div><div class=\"line\">&gt;应用预先创建一组子进程，所有子进程运行相同代码，拥有相同属性，比如PGID和优先级等；</div><div class=\"line\">&gt;常见两种工作方式：</div><div class=\"line\">1. 主进程通过随机或round robin算法来选择子进程作为新任务的服务进程；</div><div class=\"line\">2. 通过一个共享队列来进行同步，所有子进程从该队列中获取任务，不过同时只能有一个子进程能成功获得新任务处理权。</div><div class=\"line\">线程池：</div><div class=\"line\">主要应用于任务小而多，处理时间短的场景，比如简单网页请求等。</div></pre></td></tr></table></figure>\n</li>\n<li><p>死锁的概念，产生条件及处理策略</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">死锁：一组竞争同一系统资源或通信的进程由于互相等待而造成的永久阻塞。</div><div class=\"line\">产生死锁的四个条件：</div><div class=\"line\">1. 互斥： 一次只能有一个进程使用一个资源。</div><div class=\"line\">2. 占有并等待： 一个进程等待另一个资源的同时占有一个已分配的资源。</div><div class=\"line\">3. 不可抢占： 一个已被某个进程占有的资源不可被其他进程抢夺。</div><div class=\"line\">4. 循环等待： 在一个封闭进程链中，每个进程至少占有下一个进程所等待的资源。</div><div class=\"line\">处理死锁几种方式：预防/避免/检测，比如一次性申请所需资源，银行家算法。</div></pre></td></tr></table></figure>\n</li>\n<li><p>进程调度算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">调度种类：</div><div class=\"line\">1. 高级调度： 作业调度，决定把后备作业调入内存运行；</div><div class=\"line\">2. 中级调度： 内存，外存交换区进行进程对换；</div><div class=\"line\">3. 低级调度： 进程调度，决定把就绪状态的进程获得CPU。</div><div class=\"line\">CPU任务种类： 交互式任务和批处理任务。</div><div class=\"line\">调度算法：</div><div class=\"line\">1. FIFO(FCFS)： 公平简单，不利于交互式，不利于IO密集型作业；</div><div class=\"line\">2. SJF：短作业优先调度，可以保证整体的最小等待时间，但不利于长作业；</div><div class=\"line\">3. 优先权调度：拥有高优先权的作业优先处理， 有可能出现优先权低的任务“饥饿”情况；</div><div class=\"line\">4. Round-Robin：按时间片进行轮转调度，让每个任务定时有响应但是上下文切换次数可能会过多。</div><div class=\"line\">5. 多级优先级队列：按不同规则创建多个进程队列，不同队列拥有不同的优先级以及可以分配不同的时间片/调度策略。但是也存在”饥饿“可能性。</div><div class=\"line\">6. 多级反馈队列：在多级优先级队列基础上，长期得不到运行的队列优先级会被提高。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h4><ul>\n<li><p>内存管理的技术发展</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 固定分区：系统初始化阶段，内存被固定划分成多个静态分区，进程可以一次性被装载到大于或等于自身空间的分区；</div><div class=\"line\">2. 动态分区：动态创建分区，进程可以被装载到与自身相等大小的分区中；</div><div class=\"line\">3. 虚拟内存分页：系统初始化阶段，内存被划分为多个大小一致的页框；每个进程被划分成多个与页框相等的页；根据实时需要加载一定数量的页。</div><div class=\"line\">4. 虚拟内存分段：每个进程维护一个段表，系统维护一个空闲的块表，按需加载段。</div><div class=\"line\">5. 段页式： 单按页加载的调度粒度太细，单按段加载的调度粒度太粗， 结合使用可有效提高系统性能。应用地址空间可划分成多个段，每个段又划分为多个固定大小的页，段偏移量在系统角度可看作是指定段中的一个页好和页偏移。</div></pre></td></tr></table></figure>\n</li>\n<li><p>物理内存与虚拟内存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">物理地址：实际物理内存中的存储地址；</div><div class=\"line\">虚拟地址： 编码时将代码或数据分成若干段，每条代码或数据对应的地址由段号加段内偏移地址构成。</div><div class=\"line\">MMU: 实现将虚拟地址映射到物理地址的CPU中的硬件电路。</div></pre></td></tr></table></figure>\n</li>\n<li><p>几种页面置换算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">FIFIO： 淘汰最早调入的页面；</div><div class=\"line\">OPT： 理想化的最佳置换算法，将标记为下次最迟才会被访问的页面淘汰；</div><div class=\"line\">LRU： 将最近一段时间内最久没有被使用的页置换出去。</div></pre></td></tr></table></figure>\n</li>\n<li><p>DMA定义及工作流程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">DMA指外部设备不经过CPU而直接与内存交换数据的技术。</div><div class=\"line\">主要通过DMA控制器来实现： 控制器向CPU请求系统总线并获得控制权后， 与存储器直接进行数据交换， 完成后向CPU发送结束信号并交还控制权。</div></pre></td></tr></table></figure>\n</li>\n<li><p>外存分配的几种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">外存：CPU缓存及内存以外的存储器， 如硬盘/光盘等。</div><div class=\"line\">分配方式：</div><div class=\"line\">1. 连续分配：创建文件时，分配一组连续的块， FAT中每个文件只需要一项，用以说明起始块及文件大小。</div><div class=\"line\">2. 链式分配： 文件存放在若干不连续的物理块，各块之间通过指针连接。</div><div class=\"line\">3. 索引分配： 每个文件在FAT中有一个一级索引， 包含文件各个分区的入口；这个索引信息保存在单独个一个块当中， 作为文件的访问入口。</div></pre></td></tr></table></figure>\n</li>\n<li><p>CPU中的缓存及OS中的缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CPU缓存： 介于CPU与内存之间的临时存储器， 有一级/二级/三级缓存之分；</div><div class=\"line\">系统缓存： 如块表，用于存放当前访问最频繁的少量活动页，提高数据存取速度。通过需要存取的数据所在逻辑地址，在块表中找到其对应的内存块地址， 结合其页偏移地址获得物理地址；如果块表中没有该逻辑页号，则通过查询空闲块来更新块空闲区信息；如果块表没有空闲区，则通过算法来淘汰块表中某一行，并填入新的空闲区。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h4><ul>\n<li>垃圾回收的几种算法</li>\n</ul>\n<h3 id=\"网络知识\"><a href=\"#网络知识\" class=\"headerlink\" title=\"网络知识\"></a>网络知识</h3><ul>\n<li>7层模型及4层模型的具体定义</li>\n<li>常见的网络协议及所处的TCP/IP模型层次</li>\n<li>TCP建立及关闭连接过程</li>\n<li>TCP滑动窗口及拥塞控制</li>\n<li>TCP的快速重传与快速恢复算法</li>\n<li>网络差错检测CRC</li>\n</ul>\n<h3 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h3><ul>\n<li>堆，栈，链表， 树， hashmap等结构</li>\n<li>常见的搜索/排序算法</li>\n<li>经典的分治算法</li>\n<li>分布式一致性hash</li>\n<li>分布式同步算法</li>\n</ul>\n<h3 id=\"数据库知识\"><a href=\"#数据库知识\" class=\"headerlink\" title=\"数据库知识\"></a>数据库知识</h3><ul>\n<li>事务与锁的概念</li>\n<li>视图与游标的概念</li>\n<li>对索引的认识（索引的结构、对dml影响、对查询影响、为什么提高查询性能）</li>\n<li>冷备份和热备份的不同点以及各自的优点</li>\n<li>mysql, redis, couchbase, mongodb的应用场景等</li>\n</ul>"},{"title":"[Linux]用户空间与内核空间","date":"2017-10-25T06:42:48.000Z","_content":"\n源文: http://learnlinuxconcepts.blogspot.com/2014/02/kernel-space-and-user-space.html\n\n理解用户空间及内核空间对于增强理解Linux内核知识是非常重要的。\n\n- 这里的用户空间及内核空间对应于虚拟地址空间.\n- 每个linux中的进程占用独立的虚拟空间.\n- 在32位架构linux系统中, 用户空间至少对应3GB虚拟空间, 而内核空间至多占1GB空间.(普遍情况)\n- 内核空间的虚拟地址空间共享给所有进程使用.\n- 当一个进程活跃时, 要么处于用户态, 要么处于内核态.\n<!--more-->\n- 当一个进程运行在用户态时, 意味着CPU正在运行用户空间中的代码.\n- 用户态进程权限会受限, 并由CPU中的标志flag控制.\n- 虽然内核内存地址可在进程的内存映射表中访问得到, 但用户空间代码并不被允许去访问内核空间代码.(不过可通过特殊方法做到).\n- 当一个进程想要进行类似拷贝外部数据到它内存空间的操作(如打开某个文件), 它必须通过系统调用来与内核通讯.\n- 每种CPU架构都有它独特方式去进行系统调用, 但底层基础都是一致的, 也就是:\n- 一条指令被执行时, CPU将flag标志为\"privileged mode\", 同时跳到制定的内核空间地址, 也就是\"系统调用入口地址\".( 关于系统调用可参考另一篇文章)\n- 现在系统调用已进入内核空间, 进程也就进入内核态并在内核空间内存中执行指令.\n- 同样以系统调用为例, 要找到所请求的文件, 内核需要与文件系统驱动进行商议(确认文件在哪个位置) 并阻塞设备驱动 (从disk中加载必要的块) 或网络设备驱动 (从远程源中加载文件).\n- 这些驱动可以是内建或额外加载的模块， 而重点是他们都是内核空间的一部分.\n- 在系统调用请求内核拷贝模块代码和数据到内核空间, 并在内核态中运行它的初始化代码后, 模块加载便完成.\n- 如果内核不能立刻完成请求处理则将进程置为睡眠状态, 当请求处理完成后系统调用再返回到用户态.\n- 回到用户态意味着将CPU寄存器恢复到进入内核态之前的状态, 同时将CPU优先级置为none-privilege.\n- 除了系统调用, 还有一些操作也可以使CPU进入内核态, 比如\n\n1. 缺页错误- 如果进程尝试访问一个没有对应物理地址的虚拟内存地址时, CPU将进入内核态并跳到缺页错误处理模块, 判断虚拟地址是否有效, 如果有效则尝试创建一个物理页给该虚拟地址, 否则发出段错误信号(SIGSEGV).\n\n2. 中断- 当CPU接收到来自硬件的中断指令时, 将进入内核态并执行中断处理方法。当内核完成指令处理时, CPU返回用户态并从上次代码中断位置继续执行.\n","source":"_posts/linux/UserSpace-vs-KernelSpace.md","raw":"---\ntitle: '[Linux]用户空间与内核空间'\ndate: 2017-10-25 14:42:48\ntags: linux kernel\n---\n\n源文: http://learnlinuxconcepts.blogspot.com/2014/02/kernel-space-and-user-space.html\n\n理解用户空间及内核空间对于增强理解Linux内核知识是非常重要的。\n\n- 这里的用户空间及内核空间对应于虚拟地址空间.\n- 每个linux中的进程占用独立的虚拟空间.\n- 在32位架构linux系统中, 用户空间至少对应3GB虚拟空间, 而内核空间至多占1GB空间.(普遍情况)\n- 内核空间的虚拟地址空间共享给所有进程使用.\n- 当一个进程活跃时, 要么处于用户态, 要么处于内核态.\n<!--more-->\n- 当一个进程运行在用户态时, 意味着CPU正在运行用户空间中的代码.\n- 用户态进程权限会受限, 并由CPU中的标志flag控制.\n- 虽然内核内存地址可在进程的内存映射表中访问得到, 但用户空间代码并不被允许去访问内核空间代码.(不过可通过特殊方法做到).\n- 当一个进程想要进行类似拷贝外部数据到它内存空间的操作(如打开某个文件), 它必须通过系统调用来与内核通讯.\n- 每种CPU架构都有它独特方式去进行系统调用, 但底层基础都是一致的, 也就是:\n- 一条指令被执行时, CPU将flag标志为\"privileged mode\", 同时跳到制定的内核空间地址, 也就是\"系统调用入口地址\".( 关于系统调用可参考另一篇文章)\n- 现在系统调用已进入内核空间, 进程也就进入内核态并在内核空间内存中执行指令.\n- 同样以系统调用为例, 要找到所请求的文件, 内核需要与文件系统驱动进行商议(确认文件在哪个位置) 并阻塞设备驱动 (从disk中加载必要的块) 或网络设备驱动 (从远程源中加载文件).\n- 这些驱动可以是内建或额外加载的模块， 而重点是他们都是内核空间的一部分.\n- 在系统调用请求内核拷贝模块代码和数据到内核空间, 并在内核态中运行它的初始化代码后, 模块加载便完成.\n- 如果内核不能立刻完成请求处理则将进程置为睡眠状态, 当请求处理完成后系统调用再返回到用户态.\n- 回到用户态意味着将CPU寄存器恢复到进入内核态之前的状态, 同时将CPU优先级置为none-privilege.\n- 除了系统调用, 还有一些操作也可以使CPU进入内核态, 比如\n\n1. 缺页错误- 如果进程尝试访问一个没有对应物理地址的虚拟内存地址时, CPU将进入内核态并跳到缺页错误处理模块, 判断虚拟地址是否有效, 如果有效则尝试创建一个物理页给该虚拟地址, 否则发出段错误信号(SIGSEGV).\n\n2. 中断- 当CPU接收到来自硬件的中断指令时, 将进入内核态并执行中断处理方法。当内核完成指令处理时, CPU返回用户态并从上次代码中断位置继续执行.\n","slug":"linux/UserSpace-vs-KernelSpace","published":1,"updated":"2017-10-25T06:44:09.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dw300114j4d7etvtera","content":"<p>源文: <a href=\"http://learnlinuxconcepts.blogspot.com/2014/02/kernel-space-and-user-space.html\" target=\"_blank\" rel=\"external\">http://learnlinuxconcepts.blogspot.com/2014/02/kernel-space-and-user-space.html</a></p>\n<p>理解用户空间及内核空间对于增强理解Linux内核知识是非常重要的。</p>\n<ul>\n<li>这里的用户空间及内核空间对应于虚拟地址空间.</li>\n<li>每个linux中的进程占用独立的虚拟空间.</li>\n<li>在32位架构linux系统中, 用户空间至少对应3GB虚拟空间, 而内核空间至多占1GB空间.(普遍情况)</li>\n<li>内核空间的虚拟地址空间共享给所有进程使用.</li>\n<li>当一个进程活跃时, 要么处于用户态, 要么处于内核态.<a id=\"more\"></a></li>\n<li>当一个进程运行在用户态时, 意味着CPU正在运行用户空间中的代码.</li>\n<li>用户态进程权限会受限, 并由CPU中的标志flag控制.</li>\n<li>虽然内核内存地址可在进程的内存映射表中访问得到, 但用户空间代码并不被允许去访问内核空间代码.(不过可通过特殊方法做到).</li>\n<li>当一个进程想要进行类似拷贝外部数据到它内存空间的操作(如打开某个文件), 它必须通过系统调用来与内核通讯.</li>\n<li>每种CPU架构都有它独特方式去进行系统调用, 但底层基础都是一致的, 也就是:</li>\n<li>一条指令被执行时, CPU将flag标志为”privileged mode”, 同时跳到制定的内核空间地址, 也就是”系统调用入口地址”.( 关于系统调用可参考另一篇文章)</li>\n<li>现在系统调用已进入内核空间, 进程也就进入内核态并在内核空间内存中执行指令.</li>\n<li>同样以系统调用为例, 要找到所请求的文件, 内核需要与文件系统驱动进行商议(确认文件在哪个位置) 并阻塞设备驱动 (从disk中加载必要的块) 或网络设备驱动 (从远程源中加载文件).</li>\n<li>这些驱动可以是内建或额外加载的模块， 而重点是他们都是内核空间的一部分.</li>\n<li>在系统调用请求内核拷贝模块代码和数据到内核空间, 并在内核态中运行它的初始化代码后, 模块加载便完成.</li>\n<li>如果内核不能立刻完成请求处理则将进程置为睡眠状态, 当请求处理完成后系统调用再返回到用户态.</li>\n<li>回到用户态意味着将CPU寄存器恢复到进入内核态之前的状态, 同时将CPU优先级置为none-privilege.</li>\n<li>除了系统调用, 还有一些操作也可以使CPU进入内核态, 比如</li>\n</ul>\n<ol>\n<li><p>缺页错误- 如果进程尝试访问一个没有对应物理地址的虚拟内存地址时, CPU将进入内核态并跳到缺页错误处理模块, 判断虚拟地址是否有效, 如果有效则尝试创建一个物理页给该虚拟地址, 否则发出段错误信号(SIGSEGV).</p>\n</li>\n<li><p>中断- 当CPU接收到来自硬件的中断指令时, 将进入内核态并执行中断处理方法。当内核完成指令处理时, CPU返回用户态并从上次代码中断位置继续执行.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>源文: <a href=\"http://learnlinuxconcepts.blogspot.com/2014/02/kernel-space-and-user-space.html\" target=\"_blank\" rel=\"external\">http://learnlinuxconcepts.blogspot.com/2014/02/kernel-space-and-user-space.html</a></p>\n<p>理解用户空间及内核空间对于增强理解Linux内核知识是非常重要的。</p>\n<ul>\n<li>这里的用户空间及内核空间对应于虚拟地址空间.</li>\n<li>每个linux中的进程占用独立的虚拟空间.</li>\n<li>在32位架构linux系统中, 用户空间至少对应3GB虚拟空间, 而内核空间至多占1GB空间.(普遍情况)</li>\n<li>内核空间的虚拟地址空间共享给所有进程使用.</li>\n<li>当一个进程活跃时, 要么处于用户态, 要么处于内核态.","more":"</li>\n<li>当一个进程运行在用户态时, 意味着CPU正在运行用户空间中的代码.</li>\n<li>用户态进程权限会受限, 并由CPU中的标志flag控制.</li>\n<li>虽然内核内存地址可在进程的内存映射表中访问得到, 但用户空间代码并不被允许去访问内核空间代码.(不过可通过特殊方法做到).</li>\n<li>当一个进程想要进行类似拷贝外部数据到它内存空间的操作(如打开某个文件), 它必须通过系统调用来与内核通讯.</li>\n<li>每种CPU架构都有它独特方式去进行系统调用, 但底层基础都是一致的, 也就是:</li>\n<li>一条指令被执行时, CPU将flag标志为”privileged mode”, 同时跳到制定的内核空间地址, 也就是”系统调用入口地址”.( 关于系统调用可参考另一篇文章)</li>\n<li>现在系统调用已进入内核空间, 进程也就进入内核态并在内核空间内存中执行指令.</li>\n<li>同样以系统调用为例, 要找到所请求的文件, 内核需要与文件系统驱动进行商议(确认文件在哪个位置) 并阻塞设备驱动 (从disk中加载必要的块) 或网络设备驱动 (从远程源中加载文件).</li>\n<li>这些驱动可以是内建或额外加载的模块， 而重点是他们都是内核空间的一部分.</li>\n<li>在系统调用请求内核拷贝模块代码和数据到内核空间, 并在内核态中运行它的初始化代码后, 模块加载便完成.</li>\n<li>如果内核不能立刻完成请求处理则将进程置为睡眠状态, 当请求处理完成后系统调用再返回到用户态.</li>\n<li>回到用户态意味着将CPU寄存器恢复到进入内核态之前的状态, 同时将CPU优先级置为none-privilege.</li>\n<li>除了系统调用, 还有一些操作也可以使CPU进入内核态, 比如</li>\n</ul>\n<ol>\n<li><p>缺页错误- 如果进程尝试访问一个没有对应物理地址的虚拟内存地址时, CPU将进入内核态并跳到缺页错误处理模块, 判断虚拟地址是否有效, 如果有效则尝试创建一个物理页给该虚拟地址, 否则发出段错误信号(SIGSEGV).</p>\n</li>\n<li><p>中断- 当CPU接收到来自硬件的中断指令时, 将进入内核态并执行中断处理方法。当内核完成指令处理时, CPU返回用户态并从上次代码中断位置继续执行.</p>\n</li>\n</ol>"},{"title":"CentOS7 中文乱码问题","date":"2017-07-22T17:25:42.000Z","_content":"\n## 修改/etc/locale.conf\n\n```bash\nLANG=\"en_US.UTF-8\"\n```\n\n## 修改/etc/sysconfig/i18n\n\n```bash\nLANG=\"zh_CN.UTF-8\"\n```\n<!--more-->\n\n## 修改/etc/vimrc或~/.vimrc,添加\n```bash\nset fileencodings=utf-8,gb2312,gbk,gb18030  \nset termencoding=utf-8  \nset fileformats=unix  \nset encoding=prc\n```\n\n## 刷新配置文件\n\n```bash\nsource /etc/locale.conf\nsource /etc/sysconfig/i18n\nsource ~/.vimrc\nsource /etc/vimrc\n```\n","source":"_posts/encode/centos_zh.md","raw":"---\ntitle: CentOS7 中文乱码问题\ndate: 2017/07/23 1:25:42\n---\n\n## 修改/etc/locale.conf\n\n```bash\nLANG=\"en_US.UTF-8\"\n```\n\n## 修改/etc/sysconfig/i18n\n\n```bash\nLANG=\"zh_CN.UTF-8\"\n```\n<!--more-->\n\n## 修改/etc/vimrc或~/.vimrc,添加\n```bash\nset fileencodings=utf-8,gb2312,gbk,gb18030  \nset termencoding=utf-8  \nset fileformats=unix  \nset encoding=prc\n```\n\n## 刷新配置文件\n\n```bash\nsource /etc/locale.conf\nsource /etc/sysconfig/i18n\nsource ~/.vimrc\nsource /etc/vimrc\n```\n","slug":"encode/centos_zh","published":1,"updated":"2017-08-20T05:48:47.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dw400124j4dl7bzbqoc","content":"<h2 id=\"修改-etc-locale-conf\"><a href=\"#修改-etc-locale-conf\" class=\"headerlink\" title=\"修改/etc/locale.conf\"></a>修改/etc/locale.conf</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LANG=<span class=\"string\">\"en_US.UTF-8\"</span></div></pre></td></tr></table></figure>\n<h2 id=\"修改-etc-sysconfig-i18n\"><a href=\"#修改-etc-sysconfig-i18n\" class=\"headerlink\" title=\"修改/etc/sysconfig/i18n\"></a>修改/etc/sysconfig/i18n</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LANG=<span class=\"string\">\"zh_CN.UTF-8\"</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"修改-etc-vimrc或-vimrc-添加\"><a href=\"#修改-etc-vimrc或-vimrc-添加\" class=\"headerlink\" title=\"修改/etc/vimrc或~/.vimrc,添加\"></a>修改/etc/vimrc或~/.vimrc,添加</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">set</span> fileencodings=utf-8,gb2312,gbk,gb18030  </div><div class=\"line\"><span class=\"built_in\">set</span> termencoding=utf-8  </div><div class=\"line\"><span class=\"built_in\">set</span> fileformats=unix  </div><div class=\"line\"><span class=\"built_in\">set</span> encoding=prc</div></pre></td></tr></table></figure>\n<h2 id=\"刷新配置文件\"><a href=\"#刷新配置文件\" class=\"headerlink\" title=\"刷新配置文件\"></a>刷新配置文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">source</span> /etc/locale.conf</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/sysconfig/i18n</div><div class=\"line\"><span class=\"built_in\">source</span> ~/.vimrc</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/vimrc</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"修改-etc-locale-conf\"><a href=\"#修改-etc-locale-conf\" class=\"headerlink\" title=\"修改/etc/locale.conf\"></a>修改/etc/locale.conf</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LANG=<span class=\"string\">\"en_US.UTF-8\"</span></div></pre></td></tr></table></figure>\n<h2 id=\"修改-etc-sysconfig-i18n\"><a href=\"#修改-etc-sysconfig-i18n\" class=\"headerlink\" title=\"修改/etc/sysconfig/i18n\"></a>修改/etc/sysconfig/i18n</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LANG=<span class=\"string\">\"zh_CN.UTF-8\"</span></div></pre></td></tr></table></figure>","more":"<h2 id=\"修改-etc-vimrc或-vimrc-添加\"><a href=\"#修改-etc-vimrc或-vimrc-添加\" class=\"headerlink\" title=\"修改/etc/vimrc或~/.vimrc,添加\"></a>修改/etc/vimrc或~/.vimrc,添加</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">set</span> fileencodings=utf-8,gb2312,gbk,gb18030  </div><div class=\"line\"><span class=\"built_in\">set</span> termencoding=utf-8  </div><div class=\"line\"><span class=\"built_in\">set</span> fileformats=unix  </div><div class=\"line\"><span class=\"built_in\">set</span> encoding=prc</div></pre></td></tr></table></figure>\n<h2 id=\"刷新配置文件\"><a href=\"#刷新配置文件\" class=\"headerlink\" title=\"刷新配置文件\"></a>刷新配置文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">source</span> /etc/locale.conf</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/sysconfig/i18n</div><div class=\"line\"><span class=\"built_in\">source</span> ~/.vimrc</div><div class=\"line\"><span class=\"built_in\">source</span> /etc/vimrc</div></pre></td></tr></table></figure>"},{"title":"python之encode/decode","date":"2017-07-23T04:46:25.000Z","_content":"\n## python之encode/decode\n\n```python\n# coding: utf-8\n\nimport base64\n\nto_enc = 'sampledata'\nenc_res = base64.b64encode(to_enc)\nprint enc_res\n\ndec_res = base64.b64decode(enc_res)\nprint dec_res\n```\n运行效果如下:\n\n```bash\nroot@XIAOMO:/tmp# python27 b64.py\nc2FtcGxlZGF0YQ==\nsampledata\n```\n","source":"_posts/encode/base64.md","raw":"---\ntitle: python之encode/decode\ndate: 2017/7/23 12:46:25\n---\n\n## python之encode/decode\n\n```python\n# coding: utf-8\n\nimport base64\n\nto_enc = 'sampledata'\nenc_res = base64.b64encode(to_enc)\nprint enc_res\n\ndec_res = base64.b64decode(enc_res)\nprint dec_res\n```\n运行效果如下:\n\n```bash\nroot@XIAOMO:/tmp# python27 b64.py\nc2FtcGxlZGF0YQ==\nsampledata\n```\n","slug":"encode/base64","published":1,"updated":"2017-07-23T06:36:17.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dw600144j4dfds7c7ca","content":"<h2 id=\"python之encode-decode\"><a href=\"#python之encode-decode\" class=\"headerlink\" title=\"python之encode/decode\"></a>python之encode/decode</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding: utf-8</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> base64</div><div class=\"line\"></div><div class=\"line\">to_enc = <span class=\"string\">'sampledata'</span></div><div class=\"line\">enc_res = base64.b64encode(to_enc)</div><div class=\"line\"><span class=\"keyword\">print</span> enc_res</div><div class=\"line\"></div><div class=\"line\">dec_res = base64.b64decode(enc_res)</div><div class=\"line\"><span class=\"keyword\">print</span> dec_res</div></pre></td></tr></table></figure>\n<p>运行效果如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:/tmp<span class=\"comment\"># python27 b64.py</span></div><div class=\"line\">c2FtcGxlZGF0YQ==</div><div class=\"line\">sampledata</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"python之encode-decode\"><a href=\"#python之encode-decode\" class=\"headerlink\" title=\"python之encode/decode\"></a>python之encode/decode</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding: utf-8</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> base64</div><div class=\"line\"></div><div class=\"line\">to_enc = <span class=\"string\">'sampledata'</span></div><div class=\"line\">enc_res = base64.b64encode(to_enc)</div><div class=\"line\"><span class=\"keyword\">print</span> enc_res</div><div class=\"line\"></div><div class=\"line\">dec_res = base64.b64decode(enc_res)</div><div class=\"line\"><span class=\"keyword\">print</span> dec_res</div></pre></td></tr></table></figure>\n<p>运行效果如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:/tmp<span class=\"comment\"># python27 b64.py</span></div><div class=\"line\">c2FtcGxlZGF0YQ==</div><div class=\"line\">sampledata</div></pre></td></tr></table></figure>\n"},{"title":"理解TCP/IP协议栈(1)","date":"2017-10-26T09:09:45.000Z","_content":"\n翻译自: https://www.cubrid.org/blog/understanding-tcp-ip-network-stack\n\n目前我们的internet服务都是基于TCP/IP来开发的, 无法想像没有TCP/IP的Internet会是什么样子. 因此无论是在逻辑调整, 故障排除，还是发现新技术方面, 理解网络中数据的传输原理会帮助我们多方面提高服务性能表现.\n本文会介绍基于Linux系统及硬件层数据流和控制流的网络协议栈体系.\nTCP/IP重点特征\n我应该怎么设计网络协议来保证数据的快速传输， 并保证数据有序不丢失？\nTCP and IP\n严格来说由于TCP和IP在不同层次上, 分开来描述它们也是可以的. 不过这里将他们描述为一个整体.\n1. 面向连接\n首先,  两个终端(本地和远程)建立了连接, 数据开始传输. 此处\"TCP connection identifier\"是两个终端的地址组合, 类型为`<local IP address, local port number, remote IP address, remote port number> `.\n2. 双向字节流\n双向的数据以字节流来进行通讯.\n3. 按序传输\n接收者按发送者发送顺序来接收数据. 因此数据是要求有序的, 一个32位int类型的数据用于标志次序.\n<!--more-->\n4. ACK保证可靠性\n当发送者向接收者发送数据后并没有收到ACK, 发送者会重发TCP数据. 因此, 发送者会缓存没有从接收到ACK的数据.\n5. 流控制\n发送者会尽可能多的发送数据. 接收者告知发送者它能接收的最大字节数(空闲的buffer size, 接收窗口); 发送者基于这个最大字节数尽可能快的发送数据.\n6. 拥塞控制\n拥塞窗口 用于分割接收窗口,通过限制网络数据流来避免网络拥塞. 类似接收窗口, 发送者会根据接收者的拥塞窗口大小限制而使用多种策略来发送尽可能多的数据, 策略比如有TCP Vegas, Westwood, BIC, 和CUBIC. 和流控制不同的是, 拥塞控制只在发送者上实现.\n数据传输\n网络栈包含多层, Figure 1展示了每层的类型.\n![tcp/ip layer](/img/tcp_ip_stat.png)\nFigure 1: TCP/IO网络栈在数据传输时各层的处理过程.\n可以简单分为三层结构:\n\n- 用户层面\n\n- 内核层面\n\n- 设备层面\n\n用户层面和内核层面的任务由CPU来处理. 用户层和内核层称为\"host\", 以此与设备层区分. 这里的设备指的是用于发送/接收数据包的Network Interface Card (NIC). 更准确的术语叫\"LAN card\".\n用户层面: 首先应用程序创建要发送的数据 (Figure 1中\"User data\")并调用系统函数write()来发送数据. 假设socket已创建好(Figure 1中的fd). 当进入系统调用时, 系统进入内核态.\nPOSIX系列操作系统(包括Linux, Unix)通过文件描述符将socket暴露给应用程序. 在此类系统中, socket可看作是一种文件. 文件层执行简单校验后调用socket函数来连接到文件结构.\n内核socket有两个buffer:\n\n- send socket buffer: 用于发送数据;\n- receive socket buffer: 用于接收数据.\n\n当系统函数write被调用时, 数据将从用户区拷贝到内核区内存并且添加到socket buffer的末端, 这样按顺序发送数据. 如Figure 1, 浅灰色框包含的部分表示的是在发送buffer中的数据. 然后调用TCP.\nTCP Control Block (TCB)结构用于连接socket. TCB包含请求处理TCP连接的数据, 包括: 连接状态(LISTEN, ESTABLISHED, TIME_WAIT), 接收窗口, 拥塞窗口, 序号, 重发时钟, 等等.\n如果当前TCP状态允许数据传输, 一个新的TCP段(也叫packet)将被创建. 如果由于流控制这些原因无法传输数据, 系统调用会结束并且系统返回到 用户态(也就是将控制权交回应用程序).\nFigure 2展示了两个TCP段:\n\n- TCP头;\n\n- 内容载体payload.\n![tcp segment](/img/tcp_payload.png)\nFigure 2: TCP Frame Structure (source).\n\npayload包含了未接收到ACK的socket buffer内容. payload的最大长度为接收窗口大小, 拥塞窗口, maximum segment size (MSS)三者中的最大值.\n然后计算TCP检验码: 计算元素包含头部信息(IP addresses, segment length, and protocol number). 然后根据TCP状态发送一个或多个packet.\n实际上目前网络栈的TCP校验码由NIC计算而非内核. 不过我们认为内核计算TCP校验码更加方便.\nTCP段传输到IP层: IP层在TCP段头部加上IP头信息用于IP路由. IP routing是不断跳到中间IP并最终到达目标IP的过程.\nIP包传输到链路层: 链路层会使用ARP协议来找到下一个跳转IP的MAC地址. 它会将Ethernet头信息加到packet上, 这样一个host数据packet便完整了.\n经过IP routing后, 经过NIC将数据传输到下一个跳转IP, 此过程会调用NIC驱动.\n这个时候, 如果运行了tcpdump或Wireshark等抓包程序, 内核将会将数据包拷贝到这种程序的缓冲区. 这种情况下接收的数据包将在驱动层直接被抓取. 一般流量整形功能都是在链路层实现的.\n链路驱动根据NIC制造商提供的NIC驱动通讯协议来请求传输数据包.\n接收到包传输请求后, NIC将数据包从主存中拷贝到它的内存并发送到网络中. 这时根据以太网标准, 它将IFG (Inter-Frame Gap), preamble, 及CRC信息到packet中. IFG和preamble用来区分包的开始位置(专业术语, 帧), CRC用来保护数据(和TCP及IP checksum目的一样). 数据包基于以太网物理速率及流控制条件来开始传输.\n当NIC发送一个包, NIC在主机CPU产生一个中断. 每个中断有他的中断标志号, 然后OS根据中断号来调用对应的驱动来处理中断. 驱动在启动时会向系统注册一个函数, 用于处理中断指令. The OS calls the interrupt handler and then the interrupt handler returns the transmitted packet to the OS(??).\n目前我们讨论了当应用程序请求write时, 内核和设备处理数据传输的过程. 不过, 没有来自应用程序的write请求, 内核也可以直接通过TCP来传输数据包. 比如当接收到一个ACK且接收窗口已扩展时, 内核将创建一个包含socket buffer剩余数据的TCP段, 并发送给接收者.\n","source":"_posts/network/Understand-TCP-IP-Stack.md","raw":"---\ntitle: '理解TCP/IP协议栈(1)'\ndate: 2017-10-26 17:09:45\ntags: networking\n---\n\n翻译自: https://www.cubrid.org/blog/understanding-tcp-ip-network-stack\n\n目前我们的internet服务都是基于TCP/IP来开发的, 无法想像没有TCP/IP的Internet会是什么样子. 因此无论是在逻辑调整, 故障排除，还是发现新技术方面, 理解网络中数据的传输原理会帮助我们多方面提高服务性能表现.\n本文会介绍基于Linux系统及硬件层数据流和控制流的网络协议栈体系.\nTCP/IP重点特征\n我应该怎么设计网络协议来保证数据的快速传输， 并保证数据有序不丢失？\nTCP and IP\n严格来说由于TCP和IP在不同层次上, 分开来描述它们也是可以的. 不过这里将他们描述为一个整体.\n1. 面向连接\n首先,  两个终端(本地和远程)建立了连接, 数据开始传输. 此处\"TCP connection identifier\"是两个终端的地址组合, 类型为`<local IP address, local port number, remote IP address, remote port number> `.\n2. 双向字节流\n双向的数据以字节流来进行通讯.\n3. 按序传输\n接收者按发送者发送顺序来接收数据. 因此数据是要求有序的, 一个32位int类型的数据用于标志次序.\n<!--more-->\n4. ACK保证可靠性\n当发送者向接收者发送数据后并没有收到ACK, 发送者会重发TCP数据. 因此, 发送者会缓存没有从接收到ACK的数据.\n5. 流控制\n发送者会尽可能多的发送数据. 接收者告知发送者它能接收的最大字节数(空闲的buffer size, 接收窗口); 发送者基于这个最大字节数尽可能快的发送数据.\n6. 拥塞控制\n拥塞窗口 用于分割接收窗口,通过限制网络数据流来避免网络拥塞. 类似接收窗口, 发送者会根据接收者的拥塞窗口大小限制而使用多种策略来发送尽可能多的数据, 策略比如有TCP Vegas, Westwood, BIC, 和CUBIC. 和流控制不同的是, 拥塞控制只在发送者上实现.\n数据传输\n网络栈包含多层, Figure 1展示了每层的类型.\n![tcp/ip layer](/img/tcp_ip_stat.png)\nFigure 1: TCP/IO网络栈在数据传输时各层的处理过程.\n可以简单分为三层结构:\n\n- 用户层面\n\n- 内核层面\n\n- 设备层面\n\n用户层面和内核层面的任务由CPU来处理. 用户层和内核层称为\"host\", 以此与设备层区分. 这里的设备指的是用于发送/接收数据包的Network Interface Card (NIC). 更准确的术语叫\"LAN card\".\n用户层面: 首先应用程序创建要发送的数据 (Figure 1中\"User data\")并调用系统函数write()来发送数据. 假设socket已创建好(Figure 1中的fd). 当进入系统调用时, 系统进入内核态.\nPOSIX系列操作系统(包括Linux, Unix)通过文件描述符将socket暴露给应用程序. 在此类系统中, socket可看作是一种文件. 文件层执行简单校验后调用socket函数来连接到文件结构.\n内核socket有两个buffer:\n\n- send socket buffer: 用于发送数据;\n- receive socket buffer: 用于接收数据.\n\n当系统函数write被调用时, 数据将从用户区拷贝到内核区内存并且添加到socket buffer的末端, 这样按顺序发送数据. 如Figure 1, 浅灰色框包含的部分表示的是在发送buffer中的数据. 然后调用TCP.\nTCP Control Block (TCB)结构用于连接socket. TCB包含请求处理TCP连接的数据, 包括: 连接状态(LISTEN, ESTABLISHED, TIME_WAIT), 接收窗口, 拥塞窗口, 序号, 重发时钟, 等等.\n如果当前TCP状态允许数据传输, 一个新的TCP段(也叫packet)将被创建. 如果由于流控制这些原因无法传输数据, 系统调用会结束并且系统返回到 用户态(也就是将控制权交回应用程序).\nFigure 2展示了两个TCP段:\n\n- TCP头;\n\n- 内容载体payload.\n![tcp segment](/img/tcp_payload.png)\nFigure 2: TCP Frame Structure (source).\n\npayload包含了未接收到ACK的socket buffer内容. payload的最大长度为接收窗口大小, 拥塞窗口, maximum segment size (MSS)三者中的最大值.\n然后计算TCP检验码: 计算元素包含头部信息(IP addresses, segment length, and protocol number). 然后根据TCP状态发送一个或多个packet.\n实际上目前网络栈的TCP校验码由NIC计算而非内核. 不过我们认为内核计算TCP校验码更加方便.\nTCP段传输到IP层: IP层在TCP段头部加上IP头信息用于IP路由. IP routing是不断跳到中间IP并最终到达目标IP的过程.\nIP包传输到链路层: 链路层会使用ARP协议来找到下一个跳转IP的MAC地址. 它会将Ethernet头信息加到packet上, 这样一个host数据packet便完整了.\n经过IP routing后, 经过NIC将数据传输到下一个跳转IP, 此过程会调用NIC驱动.\n这个时候, 如果运行了tcpdump或Wireshark等抓包程序, 内核将会将数据包拷贝到这种程序的缓冲区. 这种情况下接收的数据包将在驱动层直接被抓取. 一般流量整形功能都是在链路层实现的.\n链路驱动根据NIC制造商提供的NIC驱动通讯协议来请求传输数据包.\n接收到包传输请求后, NIC将数据包从主存中拷贝到它的内存并发送到网络中. 这时根据以太网标准, 它将IFG (Inter-Frame Gap), preamble, 及CRC信息到packet中. IFG和preamble用来区分包的开始位置(专业术语, 帧), CRC用来保护数据(和TCP及IP checksum目的一样). 数据包基于以太网物理速率及流控制条件来开始传输.\n当NIC发送一个包, NIC在主机CPU产生一个中断. 每个中断有他的中断标志号, 然后OS根据中断号来调用对应的驱动来处理中断. 驱动在启动时会向系统注册一个函数, 用于处理中断指令. The OS calls the interrupt handler and then the interrupt handler returns the transmitted packet to the OS(??).\n目前我们讨论了当应用程序请求write时, 内核和设备处理数据传输的过程. 不过, 没有来自应用程序的write请求, 内核也可以直接通过TCP来传输数据包. 比如当接收到一个ACK且接收窗口已扩展时, 内核将创建一个包含socket buffer剩余数据的TCP段, 并发送给接收者.\n","slug":"network/Understand-TCP-IP-Stack","published":1,"updated":"2017-10-26T09:21:29.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dw700164j4dp546tlwd","content":"<p>翻译自: <a href=\"https://www.cubrid.org/blog/understanding-tcp-ip-network-stack\" target=\"_blank\" rel=\"external\">https://www.cubrid.org/blog/understanding-tcp-ip-network-stack</a></p>\n<p>目前我们的internet服务都是基于TCP/IP来开发的, 无法想像没有TCP/IP的Internet会是什么样子. 因此无论是在逻辑调整, 故障排除，还是发现新技术方面, 理解网络中数据的传输原理会帮助我们多方面提高服务性能表现.<br>本文会介绍基于Linux系统及硬件层数据流和控制流的网络协议栈体系.<br>TCP/IP重点特征<br>我应该怎么设计网络协议来保证数据的快速传输， 并保证数据有序不丢失？<br>TCP and IP<br>严格来说由于TCP和IP在不同层次上, 分开来描述它们也是可以的. 不过这里将他们描述为一个整体.</p>\n<ol>\n<li>面向连接<br>首先,  两个终端(本地和远程)建立了连接, 数据开始传输. 此处”TCP connection identifier”是两个终端的地址组合, 类型为<code>&lt;local IP address, local port number, remote IP address, remote port number&gt;</code>.</li>\n<li>双向字节流<br>双向的数据以字节流来进行通讯.</li>\n<li>按序传输<br>接收者按发送者发送顺序来接收数据. 因此数据是要求有序的, 一个32位int类型的数据用于标志次序.<a id=\"more\"></a></li>\n<li>ACK保证可靠性<br>当发送者向接收者发送数据后并没有收到ACK, 发送者会重发TCP数据. 因此, 发送者会缓存没有从接收到ACK的数据.</li>\n<li>流控制<br>发送者会尽可能多的发送数据. 接收者告知发送者它能接收的最大字节数(空闲的buffer size, 接收窗口); 发送者基于这个最大字节数尽可能快的发送数据.</li>\n<li>拥塞控制<br>拥塞窗口 用于分割接收窗口,通过限制网络数据流来避免网络拥塞. 类似接收窗口, 发送者会根据接收者的拥塞窗口大小限制而使用多种策略来发送尽可能多的数据, 策略比如有TCP Vegas, Westwood, BIC, 和CUBIC. 和流控制不同的是, 拥塞控制只在发送者上实现.<br>数据传输<br>网络栈包含多层, Figure 1展示了每层的类型.<br><img src=\"/img/tcp_ip_stat.png\" alt=\"tcp/ip layer\"><br>Figure 1: TCP/IO网络栈在数据传输时各层的处理过程.<br>可以简单分为三层结构:</li>\n</ol>\n<ul>\n<li><p>用户层面</p>\n</li>\n<li><p>内核层面</p>\n</li>\n<li><p>设备层面</p>\n</li>\n</ul>\n<p>用户层面和内核层面的任务由CPU来处理. 用户层和内核层称为”host”, 以此与设备层区分. 这里的设备指的是用于发送/接收数据包的Network Interface Card (NIC). 更准确的术语叫”LAN card”.<br>用户层面: 首先应用程序创建要发送的数据 (Figure 1中”User data”)并调用系统函数write()来发送数据. 假设socket已创建好(Figure 1中的fd). 当进入系统调用时, 系统进入内核态.<br>POSIX系列操作系统(包括Linux, Unix)通过文件描述符将socket暴露给应用程序. 在此类系统中, socket可看作是一种文件. 文件层执行简单校验后调用socket函数来连接到文件结构.<br>内核socket有两个buffer:</p>\n<ul>\n<li>send socket buffer: 用于发送数据;</li>\n<li>receive socket buffer: 用于接收数据.</li>\n</ul>\n<p>当系统函数write被调用时, 数据将从用户区拷贝到内核区内存并且添加到socket buffer的末端, 这样按顺序发送数据. 如Figure 1, 浅灰色框包含的部分表示的是在发送buffer中的数据. 然后调用TCP.<br>TCP Control Block (TCB)结构用于连接socket. TCB包含请求处理TCP连接的数据, 包括: 连接状态(LISTEN, ESTABLISHED, TIME_WAIT), 接收窗口, 拥塞窗口, 序号, 重发时钟, 等等.<br>如果当前TCP状态允许数据传输, 一个新的TCP段(也叫packet)将被创建. 如果由于流控制这些原因无法传输数据, 系统调用会结束并且系统返回到 用户态(也就是将控制权交回应用程序).<br>Figure 2展示了两个TCP段:</p>\n<ul>\n<li><p>TCP头;</p>\n</li>\n<li><p>内容载体payload.<br><img src=\"/img/tcp_payload.png\" alt=\"tcp segment\"><br>Figure 2: TCP Frame Structure (source).</p>\n</li>\n</ul>\n<p>payload包含了未接收到ACK的socket buffer内容. payload的最大长度为接收窗口大小, 拥塞窗口, maximum segment size (MSS)三者中的最大值.<br>然后计算TCP检验码: 计算元素包含头部信息(IP addresses, segment length, and protocol number). 然后根据TCP状态发送一个或多个packet.<br>实际上目前网络栈的TCP校验码由NIC计算而非内核. 不过我们认为内核计算TCP校验码更加方便.<br>TCP段传输到IP层: IP层在TCP段头部加上IP头信息用于IP路由. IP routing是不断跳到中间IP并最终到达目标IP的过程.<br>IP包传输到链路层: 链路层会使用ARP协议来找到下一个跳转IP的MAC地址. 它会将Ethernet头信息加到packet上, 这样一个host数据packet便完整了.<br>经过IP routing后, 经过NIC将数据传输到下一个跳转IP, 此过程会调用NIC驱动.<br>这个时候, 如果运行了tcpdump或Wireshark等抓包程序, 内核将会将数据包拷贝到这种程序的缓冲区. 这种情况下接收的数据包将在驱动层直接被抓取. 一般流量整形功能都是在链路层实现的.<br>链路驱动根据NIC制造商提供的NIC驱动通讯协议来请求传输数据包.<br>接收到包传输请求后, NIC将数据包从主存中拷贝到它的内存并发送到网络中. 这时根据以太网标准, 它将IFG (Inter-Frame Gap), preamble, 及CRC信息到packet中. IFG和preamble用来区分包的开始位置(专业术语, 帧), CRC用来保护数据(和TCP及IP checksum目的一样). 数据包基于以太网物理速率及流控制条件来开始传输.<br>当NIC发送一个包, NIC在主机CPU产生一个中断. 每个中断有他的中断标志号, 然后OS根据中断号来调用对应的驱动来处理中断. 驱动在启动时会向系统注册一个函数, 用于处理中断指令. The OS calls the interrupt handler and then the interrupt handler returns the transmitted packet to the OS(??).<br>目前我们讨论了当应用程序请求write时, 内核和设备处理数据传输的过程. 不过, 没有来自应用程序的write请求, 内核也可以直接通过TCP来传输数据包. 比如当接收到一个ACK且接收窗口已扩展时, 内核将创建一个包含socket buffer剩余数据的TCP段, 并发送给接收者.</p>\n","site":{"data":{}},"excerpt":"<p>翻译自: <a href=\"https://www.cubrid.org/blog/understanding-tcp-ip-network-stack\" target=\"_blank\" rel=\"external\">https://www.cubrid.org/blog/understanding-tcp-ip-network-stack</a></p>\n<p>目前我们的internet服务都是基于TCP/IP来开发的, 无法想像没有TCP/IP的Internet会是什么样子. 因此无论是在逻辑调整, 故障排除，还是发现新技术方面, 理解网络中数据的传输原理会帮助我们多方面提高服务性能表现.<br>本文会介绍基于Linux系统及硬件层数据流和控制流的网络协议栈体系.<br>TCP/IP重点特征<br>我应该怎么设计网络协议来保证数据的快速传输， 并保证数据有序不丢失？<br>TCP and IP<br>严格来说由于TCP和IP在不同层次上, 分开来描述它们也是可以的. 不过这里将他们描述为一个整体.</p>\n<ol>\n<li>面向连接<br>首先,  两个终端(本地和远程)建立了连接, 数据开始传输. 此处”TCP connection identifier”是两个终端的地址组合, 类型为<code>&lt;local IP address, local port number, remote IP address, remote port number&gt;</code>.</li>\n<li>双向字节流<br>双向的数据以字节流来进行通讯.</li>\n<li>按序传输<br>接收者按发送者发送顺序来接收数据. 因此数据是要求有序的, 一个32位int类型的数据用于标志次序.","more":"</li>\n<li>ACK保证可靠性<br>当发送者向接收者发送数据后并没有收到ACK, 发送者会重发TCP数据. 因此, 发送者会缓存没有从接收到ACK的数据.</li>\n<li>流控制<br>发送者会尽可能多的发送数据. 接收者告知发送者它能接收的最大字节数(空闲的buffer size, 接收窗口); 发送者基于这个最大字节数尽可能快的发送数据.</li>\n<li>拥塞控制<br>拥塞窗口 用于分割接收窗口,通过限制网络数据流来避免网络拥塞. 类似接收窗口, 发送者会根据接收者的拥塞窗口大小限制而使用多种策略来发送尽可能多的数据, 策略比如有TCP Vegas, Westwood, BIC, 和CUBIC. 和流控制不同的是, 拥塞控制只在发送者上实现.<br>数据传输<br>网络栈包含多层, Figure 1展示了每层的类型.<br><img src=\"/img/tcp_ip_stat.png\" alt=\"tcp/ip layer\"><br>Figure 1: TCP/IO网络栈在数据传输时各层的处理过程.<br>可以简单分为三层结构:</li>\n</ol>\n<ul>\n<li><p>用户层面</p>\n</li>\n<li><p>内核层面</p>\n</li>\n<li><p>设备层面</p>\n</li>\n</ul>\n<p>用户层面和内核层面的任务由CPU来处理. 用户层和内核层称为”host”, 以此与设备层区分. 这里的设备指的是用于发送/接收数据包的Network Interface Card (NIC). 更准确的术语叫”LAN card”.<br>用户层面: 首先应用程序创建要发送的数据 (Figure 1中”User data”)并调用系统函数write()来发送数据. 假设socket已创建好(Figure 1中的fd). 当进入系统调用时, 系统进入内核态.<br>POSIX系列操作系统(包括Linux, Unix)通过文件描述符将socket暴露给应用程序. 在此类系统中, socket可看作是一种文件. 文件层执行简单校验后调用socket函数来连接到文件结构.<br>内核socket有两个buffer:</p>\n<ul>\n<li>send socket buffer: 用于发送数据;</li>\n<li>receive socket buffer: 用于接收数据.</li>\n</ul>\n<p>当系统函数write被调用时, 数据将从用户区拷贝到内核区内存并且添加到socket buffer的末端, 这样按顺序发送数据. 如Figure 1, 浅灰色框包含的部分表示的是在发送buffer中的数据. 然后调用TCP.<br>TCP Control Block (TCB)结构用于连接socket. TCB包含请求处理TCP连接的数据, 包括: 连接状态(LISTEN, ESTABLISHED, TIME_WAIT), 接收窗口, 拥塞窗口, 序号, 重发时钟, 等等.<br>如果当前TCP状态允许数据传输, 一个新的TCP段(也叫packet)将被创建. 如果由于流控制这些原因无法传输数据, 系统调用会结束并且系统返回到 用户态(也就是将控制权交回应用程序).<br>Figure 2展示了两个TCP段:</p>\n<ul>\n<li><p>TCP头;</p>\n</li>\n<li><p>内容载体payload.<br><img src=\"/img/tcp_payload.png\" alt=\"tcp segment\"><br>Figure 2: TCP Frame Structure (source).</p>\n</li>\n</ul>\n<p>payload包含了未接收到ACK的socket buffer内容. payload的最大长度为接收窗口大小, 拥塞窗口, maximum segment size (MSS)三者中的最大值.<br>然后计算TCP检验码: 计算元素包含头部信息(IP addresses, segment length, and protocol number). 然后根据TCP状态发送一个或多个packet.<br>实际上目前网络栈的TCP校验码由NIC计算而非内核. 不过我们认为内核计算TCP校验码更加方便.<br>TCP段传输到IP层: IP层在TCP段头部加上IP头信息用于IP路由. IP routing是不断跳到中间IP并最终到达目标IP的过程.<br>IP包传输到链路层: 链路层会使用ARP协议来找到下一个跳转IP的MAC地址. 它会将Ethernet头信息加到packet上, 这样一个host数据packet便完整了.<br>经过IP routing后, 经过NIC将数据传输到下一个跳转IP, 此过程会调用NIC驱动.<br>这个时候, 如果运行了tcpdump或Wireshark等抓包程序, 内核将会将数据包拷贝到这种程序的缓冲区. 这种情况下接收的数据包将在驱动层直接被抓取. 一般流量整形功能都是在链路层实现的.<br>链路驱动根据NIC制造商提供的NIC驱动通讯协议来请求传输数据包.<br>接收到包传输请求后, NIC将数据包从主存中拷贝到它的内存并发送到网络中. 这时根据以太网标准, 它将IFG (Inter-Frame Gap), preamble, 及CRC信息到packet中. IFG和preamble用来区分包的开始位置(专业术语, 帧), CRC用来保护数据(和TCP及IP checksum目的一样). 数据包基于以太网物理速率及流控制条件来开始传输.<br>当NIC发送一个包, NIC在主机CPU产生一个中断. 每个中断有他的中断标志号, 然后OS根据中断号来调用对应的驱动来处理中断. 驱动在启动时会向系统注册一个函数, 用于处理中断指令. The OS calls the interrupt handler and then the interrupt handler returns the transmitted packet to the OS(??).<br>目前我们讨论了当应用程序请求write时, 内核和设备处理数据传输的过程. 不过, 没有来自应用程序的write请求, 内核也可以直接通过TCP来传输数据包. 比如当接收到一个ACK且接收窗口已扩展时, 内核将创建一个包含socket buffer剩余数据的TCP段, 并发送给接收者.</p>"},{"title":"理解TCP/IP协议栈(2)","date":"2017-11-06T09:33:30.000Z","_content":"\n翻译自: https://www.cubrid.org/blog/understanding-tcp-ip-network-stack\n\n### 数据接收\n\n现在来看看数据是如何接收的. 数据接收就是网络协议栈处理到达数据的过程. 如Figure 3所示:\n![tcp_ip_stat2](http://blog.moguang.me/img/tcp_ip_stat2.png)\nFigure 3: TCP/IP栈各层如何处理到达数据的过程.\n\n- 首先NIC将包写入它的内存. 它会通过CRC来检查包是否有效, 然后将数据发送到主机的内存缓冲区. 这个缓冲区已经由Driver向内核请求获取并且用来填充接收到的数据包. 当缓冲区开辟后, 驱动通知NIC对应的内存地址和大小. 当驱动没有可用的内存缓冲区而NIC不断接收数据时, NIC会丢掉接收到的数据包.\n在发送数据到主机内存缓冲区后, NIC向主机系统发送一个中断信号.\n- 然后, Driver检查是否能处理新到达的数据包. 到这一步, 会用到driver-NIC通讯协议.\n<!--more-->\n- 当driver决定向上一层发送数据包时, 需要封装成当前系统能识别的包结构. 比如, Linux中的sk_buff,  BSD系列内核的mbuf, 以及windows的NET_BUFFER_LIST等包结构.\n- 以太网链路层检查包是否有效并多路复用上层协议(网络协议). 这时它使用到Ethernet头的以太网类型值(IPv4以太网类型值为0x0800). 以太网头被去掉并把其余数据发送到IP层.\n- IP层同样会检查包的有效性, 这里检查的是IP头校验码. 它会决定是本地系统处理该数据包, 还是转发到其他系统. 如果数据需要在本地处理, IP层将根据IP头来多路复用上层协议(传输协议). TCP原型值为6. IP头信息被移除后, 数据将被发送到传输层.\n- 同样, 传输层也检查数据的有效性, 检查的是TCP校验码. 之前提到, 目前网络栈一般使用checksum offload, TCP checksum由网卡而非内核来计算.然后会搜索数据包所要连接的TCP控制块. 这时包中的<source IP, source port, target IP, target port> 被用作唯一标志. 在找到连接后, 使用对应协议来处理数据包. 如果这时新数据到达, 这些数据将被添加到socker缓冲区中. 同时根据TCP状态, 传输层可以发送一个新的TCP包(比如ACK packet). 至此TCP/IP数据接收已处理完毕.\n用于接收的socker buffer大小就是TCP接收窗口. 准确来说, 当接收窗口越大时TCP的吞吐能力也会提升. 在过去socket buffer根据应用程序或系统配置来适应调整. 最近的网络栈提供了一个接口去自动调整接收socket buffer(也就是接收窗口)大小.\n- 当应用程序进行读系统调用时, 系统进入内核态, 同时socket buffer中的数据会拷贝到用户空间, 然后socket buffer中的数据会被清理. 接着调用TCP, 由于socket buffer清理后空闲可用, TCP会增加接收窗口大小. 然后根据协议状态来发送数据包, 而如果没有数据传输, 系统调用就会结束.\n\n### 网络栈发展历程\n\n目前所提到的网络栈结构都是最基础的功能. 1990年代的网络栈的功能并没有比上面提到的功能多多少. 但是最近的网络栈拥有了更过功能以及实现得更加复杂.\n目前网络栈可以按目的进行如下分类:\n\n#### 数据包处理过程\n这里有类似Netfilter的功能 (防火墙, NAT) 以及传输控制. 通过在基础处理流中加入用户自定义代码，这部分的功能可以依据用户配置来执行不同的处理操作.\n\n#### 协议性能\n目的是在给定的网络环境中, TCP协议能尽可能的提高吞吐能力和稳定性，减少延迟. 一些拥塞控制算法和TCP方法， 比如SACK是经典的应用例子. 协议的改进并不在本文的讨论范围，因此暂时忽略.\n\n#### 包处理效率\n包处理效率目标是通过减少处理包所消耗的CPU周期，内存使用及访问等参数，来提高每秒能处理包的数量. 在减少系统延迟上已经有一些解决方案, 包括栈并行处理，header预测，zero-copy，single-copy，checksum offload, TSO, LRO, RSS等等.\n\n#### 控制流\n现在再来详细看看Linux网络栈中的内部流. 类似一个非网络栈的子系统，网络栈以事件驱动的方式来运行. 因此并没有独立的线程去执行栈过程. Figure 1及Figure 3 展示了控制流的简化图表， 而Figure 4 展示了更准确的控制流过程.\n\n![tcp_ip_stat2](http://blog.moguang.me/img/control_flow.png)\nFigure 4: Control Flow in the Stack.\n\n- (1)应用程序请求系统调用来使用TCP, 比如调用read和write方法, 但此时并没有进行包传输.\n- (2) 和(1)一样, 开始请求包传输. 它创建一个数据包并且会将包向下传送到网卡驱动. 在驱动之前有一个传输队列, 包首先会传输到这个队列, 然后队列再决定什么时候将这个包传输到驱动. 这是Linux的队列规则(qdisc). Linux的流量控制功能就是将qdisc扶助实践, 而默认的qdisc就是FIFO队列. 通过另一种qdisc, 可以实现不同效果， 比如伪造丢包, 包延迟, 传输速率限制等.  (1) 和(2)中, 应用进程都有调用驱动程序.\n- (3)中展示了TCP所用的时钟超时示例. 比如, 当TIME_WAIT 的时钟超时后, 会调用TCP去关闭这个连接.\n- 和(3)类似, (4)中TCP时钟超时，这时TCP的执行结果应该被通知回去. 比如, 当重传时钟超时后, 没有收到ACK响应的数据包会被重新传输.(3) 和(4)阐述了处理时钟中断的软中断流程.\n- 当网卡驱动收到一个中断信号, 它会释放已经传输的包. 通常驱动处理在这里便结束. (5)中, 驱动请求软中断，软中断处理器便处理传输队列并将等待的包传输到驱动.\n- 当网卡驱动接收到中断并发现一个新到达的包，它会请求softirq. 处理接收包的softirq调用驱动并将该包传输到上层应用. Linux中, 像上面展示的接收包处理过程称为New API (NAPI). 和polling类似，因为驱动并没有直接将包传输到上层, 真正执行的代码叫NAPI poll.\n(6)中展示了TCP的操作完成而(7)则是TCP请求更多的包传输. 流程(5), (6)及 (7)均由NIC中断softirq执行处理.\n\n","source":"_posts/network/Understand-TCP-IP-Stack2.md","raw":"---\ntitle: '理解TCP/IP协议栈(2)'\ndate: 2017-11-06 17:33:30\ntags: networking\n---\n\n翻译自: https://www.cubrid.org/blog/understanding-tcp-ip-network-stack\n\n### 数据接收\n\n现在来看看数据是如何接收的. 数据接收就是网络协议栈处理到达数据的过程. 如Figure 3所示:\n![tcp_ip_stat2](http://blog.moguang.me/img/tcp_ip_stat2.png)\nFigure 3: TCP/IP栈各层如何处理到达数据的过程.\n\n- 首先NIC将包写入它的内存. 它会通过CRC来检查包是否有效, 然后将数据发送到主机的内存缓冲区. 这个缓冲区已经由Driver向内核请求获取并且用来填充接收到的数据包. 当缓冲区开辟后, 驱动通知NIC对应的内存地址和大小. 当驱动没有可用的内存缓冲区而NIC不断接收数据时, NIC会丢掉接收到的数据包.\n在发送数据到主机内存缓冲区后, NIC向主机系统发送一个中断信号.\n- 然后, Driver检查是否能处理新到达的数据包. 到这一步, 会用到driver-NIC通讯协议.\n<!--more-->\n- 当driver决定向上一层发送数据包时, 需要封装成当前系统能识别的包结构. 比如, Linux中的sk_buff,  BSD系列内核的mbuf, 以及windows的NET_BUFFER_LIST等包结构.\n- 以太网链路层检查包是否有效并多路复用上层协议(网络协议). 这时它使用到Ethernet头的以太网类型值(IPv4以太网类型值为0x0800). 以太网头被去掉并把其余数据发送到IP层.\n- IP层同样会检查包的有效性, 这里检查的是IP头校验码. 它会决定是本地系统处理该数据包, 还是转发到其他系统. 如果数据需要在本地处理, IP层将根据IP头来多路复用上层协议(传输协议). TCP原型值为6. IP头信息被移除后, 数据将被发送到传输层.\n- 同样, 传输层也检查数据的有效性, 检查的是TCP校验码. 之前提到, 目前网络栈一般使用checksum offload, TCP checksum由网卡而非内核来计算.然后会搜索数据包所要连接的TCP控制块. 这时包中的<source IP, source port, target IP, target port> 被用作唯一标志. 在找到连接后, 使用对应协议来处理数据包. 如果这时新数据到达, 这些数据将被添加到socker缓冲区中. 同时根据TCP状态, 传输层可以发送一个新的TCP包(比如ACK packet). 至此TCP/IP数据接收已处理完毕.\n用于接收的socker buffer大小就是TCP接收窗口. 准确来说, 当接收窗口越大时TCP的吞吐能力也会提升. 在过去socket buffer根据应用程序或系统配置来适应调整. 最近的网络栈提供了一个接口去自动调整接收socket buffer(也就是接收窗口)大小.\n- 当应用程序进行读系统调用时, 系统进入内核态, 同时socket buffer中的数据会拷贝到用户空间, 然后socket buffer中的数据会被清理. 接着调用TCP, 由于socket buffer清理后空闲可用, TCP会增加接收窗口大小. 然后根据协议状态来发送数据包, 而如果没有数据传输, 系统调用就会结束.\n\n### 网络栈发展历程\n\n目前所提到的网络栈结构都是最基础的功能. 1990年代的网络栈的功能并没有比上面提到的功能多多少. 但是最近的网络栈拥有了更过功能以及实现得更加复杂.\n目前网络栈可以按目的进行如下分类:\n\n#### 数据包处理过程\n这里有类似Netfilter的功能 (防火墙, NAT) 以及传输控制. 通过在基础处理流中加入用户自定义代码，这部分的功能可以依据用户配置来执行不同的处理操作.\n\n#### 协议性能\n目的是在给定的网络环境中, TCP协议能尽可能的提高吞吐能力和稳定性，减少延迟. 一些拥塞控制算法和TCP方法， 比如SACK是经典的应用例子. 协议的改进并不在本文的讨论范围，因此暂时忽略.\n\n#### 包处理效率\n包处理效率目标是通过减少处理包所消耗的CPU周期，内存使用及访问等参数，来提高每秒能处理包的数量. 在减少系统延迟上已经有一些解决方案, 包括栈并行处理，header预测，zero-copy，single-copy，checksum offload, TSO, LRO, RSS等等.\n\n#### 控制流\n现在再来详细看看Linux网络栈中的内部流. 类似一个非网络栈的子系统，网络栈以事件驱动的方式来运行. 因此并没有独立的线程去执行栈过程. Figure 1及Figure 3 展示了控制流的简化图表， 而Figure 4 展示了更准确的控制流过程.\n\n![tcp_ip_stat2](http://blog.moguang.me/img/control_flow.png)\nFigure 4: Control Flow in the Stack.\n\n- (1)应用程序请求系统调用来使用TCP, 比如调用read和write方法, 但此时并没有进行包传输.\n- (2) 和(1)一样, 开始请求包传输. 它创建一个数据包并且会将包向下传送到网卡驱动. 在驱动之前有一个传输队列, 包首先会传输到这个队列, 然后队列再决定什么时候将这个包传输到驱动. 这是Linux的队列规则(qdisc). Linux的流量控制功能就是将qdisc扶助实践, 而默认的qdisc就是FIFO队列. 通过另一种qdisc, 可以实现不同效果， 比如伪造丢包, 包延迟, 传输速率限制等.  (1) 和(2)中, 应用进程都有调用驱动程序.\n- (3)中展示了TCP所用的时钟超时示例. 比如, 当TIME_WAIT 的时钟超时后, 会调用TCP去关闭这个连接.\n- 和(3)类似, (4)中TCP时钟超时，这时TCP的执行结果应该被通知回去. 比如, 当重传时钟超时后, 没有收到ACK响应的数据包会被重新传输.(3) 和(4)阐述了处理时钟中断的软中断流程.\n- 当网卡驱动收到一个中断信号, 它会释放已经传输的包. 通常驱动处理在这里便结束. (5)中, 驱动请求软中断，软中断处理器便处理传输队列并将等待的包传输到驱动.\n- 当网卡驱动接收到中断并发现一个新到达的包，它会请求softirq. 处理接收包的softirq调用驱动并将该包传输到上层应用. Linux中, 像上面展示的接收包处理过程称为New API (NAPI). 和polling类似，因为驱动并没有直接将包传输到上层, 真正执行的代码叫NAPI poll.\n(6)中展示了TCP的操作完成而(7)则是TCP请求更多的包传输. 流程(5), (6)及 (7)均由NIC中断softirq执行处理.\n\n","slug":"network/Understand-TCP-IP-Stack2","published":1,"updated":"2017-11-06T09:47:42.061Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dw800184j4donm15390","content":"<p>翻译自: <a href=\"https://www.cubrid.org/blog/understanding-tcp-ip-network-stack\" target=\"_blank\" rel=\"external\">https://www.cubrid.org/blog/understanding-tcp-ip-network-stack</a></p>\n<h3 id=\"数据接收\"><a href=\"#数据接收\" class=\"headerlink\" title=\"数据接收\"></a>数据接收</h3><p>现在来看看数据是如何接收的. 数据接收就是网络协议栈处理到达数据的过程. 如Figure 3所示:<br><img src=\"http://blog.moguang.me/img/tcp_ip_stat2.png\" alt=\"tcp_ip_stat2\"><br>Figure 3: TCP/IP栈各层如何处理到达数据的过程.</p>\n<ul>\n<li>首先NIC将包写入它的内存. 它会通过CRC来检查包是否有效, 然后将数据发送到主机的内存缓冲区. 这个缓冲区已经由Driver向内核请求获取并且用来填充接收到的数据包. 当缓冲区开辟后, 驱动通知NIC对应的内存地址和大小. 当驱动没有可用的内存缓冲区而NIC不断接收数据时, NIC会丢掉接收到的数据包.<br>在发送数据到主机内存缓冲区后, NIC向主机系统发送一个中断信号.</li>\n<li>然后, Driver检查是否能处理新到达的数据包. 到这一步, 会用到driver-NIC通讯协议.<a id=\"more\"></a></li>\n<li>当driver决定向上一层发送数据包时, 需要封装成当前系统能识别的包结构. 比如, Linux中的sk_buff,  BSD系列内核的mbuf, 以及windows的NET_BUFFER_LIST等包结构.</li>\n<li>以太网链路层检查包是否有效并多路复用上层协议(网络协议). 这时它使用到Ethernet头的以太网类型值(IPv4以太网类型值为0x0800). 以太网头被去掉并把其余数据发送到IP层.</li>\n<li>IP层同样会检查包的有效性, 这里检查的是IP头校验码. 它会决定是本地系统处理该数据包, 还是转发到其他系统. 如果数据需要在本地处理, IP层将根据IP头来多路复用上层协议(传输协议). TCP原型值为6. IP头信息被移除后, 数据将被发送到传输层.</li>\n<li>同样, 传输层也检查数据的有效性, 检查的是TCP校验码. 之前提到, 目前网络栈一般使用checksum offload, TCP checksum由网卡而非内核来计算.然后会搜索数据包所要连接的TCP控制块. 这时包中的<source ip,=\"\" source=\"\" port,=\"\" target=\"\" port=\"\"> 被用作唯一标志. 在找到连接后, 使用对应协议来处理数据包. 如果这时新数据到达, 这些数据将被添加到socker缓冲区中. 同时根据TCP状态, 传输层可以发送一个新的TCP包(比如ACK packet). 至此TCP/IP数据接收已处理完毕.<br>用于接收的socker buffer大小就是TCP接收窗口. 准确来说, 当接收窗口越大时TCP的吞吐能力也会提升. 在过去socket buffer根据应用程序或系统配置来适应调整. 最近的网络栈提供了一个接口去自动调整接收socket buffer(也就是接收窗口)大小.</li>\n<li>当应用程序进行读系统调用时, 系统进入内核态, 同时socket buffer中的数据会拷贝到用户空间, 然后socket buffer中的数据会被清理. 接着调用TCP, 由于socket buffer清理后空闲可用, TCP会增加接收窗口大小. 然后根据协议状态来发送数据包, 而如果没有数据传输, 系统调用就会结束.</li>\n</ul>\n<h3 id=\"网络栈发展历程\"><a href=\"#网络栈发展历程\" class=\"headerlink\" title=\"网络栈发展历程\"></a>网络栈发展历程</h3><p>目前所提到的网络栈结构都是最基础的功能. 1990年代的网络栈的功能并没有比上面提到的功能多多少. 但是最近的网络栈拥有了更过功能以及实现得更加复杂.<br>目前网络栈可以按目的进行如下分类:</p>\n<h4 id=\"数据包处理过程\"><a href=\"#数据包处理过程\" class=\"headerlink\" title=\"数据包处理过程\"></a>数据包处理过程</h4><p>这里有类似Netfilter的功能 (防火墙, NAT) 以及传输控制. 通过在基础处理流中加入用户自定义代码，这部分的功能可以依据用户配置来执行不同的处理操作.</p>\n<h4 id=\"协议性能\"><a href=\"#协议性能\" class=\"headerlink\" title=\"协议性能\"></a>协议性能</h4><p>目的是在给定的网络环境中, TCP协议能尽可能的提高吞吐能力和稳定性，减少延迟. 一些拥塞控制算法和TCP方法， 比如SACK是经典的应用例子. 协议的改进并不在本文的讨论范围，因此暂时忽略.</p>\n<h4 id=\"包处理效率\"><a href=\"#包处理效率\" class=\"headerlink\" title=\"包处理效率\"></a>包处理效率</h4><p>包处理效率目标是通过减少处理包所消耗的CPU周期，内存使用及访问等参数，来提高每秒能处理包的数量. 在减少系统延迟上已经有一些解决方案, 包括栈并行处理，header预测，zero-copy，single-copy，checksum offload, TSO, LRO, RSS等等.</p>\n<h4 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h4><p>现在再来详细看看Linux网络栈中的内部流. 类似一个非网络栈的子系统，网络栈以事件驱动的方式来运行. 因此并没有独立的线程去执行栈过程. Figure 1及Figure 3 展示了控制流的简化图表， 而Figure 4 展示了更准确的控制流过程.</p>\n<p><img src=\"http://blog.moguang.me/img/control_flow.png\" alt=\"tcp_ip_stat2\"><br>Figure 4: Control Flow in the Stack.</p>\n<ul>\n<li>(1)应用程序请求系统调用来使用TCP, 比如调用read和write方法, 但此时并没有进行包传输.</li>\n<li>(2) 和(1)一样, 开始请求包传输. 它创建一个数据包并且会将包向下传送到网卡驱动. 在驱动之前有一个传输队列, 包首先会传输到这个队列, 然后队列再决定什么时候将这个包传输到驱动. 这是Linux的队列规则(qdisc). Linux的流量控制功能就是将qdisc扶助实践, 而默认的qdisc就是FIFO队列. 通过另一种qdisc, 可以实现不同效果， 比如伪造丢包, 包延迟, 传输速率限制等.  (1) 和(2)中, 应用进程都有调用驱动程序.</li>\n<li>(3)中展示了TCP所用的时钟超时示例. 比如, 当TIME_WAIT 的时钟超时后, 会调用TCP去关闭这个连接.</li>\n<li>和(3)类似, (4)中TCP时钟超时，这时TCP的执行结果应该被通知回去. 比如, 当重传时钟超时后, 没有收到ACK响应的数据包会被重新传输.(3) 和(4)阐述了处理时钟中断的软中断流程.</li>\n<li>当网卡驱动收到一个中断信号, 它会释放已经传输的包. 通常驱动处理在这里便结束. (5)中, 驱动请求软中断，软中断处理器便处理传输队列并将等待的包传输到驱动.</li>\n<li>当网卡驱动接收到中断并发现一个新到达的包，它会请求softirq. 处理接收包的softirq调用驱动并将该包传输到上层应用. Linux中, 像上面展示的接收包处理过程称为New API (NAPI). 和polling类似，因为驱动并没有直接将包传输到上层, 真正执行的代码叫NAPI poll.<br>(6)中展示了TCP的操作完成而(7)则是TCP请求更多的包传输. 流程(5), (6)及 (7)均由NIC中断softirq执行处理.</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>翻译自: <a href=\"https://www.cubrid.org/blog/understanding-tcp-ip-network-stack\" target=\"_blank\" rel=\"external\">https://www.cubrid.org/blog/understanding-tcp-ip-network-stack</a></p>\n<h3 id=\"数据接收\"><a href=\"#数据接收\" class=\"headerlink\" title=\"数据接收\"></a>数据接收</h3><p>现在来看看数据是如何接收的. 数据接收就是网络协议栈处理到达数据的过程. 如Figure 3所示:<br><img src=\"http://blog.moguang.me/img/tcp_ip_stat2.png\" alt=\"tcp_ip_stat2\"><br>Figure 3: TCP/IP栈各层如何处理到达数据的过程.</p>\n<ul>\n<li>首先NIC将包写入它的内存. 它会通过CRC来检查包是否有效, 然后将数据发送到主机的内存缓冲区. 这个缓冲区已经由Driver向内核请求获取并且用来填充接收到的数据包. 当缓冲区开辟后, 驱动通知NIC对应的内存地址和大小. 当驱动没有可用的内存缓冲区而NIC不断接收数据时, NIC会丢掉接收到的数据包.<br>在发送数据到主机内存缓冲区后, NIC向主机系统发送一个中断信号.</li>\n<li>然后, Driver检查是否能处理新到达的数据包. 到这一步, 会用到driver-NIC通讯协议.","more":"</li>\n<li>当driver决定向上一层发送数据包时, 需要封装成当前系统能识别的包结构. 比如, Linux中的sk_buff,  BSD系列内核的mbuf, 以及windows的NET_BUFFER_LIST等包结构.</li>\n<li>以太网链路层检查包是否有效并多路复用上层协议(网络协议). 这时它使用到Ethernet头的以太网类型值(IPv4以太网类型值为0x0800). 以太网头被去掉并把其余数据发送到IP层.</li>\n<li>IP层同样会检查包的有效性, 这里检查的是IP头校验码. 它会决定是本地系统处理该数据包, 还是转发到其他系统. 如果数据需要在本地处理, IP层将根据IP头来多路复用上层协议(传输协议). TCP原型值为6. IP头信息被移除后, 数据将被发送到传输层.</li>\n<li>同样, 传输层也检查数据的有效性, 检查的是TCP校验码. 之前提到, 目前网络栈一般使用checksum offload, TCP checksum由网卡而非内核来计算.然后会搜索数据包所要连接的TCP控制块. 这时包中的<source ip,=\"\" source=\"\" port,=\"\" target=\"\" port=\"\"> 被用作唯一标志. 在找到连接后, 使用对应协议来处理数据包. 如果这时新数据到达, 这些数据将被添加到socker缓冲区中. 同时根据TCP状态, 传输层可以发送一个新的TCP包(比如ACK packet). 至此TCP/IP数据接收已处理完毕.<br>用于接收的socker buffer大小就是TCP接收窗口. 准确来说, 当接收窗口越大时TCP的吞吐能力也会提升. 在过去socket buffer根据应用程序或系统配置来适应调整. 最近的网络栈提供了一个接口去自动调整接收socket buffer(也就是接收窗口)大小.</li>\n<li>当应用程序进行读系统调用时, 系统进入内核态, 同时socket buffer中的数据会拷贝到用户空间, 然后socket buffer中的数据会被清理. 接着调用TCP, 由于socket buffer清理后空闲可用, TCP会增加接收窗口大小. 然后根据协议状态来发送数据包, 而如果没有数据传输, 系统调用就会结束.</li>\n</ul>\n<h3 id=\"网络栈发展历程\"><a href=\"#网络栈发展历程\" class=\"headerlink\" title=\"网络栈发展历程\"></a>网络栈发展历程</h3><p>目前所提到的网络栈结构都是最基础的功能. 1990年代的网络栈的功能并没有比上面提到的功能多多少. 但是最近的网络栈拥有了更过功能以及实现得更加复杂.<br>目前网络栈可以按目的进行如下分类:</p>\n<h4 id=\"数据包处理过程\"><a href=\"#数据包处理过程\" class=\"headerlink\" title=\"数据包处理过程\"></a>数据包处理过程</h4><p>这里有类似Netfilter的功能 (防火墙, NAT) 以及传输控制. 通过在基础处理流中加入用户自定义代码，这部分的功能可以依据用户配置来执行不同的处理操作.</p>\n<h4 id=\"协议性能\"><a href=\"#协议性能\" class=\"headerlink\" title=\"协议性能\"></a>协议性能</h4><p>目的是在给定的网络环境中, TCP协议能尽可能的提高吞吐能力和稳定性，减少延迟. 一些拥塞控制算法和TCP方法， 比如SACK是经典的应用例子. 协议的改进并不在本文的讨论范围，因此暂时忽略.</p>\n<h4 id=\"包处理效率\"><a href=\"#包处理效率\" class=\"headerlink\" title=\"包处理效率\"></a>包处理效率</h4><p>包处理效率目标是通过减少处理包所消耗的CPU周期，内存使用及访问等参数，来提高每秒能处理包的数量. 在减少系统延迟上已经有一些解决方案, 包括栈并行处理，header预测，zero-copy，single-copy，checksum offload, TSO, LRO, RSS等等.</p>\n<h4 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h4><p>现在再来详细看看Linux网络栈中的内部流. 类似一个非网络栈的子系统，网络栈以事件驱动的方式来运行. 因此并没有独立的线程去执行栈过程. Figure 1及Figure 3 展示了控制流的简化图表， 而Figure 4 展示了更准确的控制流过程.</p>\n<p><img src=\"http://blog.moguang.me/img/control_flow.png\" alt=\"tcp_ip_stat2\"><br>Figure 4: Control Flow in the Stack.</p>\n<ul>\n<li>(1)应用程序请求系统调用来使用TCP, 比如调用read和write方法, 但此时并没有进行包传输.</li>\n<li>(2) 和(1)一样, 开始请求包传输. 它创建一个数据包并且会将包向下传送到网卡驱动. 在驱动之前有一个传输队列, 包首先会传输到这个队列, 然后队列再决定什么时候将这个包传输到驱动. 这是Linux的队列规则(qdisc). Linux的流量控制功能就是将qdisc扶助实践, 而默认的qdisc就是FIFO队列. 通过另一种qdisc, 可以实现不同效果， 比如伪造丢包, 包延迟, 传输速率限制等.  (1) 和(2)中, 应用进程都有调用驱动程序.</li>\n<li>(3)中展示了TCP所用的时钟超时示例. 比如, 当TIME_WAIT 的时钟超时后, 会调用TCP去关闭这个连接.</li>\n<li>和(3)类似, (4)中TCP时钟超时，这时TCP的执行结果应该被通知回去. 比如, 当重传时钟超时后, 没有收到ACK响应的数据包会被重新传输.(3) 和(4)阐述了处理时钟中断的软中断流程.</li>\n<li>当网卡驱动收到一个中断信号, 它会释放已经传输的包. 通常驱动处理在这里便结束. (5)中, 驱动请求软中断，软中断处理器便处理传输队列并将等待的包传输到驱动.</li>\n<li>当网卡驱动接收到中断并发现一个新到达的包，它会请求softirq. 处理接收包的softirq调用驱动并将该包传输到上层应用. Linux中, 像上面展示的接收包处理过程称为New API (NAPI). 和polling类似，因为驱动并没有直接将包传输到上层, 真正执行的代码叫NAPI poll.<br>(6)中展示了TCP的操作完成而(7)则是TCP请求更多的包传输. 流程(5), (6)及 (7)均由NIC中断softirq执行处理.</li>\n</ul>"},{"title":"理解TCP/IP协议栈(3)","date":"2017-11-07T06:14:27.000Z","_content":"\n翻译自: https://www.cubrid.org/blog/understanding-tcp-ip-network-stack\n\n### 如何处理中断及接收包\n中断处理很复杂, 而你需要理解与之相关的到达包处理的性能. Figure 5展示了一个中断处理的流程.\n![irq_handle.png](http://www.moguang.me/img/irq_handle.png)\nFigure 5: Processing Interrupt, softirq, and Received Packet.\n<!--more-->\n- 假设CPU 0正在执行一个用户程序. 这时NIC接收到一个数据包并在CPU 0上产生一个中断. 接着CPU执行内核中断处理handler. 该handler根据中断号来调对应的驱动中断handler. 驱动释放已传输的包后调用napi_schedule()函数来处理到达的包. 该函数会请求softirq(软中断).\n- 在驱动中断handler执行结束后, 控制权交还给内核handler. 内核handler便接着执行该softirq的处理.\n- 在中断上下文执行后, softirq上下文会被执行. 中断上下文和softirq上下文在一个独立的线程中执行. 然而他们用的是不同栈, 而且中断上下文会阻塞硬件中断; 不过softirq上下文不会阻塞硬件中断.softirq handler中处理到达包的函数是net_rx_action() function. 该函数会调用驱动函数poll(), 而poll()函数会调用netif_receive_skb()函数并将到达包一个个发送到上层程序. 处理softirq后, 应用会回到上次进行系统调用时的中止位置并重新执行.\n- 此时接收到中断信号的CPU已经完整的处理了一遍到达的数据包. 像Linux, BSD, 和Microsoft Windows这些系统, 这些处理流程基本是一致的.\n- 当你检查CPU利用率时, 有时你会发现只有一个CPU在执行softirq. 这个情况是目前介绍到的包处理流程方式引起的. 为了解决这个问题, 多队列NIC, RSS, 和RPS等技术被开发了出来.\n### 数据结构\n下面是一些重要的数据结构, 现在来看看相关代码.\n``sk_buff structure``\n首先是表示一个包结构的sk_buff或skb. Figure 6 展示了 sk_buff 的部分结构. 实际上这些函数在不断完善, 要比图示复杂的多. 不过基础的功能还是基本一样的.\n![irq_handle.png](http://www.moguang.me/img/skbuff.png)\nFigure 6: Packet Structure sk_buff.\n\n#### 包含包数据及元数据\n该结构直接包含了包数据或通过指针指向数据. Figure 6, 一些包(从Ethernet到buffer)包含了数据指针而其他数据(flags)存在于内存页中.\n一些必须的信息，比如header以及payload大小等保存在元数据区域. 比如Figure 6中的mac_header, network_header, transport_header有对应的指针分别指向Ethernet header, IP header及TCP header的开始位置. 这样使得TCP处理起来更简易.\n#### 如何增加/删除一个header\n在网络栈中的不同层，header会根据实际情况增加删除. 指针使得流程处理更有效率. 比如要删除Ethernet header, just increase the head pointer？\n#### 如何合并包/拆包\n链表使得在sokcet buffer/packt chain中增加/删除包的payload内容这些task更有效率. 指针next, prev就是用来做这些操作的.\n#### 快速分配和释放\n由于在创建包时会初始化一个数据结构体, 会用到quick allocator.比如如果数据在10Gb的以太网上传输, 每秒将有超过一百万次的包创建/回收操作.\n#### TCP控制块\n其次专门有一个结构表示TCP连接, 之前笼统的称为TCP控制块. Linux中使用tcp_sock来表示这个结构. Figure 7中, 你可以看到文件与socket, tcp_socket之间的关系.\n![irq_handle.png](http://www.moguang.me/img/tcp_conn_struct.png)\nFigure 7: TCP Connection Structure.\n\n- 当发生系统调用时, 内核会去搜索应用所传递过来的文件描述符. 在Unix系列系统中, socket, file和文件系统存储设备被抽象成file的概念. 因此file结构包含了尽可能少的信息. 对于socket, 一个socket结构包含了socket相关的信息以及作为指针指向socket, socket同时又指向tcp_sock. tcp_sock 可分类成sock, inet_sock等, 支持除TCP外的多种协议. 可以看作是一种多态polymorphism.\n- TCP协议所用到的状态信息保存tcp_sock. 比如序列号, 接收窗口, 拥塞控制, 以及重传时钟等都保存在tcp_sock.\n- 用于发送/接收的socket buffer为sk_buff列表，他们包含了tcp_sock. IP路由结果结构dst_entry用于避免过于频繁的routing. dst_entry允许用于简单的ARP结果搜索, 也就是MAC地址. dst_entry是routing表的一部分. routing表很复杂而本文不会详细讨论它. 搜索用于传输包的NIC时会用到dst_entry. NIC信息保存在net_device结构中.\n- 因此通过查找文件，可以容易找到利用指针处理TCP连接的所有数据结构(from the file to the driver). 结构的大小就是一个TCP连接在内存中占用的内存， 大概是几KB (不包括包数据). 随着用到更多功能，内存占用大小也有所增加.\n- 最后看下TCP连接的lookup表. 这里用了一张hash表去查找到达包所属的TCP连接. hash值通过传入的包头<source IP, target IP, source port, target port>来通过Jenkins hash算法计算. 据说使用了防御攻击hash表的hash函数.\n","source":"_posts/network/Understand-TCP-IP-Stack3.md","raw":"---\ntitle: '理解TCP/IP协议栈(3)'\ndate: 2017-11-07 14:14:27\ntags: networking\n---\n\n翻译自: https://www.cubrid.org/blog/understanding-tcp-ip-network-stack\n\n### 如何处理中断及接收包\n中断处理很复杂, 而你需要理解与之相关的到达包处理的性能. Figure 5展示了一个中断处理的流程.\n![irq_handle.png](http://www.moguang.me/img/irq_handle.png)\nFigure 5: Processing Interrupt, softirq, and Received Packet.\n<!--more-->\n- 假设CPU 0正在执行一个用户程序. 这时NIC接收到一个数据包并在CPU 0上产生一个中断. 接着CPU执行内核中断处理handler. 该handler根据中断号来调对应的驱动中断handler. 驱动释放已传输的包后调用napi_schedule()函数来处理到达的包. 该函数会请求softirq(软中断).\n- 在驱动中断handler执行结束后, 控制权交还给内核handler. 内核handler便接着执行该softirq的处理.\n- 在中断上下文执行后, softirq上下文会被执行. 中断上下文和softirq上下文在一个独立的线程中执行. 然而他们用的是不同栈, 而且中断上下文会阻塞硬件中断; 不过softirq上下文不会阻塞硬件中断.softirq handler中处理到达包的函数是net_rx_action() function. 该函数会调用驱动函数poll(), 而poll()函数会调用netif_receive_skb()函数并将到达包一个个发送到上层程序. 处理softirq后, 应用会回到上次进行系统调用时的中止位置并重新执行.\n- 此时接收到中断信号的CPU已经完整的处理了一遍到达的数据包. 像Linux, BSD, 和Microsoft Windows这些系统, 这些处理流程基本是一致的.\n- 当你检查CPU利用率时, 有时你会发现只有一个CPU在执行softirq. 这个情况是目前介绍到的包处理流程方式引起的. 为了解决这个问题, 多队列NIC, RSS, 和RPS等技术被开发了出来.\n### 数据结构\n下面是一些重要的数据结构, 现在来看看相关代码.\n``sk_buff structure``\n首先是表示一个包结构的sk_buff或skb. Figure 6 展示了 sk_buff 的部分结构. 实际上这些函数在不断完善, 要比图示复杂的多. 不过基础的功能还是基本一样的.\n![irq_handle.png](http://www.moguang.me/img/skbuff.png)\nFigure 6: Packet Structure sk_buff.\n\n#### 包含包数据及元数据\n该结构直接包含了包数据或通过指针指向数据. Figure 6, 一些包(从Ethernet到buffer)包含了数据指针而其他数据(flags)存在于内存页中.\n一些必须的信息，比如header以及payload大小等保存在元数据区域. 比如Figure 6中的mac_header, network_header, transport_header有对应的指针分别指向Ethernet header, IP header及TCP header的开始位置. 这样使得TCP处理起来更简易.\n#### 如何增加/删除一个header\n在网络栈中的不同层，header会根据实际情况增加删除. 指针使得流程处理更有效率. 比如要删除Ethernet header, just increase the head pointer？\n#### 如何合并包/拆包\n链表使得在sokcet buffer/packt chain中增加/删除包的payload内容这些task更有效率. 指针next, prev就是用来做这些操作的.\n#### 快速分配和释放\n由于在创建包时会初始化一个数据结构体, 会用到quick allocator.比如如果数据在10Gb的以太网上传输, 每秒将有超过一百万次的包创建/回收操作.\n#### TCP控制块\n其次专门有一个结构表示TCP连接, 之前笼统的称为TCP控制块. Linux中使用tcp_sock来表示这个结构. Figure 7中, 你可以看到文件与socket, tcp_socket之间的关系.\n![irq_handle.png](http://www.moguang.me/img/tcp_conn_struct.png)\nFigure 7: TCP Connection Structure.\n\n- 当发生系统调用时, 内核会去搜索应用所传递过来的文件描述符. 在Unix系列系统中, socket, file和文件系统存储设备被抽象成file的概念. 因此file结构包含了尽可能少的信息. 对于socket, 一个socket结构包含了socket相关的信息以及作为指针指向socket, socket同时又指向tcp_sock. tcp_sock 可分类成sock, inet_sock等, 支持除TCP外的多种协议. 可以看作是一种多态polymorphism.\n- TCP协议所用到的状态信息保存tcp_sock. 比如序列号, 接收窗口, 拥塞控制, 以及重传时钟等都保存在tcp_sock.\n- 用于发送/接收的socket buffer为sk_buff列表，他们包含了tcp_sock. IP路由结果结构dst_entry用于避免过于频繁的routing. dst_entry允许用于简单的ARP结果搜索, 也就是MAC地址. dst_entry是routing表的一部分. routing表很复杂而本文不会详细讨论它. 搜索用于传输包的NIC时会用到dst_entry. NIC信息保存在net_device结构中.\n- 因此通过查找文件，可以容易找到利用指针处理TCP连接的所有数据结构(from the file to the driver). 结构的大小就是一个TCP连接在内存中占用的内存， 大概是几KB (不包括包数据). 随着用到更多功能，内存占用大小也有所增加.\n- 最后看下TCP连接的lookup表. 这里用了一张hash表去查找到达包所属的TCP连接. hash值通过传入的包头<source IP, target IP, source port, target port>来通过Jenkins hash算法计算. 据说使用了防御攻击hash表的hash函数.\n","slug":"network/Understand-TCP-IP-Stack3","published":1,"updated":"2017-11-07T06:16:06.608Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dw9001a4j4dhn3vo2j7","content":"<p>翻译自: <a href=\"https://www.cubrid.org/blog/understanding-tcp-ip-network-stack\" target=\"_blank\" rel=\"external\">https://www.cubrid.org/blog/understanding-tcp-ip-network-stack</a></p>\n<h3 id=\"如何处理中断及接收包\"><a href=\"#如何处理中断及接收包\" class=\"headerlink\" title=\"如何处理中断及接收包\"></a>如何处理中断及接收包</h3><p>中断处理很复杂, 而你需要理解与之相关的到达包处理的性能. Figure 5展示了一个中断处理的流程.<br><img src=\"http://www.moguang.me/img/irq_handle.png\" alt=\"irq_handle.png\"><br>Figure 5: Processing Interrupt, softirq, and Received Packet.<br><a id=\"more\"></a></p>\n<ul>\n<li>假设CPU 0正在执行一个用户程序. 这时NIC接收到一个数据包并在CPU 0上产生一个中断. 接着CPU执行内核中断处理handler. 该handler根据中断号来调对应的驱动中断handler. 驱动释放已传输的包后调用napi_schedule()函数来处理到达的包. 该函数会请求softirq(软中断).</li>\n<li>在驱动中断handler执行结束后, 控制权交还给内核handler. 内核handler便接着执行该softirq的处理.</li>\n<li>在中断上下文执行后, softirq上下文会被执行. 中断上下文和softirq上下文在一个独立的线程中执行. 然而他们用的是不同栈, 而且中断上下文会阻塞硬件中断; 不过softirq上下文不会阻塞硬件中断.softirq handler中处理到达包的函数是net_rx_action() function. 该函数会调用驱动函数poll(), 而poll()函数会调用netif_receive_skb()函数并将到达包一个个发送到上层程序. 处理softirq后, 应用会回到上次进行系统调用时的中止位置并重新执行.</li>\n<li>此时接收到中断信号的CPU已经完整的处理了一遍到达的数据包. 像Linux, BSD, 和Microsoft Windows这些系统, 这些处理流程基本是一致的.</li>\n<li>当你检查CPU利用率时, 有时你会发现只有一个CPU在执行softirq. 这个情况是目前介绍到的包处理流程方式引起的. 为了解决这个问题, 多队列NIC, RSS, 和RPS等技术被开发了出来.<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3>下面是一些重要的数据结构, 现在来看看相关代码.<br><code>sk_buff structure</code><br>首先是表示一个包结构的sk_buff或skb. Figure 6 展示了 sk_buff 的部分结构. 实际上这些函数在不断完善, 要比图示复杂的多. 不过基础的功能还是基本一样的.<br><img src=\"http://www.moguang.me/img/skbuff.png\" alt=\"irq_handle.png\"><br>Figure 6: Packet Structure sk_buff.</li>\n</ul>\n<h4 id=\"包含包数据及元数据\"><a href=\"#包含包数据及元数据\" class=\"headerlink\" title=\"包含包数据及元数据\"></a>包含包数据及元数据</h4><p>该结构直接包含了包数据或通过指针指向数据. Figure 6, 一些包(从Ethernet到buffer)包含了数据指针而其他数据(flags)存在于内存页中.<br>一些必须的信息，比如header以及payload大小等保存在元数据区域. 比如Figure 6中的mac_header, network_header, transport_header有对应的指针分别指向Ethernet header, IP header及TCP header的开始位置. 这样使得TCP处理起来更简易.</p>\n<h4 id=\"如何增加-删除一个header\"><a href=\"#如何增加-删除一个header\" class=\"headerlink\" title=\"如何增加/删除一个header\"></a>如何增加/删除一个header</h4><p>在网络栈中的不同层，header会根据实际情况增加删除. 指针使得流程处理更有效率. 比如要删除Ethernet header, just increase the head pointer？</p>\n<h4 id=\"如何合并包-拆包\"><a href=\"#如何合并包-拆包\" class=\"headerlink\" title=\"如何合并包/拆包\"></a>如何合并包/拆包</h4><p>链表使得在sokcet buffer/packt chain中增加/删除包的payload内容这些task更有效率. 指针next, prev就是用来做这些操作的.</p>\n<h4 id=\"快速分配和释放\"><a href=\"#快速分配和释放\" class=\"headerlink\" title=\"快速分配和释放\"></a>快速分配和释放</h4><p>由于在创建包时会初始化一个数据结构体, 会用到quick allocator.比如如果数据在10Gb的以太网上传输, 每秒将有超过一百万次的包创建/回收操作.</p>\n<h4 id=\"TCP控制块\"><a href=\"#TCP控制块\" class=\"headerlink\" title=\"TCP控制块\"></a>TCP控制块</h4><p>其次专门有一个结构表示TCP连接, 之前笼统的称为TCP控制块. Linux中使用tcp_sock来表示这个结构. Figure 7中, 你可以看到文件与socket, tcp_socket之间的关系.<br><img src=\"http://www.moguang.me/img/tcp_conn_struct.png\" alt=\"irq_handle.png\"><br>Figure 7: TCP Connection Structure.</p>\n<ul>\n<li>当发生系统调用时, 内核会去搜索应用所传递过来的文件描述符. 在Unix系列系统中, socket, file和文件系统存储设备被抽象成file的概念. 因此file结构包含了尽可能少的信息. 对于socket, 一个socket结构包含了socket相关的信息以及作为指针指向socket, socket同时又指向tcp_sock. tcp_sock 可分类成sock, inet_sock等, 支持除TCP外的多种协议. 可以看作是一种多态polymorphism.</li>\n<li>TCP协议所用到的状态信息保存tcp_sock. 比如序列号, 接收窗口, 拥塞控制, 以及重传时钟等都保存在tcp_sock.</li>\n<li>用于发送/接收的socket buffer为sk_buff列表，他们包含了tcp_sock. IP路由结果结构dst_entry用于避免过于频繁的routing. dst_entry允许用于简单的ARP结果搜索, 也就是MAC地址. dst_entry是routing表的一部分. routing表很复杂而本文不会详细讨论它. 搜索用于传输包的NIC时会用到dst_entry. NIC信息保存在net_device结构中.</li>\n<li>因此通过查找文件，可以容易找到利用指针处理TCP连接的所有数据结构(from the file to the driver). 结构的大小就是一个TCP连接在内存中占用的内存， 大概是几KB (不包括包数据). 随着用到更多功能，内存占用大小也有所增加.</li>\n<li>最后看下TCP连接的lookup表. 这里用了一张hash表去查找到达包所属的TCP连接. hash值通过传入的包头<source ip,=\"\" target=\"\" source=\"\" port,=\"\" port=\"\">来通过Jenkins hash算法计算. 据说使用了防御攻击hash表的hash函数.</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>翻译自: <a href=\"https://www.cubrid.org/blog/understanding-tcp-ip-network-stack\" target=\"_blank\" rel=\"external\">https://www.cubrid.org/blog/understanding-tcp-ip-network-stack</a></p>\n<h3 id=\"如何处理中断及接收包\"><a href=\"#如何处理中断及接收包\" class=\"headerlink\" title=\"如何处理中断及接收包\"></a>如何处理中断及接收包</h3><p>中断处理很复杂, 而你需要理解与之相关的到达包处理的性能. Figure 5展示了一个中断处理的流程.<br><img src=\"http://www.moguang.me/img/irq_handle.png\" alt=\"irq_handle.png\"><br>Figure 5: Processing Interrupt, softirq, and Received Packet.<br>","more":"</p>\n<ul>\n<li>假设CPU 0正在执行一个用户程序. 这时NIC接收到一个数据包并在CPU 0上产生一个中断. 接着CPU执行内核中断处理handler. 该handler根据中断号来调对应的驱动中断handler. 驱动释放已传输的包后调用napi_schedule()函数来处理到达的包. 该函数会请求softirq(软中断).</li>\n<li>在驱动中断handler执行结束后, 控制权交还给内核handler. 内核handler便接着执行该softirq的处理.</li>\n<li>在中断上下文执行后, softirq上下文会被执行. 中断上下文和softirq上下文在一个独立的线程中执行. 然而他们用的是不同栈, 而且中断上下文会阻塞硬件中断; 不过softirq上下文不会阻塞硬件中断.softirq handler中处理到达包的函数是net_rx_action() function. 该函数会调用驱动函数poll(), 而poll()函数会调用netif_receive_skb()函数并将到达包一个个发送到上层程序. 处理softirq后, 应用会回到上次进行系统调用时的中止位置并重新执行.</li>\n<li>此时接收到中断信号的CPU已经完整的处理了一遍到达的数据包. 像Linux, BSD, 和Microsoft Windows这些系统, 这些处理流程基本是一致的.</li>\n<li>当你检查CPU利用率时, 有时你会发现只有一个CPU在执行softirq. 这个情况是目前介绍到的包处理流程方式引起的. 为了解决这个问题, 多队列NIC, RSS, 和RPS等技术被开发了出来.<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3>下面是一些重要的数据结构, 现在来看看相关代码.<br><code>sk_buff structure</code><br>首先是表示一个包结构的sk_buff或skb. Figure 6 展示了 sk_buff 的部分结构. 实际上这些函数在不断完善, 要比图示复杂的多. 不过基础的功能还是基本一样的.<br><img src=\"http://www.moguang.me/img/skbuff.png\" alt=\"irq_handle.png\"><br>Figure 6: Packet Structure sk_buff.</li>\n</ul>\n<h4 id=\"包含包数据及元数据\"><a href=\"#包含包数据及元数据\" class=\"headerlink\" title=\"包含包数据及元数据\"></a>包含包数据及元数据</h4><p>该结构直接包含了包数据或通过指针指向数据. Figure 6, 一些包(从Ethernet到buffer)包含了数据指针而其他数据(flags)存在于内存页中.<br>一些必须的信息，比如header以及payload大小等保存在元数据区域. 比如Figure 6中的mac_header, network_header, transport_header有对应的指针分别指向Ethernet header, IP header及TCP header的开始位置. 这样使得TCP处理起来更简易.</p>\n<h4 id=\"如何增加-删除一个header\"><a href=\"#如何增加-删除一个header\" class=\"headerlink\" title=\"如何增加/删除一个header\"></a>如何增加/删除一个header</h4><p>在网络栈中的不同层，header会根据实际情况增加删除. 指针使得流程处理更有效率. 比如要删除Ethernet header, just increase the head pointer？</p>\n<h4 id=\"如何合并包-拆包\"><a href=\"#如何合并包-拆包\" class=\"headerlink\" title=\"如何合并包/拆包\"></a>如何合并包/拆包</h4><p>链表使得在sokcet buffer/packt chain中增加/删除包的payload内容这些task更有效率. 指针next, prev就是用来做这些操作的.</p>\n<h4 id=\"快速分配和释放\"><a href=\"#快速分配和释放\" class=\"headerlink\" title=\"快速分配和释放\"></a>快速分配和释放</h4><p>由于在创建包时会初始化一个数据结构体, 会用到quick allocator.比如如果数据在10Gb的以太网上传输, 每秒将有超过一百万次的包创建/回收操作.</p>\n<h4 id=\"TCP控制块\"><a href=\"#TCP控制块\" class=\"headerlink\" title=\"TCP控制块\"></a>TCP控制块</h4><p>其次专门有一个结构表示TCP连接, 之前笼统的称为TCP控制块. Linux中使用tcp_sock来表示这个结构. Figure 7中, 你可以看到文件与socket, tcp_socket之间的关系.<br><img src=\"http://www.moguang.me/img/tcp_conn_struct.png\" alt=\"irq_handle.png\"><br>Figure 7: TCP Connection Structure.</p>\n<ul>\n<li>当发生系统调用时, 内核会去搜索应用所传递过来的文件描述符. 在Unix系列系统中, socket, file和文件系统存储设备被抽象成file的概念. 因此file结构包含了尽可能少的信息. 对于socket, 一个socket结构包含了socket相关的信息以及作为指针指向socket, socket同时又指向tcp_sock. tcp_sock 可分类成sock, inet_sock等, 支持除TCP外的多种协议. 可以看作是一种多态polymorphism.</li>\n<li>TCP协议所用到的状态信息保存tcp_sock. 比如序列号, 接收窗口, 拥塞控制, 以及重传时钟等都保存在tcp_sock.</li>\n<li>用于发送/接收的socket buffer为sk_buff列表，他们包含了tcp_sock. IP路由结果结构dst_entry用于避免过于频繁的routing. dst_entry允许用于简单的ARP结果搜索, 也就是MAC地址. dst_entry是routing表的一部分. routing表很复杂而本文不会详细讨论它. 搜索用于传输包的NIC时会用到dst_entry. NIC信息保存在net_device结构中.</li>\n<li>因此通过查找文件，可以容易找到利用指针处理TCP连接的所有数据结构(from the file to the driver). 结构的大小就是一个TCP连接在内存中占用的内存， 大概是几KB (不包括包数据). 随着用到更多功能，内存占用大小也有所增加.</li>\n<li>最后看下TCP连接的lookup表. 这里用了一张hash表去查找到达包所属的TCP连接. hash值通过传入的包头<source ip,=\"\" target=\"\" source=\"\" port,=\"\" port=\"\">来通过Jenkins hash算法计算. 据说使用了防御攻击hash表的hash函数.</li>\n</ul>"},{"title":"network transport layer","date":"2016-08-15T03:33:04.000Z","_content":"\nUDP包结构, 如图所示:<br>\n![UDP包结](/img/udppackage.png)\n<!--more-->\n\nTCP包结构, 如图所示:<br>\n![TCP包结构](/img/tcppackage.png)\n\n关于TCP包几点说明:<br>\n\n- 连接请求号：即SEQ, 该部分占32位，值从1到2的32次方减1。\n- 应答号：即对方返回的ACK值, 该部分占32位，值从1到2的32次方减1。\n- 标志位：例如：Flags＝01,该值用两个十六进制数来表示。该部分长度为6位，6个标志位的含义分别是：\n - URG位：紧急标志，和紧急指针配合使用，当其为1时表示，此报文要尽快传送。\n - ACK位：确认标志，和确认号字段配合使用，当ACK位置1时，确认号字段有效。\n - PSH位：为推送标志，置1时，发送方将立即发送缓冲区中的数据。\n - RST位：复位标志，置1时，表明有严重差错，必须释放连接。\n - SYN位： 同步标志，置1时，表示请求建立连接。\n - FIN位：终止标志，置1时，表明数据已经发送完，请求释放连接。\n- 窗口大小：32bit，用于向对方通告当前本机的接受缓冲区的大小。\n","source":"_posts/network/network-transport-layer.md","raw":"---\ntitle: network transport layer\ndate: 2016-08-15 11:33:04\ntags: networking\n---\n\nUDP包结构, 如图所示:<br>\n![UDP包结](/img/udppackage.png)\n<!--more-->\n\nTCP包结构, 如图所示:<br>\n![TCP包结构](/img/tcppackage.png)\n\n关于TCP包几点说明:<br>\n\n- 连接请求号：即SEQ, 该部分占32位，值从1到2的32次方减1。\n- 应答号：即对方返回的ACK值, 该部分占32位，值从1到2的32次方减1。\n- 标志位：例如：Flags＝01,该值用两个十六进制数来表示。该部分长度为6位，6个标志位的含义分别是：\n - URG位：紧急标志，和紧急指针配合使用，当其为1时表示，此报文要尽快传送。\n - ACK位：确认标志，和确认号字段配合使用，当ACK位置1时，确认号字段有效。\n - PSH位：为推送标志，置1时，发送方将立即发送缓冲区中的数据。\n - RST位：复位标志，置1时，表明有严重差错，必须释放连接。\n - SYN位： 同步标志，置1时，表示请求建立连接。\n - FIN位：终止标志，置1时，表明数据已经发送完，请求释放连接。\n- 窗口大小：32bit，用于向对方通告当前本机的接受缓冲区的大小。\n","slug":"network/network-transport-layer","published":1,"updated":"2017-08-15T03:58:49.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dwf001c4j4d4dhkasd4","content":"<p>UDP包结构, 如图所示:<br><br><img src=\"/img/udppackage.png\" alt=\"UDP包结\"><br><a id=\"more\"></a></p>\n<p>TCP包结构, 如图所示:<br><br><img src=\"/img/tcppackage.png\" alt=\"TCP包结构\"></p>\n<p>关于TCP包几点说明:<br></p>\n<ul>\n<li>连接请求号：即SEQ, 该部分占32位，值从1到2的32次方减1。</li>\n<li>应答号：即对方返回的ACK值, 该部分占32位，值从1到2的32次方减1。</li>\n<li>标志位：例如：Flags＝01,该值用两个十六进制数来表示。该部分长度为6位，6个标志位的含义分别是：<ul>\n<li>URG位：紧急标志，和紧急指针配合使用，当其为1时表示，此报文要尽快传送。</li>\n<li>ACK位：确认标志，和确认号字段配合使用，当ACK位置1时，确认号字段有效。</li>\n<li>PSH位：为推送标志，置1时，发送方将立即发送缓冲区中的数据。</li>\n<li>RST位：复位标志，置1时，表明有严重差错，必须释放连接。</li>\n<li>SYN位： 同步标志，置1时，表示请求建立连接。</li>\n<li>FIN位：终止标志，置1时，表明数据已经发送完，请求释放连接。</li>\n</ul>\n</li>\n<li>窗口大小：32bit，用于向对方通告当前本机的接受缓冲区的大小。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>UDP包结构, 如图所示:<br><br><img src=\"/img/udppackage.png\" alt=\"UDP包结\"><br>","more":"</p>\n<p>TCP包结构, 如图所示:<br><br><img src=\"/img/tcppackage.png\" alt=\"TCP包结构\"></p>\n<p>关于TCP包几点说明:<br></p>\n<ul>\n<li>连接请求号：即SEQ, 该部分占32位，值从1到2的32次方减1。</li>\n<li>应答号：即对方返回的ACK值, 该部分占32位，值从1到2的32次方减1。</li>\n<li>标志位：例如：Flags＝01,该值用两个十六进制数来表示。该部分长度为6位，6个标志位的含义分别是：<ul>\n<li>URG位：紧急标志，和紧急指针配合使用，当其为1时表示，此报文要尽快传送。</li>\n<li>ACK位：确认标志，和确认号字段配合使用，当ACK位置1时，确认号字段有效。</li>\n<li>PSH位：为推送标志，置1时，发送方将立即发送缓冲区中的数据。</li>\n<li>RST位：复位标志，置1时，表明有严重差错，必须释放连接。</li>\n<li>SYN位： 同步标志，置1时，表示请求建立连接。</li>\n<li>FIN位：终止标志，置1时，表明数据已经发送完，请求释放连接。</li>\n</ul>\n</li>\n<li>窗口大小：32bit，用于向对方通告当前本机的接受缓冲区的大小。</li>\n</ul>"},{"title":"VS Code下创建SpringBoot应用","date":"2018-06-23T15:36:36.000Z","_content":"\n## 在vscode中安装相关扩展包\n\n主要选择了`Java Extension Pack`,`Spring Boot Extension Pack`这两个扩展包，如图：\n![](/img/vscdep.png)\n\n<!--more-->\n## 创建spring boot项目\n\n`Ctrl + Shift + P`打开命令选项板，输入`Spring Initializr`开始生成Maven或Gradle项目。这里以Gradle为例，其中在选择依赖包一步，可以选择web和devTools这两个，创建好后打开对应工作区，可以看到初始化的项目结构是这样子的(HelloController.java是后来所建)：\n![](/img/vscstruct.png)\n\n## 创建一个controller类\n\n这里创建了`HelloController`, 用以注册请求url及对应的处理方法，主要代码如下：\n\n```java\npackage com.example.demo.controller;  \n  \nimport org.springframework.web.bind.annotation.RequestMapping;  \nimport org.springframework.web.bind.annotation.RestController;  \n  \n@RestController\npublic class HelloController {  \n\n    @RequestMapping(\"/hello\")  \n    String greeting() {  \n        return \"Hello my friend!\";\n    }\n}\n```\n\n## 通过gradlew直接启动服务\n\n在终端环境中，cd到项目根目录下，可直接通过 `chmod +x gradlew && ./gradlew bootRun` 来启动springboot程序：\n\n```shell\n$./gradlew bootRun\nStarting a Gradle Daemon, 1 busy Daemon could not be reused, use --status for details\n> Task :bootRun22:53:25.501 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Included patterns for restart : []\n22:53:25.505 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Excluded patterns for restart : [/sprin\ng-boot-actuator/target/classes/, /spring-boot-devtools/target/classes/, /spring-boot/target/classes/, /spring-boot-starter-[\\w-\n]+/, /spring-boot-autoconfigure/target/classes/, /spring-boot-starter/target/classes/]\n22:53:25.505 [main] DEBUG org.springframework.boot.devtools.restart.ChangeableUrls - Matching URLs for reloading : [file:/data/\napps/javaproc/secondprocj/build/classes/java/main/, file:/data/apps/javaproc/secondprocj/build/resources/main/]\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.0.3.RELEASE)\n\n2018-06-23 22:53:25.993  INFO 37795 --- [  restartedMain] com.example.demo.DemoApplication         : Starting DemoApplication on AppledeMBP.lan with PID 37795 (/data/apps/javaproc/secondprocj/build/classes/java/main started by apple in /data/apps/javaproc/secondprocj)\n// ... 这里忽略部分日志\n2018-06-23 22:53:29.863  INFO 37795 --- [  restartedMain] com.example.demo.DemoApplication         : Started DemoApplication in 4.334 seconds (JVM running for 5.009)\n2018-06-23 22:53:41.140  INFO 37795 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring Framew\norkServlet 'dispatcherServlet'\n2018-06-23 22:53:41.140  INFO 37795 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started\n2018-06-23 22:53:41.165  INFO 37795 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 24 ms\n<=========----> 75% EXECUTING [3m 50s]\n> :bootRun\n```\n\n服务起来后， 我们去打开浏览器，输入 `http://localhost:8080/hello`，将会得到如下响应结果：\n![](/img/vscsbshow.png)\n\n### 打包成可执行jar文件\n\n当然我们可以把项目源码编译成可执行jar包，再部署到对应的位置并启动:\n\n```shell\n$./gradlew build\nStarting a Gradle Daemon (subsequent builds will be faster)\n\n> Task :test\n2018-06-23 23:30:54.215  INFO 39578 --- [       Thread-6] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframewor\nk.web.context.support.GenericWebApplicationContext@3dfafd95: startup date [Sat Jun 23 23:30:49 CST 2018]; root of context hierarchy\n\n\nBUILD SUCCESSFUL in 23s\n5 actionable tasks: 4 executed, 1 up-to-date\n```\n这时候我们可以看到在`./build/libs/`下会生成对应的jar包，我们将它拷到某个位置后，再启动测试一下:\n\n```shell\n$java -jar demo-0.0.1-SNAPSHOT.jar\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.0.3.RELEASE)\n\n2018-06-23 23:33:24.134  INFO 39652 --- [           main] com.example.demo.DemoApplication         : Starting DemoApplication on AppledeMBP.lan with PID 39652 (/data/apps/demo-0.0.1-SNAPSHOT.jar started by apple in /data/apps)\n// ... 这里忽略部分日志\n2018-06-23 23:33:28.515  INFO 39652 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 5.352 seconds (JVM running for 6.077)\n```\n在浏览器中重新刷新`http://localhost:8080/hello`， 同样可以得到预期的响应内容。\n","source":"_posts/java/springboot-on-vscode.md","raw":"---\ntitle: 'VS Code下创建SpringBoot应用'\ndate: 2018-06-23 23:36:36\ntags: [\"java\",\"springboot\"]\n---\n\n## 在vscode中安装相关扩展包\n\n主要选择了`Java Extension Pack`,`Spring Boot Extension Pack`这两个扩展包，如图：\n![](/img/vscdep.png)\n\n<!--more-->\n## 创建spring boot项目\n\n`Ctrl + Shift + P`打开命令选项板，输入`Spring Initializr`开始生成Maven或Gradle项目。这里以Gradle为例，其中在选择依赖包一步，可以选择web和devTools这两个，创建好后打开对应工作区，可以看到初始化的项目结构是这样子的(HelloController.java是后来所建)：\n![](/img/vscstruct.png)\n\n## 创建一个controller类\n\n这里创建了`HelloController`, 用以注册请求url及对应的处理方法，主要代码如下：\n\n```java\npackage com.example.demo.controller;  \n  \nimport org.springframework.web.bind.annotation.RequestMapping;  \nimport org.springframework.web.bind.annotation.RestController;  \n  \n@RestController\npublic class HelloController {  \n\n    @RequestMapping(\"/hello\")  \n    String greeting() {  \n        return \"Hello my friend!\";\n    }\n}\n```\n\n## 通过gradlew直接启动服务\n\n在终端环境中，cd到项目根目录下，可直接通过 `chmod +x gradlew && ./gradlew bootRun` 来启动springboot程序：\n\n```shell\n$./gradlew bootRun\nStarting a Gradle Daemon, 1 busy Daemon could not be reused, use --status for details\n> Task :bootRun22:53:25.501 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Included patterns for restart : []\n22:53:25.505 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Excluded patterns for restart : [/sprin\ng-boot-actuator/target/classes/, /spring-boot-devtools/target/classes/, /spring-boot/target/classes/, /spring-boot-starter-[\\w-\n]+/, /spring-boot-autoconfigure/target/classes/, /spring-boot-starter/target/classes/]\n22:53:25.505 [main] DEBUG org.springframework.boot.devtools.restart.ChangeableUrls - Matching URLs for reloading : [file:/data/\napps/javaproc/secondprocj/build/classes/java/main/, file:/data/apps/javaproc/secondprocj/build/resources/main/]\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.0.3.RELEASE)\n\n2018-06-23 22:53:25.993  INFO 37795 --- [  restartedMain] com.example.demo.DemoApplication         : Starting DemoApplication on AppledeMBP.lan with PID 37795 (/data/apps/javaproc/secondprocj/build/classes/java/main started by apple in /data/apps/javaproc/secondprocj)\n// ... 这里忽略部分日志\n2018-06-23 22:53:29.863  INFO 37795 --- [  restartedMain] com.example.demo.DemoApplication         : Started DemoApplication in 4.334 seconds (JVM running for 5.009)\n2018-06-23 22:53:41.140  INFO 37795 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring Framew\norkServlet 'dispatcherServlet'\n2018-06-23 22:53:41.140  INFO 37795 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started\n2018-06-23 22:53:41.165  INFO 37795 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 24 ms\n<=========----> 75% EXECUTING [3m 50s]\n> :bootRun\n```\n\n服务起来后， 我们去打开浏览器，输入 `http://localhost:8080/hello`，将会得到如下响应结果：\n![](/img/vscsbshow.png)\n\n### 打包成可执行jar文件\n\n当然我们可以把项目源码编译成可执行jar包，再部署到对应的位置并启动:\n\n```shell\n$./gradlew build\nStarting a Gradle Daemon (subsequent builds will be faster)\n\n> Task :test\n2018-06-23 23:30:54.215  INFO 39578 --- [       Thread-6] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframewor\nk.web.context.support.GenericWebApplicationContext@3dfafd95: startup date [Sat Jun 23 23:30:49 CST 2018]; root of context hierarchy\n\n\nBUILD SUCCESSFUL in 23s\n5 actionable tasks: 4 executed, 1 up-to-date\n```\n这时候我们可以看到在`./build/libs/`下会生成对应的jar包，我们将它拷到某个位置后，再启动测试一下:\n\n```shell\n$java -jar demo-0.0.1-SNAPSHOT.jar\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.0.3.RELEASE)\n\n2018-06-23 23:33:24.134  INFO 39652 --- [           main] com.example.demo.DemoApplication         : Starting DemoApplication on AppledeMBP.lan with PID 39652 (/data/apps/demo-0.0.1-SNAPSHOT.jar started by apple in /data/apps)\n// ... 这里忽略部分日志\n2018-06-23 23:33:28.515  INFO 39652 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 5.352 seconds (JVM running for 6.077)\n```\n在浏览器中重新刷新`http://localhost:8080/hello`， 同样可以得到预期的响应内容。\n","slug":"java/springboot-on-vscode","published":1,"updated":"2018-06-24T14:05:11.575Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dwh001e4j4dzhhs89fc","content":"<h2 id=\"在vscode中安装相关扩展包\"><a href=\"#在vscode中安装相关扩展包\" class=\"headerlink\" title=\"在vscode中安装相关扩展包\"></a>在vscode中安装相关扩展包</h2><p>主要选择了<code>Java Extension Pack</code>,<code>Spring Boot Extension Pack</code>这两个扩展包，如图：<br><img src=\"/img/vscdep.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"创建spring-boot项目\"><a href=\"#创建spring-boot项目\" class=\"headerlink\" title=\"创建spring boot项目\"></a>创建spring boot项目</h2><p><code>Ctrl + Shift + P</code>打开命令选项板，输入<code>Spring Initializr</code>开始生成Maven或Gradle项目。这里以Gradle为例，其中在选择依赖包一步，可以选择web和devTools这两个，创建好后打开对应工作区，可以看到初始化的项目结构是这样子的(HelloController.java是后来所建)：<br><img src=\"/img/vscstruct.png\" alt=\"\"></p>\n<h2 id=\"创建一个controller类\"><a href=\"#创建一个controller类\" class=\"headerlink\" title=\"创建一个controller类\"></a>创建一个controller类</h2><p>这里创建了<code>HelloController</code>, 用以注册请求url及对应的处理方法，主要代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.demo.controller;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;  </div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"meta\">@RestController</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloController</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/hello\"</span>)  </div><div class=\"line\">    <span class=\"function\">String <span class=\"title\">greeting</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello my friend!\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"通过gradlew直接启动服务\"><a href=\"#通过gradlew直接启动服务\" class=\"headerlink\" title=\"通过gradlew直接启动服务\"></a>通过gradlew直接启动服务</h2><p>在终端环境中，cd到项目根目录下，可直接通过 <code>chmod +x gradlew &amp;&amp; ./gradlew bootRun</code> 来启动springboot程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">./gradlew bootRun</span></div><div class=\"line\">Starting a Gradle Daemon, 1 busy Daemon could not be reused, use --status for details</div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> Task :bootRun22:53:25.501 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Included patterns <span class=\"keyword\">for</span> restart : []</span></div><div class=\"line\">22:53:25.505 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Excluded patterns for restart : [/sprin</div><div class=\"line\">g-boot-actuator/target/classes/, /spring-boot-devtools/target/classes/, /spring-boot/target/classes/, /spring-boot-starter-[\\w-</div><div class=\"line\">]+/, /spring-boot-autoconfigure/target/classes/, /spring-boot-starter/target/classes/]</div><div class=\"line\">22:53:25.505 [main] DEBUG org.springframework.boot.devtools.restart.ChangeableUrls - Matching URLs for reloading : [file:/data/</div><div class=\"line\">apps/javaproc/secondprocj/build/classes/java/main/, file:/data/apps/javaproc/secondprocj/build/resources/main/]</div><div class=\"line\">  .   ____          _            __ _ _</div><div class=\"line\"> /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\</div><div class=\"line\">( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\</div><div class=\"line\"> \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )</div><div class=\"line\">  '  |____| .__|_| |_|_| |_\\__, | / / / /</div><div class=\"line\"> =========|_|==============|___/=/_/_/_/</div><div class=\"line\"> :: Spring Boot ::        (v2.0.3.RELEASE)</div><div class=\"line\"></div><div class=\"line\">2018-06-23 22:53:25.993  INFO 37795 --- [  restartedMain] com.example.demo.DemoApplication         : Starting DemoApplication on AppledeMBP.lan with PID 37795 (/data/apps/javaproc/secondprocj/build/classes/java/main started by apple in /data/apps/javaproc/secondprocj)</div><div class=\"line\">// ... 这里忽略部分日志</div><div class=\"line\">2018-06-23 22:53:29.863  INFO 37795 --- [  restartedMain] com.example.demo.DemoApplication         : Started DemoApplication in 4.334 seconds (JVM running for 5.009)</div><div class=\"line\">2018-06-23 22:53:41.140  INFO 37795 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring Framew</div><div class=\"line\">orkServlet 'dispatcherServlet'</div><div class=\"line\">2018-06-23 22:53:41.140  INFO 37795 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started</div><div class=\"line\">2018-06-23 22:53:41.165  INFO 37795 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 24 ms</div><div class=\"line\">&lt;=========----&gt; 75% EXECUTING [3m 50s]</div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> :bootRun</span></div></pre></td></tr></table></figure>\n<p>服务起来后， 我们去打开浏览器，输入 <code>http://localhost:8080/hello</code>，将会得到如下响应结果：<br><img src=\"/img/vscsbshow.png\" alt=\"\"></p>\n<h3 id=\"打包成可执行jar文件\"><a href=\"#打包成可执行jar文件\" class=\"headerlink\" title=\"打包成可执行jar文件\"></a>打包成可执行jar文件</h3><p>当然我们可以把项目源码编译成可执行jar包，再部署到对应的位置并启动:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">./gradlew build</span></div><div class=\"line\">Starting a Gradle Daemon (subsequent builds will be faster)</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">&gt;<span class=\"bash\"> Task :<span class=\"built_in\">test</span></span></div><div class=\"line\">2018-06-23 23:30:54.215  INFO 39578 --- [       Thread-6] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframewor</div><div class=\"line\">k.web.context.support.GenericWebApplicationContext@3dfafd95: startup date [Sat Jun 23 23:30:49 CST 2018]; root of context hierarchy</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">BUILD SUCCESSFUL in 23s</div><div class=\"line\">5 actionable tasks: 4 executed, 1 up-to-date</div></pre></td></tr></table></figure>\n<p>这时候我们可以看到在<code>./build/libs/</code>下会生成对应的jar包，我们将它拷到某个位置后，再启动测试一下:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">java -jar demo-0.0.1-SNAPSHOT.jar</span></div><div class=\"line\"></div><div class=\"line\">  .   ____          _            __ _ _</div><div class=\"line\"> /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\</div><div class=\"line\">( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\</div><div class=\"line\"> \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )</div><div class=\"line\">  '  |____| .__|_| |_|_| |_\\__, | / / / /</div><div class=\"line\"> =========|_|==============|___/=/_/_/_/</div><div class=\"line\"> :: Spring Boot ::        (v2.0.3.RELEASE)</div><div class=\"line\"></div><div class=\"line\">2018-06-23 23:33:24.134  INFO 39652 --- [           main] com.example.demo.DemoApplication         : Starting DemoApplication on AppledeMBP.lan with PID 39652 (/data/apps/demo-0.0.1-SNAPSHOT.jar started by apple in /data/apps)</div><div class=\"line\">// ... 这里忽略部分日志</div><div class=\"line\">2018-06-23 23:33:28.515  INFO 39652 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 5.352 seconds (JVM running for 6.077)</div></pre></td></tr></table></figure>\n<p>在浏览器中重新刷新<code>http://localhost:8080/hello</code>， 同样可以得到预期的响应内容。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"在vscode中安装相关扩展包\"><a href=\"#在vscode中安装相关扩展包\" class=\"headerlink\" title=\"在vscode中安装相关扩展包\"></a>在vscode中安装相关扩展包</h2><p>主要选择了<code>Java Extension Pack</code>,<code>Spring Boot Extension Pack</code>这两个扩展包，如图：<br><img src=\"/img/vscdep.png\" alt=\"\"></p>","more":"<h2 id=\"创建spring-boot项目\"><a href=\"#创建spring-boot项目\" class=\"headerlink\" title=\"创建spring boot项目\"></a>创建spring boot项目</h2><p><code>Ctrl + Shift + P</code>打开命令选项板，输入<code>Spring Initializr</code>开始生成Maven或Gradle项目。这里以Gradle为例，其中在选择依赖包一步，可以选择web和devTools这两个，创建好后打开对应工作区，可以看到初始化的项目结构是这样子的(HelloController.java是后来所建)：<br><img src=\"/img/vscstruct.png\" alt=\"\"></p>\n<h2 id=\"创建一个controller类\"><a href=\"#创建一个controller类\" class=\"headerlink\" title=\"创建一个controller类\"></a>创建一个controller类</h2><p>这里创建了<code>HelloController</code>, 用以注册请求url及对应的处理方法，主要代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.demo.controller;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;  </div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"meta\">@RestController</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloController</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/hello\"</span>)  </div><div class=\"line\">    <span class=\"function\">String <span class=\"title\">greeting</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello my friend!\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"通过gradlew直接启动服务\"><a href=\"#通过gradlew直接启动服务\" class=\"headerlink\" title=\"通过gradlew直接启动服务\"></a>通过gradlew直接启动服务</h2><p>在终端环境中，cd到项目根目录下，可直接通过 <code>chmod +x gradlew &amp;&amp; ./gradlew bootRun</code> 来启动springboot程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">./gradlew bootRun</span></div><div class=\"line\">Starting a Gradle Daemon, 1 busy Daemon could not be reused, use --status for details</div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> Task :bootRun22:53:25.501 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Included patterns <span class=\"keyword\">for</span> restart : []</span></div><div class=\"line\">22:53:25.505 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Excluded patterns for restart : [/sprin</div><div class=\"line\">g-boot-actuator/target/classes/, /spring-boot-devtools/target/classes/, /spring-boot/target/classes/, /spring-boot-starter-[\\w-</div><div class=\"line\">]+/, /spring-boot-autoconfigure/target/classes/, /spring-boot-starter/target/classes/]</div><div class=\"line\">22:53:25.505 [main] DEBUG org.springframework.boot.devtools.restart.ChangeableUrls - Matching URLs for reloading : [file:/data/</div><div class=\"line\">apps/javaproc/secondprocj/build/classes/java/main/, file:/data/apps/javaproc/secondprocj/build/resources/main/]</div><div class=\"line\">  .   ____          _            __ _ _</div><div class=\"line\"> /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\</div><div class=\"line\">( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\</div><div class=\"line\"> \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )</div><div class=\"line\">  '  |____| .__|_| |_|_| |_\\__, | / / / /</div><div class=\"line\"> =========|_|==============|___/=/_/_/_/</div><div class=\"line\"> :: Spring Boot ::        (v2.0.3.RELEASE)</div><div class=\"line\"></div><div class=\"line\">2018-06-23 22:53:25.993  INFO 37795 --- [  restartedMain] com.example.demo.DemoApplication         : Starting DemoApplication on AppledeMBP.lan with PID 37795 (/data/apps/javaproc/secondprocj/build/classes/java/main started by apple in /data/apps/javaproc/secondprocj)</div><div class=\"line\">// ... 这里忽略部分日志</div><div class=\"line\">2018-06-23 22:53:29.863  INFO 37795 --- [  restartedMain] com.example.demo.DemoApplication         : Started DemoApplication in 4.334 seconds (JVM running for 5.009)</div><div class=\"line\">2018-06-23 22:53:41.140  INFO 37795 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring Framew</div><div class=\"line\">orkServlet 'dispatcherServlet'</div><div class=\"line\">2018-06-23 22:53:41.140  INFO 37795 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started</div><div class=\"line\">2018-06-23 22:53:41.165  INFO 37795 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 24 ms</div><div class=\"line\">&lt;=========----&gt; 75% EXECUTING [3m 50s]</div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> :bootRun</span></div></pre></td></tr></table></figure>\n<p>服务起来后， 我们去打开浏览器，输入 <code>http://localhost:8080/hello</code>，将会得到如下响应结果：<br><img src=\"/img/vscsbshow.png\" alt=\"\"></p>\n<h3 id=\"打包成可执行jar文件\"><a href=\"#打包成可执行jar文件\" class=\"headerlink\" title=\"打包成可执行jar文件\"></a>打包成可执行jar文件</h3><p>当然我们可以把项目源码编译成可执行jar包，再部署到对应的位置并启动:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">./gradlew build</span></div><div class=\"line\">Starting a Gradle Daemon (subsequent builds will be faster)</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">&gt;<span class=\"bash\"> Task :<span class=\"built_in\">test</span></span></div><div class=\"line\">2018-06-23 23:30:54.215  INFO 39578 --- [       Thread-6] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframewor</div><div class=\"line\">k.web.context.support.GenericWebApplicationContext@3dfafd95: startup date [Sat Jun 23 23:30:49 CST 2018]; root of context hierarchy</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">BUILD SUCCESSFUL in 23s</div><div class=\"line\">5 actionable tasks: 4 executed, 1 up-to-date</div></pre></td></tr></table></figure>\n<p>这时候我们可以看到在<code>./build/libs/</code>下会生成对应的jar包，我们将它拷到某个位置后，再启动测试一下:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">java -jar demo-0.0.1-SNAPSHOT.jar</span></div><div class=\"line\"></div><div class=\"line\">  .   ____          _            __ _ _</div><div class=\"line\"> /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\</div><div class=\"line\">( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\</div><div class=\"line\"> \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )</div><div class=\"line\">  '  |____| .__|_| |_|_| |_\\__, | / / / /</div><div class=\"line\"> =========|_|==============|___/=/_/_/_/</div><div class=\"line\"> :: Spring Boot ::        (v2.0.3.RELEASE)</div><div class=\"line\"></div><div class=\"line\">2018-06-23 23:33:24.134  INFO 39652 --- [           main] com.example.demo.DemoApplication         : Starting DemoApplication on AppledeMBP.lan with PID 39652 (/data/apps/demo-0.0.1-SNAPSHOT.jar started by apple in /data/apps)</div><div class=\"line\">// ... 这里忽略部分日志</div><div class=\"line\">2018-06-23 23:33:28.515  INFO 39652 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 5.352 seconds (JVM running for 6.077)</div></pre></td></tr></table></figure>\n<p>在浏览器中重新刷新<code>http://localhost:8080/hello</code>， 同样可以得到预期的响应内容。</p>"},{"title":"使用parallel-ssh批量执行远程shell命令","date":"2017-12-05T03:42:00.000Z","_content":"\n### 使用parallel-ssh批量执行远程shell命令\n\n#### pssh使用场景\n假设现在需要对数百台服务器节点进行配置更新或者执行一些简短command，而目前并没有完备的部署工具软件， 那可以选择向pssh这样的并行登录远程终端并执行指定命令的shell工具。\n以前机器节点少的时候，直接用shell写个for循环来执行命令，也没什么问题。当节点数量多了之后，一个shell命令可能要消耗几秒， 这时才能感受到pssh这种并行方式的好处，省时省力。\n<!--more-->\n#### pssh可选配置参数列表\n除了pssh，当需要传递登录密码时，可以用到sshpass命令：\n```shell\npintai@MG:~/bak$ pssh --help\nUsage: pssh [OPTIONS] command [...]\n\nOptions:\n  --version             show program's version number and exit\n  --help                show this help message and exit\n  -h HOST_FILE, --hosts=HOST_FILE\n                        hosts file (each line \"[user@]host[:port]\")\n  -H HOST_STRING, --host=HOST_STRING\n                        additional host entries (\"[user@]host[:port]\")\n  -l USER, --user=USER  username (OPTIONAL)\n  -p PAR, --par=PAR     max number of parallel threads (OPTIONAL)\n  -o OUTDIR, --outdir=OUTDIR\n                        output directory for stdout files (OPTIONAL)\n  -e ERRDIR, --errdir=ERRDIR\n                        output directory for stderr files (OPTIONAL)\n  -t TIMEOUT, --timeout=TIMEOUT\n                        timeout (secs) (0 = no timeout) per host (OPTIONAL)\n  -O OPTION, --option=OPTION\n                        SSH option (OPTIONAL)\n  -v, --verbose         turn on warning and diagnostic messages (OPTIONAL)\n  -A, --askpass         Ask for a password (OPTIONAL)\n  -x ARGS, --extra-args=ARGS\n                        Extra command-line arguments, with processing for\n                        spaces, quotes, and backslashes\n  -X ARG, --extra-arg=ARG\n                        Extra command-line argument\n  -i, --inline          inline aggregated output and error for each server\n  --inline-stdout       inline standard output for each server\n  -I, --send-input      read from standard input and send as input to ssh\n  -P, --print           print output as we get it\n\nExample: pssh -h hosts.txt -l irb2 -o /tmp/foo uptime\n\npintai@MG:~/bak$ sshpass --help\nsshpass: invalid option -- '-'\nUsage: sshpass [-f|-d|-p|-e] [-hV] command parameters\n   -f filename   Take password to use from file\n   -d number     Use number as file descriptor for getting password\n   -p password   Provide password as argument (security unwise)\n   -e            Password is passed as env-var \"SSHPASS\"\n   With no parameters - password will be taken from stdin\n\n   -h            Show help (this screen)\n   -V            Print version information\nAt most one of -f, -d, -p or -e should be used\n```\n\n\n#### 1.使用sshpass传递登录密码\n先把需要远程登录的host集中写到一个文件， 比如叫hostlist，写入host列表:\n```\n192.168.1.11:22\n192.168.1.12:22\n192.168.1.13:22\n```\n然后将ssh登录密码写到另一个文件， 比如叫remotepass， 写入密码:\n```\nyourpassword\n```\n最后执行相关命令， 直接打印每个节点的输出内容：\n```shell\nsshpass -f remotepass pssh -h hostlist -l yourloginname -A -i \"hostname\"\n```\n输出结果如下\n```\nWarning: do not enter your password if anyone else has superuser\nprivileges or access to your account.\n[1] 11:23:21 [SUCCESS] 192.168.1.11:22\ntest1.hostname\n[2] 11:23:21 [SUCCESS] 192.168.1.12:22\ntest2.hostname\n[3] 11:23:21 [SUCCESS] 192.168.1.13:22\ntest3.hostname\n```\n#### 2.将结果输出到指定文件\n\n如果需要将输出结果收集起来，那么可以通过*-o*选项来指定结果输出目录，比如：\n```shell\nsshpass -f remotepass pssh -h hostlist -l yourloginname -o outputdir -A \"hostname\"\n```\n执行时终端输出:\n```\nWarning: do not enter your password if anyone else has superuser\nprivileges or access to your account.\n[1] 11:23:21 [SUCCESS] 192.168.1.11:22\n[2] 11:23:21 [SUCCESS] 192.168.1.12:22\n[3] 11:23:21 [SUCCESS] 192.168.1.13:22\n```\n而当前目录会生成*outputdir*目录，目录中每个host占一个文件，如：\n```\npintai@MG:~/bak$ ls output/\n192.168.1.11:22 192.168.1.12:22 192.168.1.13:22\npintai@MG:~/bak$ cat output/*\ntest1.hostname\ntest2.hostname\ntest3.hostname\n```\n\n#### 3.  执行sudo命令\n有些shell命令可能需要通过sudo权限来执行，一般来说本地可以这么执行\n```\necho your_sudo_pass | sudo -S your_command\n```\n而在pssh中可以这么做：\n```shell\nsshpass -f remotepass pssh -h hostlist -l yourloginname -o outputdir -A \"echo your_sudo_pass | sudo netstat -antup | grep xxx\"\n```\n执行完毕后，具体输出结果可以在outputdir目录下查找。\n","source":"_posts/script/parallel-shell-md.md","raw":"---\ntitle: \"使用parallel-ssh批量执行远程shell命令\"\ndate: 2017-12-05 11:42:00\ntags: shell\n---\n\n### 使用parallel-ssh批量执行远程shell命令\n\n#### pssh使用场景\n假设现在需要对数百台服务器节点进行配置更新或者执行一些简短command，而目前并没有完备的部署工具软件， 那可以选择向pssh这样的并行登录远程终端并执行指定命令的shell工具。\n以前机器节点少的时候，直接用shell写个for循环来执行命令，也没什么问题。当节点数量多了之后，一个shell命令可能要消耗几秒， 这时才能感受到pssh这种并行方式的好处，省时省力。\n<!--more-->\n#### pssh可选配置参数列表\n除了pssh，当需要传递登录密码时，可以用到sshpass命令：\n```shell\npintai@MG:~/bak$ pssh --help\nUsage: pssh [OPTIONS] command [...]\n\nOptions:\n  --version             show program's version number and exit\n  --help                show this help message and exit\n  -h HOST_FILE, --hosts=HOST_FILE\n                        hosts file (each line \"[user@]host[:port]\")\n  -H HOST_STRING, --host=HOST_STRING\n                        additional host entries (\"[user@]host[:port]\")\n  -l USER, --user=USER  username (OPTIONAL)\n  -p PAR, --par=PAR     max number of parallel threads (OPTIONAL)\n  -o OUTDIR, --outdir=OUTDIR\n                        output directory for stdout files (OPTIONAL)\n  -e ERRDIR, --errdir=ERRDIR\n                        output directory for stderr files (OPTIONAL)\n  -t TIMEOUT, --timeout=TIMEOUT\n                        timeout (secs) (0 = no timeout) per host (OPTIONAL)\n  -O OPTION, --option=OPTION\n                        SSH option (OPTIONAL)\n  -v, --verbose         turn on warning and diagnostic messages (OPTIONAL)\n  -A, --askpass         Ask for a password (OPTIONAL)\n  -x ARGS, --extra-args=ARGS\n                        Extra command-line arguments, with processing for\n                        spaces, quotes, and backslashes\n  -X ARG, --extra-arg=ARG\n                        Extra command-line argument\n  -i, --inline          inline aggregated output and error for each server\n  --inline-stdout       inline standard output for each server\n  -I, --send-input      read from standard input and send as input to ssh\n  -P, --print           print output as we get it\n\nExample: pssh -h hosts.txt -l irb2 -o /tmp/foo uptime\n\npintai@MG:~/bak$ sshpass --help\nsshpass: invalid option -- '-'\nUsage: sshpass [-f|-d|-p|-e] [-hV] command parameters\n   -f filename   Take password to use from file\n   -d number     Use number as file descriptor for getting password\n   -p password   Provide password as argument (security unwise)\n   -e            Password is passed as env-var \"SSHPASS\"\n   With no parameters - password will be taken from stdin\n\n   -h            Show help (this screen)\n   -V            Print version information\nAt most one of -f, -d, -p or -e should be used\n```\n\n\n#### 1.使用sshpass传递登录密码\n先把需要远程登录的host集中写到一个文件， 比如叫hostlist，写入host列表:\n```\n192.168.1.11:22\n192.168.1.12:22\n192.168.1.13:22\n```\n然后将ssh登录密码写到另一个文件， 比如叫remotepass， 写入密码:\n```\nyourpassword\n```\n最后执行相关命令， 直接打印每个节点的输出内容：\n```shell\nsshpass -f remotepass pssh -h hostlist -l yourloginname -A -i \"hostname\"\n```\n输出结果如下\n```\nWarning: do not enter your password if anyone else has superuser\nprivileges or access to your account.\n[1] 11:23:21 [SUCCESS] 192.168.1.11:22\ntest1.hostname\n[2] 11:23:21 [SUCCESS] 192.168.1.12:22\ntest2.hostname\n[3] 11:23:21 [SUCCESS] 192.168.1.13:22\ntest3.hostname\n```\n#### 2.将结果输出到指定文件\n\n如果需要将输出结果收集起来，那么可以通过*-o*选项来指定结果输出目录，比如：\n```shell\nsshpass -f remotepass pssh -h hostlist -l yourloginname -o outputdir -A \"hostname\"\n```\n执行时终端输出:\n```\nWarning: do not enter your password if anyone else has superuser\nprivileges or access to your account.\n[1] 11:23:21 [SUCCESS] 192.168.1.11:22\n[2] 11:23:21 [SUCCESS] 192.168.1.12:22\n[3] 11:23:21 [SUCCESS] 192.168.1.13:22\n```\n而当前目录会生成*outputdir*目录，目录中每个host占一个文件，如：\n```\npintai@MG:~/bak$ ls output/\n192.168.1.11:22 192.168.1.12:22 192.168.1.13:22\npintai@MG:~/bak$ cat output/*\ntest1.hostname\ntest2.hostname\ntest3.hostname\n```\n\n#### 3.  执行sudo命令\n有些shell命令可能需要通过sudo权限来执行，一般来说本地可以这么执行\n```\necho your_sudo_pass | sudo -S your_command\n```\n而在pssh中可以这么做：\n```shell\nsshpass -f remotepass pssh -h hostlist -l yourloginname -o outputdir -A \"echo your_sudo_pass | sudo netstat -antup | grep xxx\"\n```\n执行完毕后，具体输出结果可以在outputdir目录下查找。\n","slug":"script/parallel-shell-md","published":1,"updated":"2017-12-05T03:43:04.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dwh001f4j4d8o2dwzyq","content":"<h3 id=\"使用parallel-ssh批量执行远程shell命令\"><a href=\"#使用parallel-ssh批量执行远程shell命令\" class=\"headerlink\" title=\"使用parallel-ssh批量执行远程shell命令\"></a>使用parallel-ssh批量执行远程shell命令</h3><h4 id=\"pssh使用场景\"><a href=\"#pssh使用场景\" class=\"headerlink\" title=\"pssh使用场景\"></a>pssh使用场景</h4><p>假设现在需要对数百台服务器节点进行配置更新或者执行一些简短command，而目前并没有完备的部署工具软件， 那可以选择向pssh这样的并行登录远程终端并执行指定命令的shell工具。<br>以前机器节点少的时候，直接用shell写个for循环来执行命令，也没什么问题。当节点数量多了之后，一个shell命令可能要消耗几秒， 这时才能感受到pssh这种并行方式的好处，省时省力。<br><a id=\"more\"></a></p>\n<h4 id=\"pssh可选配置参数列表\"><a href=\"#pssh可选配置参数列表\" class=\"headerlink\" title=\"pssh可选配置参数列表\"></a>pssh可选配置参数列表</h4><p>除了pssh，当需要传递登录密码时，可以用到sshpass命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">pintai@MG:~/bak$ pssh --help</div><div class=\"line\">Usage: pssh [OPTIONS] command [...]</div><div class=\"line\"></div><div class=\"line\">Options:</div><div class=\"line\">  --version             show program's version number and exit</div><div class=\"line\">  --help                show this help message and exit</div><div class=\"line\">  -h HOST_FILE, --hosts=HOST_FILE</div><div class=\"line\">                        hosts file (each line \"[user@]host[:port]\")</div><div class=\"line\">  -H HOST_STRING, --host=HOST_STRING</div><div class=\"line\">                        additional host entries (\"[user@]host[:port]\")</div><div class=\"line\">  -l USER, --user=USER  username (OPTIONAL)</div><div class=\"line\">  -p PAR, --par=PAR     max number of parallel threads (OPTIONAL)</div><div class=\"line\">  -o OUTDIR, --outdir=OUTDIR</div><div class=\"line\">                        output directory for stdout files (OPTIONAL)</div><div class=\"line\">  -e ERRDIR, --errdir=ERRDIR</div><div class=\"line\">                        output directory for stderr files (OPTIONAL)</div><div class=\"line\">  -t TIMEOUT, --timeout=TIMEOUT</div><div class=\"line\">                        timeout (secs) (0 = no timeout) per host (OPTIONAL)</div><div class=\"line\">  -O OPTION, --option=OPTION</div><div class=\"line\">                        SSH option (OPTIONAL)</div><div class=\"line\">  -v, --verbose         turn on warning and diagnostic messages (OPTIONAL)</div><div class=\"line\">  -A, --askpass         Ask for a password (OPTIONAL)</div><div class=\"line\">  -x ARGS, --extra-args=ARGS</div><div class=\"line\">                        Extra command-line arguments, with processing for</div><div class=\"line\">                        spaces, quotes, and backslashes</div><div class=\"line\">  -X ARG, --extra-arg=ARG</div><div class=\"line\">                        Extra command-line argument</div><div class=\"line\">  -i, --inline          inline aggregated output and error for each server</div><div class=\"line\">  --inline-stdout       inline standard output for each server</div><div class=\"line\">  -I, --send-input      read from standard input and send as input to ssh</div><div class=\"line\">  -P, --print           print output as we get it</div><div class=\"line\"></div><div class=\"line\">Example: pssh -h hosts.txt -l irb2 -o /tmp/foo uptime</div><div class=\"line\"></div><div class=\"line\">pintai@MG:~/bak$ sshpass --help</div><div class=\"line\">sshpass: invalid option -- '-'</div><div class=\"line\">Usage: sshpass [-f|-d|-p|-e] [-hV] command parameters</div><div class=\"line\">   -f filename   Take password to use from file</div><div class=\"line\">   -d number     Use number as file descriptor for getting password</div><div class=\"line\">   -p password   Provide password as argument (security unwise)</div><div class=\"line\">   -e            Password is passed as env-var \"SSHPASS\"</div><div class=\"line\">   With no parameters - password will be taken from stdin</div><div class=\"line\"></div><div class=\"line\">   -h            Show help (this screen)</div><div class=\"line\">   -V            Print version information</div><div class=\"line\">At most one of -f, -d, -p or -e should be used</div></pre></td></tr></table></figure></p>\n<h4 id=\"1-使用sshpass传递登录密码\"><a href=\"#1-使用sshpass传递登录密码\" class=\"headerlink\" title=\"1.使用sshpass传递登录密码\"></a>1.使用sshpass传递登录密码</h4><p>先把需要远程登录的host集中写到一个文件， 比如叫hostlist，写入host列表:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">192.168.1.11:22</div><div class=\"line\">192.168.1.12:22</div><div class=\"line\">192.168.1.13:22</div></pre></td></tr></table></figure></p>\n<p>然后将ssh登录密码写到另一个文件， 比如叫remotepass， 写入密码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yourpassword</div></pre></td></tr></table></figure></p>\n<p>最后执行相关命令， 直接打印每个节点的输出内容：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sshpass -f remotepass pssh -h hostlist -l yourloginname -A -i \"hostname\"</div></pre></td></tr></table></figure></p>\n<p>输出结果如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Warning: do not enter your password if anyone else has superuser</div><div class=\"line\">privileges or access to your account.</div><div class=\"line\">[1] 11:23:21 [SUCCESS] 192.168.1.11:22</div><div class=\"line\">test1.hostname</div><div class=\"line\">[2] 11:23:21 [SUCCESS] 192.168.1.12:22</div><div class=\"line\">test2.hostname</div><div class=\"line\">[3] 11:23:21 [SUCCESS] 192.168.1.13:22</div><div class=\"line\">test3.hostname</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-将结果输出到指定文件\"><a href=\"#2-将结果输出到指定文件\" class=\"headerlink\" title=\"2.将结果输出到指定文件\"></a>2.将结果输出到指定文件</h4><p>如果需要将输出结果收集起来，那么可以通过<em>-o</em>选项来指定结果输出目录，比如：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sshpass -f remotepass pssh -h hostlist -l yourloginname -o outputdir -A \"hostname\"</div></pre></td></tr></table></figure></p>\n<p>执行时终端输出:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Warning: do not enter your password if anyone else has superuser</div><div class=\"line\">privileges or access to your account.</div><div class=\"line\">[1] 11:23:21 [SUCCESS] 192.168.1.11:22</div><div class=\"line\">[2] 11:23:21 [SUCCESS] 192.168.1.12:22</div><div class=\"line\">[3] 11:23:21 [SUCCESS] 192.168.1.13:22</div></pre></td></tr></table></figure></p>\n<p>而当前目录会生成<em>outputdir</em>目录，目录中每个host占一个文件，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">pintai@MG:~/bak$ ls output/</div><div class=\"line\">192.168.1.11:22 192.168.1.12:22 192.168.1.13:22</div><div class=\"line\">pintai@MG:~/bak$ cat output/*</div><div class=\"line\">test1.hostname</div><div class=\"line\">test2.hostname</div><div class=\"line\">test3.hostname</div></pre></td></tr></table></figure></p>\n<h4 id=\"3-执行sudo命令\"><a href=\"#3-执行sudo命令\" class=\"headerlink\" title=\"3.  执行sudo命令\"></a>3.  执行sudo命令</h4><p>有些shell命令可能需要通过sudo权限来执行，一般来说本地可以这么执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo your_sudo_pass | sudo -S your_command</div></pre></td></tr></table></figure></p>\n<p>而在pssh中可以这么做：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sshpass -f remotepass pssh -h hostlist -l yourloginname -o outputdir -A \"echo your_sudo_pass | sudo netstat -antup | grep xxx\"</div></pre></td></tr></table></figure></p>\n<p>执行完毕后，具体输出结果可以在outputdir目录下查找。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"使用parallel-ssh批量执行远程shell命令\"><a href=\"#使用parallel-ssh批量执行远程shell命令\" class=\"headerlink\" title=\"使用parallel-ssh批量执行远程shell命令\"></a>使用parallel-ssh批量执行远程shell命令</h3><h4 id=\"pssh使用场景\"><a href=\"#pssh使用场景\" class=\"headerlink\" title=\"pssh使用场景\"></a>pssh使用场景</h4><p>假设现在需要对数百台服务器节点进行配置更新或者执行一些简短command，而目前并没有完备的部署工具软件， 那可以选择向pssh这样的并行登录远程终端并执行指定命令的shell工具。<br>以前机器节点少的时候，直接用shell写个for循环来执行命令，也没什么问题。当节点数量多了之后，一个shell命令可能要消耗几秒， 这时才能感受到pssh这种并行方式的好处，省时省力。<br>","more":"</p>\n<h4 id=\"pssh可选配置参数列表\"><a href=\"#pssh可选配置参数列表\" class=\"headerlink\" title=\"pssh可选配置参数列表\"></a>pssh可选配置参数列表</h4><p>除了pssh，当需要传递登录密码时，可以用到sshpass命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">pintai@MG:~/bak$ pssh --help</div><div class=\"line\">Usage: pssh [OPTIONS] command [...]</div><div class=\"line\"></div><div class=\"line\">Options:</div><div class=\"line\">  --version             show program's version number and exit</div><div class=\"line\">  --help                show this help message and exit</div><div class=\"line\">  -h HOST_FILE, --hosts=HOST_FILE</div><div class=\"line\">                        hosts file (each line \"[user@]host[:port]\")</div><div class=\"line\">  -H HOST_STRING, --host=HOST_STRING</div><div class=\"line\">                        additional host entries (\"[user@]host[:port]\")</div><div class=\"line\">  -l USER, --user=USER  username (OPTIONAL)</div><div class=\"line\">  -p PAR, --par=PAR     max number of parallel threads (OPTIONAL)</div><div class=\"line\">  -o OUTDIR, --outdir=OUTDIR</div><div class=\"line\">                        output directory for stdout files (OPTIONAL)</div><div class=\"line\">  -e ERRDIR, --errdir=ERRDIR</div><div class=\"line\">                        output directory for stderr files (OPTIONAL)</div><div class=\"line\">  -t TIMEOUT, --timeout=TIMEOUT</div><div class=\"line\">                        timeout (secs) (0 = no timeout) per host (OPTIONAL)</div><div class=\"line\">  -O OPTION, --option=OPTION</div><div class=\"line\">                        SSH option (OPTIONAL)</div><div class=\"line\">  -v, --verbose         turn on warning and diagnostic messages (OPTIONAL)</div><div class=\"line\">  -A, --askpass         Ask for a password (OPTIONAL)</div><div class=\"line\">  -x ARGS, --extra-args=ARGS</div><div class=\"line\">                        Extra command-line arguments, with processing for</div><div class=\"line\">                        spaces, quotes, and backslashes</div><div class=\"line\">  -X ARG, --extra-arg=ARG</div><div class=\"line\">                        Extra command-line argument</div><div class=\"line\">  -i, --inline          inline aggregated output and error for each server</div><div class=\"line\">  --inline-stdout       inline standard output for each server</div><div class=\"line\">  -I, --send-input      read from standard input and send as input to ssh</div><div class=\"line\">  -P, --print           print output as we get it</div><div class=\"line\"></div><div class=\"line\">Example: pssh -h hosts.txt -l irb2 -o /tmp/foo uptime</div><div class=\"line\"></div><div class=\"line\">pintai@MG:~/bak$ sshpass --help</div><div class=\"line\">sshpass: invalid option -- '-'</div><div class=\"line\">Usage: sshpass [-f|-d|-p|-e] [-hV] command parameters</div><div class=\"line\">   -f filename   Take password to use from file</div><div class=\"line\">   -d number     Use number as file descriptor for getting password</div><div class=\"line\">   -p password   Provide password as argument (security unwise)</div><div class=\"line\">   -e            Password is passed as env-var \"SSHPASS\"</div><div class=\"line\">   With no parameters - password will be taken from stdin</div><div class=\"line\"></div><div class=\"line\">   -h            Show help (this screen)</div><div class=\"line\">   -V            Print version information</div><div class=\"line\">At most one of -f, -d, -p or -e should be used</div></pre></td></tr></table></figure></p>\n<h4 id=\"1-使用sshpass传递登录密码\"><a href=\"#1-使用sshpass传递登录密码\" class=\"headerlink\" title=\"1.使用sshpass传递登录密码\"></a>1.使用sshpass传递登录密码</h4><p>先把需要远程登录的host集中写到一个文件， 比如叫hostlist，写入host列表:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">192.168.1.11:22</div><div class=\"line\">192.168.1.12:22</div><div class=\"line\">192.168.1.13:22</div></pre></td></tr></table></figure></p>\n<p>然后将ssh登录密码写到另一个文件， 比如叫remotepass， 写入密码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yourpassword</div></pre></td></tr></table></figure></p>\n<p>最后执行相关命令， 直接打印每个节点的输出内容：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sshpass -f remotepass pssh -h hostlist -l yourloginname -A -i \"hostname\"</div></pre></td></tr></table></figure></p>\n<p>输出结果如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Warning: do not enter your password if anyone else has superuser</div><div class=\"line\">privileges or access to your account.</div><div class=\"line\">[1] 11:23:21 [SUCCESS] 192.168.1.11:22</div><div class=\"line\">test1.hostname</div><div class=\"line\">[2] 11:23:21 [SUCCESS] 192.168.1.12:22</div><div class=\"line\">test2.hostname</div><div class=\"line\">[3] 11:23:21 [SUCCESS] 192.168.1.13:22</div><div class=\"line\">test3.hostname</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-将结果输出到指定文件\"><a href=\"#2-将结果输出到指定文件\" class=\"headerlink\" title=\"2.将结果输出到指定文件\"></a>2.将结果输出到指定文件</h4><p>如果需要将输出结果收集起来，那么可以通过<em>-o</em>选项来指定结果输出目录，比如：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sshpass -f remotepass pssh -h hostlist -l yourloginname -o outputdir -A \"hostname\"</div></pre></td></tr></table></figure></p>\n<p>执行时终端输出:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Warning: do not enter your password if anyone else has superuser</div><div class=\"line\">privileges or access to your account.</div><div class=\"line\">[1] 11:23:21 [SUCCESS] 192.168.1.11:22</div><div class=\"line\">[2] 11:23:21 [SUCCESS] 192.168.1.12:22</div><div class=\"line\">[3] 11:23:21 [SUCCESS] 192.168.1.13:22</div></pre></td></tr></table></figure></p>\n<p>而当前目录会生成<em>outputdir</em>目录，目录中每个host占一个文件，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">pintai@MG:~/bak$ ls output/</div><div class=\"line\">192.168.1.11:22 192.168.1.12:22 192.168.1.13:22</div><div class=\"line\">pintai@MG:~/bak$ cat output/*</div><div class=\"line\">test1.hostname</div><div class=\"line\">test2.hostname</div><div class=\"line\">test3.hostname</div></pre></td></tr></table></figure></p>\n<h4 id=\"3-执行sudo命令\"><a href=\"#3-执行sudo命令\" class=\"headerlink\" title=\"3.  执行sudo命令\"></a>3.  执行sudo命令</h4><p>有些shell命令可能需要通过sudo权限来执行，一般来说本地可以这么执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo your_sudo_pass | sudo -S your_command</div></pre></td></tr></table></figure></p>\n<p>而在pssh中可以这么做：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sshpass -f remotepass pssh -h hostlist -l yourloginname -o outputdir -A \"echo your_sudo_pass | sudo netstat -antup | grep xxx\"</div></pre></td></tr></table></figure></p>\n<p>执行完毕后，具体输出结果可以在outputdir目录下查找。</p>"},{"title":"springboot+gradle下访问mysql用例","date":"2018-06-29T13:05:46.000Z","_content":"\n参考资料： [https://blog.csdn.net/chentao866/article/details/67636520](https://blog.csdn.net/chentao866/article/details/67636520)\n\n## 配置依赖build.gradle\n\n```\ndependencies {\n\tcompile('org.springframework.boot:spring-boot-starter-web')\n\truntime('org.springframework.boot:spring-boot-devtools')\n\tcompile 'org.springframework.boot:spring-boot-starter-data-jpa'\n\truntime(\"mysql:mysql-connector-java\")\n\ttestCompile('org.springframework.boot:spring-boot-starter-test')\n}\n```\n<!--more-->\n\n## 配置mysql连接属性application.properties\n\n假设已经创建好了mysql表test::dept，并且已插入部分测试数据，\n\n```\nserver.port=8004\n\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://127.0.0.1:13306/test?useUnicode=true&useSSL=false\nspring.datasource.username=root\nspring.datasource.password=root\n \nspring.jpa.database=mysql\nspring.jpa.show-sql=true\nspring.jpa.hibernate.ddl-auto=update\n#spring.jpa.hibernate.ddl-auto=create-drop\nspring.jpa.hibernate.naming-strategy=org.hibernate.cfg.ImprovedNamingStrategy\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect\n```\n\n## 部门表实体类Dept.java\n\n```java\npackage com.example.demo;\n\n\nimport javax.persistence.*;\n\nimport org.hibernate.annotations.GenericGenerator;\n \n \n/**\n * 部门表实体类\n */\n@Entity\n@Table(name = \"dept\")\npublic class Dept {\n \n    //部门编号 主键\n    @Id\n    @Column(name = \"id\")\n    @GeneratedValue(generator = \"uuid2\")\n    @GenericGenerator(name = \"uuid2\", strategy = \"uuid2\")\n    private String id;\n \n    //部门编码\n    @Column(name = \"code\")\n    private String code;\n \n    //部门名称\n    @Column(name = \"name\")\n    private String name;\n \n    public String getId() {\n        return id;\n    }\n \n    public void setId(String id) {\n        this.id = id;\n    }\n \n    public String getCode() {\n        return code;\n    }\n \n    public void setCode(String code) {\n        this.code = code;\n    }\n \n    public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n\n## 仓库接口实现类DeptRepository.java\n\n```java\npackage com.example.demo;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\n \n/**\n * 实现Jpa仓库接口类 \n */\npublic interface DeptRepository extends JpaRepository<Dept, String> {\n}\n```\n\n## 控制类DeptController.java\n\n```java\npackage com.example.demo;  \n\nimport java.util.*;  \nimport org.springframework.web.bind.annotation.RequestMapping;  \nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n \n@RestController\npublic class DeptController {\n    //部门Jpa仓库接口\n    @Autowired\n    private DeptRepository deptRepository;\n \n    @RequestMapping(value=\"/deptfind\", method = RequestMethod.GET)\n    public List<Dept> deptfind() {\n        List<Dept> deptList = deptRepository.findAll();\n        for (int i = 0; i < deptList.size(); i++) {\n            System.out.println(deptList.get(i));\n        }\n        return deptList;\n    }\n}\n```\n\n## 测试\n\n具体代码结构如下图所示：\n![](/img/deptstruct.png)\n\n```shell\n$./gradlew bootRun\n\n> Task :bootRun\n// ... 省略\n```\n服务起来后，通过浏览器访问：\n![](/img/depttest.png)\n","source":"_posts/java/springboot-gradle-mysql.md","raw":"---\ntitle: 'springboot+gradle下访问mysql用例'\ndate: 2018-06-29 21:05:46\ntags: java\n---\n\n参考资料： [https://blog.csdn.net/chentao866/article/details/67636520](https://blog.csdn.net/chentao866/article/details/67636520)\n\n## 配置依赖build.gradle\n\n```\ndependencies {\n\tcompile('org.springframework.boot:spring-boot-starter-web')\n\truntime('org.springframework.boot:spring-boot-devtools')\n\tcompile 'org.springframework.boot:spring-boot-starter-data-jpa'\n\truntime(\"mysql:mysql-connector-java\")\n\ttestCompile('org.springframework.boot:spring-boot-starter-test')\n}\n```\n<!--more-->\n\n## 配置mysql连接属性application.properties\n\n假设已经创建好了mysql表test::dept，并且已插入部分测试数据，\n\n```\nserver.port=8004\n\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://127.0.0.1:13306/test?useUnicode=true&useSSL=false\nspring.datasource.username=root\nspring.datasource.password=root\n \nspring.jpa.database=mysql\nspring.jpa.show-sql=true\nspring.jpa.hibernate.ddl-auto=update\n#spring.jpa.hibernate.ddl-auto=create-drop\nspring.jpa.hibernate.naming-strategy=org.hibernate.cfg.ImprovedNamingStrategy\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect\n```\n\n## 部门表实体类Dept.java\n\n```java\npackage com.example.demo;\n\n\nimport javax.persistence.*;\n\nimport org.hibernate.annotations.GenericGenerator;\n \n \n/**\n * 部门表实体类\n */\n@Entity\n@Table(name = \"dept\")\npublic class Dept {\n \n    //部门编号 主键\n    @Id\n    @Column(name = \"id\")\n    @GeneratedValue(generator = \"uuid2\")\n    @GenericGenerator(name = \"uuid2\", strategy = \"uuid2\")\n    private String id;\n \n    //部门编码\n    @Column(name = \"code\")\n    private String code;\n \n    //部门名称\n    @Column(name = \"name\")\n    private String name;\n \n    public String getId() {\n        return id;\n    }\n \n    public void setId(String id) {\n        this.id = id;\n    }\n \n    public String getCode() {\n        return code;\n    }\n \n    public void setCode(String code) {\n        this.code = code;\n    }\n \n    public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n\n## 仓库接口实现类DeptRepository.java\n\n```java\npackage com.example.demo;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\n \n/**\n * 实现Jpa仓库接口类 \n */\npublic interface DeptRepository extends JpaRepository<Dept, String> {\n}\n```\n\n## 控制类DeptController.java\n\n```java\npackage com.example.demo;  \n\nimport java.util.*;  \nimport org.springframework.web.bind.annotation.RequestMapping;  \nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n \n@RestController\npublic class DeptController {\n    //部门Jpa仓库接口\n    @Autowired\n    private DeptRepository deptRepository;\n \n    @RequestMapping(value=\"/deptfind\", method = RequestMethod.GET)\n    public List<Dept> deptfind() {\n        List<Dept> deptList = deptRepository.findAll();\n        for (int i = 0; i < deptList.size(); i++) {\n            System.out.println(deptList.get(i));\n        }\n        return deptList;\n    }\n}\n```\n\n## 测试\n\n具体代码结构如下图所示：\n![](/img/deptstruct.png)\n\n```shell\n$./gradlew bootRun\n\n> Task :bootRun\n// ... 省略\n```\n服务起来后，通过浏览器访问：\n![](/img/depttest.png)\n","slug":"java/springboot-gradle-mysql","published":1,"updated":"2018-06-29T13:17:29.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dwj001h4j4di7ggg7hv","content":"<p>参考资料： <a href=\"https://blog.csdn.net/chentao866/article/details/67636520\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/chentao866/article/details/67636520</a></p>\n<h2 id=\"配置依赖build-gradle\"><a href=\"#配置依赖build-gradle\" class=\"headerlink\" title=\"配置依赖build.gradle\"></a>配置依赖build.gradle</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">\tcompile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)</div><div class=\"line\">\truntime(&apos;org.springframework.boot:spring-boot-devtools&apos;)</div><div class=\"line\">\tcompile &apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;</div><div class=\"line\">\truntime(&quot;mysql:mysql-connector-java&quot;)</div><div class=\"line\">\ttestCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"配置mysql连接属性application-properties\"><a href=\"#配置mysql连接属性application-properties\" class=\"headerlink\" title=\"配置mysql连接属性application.properties\"></a>配置mysql连接属性application.properties</h2><p>假设已经创建好了mysql表test::dept，并且已插入部分测试数据，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">server.port=8004</div><div class=\"line\"></div><div class=\"line\">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</div><div class=\"line\">spring.datasource.url=jdbc:mysql://127.0.0.1:13306/test?useUnicode=true&amp;useSSL=false</div><div class=\"line\">spring.datasource.username=root</div><div class=\"line\">spring.datasource.password=root</div><div class=\"line\"> </div><div class=\"line\">spring.jpa.database=mysql</div><div class=\"line\">spring.jpa.show-sql=true</div><div class=\"line\">spring.jpa.hibernate.ddl-auto=update</div><div class=\"line\">#spring.jpa.hibernate.ddl-auto=create-drop</div><div class=\"line\">spring.jpa.hibernate.naming-strategy=org.hibernate.cfg.ImprovedNamingStrategy</div><div class=\"line\">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect</div></pre></td></tr></table></figure>\n<h2 id=\"部门表实体类Dept-java\"><a href=\"#部门表实体类Dept-java\" class=\"headerlink\" title=\"部门表实体类Dept.java\"></a>部门表实体类Dept.java</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.demo;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> javax.persistence.*;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.annotations.GenericGenerator;</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 部门表实体类</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"meta\">@Entity</span></div><div class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"dept\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dept</span> </span>&#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//部门编号 主键</span></div><div class=\"line\">    <span class=\"meta\">@Id</span></div><div class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</div><div class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(generator = <span class=\"string\">\"uuid2\"</span>)</div><div class=\"line\">    <span class=\"meta\">@GenericGenerator</span>(name = <span class=\"string\">\"uuid2\"</span>, strategy = <span class=\"string\">\"uuid2\"</span>)</div><div class=\"line\">    <span class=\"keyword\">private</span> String id;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//部门编码</span></div><div class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"code\"</span>)</div><div class=\"line\">    <span class=\"keyword\">private</span> String code;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//部门名称</span></div><div class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"name\"</span>)</div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> id;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(String id)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> code;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCode</span><span class=\"params\">(String code)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.code = code;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"仓库接口实现类DeptRepository-java\"><a href=\"#仓库接口实现类DeptRepository-java\" class=\"headerlink\" title=\"仓库接口实现类DeptRepository.java\"></a>仓库接口实现类DeptRepository.java</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.demo;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.jpa.repository.JpaRepository;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 实现Jpa仓库接口类 </div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DeptRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">Dept</span>, <span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"控制类DeptController-java\"><a href=\"#控制类DeptController-java\" class=\"headerlink\" title=\"控制类DeptController.java\"></a>控制类DeptController.java</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.demo;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.*;  </div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;  </div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMethod;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"meta\">@RestController</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeptController</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//部门Jpa仓库接口</span></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> DeptRepository deptRepository;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/deptfind\"</span>, method = RequestMethod.GET)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Dept&gt; <span class=\"title\">deptfind</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        List&lt;Dept&gt; deptList = deptRepository.findAll();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; deptList.size(); i++) &#123;</div><div class=\"line\">            System.out.println(deptList.get(i));</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> deptList;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>具体代码结构如下图所示：<br><img src=\"/img/deptstruct.png\" alt=\"\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">./gradlew bootRun</span></div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">&gt;<span class=\"bash\"> Task :bootRun</span></div><div class=\"line\">// ... 省略</div></pre></td></tr></table></figure>\n<p>服务起来后，通过浏览器访问：<br><img src=\"/img/depttest.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>参考资料： <a href=\"https://blog.csdn.net/chentao866/article/details/67636520\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/chentao866/article/details/67636520</a></p>\n<h2 id=\"配置依赖build-gradle\"><a href=\"#配置依赖build-gradle\" class=\"headerlink\" title=\"配置依赖build.gradle\"></a>配置依赖build.gradle</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">\tcompile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)</div><div class=\"line\">\truntime(&apos;org.springframework.boot:spring-boot-devtools&apos;)</div><div class=\"line\">\tcompile &apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;</div><div class=\"line\">\truntime(&quot;mysql:mysql-connector-java&quot;)</div><div class=\"line\">\ttestCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<h2 id=\"配置mysql连接属性application-properties\"><a href=\"#配置mysql连接属性application-properties\" class=\"headerlink\" title=\"配置mysql连接属性application.properties\"></a>配置mysql连接属性application.properties</h2><p>假设已经创建好了mysql表test::dept，并且已插入部分测试数据，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">server.port=8004</div><div class=\"line\"></div><div class=\"line\">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</div><div class=\"line\">spring.datasource.url=jdbc:mysql://127.0.0.1:13306/test?useUnicode=true&amp;useSSL=false</div><div class=\"line\">spring.datasource.username=root</div><div class=\"line\">spring.datasource.password=root</div><div class=\"line\"> </div><div class=\"line\">spring.jpa.database=mysql</div><div class=\"line\">spring.jpa.show-sql=true</div><div class=\"line\">spring.jpa.hibernate.ddl-auto=update</div><div class=\"line\">#spring.jpa.hibernate.ddl-auto=create-drop</div><div class=\"line\">spring.jpa.hibernate.naming-strategy=org.hibernate.cfg.ImprovedNamingStrategy</div><div class=\"line\">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect</div></pre></td></tr></table></figure>\n<h2 id=\"部门表实体类Dept-java\"><a href=\"#部门表实体类Dept-java\" class=\"headerlink\" title=\"部门表实体类Dept.java\"></a>部门表实体类Dept.java</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.demo;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> javax.persistence.*;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.annotations.GenericGenerator;</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 部门表实体类</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"meta\">@Entity</span></div><div class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"dept\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dept</span> </span>&#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//部门编号 主键</span></div><div class=\"line\">    <span class=\"meta\">@Id</span></div><div class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</div><div class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(generator = <span class=\"string\">\"uuid2\"</span>)</div><div class=\"line\">    <span class=\"meta\">@GenericGenerator</span>(name = <span class=\"string\">\"uuid2\"</span>, strategy = <span class=\"string\">\"uuid2\"</span>)</div><div class=\"line\">    <span class=\"keyword\">private</span> String id;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//部门编码</span></div><div class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"code\"</span>)</div><div class=\"line\">    <span class=\"keyword\">private</span> String code;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//部门名称</span></div><div class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"name\"</span>)</div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> id;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(String id)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> code;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCode</span><span class=\"params\">(String code)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.code = code;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"仓库接口实现类DeptRepository-java\"><a href=\"#仓库接口实现类DeptRepository-java\" class=\"headerlink\" title=\"仓库接口实现类DeptRepository.java\"></a>仓库接口实现类DeptRepository.java</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.demo;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.jpa.repository.JpaRepository;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 实现Jpa仓库接口类 </div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DeptRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">Dept</span>, <span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"控制类DeptController-java\"><a href=\"#控制类DeptController-java\" class=\"headerlink\" title=\"控制类DeptController.java\"></a>控制类DeptController.java</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.demo;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.*;  </div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;  </div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMethod;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"meta\">@RestController</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeptController</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//部门Jpa仓库接口</span></div><div class=\"line\">    <span class=\"meta\">@Autowired</span></div><div class=\"line\">    <span class=\"keyword\">private</span> DeptRepository deptRepository;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/deptfind\"</span>, method = RequestMethod.GET)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Dept&gt; <span class=\"title\">deptfind</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        List&lt;Dept&gt; deptList = deptRepository.findAll();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; deptList.size(); i++) &#123;</div><div class=\"line\">            System.out.println(deptList.get(i));</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> deptList;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>具体代码结构如下图所示：<br><img src=\"/img/deptstruct.png\" alt=\"\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">./gradlew bootRun</span></div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">&gt;<span class=\"bash\"> Task :bootRun</span></div><div class=\"line\">// ... 省略</div></pre></td></tr></table></figure>\n<p>服务起来后，通过浏览器访问：<br><img src=\"/img/depttest.png\" alt=\"\"></p>"},{"title":"[shell]批量对比两个host上的文件","date":"2017-09-28T11:09:37.000Z","_content":"\n假设有一个数据集群, 它的每个节点的目录/data/下面有很多子目录, 子目录内包含很多文件; <br>\n每两个节点的/data/目录下所有文件理论上要保持一致(比如fastdfs的两副本模式)。<br>\n\n现在需要快速的对每两台机器上的/data目录下的文件检测是否全部一致, 那么可以怎么做呢?<br>\n一个思路是利用shell实现, 每次将两台机器上的文件全部扫描并排序到一个文件内, 然后拉取到本地上进行对比。<br>\n\n具体示例代码(同时解决了sudo密码验证的问题)如下:\n\n```bash\n#!/bin/bash\n\n# 每行两个要用于对比文件的ip\nipPairs=(\n192.168.1.59 192.168.1.60\n192.168.1.81 192.168.1.86\n192.168.1.82 192.168.1.87\n)\n# ssh用户/ssh端口/sudo密码\nusername=\"yourname\"\nport=\"yourport\"\nsudoPasswd=\"yourpassword\"\n\n# 检查列表长度是否为偶数\nif [[ ${#ipPairs[@]}%2 -eq 1 ]];\nthen\n    echo \"invalid pair in ipPairs.\"\n    exit\nfi\n\nfor((i=0;i<${#ipPairs[@]};i+=2))\ndo\n    ipOne=${ipPairs[$i]}\n    ipTwo=${ipPairs[$i+1]}\n    echo \"ip1:\" $ipOne \"ip2:\" $ipTwo\n\n/usr/bin/expect <<-EOF\n    set timeout 300\n    spawn ssh -t -p $port -l ${username} $ipOne {sudo find /data/ -type f | sort > /tmp/${ipOne}.log}\n    expect {\n        \"(yes/no)? \" { send \"yes\\n\" }\n        \"password for ${username}: \" { send \"${sudoPasswd}\\n\" }\n    }\n\n    spawn ssh -t -p $port -l ${username} $ipTwo {sudo find /data/ -type f | sort > /tmp/${ipTwo}.log}\n    expect {\n        \"(yes/no)? \" { send \"yes\\n\" }\n        \"password for ${username}: \" { send \"${sudoPasswd}\\n\" }\n    }\ninteract\nexpect eof\nEOF\n\n    scp -P $port ${username}@$ipOne:/tmp/${ipOne}.log ${ipOne}.log\n    if [ `ls -l ${ipOne}.log | awk '{ print $5 }'` -lt  1 ]\n    then\n        echo \"${ipOne}.log is empty.\"\n    fi\n    \n    scp -P $port ${username}@$ipTwo:/tmp/${ipTwo}.log ${ipTwo}.log\n    if [ `ls -l ${ipTwo}.log | awk '{ print $5 }'` -lt  1 ]\n    then\n        echo \"${ipTwo}.log is empty.\"\n    fi\n\n    # 对比sha1\n    sha1sum ${ipOne}.log ${ipTwo}.log\n\n    # 查找差集\n    comm -1 -3 ${ipOne}.log ${ipTwo}.log > ${ipTwo}_${ipOne}.log\ndone\n```\n","source":"_posts/script/shell-compare-files.md","raw":"---\ntitle: '[shell]批量对比两个host上的文件'\ndate: 2017-09-28 19:09:37\ntags: shell\n---\n\n假设有一个数据集群, 它的每个节点的目录/data/下面有很多子目录, 子目录内包含很多文件; <br>\n每两个节点的/data/目录下所有文件理论上要保持一致(比如fastdfs的两副本模式)。<br>\n\n现在需要快速的对每两台机器上的/data目录下的文件检测是否全部一致, 那么可以怎么做呢?<br>\n一个思路是利用shell实现, 每次将两台机器上的文件全部扫描并排序到一个文件内, 然后拉取到本地上进行对比。<br>\n\n具体示例代码(同时解决了sudo密码验证的问题)如下:\n\n```bash\n#!/bin/bash\n\n# 每行两个要用于对比文件的ip\nipPairs=(\n192.168.1.59 192.168.1.60\n192.168.1.81 192.168.1.86\n192.168.1.82 192.168.1.87\n)\n# ssh用户/ssh端口/sudo密码\nusername=\"yourname\"\nport=\"yourport\"\nsudoPasswd=\"yourpassword\"\n\n# 检查列表长度是否为偶数\nif [[ ${#ipPairs[@]}%2 -eq 1 ]];\nthen\n    echo \"invalid pair in ipPairs.\"\n    exit\nfi\n\nfor((i=0;i<${#ipPairs[@]};i+=2))\ndo\n    ipOne=${ipPairs[$i]}\n    ipTwo=${ipPairs[$i+1]}\n    echo \"ip1:\" $ipOne \"ip2:\" $ipTwo\n\n/usr/bin/expect <<-EOF\n    set timeout 300\n    spawn ssh -t -p $port -l ${username} $ipOne {sudo find /data/ -type f | sort > /tmp/${ipOne}.log}\n    expect {\n        \"(yes/no)? \" { send \"yes\\n\" }\n        \"password for ${username}: \" { send \"${sudoPasswd}\\n\" }\n    }\n\n    spawn ssh -t -p $port -l ${username} $ipTwo {sudo find /data/ -type f | sort > /tmp/${ipTwo}.log}\n    expect {\n        \"(yes/no)? \" { send \"yes\\n\" }\n        \"password for ${username}: \" { send \"${sudoPasswd}\\n\" }\n    }\ninteract\nexpect eof\nEOF\n\n    scp -P $port ${username}@$ipOne:/tmp/${ipOne}.log ${ipOne}.log\n    if [ `ls -l ${ipOne}.log | awk '{ print $5 }'` -lt  1 ]\n    then\n        echo \"${ipOne}.log is empty.\"\n    fi\n    \n    scp -P $port ${username}@$ipTwo:/tmp/${ipTwo}.log ${ipTwo}.log\n    if [ `ls -l ${ipTwo}.log | awk '{ print $5 }'` -lt  1 ]\n    then\n        echo \"${ipTwo}.log is empty.\"\n    fi\n\n    # 对比sha1\n    sha1sum ${ipOne}.log ${ipTwo}.log\n\n    # 查找差集\n    comm -1 -3 ${ipOne}.log ${ipTwo}.log > ${ipTwo}_${ipOne}.log\ndone\n```\n","slug":"script/shell-compare-files","published":1,"updated":"2017-09-28T16:03:15.998Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dwk001i4j4dnudlkgti","content":"<p>假设有一个数据集群, 它的每个节点的目录/data/下面有很多子目录, 子目录内包含很多文件; <br><br>每两个节点的/data/目录下所有文件理论上要保持一致(比如fastdfs的两副本模式)。<br></p>\n<p>现在需要快速的对每两台机器上的/data目录下的文件检测是否全部一致, 那么可以怎么做呢?<br><br>一个思路是利用shell实现, 每次将两台机器上的文件全部扫描并排序到一个文件内, 然后拉取到本地上进行对比。<br></p>\n<p>具体示例代码(同时解决了sudo密码验证的问题)如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 每行两个要用于对比文件的ip</span></div><div class=\"line\">ipPairs=(</div><div class=\"line\">192.168.1.59 192.168.1.60</div><div class=\"line\">192.168.1.81 192.168.1.86</div><div class=\"line\">192.168.1.82 192.168.1.87</div><div class=\"line\">)</div><div class=\"line\"><span class=\"comment\"># ssh用户/ssh端口/sudo密码</span></div><div class=\"line\">username=<span class=\"string\">\"yourname\"</span></div><div class=\"line\">port=<span class=\"string\">\"yourport\"</span></div><div class=\"line\">sudoPasswd=<span class=\"string\">\"yourpassword\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 检查列表长度是否为偶数</span></div><div class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;#ipPairs[@]&#125;</span>%2 -eq 1 ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"invalid pair in ipPairs.\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span>((i=0;i&lt;<span class=\"variable\">$&#123;#ipPairs[@]&#125;</span>;i+=2))</div><div class=\"line\"><span class=\"keyword\">do</span></div><div class=\"line\">    ipOne=<span class=\"variable\">$&#123;ipPairs[$i]&#125;</span></div><div class=\"line\">    ipTwo=<span class=\"variable\">$&#123;ipPairs[$i+1]&#125;</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"ip1:\"</span> <span class=\"variable\">$ipOne</span> <span class=\"string\">\"ip2:\"</span> <span class=\"variable\">$ipTwo</span></div><div class=\"line\"></div><div class=\"line\">/usr/bin/expect &lt;&lt;-EOF</div><div class=\"line\">    <span class=\"built_in\">set</span> timeout 300</div><div class=\"line\">    spawn ssh -t -p <span class=\"variable\">$port</span> -l <span class=\"variable\">$&#123;username&#125;</span> <span class=\"variable\">$ipOne</span> &#123;sudo find /data/ -<span class=\"built_in\">type</span> f | sort &gt; /tmp/<span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span>&#125;</div><div class=\"line\">    expect &#123;</div><div class=\"line\">        <span class=\"string\">\"(yes/no)? \"</span> &#123; send <span class=\"string\">\"yes\\n\"</span> &#125;</div><div class=\"line\">        <span class=\"string\">\"password for <span class=\"variable\">$&#123;username&#125;</span>: \"</span> &#123; send <span class=\"string\">\"<span class=\"variable\">$&#123;sudoPasswd&#125;</span>\\n\"</span> &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    spawn ssh -t -p <span class=\"variable\">$port</span> -l <span class=\"variable\">$&#123;username&#125;</span> <span class=\"variable\">$ipTwo</span> &#123;sudo find /data/ -<span class=\"built_in\">type</span> f | sort &gt; /tmp/<span class=\"variable\">$&#123;ipTwo&#125;</span>.<span class=\"built_in\">log</span>&#125;</div><div class=\"line\">    expect &#123;</div><div class=\"line\">        <span class=\"string\">\"(yes/no)? \"</span> &#123; send <span class=\"string\">\"yes\\n\"</span> &#125;</div><div class=\"line\">        <span class=\"string\">\"password for <span class=\"variable\">$&#123;username&#125;</span>: \"</span> &#123; send <span class=\"string\">\"<span class=\"variable\">$&#123;sudoPasswd&#125;</span>\\n\"</span> &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">interact</div><div class=\"line\">expect eof</div><div class=\"line\">EOF</div><div class=\"line\"></div><div class=\"line\">    scp -P <span class=\"variable\">$port</span> <span class=\"variable\">$&#123;username&#125;</span>@<span class=\"variable\">$ipOne</span>:/tmp/<span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span> <span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span></div><div class=\"line\">    <span class=\"keyword\">if</span> [ `ls -l <span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span> | awk <span class=\"string\">'&#123; print $5 &#125;'</span>` -lt  1 ]</div><div class=\"line\">    <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;ipOne&#125;</span>.log is empty.\"</span></div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\">    </div><div class=\"line\">    scp -P <span class=\"variable\">$port</span> <span class=\"variable\">$&#123;username&#125;</span>@<span class=\"variable\">$ipTwo</span>:/tmp/<span class=\"variable\">$&#123;ipTwo&#125;</span>.<span class=\"built_in\">log</span> <span class=\"variable\">$&#123;ipTwo&#125;</span>.<span class=\"built_in\">log</span></div><div class=\"line\">    <span class=\"keyword\">if</span> [ `ls -l <span class=\"variable\">$&#123;ipTwo&#125;</span>.<span class=\"built_in\">log</span> | awk <span class=\"string\">'&#123; print $5 &#125;'</span>` -lt  1 ]</div><div class=\"line\">    <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;ipTwo&#125;</span>.log is empty.\"</span></div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># 对比sha1</span></div><div class=\"line\">    sha1sum <span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span> <span class=\"variable\">$&#123;ipTwo&#125;</span>.<span class=\"built_in\">log</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># 查找差集</span></div><div class=\"line\">    comm -1 -3 <span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span> <span class=\"variable\">$&#123;ipTwo&#125;</span>.<span class=\"built_in\">log</span> &gt; <span class=\"variable\">$&#123;ipTwo&#125;</span>_<span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span></div><div class=\"line\"><span class=\"keyword\">done</span></div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>假设有一个数据集群, 它的每个节点的目录/data/下面有很多子目录, 子目录内包含很多文件; <br><br>每两个节点的/data/目录下所有文件理论上要保持一致(比如fastdfs的两副本模式)。<br></p>\n<p>现在需要快速的对每两台机器上的/data目录下的文件检测是否全部一致, 那么可以怎么做呢?<br><br>一个思路是利用shell实现, 每次将两台机器上的文件全部扫描并排序到一个文件内, 然后拉取到本地上进行对比。<br></p>\n<p>具体示例代码(同时解决了sudo密码验证的问题)如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 每行两个要用于对比文件的ip</span></div><div class=\"line\">ipPairs=(</div><div class=\"line\">192.168.1.59 192.168.1.60</div><div class=\"line\">192.168.1.81 192.168.1.86</div><div class=\"line\">192.168.1.82 192.168.1.87</div><div class=\"line\">)</div><div class=\"line\"><span class=\"comment\"># ssh用户/ssh端口/sudo密码</span></div><div class=\"line\">username=<span class=\"string\">\"yourname\"</span></div><div class=\"line\">port=<span class=\"string\">\"yourport\"</span></div><div class=\"line\">sudoPasswd=<span class=\"string\">\"yourpassword\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 检查列表长度是否为偶数</span></div><div class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;#ipPairs[@]&#125;</span>%2 -eq 1 ]];</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"invalid pair in ipPairs.\"</span></div><div class=\"line\">    <span class=\"built_in\">exit</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span>((i=0;i&lt;<span class=\"variable\">$&#123;#ipPairs[@]&#125;</span>;i+=2))</div><div class=\"line\"><span class=\"keyword\">do</span></div><div class=\"line\">    ipOne=<span class=\"variable\">$&#123;ipPairs[$i]&#125;</span></div><div class=\"line\">    ipTwo=<span class=\"variable\">$&#123;ipPairs[$i+1]&#125;</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"ip1:\"</span> <span class=\"variable\">$ipOne</span> <span class=\"string\">\"ip2:\"</span> <span class=\"variable\">$ipTwo</span></div><div class=\"line\"></div><div class=\"line\">/usr/bin/expect &lt;&lt;-EOF</div><div class=\"line\">    <span class=\"built_in\">set</span> timeout 300</div><div class=\"line\">    spawn ssh -t -p <span class=\"variable\">$port</span> -l <span class=\"variable\">$&#123;username&#125;</span> <span class=\"variable\">$ipOne</span> &#123;sudo find /data/ -<span class=\"built_in\">type</span> f | sort &gt; /tmp/<span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span>&#125;</div><div class=\"line\">    expect &#123;</div><div class=\"line\">        <span class=\"string\">\"(yes/no)? \"</span> &#123; send <span class=\"string\">\"yes\\n\"</span> &#125;</div><div class=\"line\">        <span class=\"string\">\"password for <span class=\"variable\">$&#123;username&#125;</span>: \"</span> &#123; send <span class=\"string\">\"<span class=\"variable\">$&#123;sudoPasswd&#125;</span>\\n\"</span> &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    spawn ssh -t -p <span class=\"variable\">$port</span> -l <span class=\"variable\">$&#123;username&#125;</span> <span class=\"variable\">$ipTwo</span> &#123;sudo find /data/ -<span class=\"built_in\">type</span> f | sort &gt; /tmp/<span class=\"variable\">$&#123;ipTwo&#125;</span>.<span class=\"built_in\">log</span>&#125;</div><div class=\"line\">    expect &#123;</div><div class=\"line\">        <span class=\"string\">\"(yes/no)? \"</span> &#123; send <span class=\"string\">\"yes\\n\"</span> &#125;</div><div class=\"line\">        <span class=\"string\">\"password for <span class=\"variable\">$&#123;username&#125;</span>: \"</span> &#123; send <span class=\"string\">\"<span class=\"variable\">$&#123;sudoPasswd&#125;</span>\\n\"</span> &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">interact</div><div class=\"line\">expect eof</div><div class=\"line\">EOF</div><div class=\"line\"></div><div class=\"line\">    scp -P <span class=\"variable\">$port</span> <span class=\"variable\">$&#123;username&#125;</span>@<span class=\"variable\">$ipOne</span>:/tmp/<span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span> <span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span></div><div class=\"line\">    <span class=\"keyword\">if</span> [ `ls -l <span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span> | awk <span class=\"string\">'&#123; print $5 &#125;'</span>` -lt  1 ]</div><div class=\"line\">    <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;ipOne&#125;</span>.log is empty.\"</span></div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\">    </div><div class=\"line\">    scp -P <span class=\"variable\">$port</span> <span class=\"variable\">$&#123;username&#125;</span>@<span class=\"variable\">$ipTwo</span>:/tmp/<span class=\"variable\">$&#123;ipTwo&#125;</span>.<span class=\"built_in\">log</span> <span class=\"variable\">$&#123;ipTwo&#125;</span>.<span class=\"built_in\">log</span></div><div class=\"line\">    <span class=\"keyword\">if</span> [ `ls -l <span class=\"variable\">$&#123;ipTwo&#125;</span>.<span class=\"built_in\">log</span> | awk <span class=\"string\">'&#123; print $5 &#125;'</span>` -lt  1 ]</div><div class=\"line\">    <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;ipTwo&#125;</span>.log is empty.\"</span></div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># 对比sha1</span></div><div class=\"line\">    sha1sum <span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span> <span class=\"variable\">$&#123;ipTwo&#125;</span>.<span class=\"built_in\">log</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># 查找差集</span></div><div class=\"line\">    comm -1 -3 <span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span> <span class=\"variable\">$&#123;ipTwo&#125;</span>.<span class=\"built_in\">log</span> &gt; <span class=\"variable\">$&#123;ipTwo&#125;</span>_<span class=\"variable\">$&#123;ipOne&#125;</span>.<span class=\"built_in\">log</span></div><div class=\"line\"><span class=\"keyword\">done</span></div></pre></td></tr></table></figure>\n"},{"title":"[shell]curl结果获取http header的问题","date":"2017-10-24T04:17:05.000Z","_content":"\n在通过curl请求http获取response header时， 发现字符串拼接一个问题。\n比如以下程序:\n```shell\nhadoop@1:~$ ct=$(curl -s -I http://www.baidu.com | grep Content-Type | awk '{print $2}')\nhadoop@1:~$ echo $ct\ntext/html\nhadoop@1:~$ echo $ct\"_postfix\"\n_postfixl\n```\n最后一行输出竟然是: `_postfixl`, 而不是期待的`text/html_postfix`\n细看结果应该是`_postfix` 直接覆盖了`text/html` 前面的内容。\nhttp header是以`\\r\\n` 作为行分割符，与echo机制有什么冲突?\n原因未解， 不过找到这样一种替代方法(如test.sh):\n<!--more-->\n\n```bash\nshopt -s extglob # 识别正则, 用于后面去掉空格\n\nfunction grepCT()\n{\n    while IFS=':' read key value; do\n        # 去掉\"value\"内的空格\n        value=${value##+([[:space:]])}; value=${value%%+([[:space:]])}\n        case \"$key\" in\n            Server) SERVER=\"$value\"\n                    ;;\n            Content-Type) CT=\"$value\"\n                    ;;\n            HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\"\n                    ;;\n         esac\n    done < <(curl -sI $1)\n    echo $CT\n}\nct=$(grepCT http://www.baidu.com)\necho $ct\"_postfix\"\n```\n执行shell文件:\n```shell\nhadoop@1:~$ bash test.sh\ntext/html_postfix\n```\n","source":"_posts/script/shell-curl-httpheader.md","raw":"---\ntitle: '[shell]curl结果获取http header的问题'\ndate: 2017-10-24 12:17:05\ntags: shell\n---\n\n在通过curl请求http获取response header时， 发现字符串拼接一个问题。\n比如以下程序:\n```shell\nhadoop@1:~$ ct=$(curl -s -I http://www.baidu.com | grep Content-Type | awk '{print $2}')\nhadoop@1:~$ echo $ct\ntext/html\nhadoop@1:~$ echo $ct\"_postfix\"\n_postfixl\n```\n最后一行输出竟然是: `_postfixl`, 而不是期待的`text/html_postfix`\n细看结果应该是`_postfix` 直接覆盖了`text/html` 前面的内容。\nhttp header是以`\\r\\n` 作为行分割符，与echo机制有什么冲突?\n原因未解， 不过找到这样一种替代方法(如test.sh):\n<!--more-->\n\n```bash\nshopt -s extglob # 识别正则, 用于后面去掉空格\n\nfunction grepCT()\n{\n    while IFS=':' read key value; do\n        # 去掉\"value\"内的空格\n        value=${value##+([[:space:]])}; value=${value%%+([[:space:]])}\n        case \"$key\" in\n            Server) SERVER=\"$value\"\n                    ;;\n            Content-Type) CT=\"$value\"\n                    ;;\n            HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\"\n                    ;;\n         esac\n    done < <(curl -sI $1)\n    echo $CT\n}\nct=$(grepCT http://www.baidu.com)\necho $ct\"_postfix\"\n```\n执行shell文件:\n```shell\nhadoop@1:~$ bash test.sh\ntext/html_postfix\n```\n","slug":"script/shell-curl-httpheader","published":1,"updated":"2017-10-24T04:19:08.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dwl001k4j4dt52thr9j","content":"<p>在通过curl请求http获取response header时， 发现字符串拼接一个问题。<br>比如以下程序:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:~$ ct=$(curl -s -I http://www.baidu.com | grep Content-Type | awk '&#123;print $2&#125;')</div><div class=\"line\">hadoop@1:~$ echo $ct</div><div class=\"line\">text/html</div><div class=\"line\">hadoop@1:~$ echo $ct\"_postfix\"</div><div class=\"line\">_postfixl</div></pre></td></tr></table></figure></p>\n<p>最后一行输出竟然是: <code>_postfixl</code>, 而不是期待的<code>text/html_postfix</code><br>细看结果应该是<code>_postfix</code> 直接覆盖了<code>text/html</code> 前面的内容。<br>http header是以<code>\\r\\n</code> 作为行分割符，与echo机制有什么冲突?<br>原因未解， 不过找到这样一种替代方法(如test.sh):<br><a id=\"more\"></a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">shopt</span> -s extglob <span class=\"comment\"># 识别正则, 用于后面去掉空格</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">grepCT</span></span>()</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> IFS=<span class=\"string\">':'</span> <span class=\"built_in\">read</span> key value; <span class=\"keyword\">do</span></div><div class=\"line\">        <span class=\"comment\"># 去掉\"value\"内的空格</span></div><div class=\"line\">        value=<span class=\"variable\">$&#123;value##+([[:space:]])&#125;</span>; value=<span class=\"variable\">$&#123;value%%+([[:space:]])&#125;</span></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"<span class=\"variable\">$key</span>\"</span> <span class=\"keyword\">in</span></div><div class=\"line\">            Server) SERVER=<span class=\"string\">\"<span class=\"variable\">$value</span>\"</span></div><div class=\"line\">                    ;;</div><div class=\"line\">            Content-Type) CT=<span class=\"string\">\"<span class=\"variable\">$value</span>\"</span></div><div class=\"line\">                    ;;</div><div class=\"line\">            HTTP*) <span class=\"built_in\">read</span> PROTO STATUS MSG &lt;&lt;&lt; <span class=\"string\">\"<span class=\"variable\">$key</span>&#123;<span class=\"variable\">$value</span>:+:<span class=\"variable\">$value</span>&#125;\"</span></div><div class=\"line\">                    ;;</div><div class=\"line\">         <span class=\"keyword\">esac</span></div><div class=\"line\">    <span class=\"keyword\">done</span> &lt; &lt;(curl -sI <span class=\"variable\">$1</span>)</div><div class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$CT</span></div><div class=\"line\">&#125;</div><div class=\"line\">ct=$(grepCT http://www.baidu.com)</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$ct</span><span class=\"string\">\"_postfix\"</span></div></pre></td></tr></table></figure>\n<p>执行shell文件:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:~$ bash test.sh</div><div class=\"line\">text/html_postfix</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>在通过curl请求http获取response header时， 发现字符串拼接一个问题。<br>比如以下程序:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:~$ ct=$(curl -s -I http://www.baidu.com | grep Content-Type | awk '&#123;print $2&#125;')</div><div class=\"line\">hadoop@1:~$ echo $ct</div><div class=\"line\">text/html</div><div class=\"line\">hadoop@1:~$ echo $ct\"_postfix\"</div><div class=\"line\">_postfixl</div></pre></td></tr></table></figure></p>\n<p>最后一行输出竟然是: <code>_postfixl</code>, 而不是期待的<code>text/html_postfix</code><br>细看结果应该是<code>_postfix</code> 直接覆盖了<code>text/html</code> 前面的内容。<br>http header是以<code>\\r\\n</code> 作为行分割符，与echo机制有什么冲突?<br>原因未解， 不过找到这样一种替代方法(如test.sh):<br>","more":"</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">shopt</span> -s extglob <span class=\"comment\"># 识别正则, 用于后面去掉空格</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">grepCT</span></span>()</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> IFS=<span class=\"string\">':'</span> <span class=\"built_in\">read</span> key value; <span class=\"keyword\">do</span></div><div class=\"line\">        <span class=\"comment\"># 去掉\"value\"内的空格</span></div><div class=\"line\">        value=<span class=\"variable\">$&#123;value##+([[:space:]])&#125;</span>; value=<span class=\"variable\">$&#123;value%%+([[:space:]])&#125;</span></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"<span class=\"variable\">$key</span>\"</span> <span class=\"keyword\">in</span></div><div class=\"line\">            Server) SERVER=<span class=\"string\">\"<span class=\"variable\">$value</span>\"</span></div><div class=\"line\">                    ;;</div><div class=\"line\">            Content-Type) CT=<span class=\"string\">\"<span class=\"variable\">$value</span>\"</span></div><div class=\"line\">                    ;;</div><div class=\"line\">            HTTP*) <span class=\"built_in\">read</span> PROTO STATUS MSG &lt;&lt;&lt; <span class=\"string\">\"<span class=\"variable\">$key</span>&#123;<span class=\"variable\">$value</span>:+:<span class=\"variable\">$value</span>&#125;\"</span></div><div class=\"line\">                    ;;</div><div class=\"line\">         <span class=\"keyword\">esac</span></div><div class=\"line\">    <span class=\"keyword\">done</span> &lt; &lt;(curl -sI <span class=\"variable\">$1</span>)</div><div class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$CT</span></div><div class=\"line\">&#125;</div><div class=\"line\">ct=$(grepCT http://www.baidu.com)</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$ct</span><span class=\"string\">\"_postfix\"</span></div></pre></td></tr></table></figure>\n<p>执行shell文件:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hadoop@1:~$ bash test.sh</div><div class=\"line\">text/html_postfix</div></pre></td></tr></table></figure></p>"},{"title":"shell curl 与 python requests","date":"2018-04-19T05:48:45.000Z","_content":"\n### shell curl 与 python requests\n\n偶然发现了curl和requests库的一个区别。场景是这样的--\n\n这样使用curl去发起post请求：\n```\ncurl -v -X POST http://api.xx.com/api/yy.php --data 'params={\"sign\":\"xxxx\",\"data\":[{\"uid\":110,\"remark\":\"just4test\"}]}'\n```\n\n后端接口服务能正常解析params参数并响应结果。但是当我改用python去请求时：\n\n```python\nimport json\nimport requests\n\ndata = {\"sign\":\"xxxx\",\"data\":[{\"uid\":110,\"remark\":\"just4test\"}]}\nreqbody = ('params=%s'%json.dumps(data))\nres = requests.post(\n    'http://api.xx.com/api/yy.php',\n    data=reqbody)\n```\n接口无法解析params并返回错误。\n<!--more-->\n后来认真对比了一下headers和body，发现有可能是header设置不同的原因。\n仔细查看，curl中的header有一行是：\n```\nContent-Type: application/x-www-form-urlencoded\n```\n但在python requests中并没有对应的设置，因此加上了这一个header，其后请求能正常返回。\n\n```\nimport json\nimport requests\n\nheaders = {'Content-Type': 'application/x-www-form-urlencoded'}\ndata = {\"sign\":\"xxxx\",\"data\":[{\"uid\":110,\"remark\":\"just4test\"}]}\nreqbody = ('params=%s'%json.dumps(data))\nres = requests.post(\n    'http://api.xx.com/api/yy.php',\n    data=reqbody，\n    headers=headers)\n```\n","source":"_posts/python/curl-vs-python-requests.md","raw":"---\ntitle: 'shell curl 与 python requests'\ndate: 2018-04-19 13:48:45\ntags: python\n---\n\n### shell curl 与 python requests\n\n偶然发现了curl和requests库的一个区别。场景是这样的--\n\n这样使用curl去发起post请求：\n```\ncurl -v -X POST http://api.xx.com/api/yy.php --data 'params={\"sign\":\"xxxx\",\"data\":[{\"uid\":110,\"remark\":\"just4test\"}]}'\n```\n\n后端接口服务能正常解析params参数并响应结果。但是当我改用python去请求时：\n\n```python\nimport json\nimport requests\n\ndata = {\"sign\":\"xxxx\",\"data\":[{\"uid\":110,\"remark\":\"just4test\"}]}\nreqbody = ('params=%s'%json.dumps(data))\nres = requests.post(\n    'http://api.xx.com/api/yy.php',\n    data=reqbody)\n```\n接口无法解析params并返回错误。\n<!--more-->\n后来认真对比了一下headers和body，发现有可能是header设置不同的原因。\n仔细查看，curl中的header有一行是：\n```\nContent-Type: application/x-www-form-urlencoded\n```\n但在python requests中并没有对应的设置，因此加上了这一个header，其后请求能正常返回。\n\n```\nimport json\nimport requests\n\nheaders = {'Content-Type': 'application/x-www-form-urlencoded'}\ndata = {\"sign\":\"xxxx\",\"data\":[{\"uid\":110,\"remark\":\"just4test\"}]}\nreqbody = ('params=%s'%json.dumps(data))\nres = requests.post(\n    'http://api.xx.com/api/yy.php',\n    data=reqbody，\n    headers=headers)\n```\n","slug":"python/curl-vs-python-requests","published":1,"updated":"2018-04-19T05:53:11.403Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dx3002k4j4dcy0jqmpl","content":"<h3 id=\"shell-curl-与-python-requests\"><a href=\"#shell-curl-与-python-requests\" class=\"headerlink\" title=\"shell curl 与 python requests\"></a>shell curl 与 python requests</h3><p>偶然发现了curl和requests库的一个区别。场景是这样的–</p>\n<p>这样使用curl去发起post请求：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -v -X POST http://api.xx.com/api/yy.php --data &apos;params=&#123;&quot;sign&quot;:&quot;xxxx&quot;,&quot;data&quot;:[&#123;&quot;uid&quot;:110,&quot;remark&quot;:&quot;just4test&quot;&#125;]&#125;&apos;</div></pre></td></tr></table></figure></p>\n<p>后端接口服务能正常解析params参数并响应结果。但是当我改用python去请求时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> json</div><div class=\"line\"><span class=\"keyword\">import</span> requests</div><div class=\"line\"></div><div class=\"line\">data = &#123;<span class=\"string\">\"sign\"</span>:<span class=\"string\">\"xxxx\"</span>,<span class=\"string\">\"data\"</span>:[&#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">110</span>,<span class=\"string\">\"remark\"</span>:<span class=\"string\">\"just4test\"</span>&#125;]&#125;</div><div class=\"line\">reqbody = (<span class=\"string\">'params=%s'</span>%json.dumps(data))</div><div class=\"line\">res = requests.post(</div><div class=\"line\">    <span class=\"string\">'http://api.xx.com/api/yy.php'</span>,</div><div class=\"line\">    data=reqbody)</div></pre></td></tr></table></figure>\n<p>接口无法解析params并返回错误。<br><a id=\"more\"></a><br>后来认真对比了一下headers和body，发现有可能是header设置不同的原因。<br>仔细查看，curl中的header有一行是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Content-Type: application/x-www-form-urlencoded</div></pre></td></tr></table></figure></p>\n<p>但在python requests中并没有对应的设置，因此加上了这一个header，其后请求能正常返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">import json</div><div class=\"line\">import requests</div><div class=\"line\"></div><div class=\"line\">headers = &#123;&apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;&#125;</div><div class=\"line\">data = &#123;&quot;sign&quot;:&quot;xxxx&quot;,&quot;data&quot;:[&#123;&quot;uid&quot;:110,&quot;remark&quot;:&quot;just4test&quot;&#125;]&#125;</div><div class=\"line\">reqbody = (&apos;params=%s&apos;%json.dumps(data))</div><div class=\"line\">res = requests.post(</div><div class=\"line\">    &apos;http://api.xx.com/api/yy.php&apos;,</div><div class=\"line\">    data=reqbody，</div><div class=\"line\">    headers=headers)</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"shell-curl-与-python-requests\"><a href=\"#shell-curl-与-python-requests\" class=\"headerlink\" title=\"shell curl 与 python requests\"></a>shell curl 与 python requests</h3><p>偶然发现了curl和requests库的一个区别。场景是这样的–</p>\n<p>这样使用curl去发起post请求：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -v -X POST http://api.xx.com/api/yy.php --data &apos;params=&#123;&quot;sign&quot;:&quot;xxxx&quot;,&quot;data&quot;:[&#123;&quot;uid&quot;:110,&quot;remark&quot;:&quot;just4test&quot;&#125;]&#125;&apos;</div></pre></td></tr></table></figure></p>\n<p>后端接口服务能正常解析params参数并响应结果。但是当我改用python去请求时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> json</div><div class=\"line\"><span class=\"keyword\">import</span> requests</div><div class=\"line\"></div><div class=\"line\">data = &#123;<span class=\"string\">\"sign\"</span>:<span class=\"string\">\"xxxx\"</span>,<span class=\"string\">\"data\"</span>:[&#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">110</span>,<span class=\"string\">\"remark\"</span>:<span class=\"string\">\"just4test\"</span>&#125;]&#125;</div><div class=\"line\">reqbody = (<span class=\"string\">'params=%s'</span>%json.dumps(data))</div><div class=\"line\">res = requests.post(</div><div class=\"line\">    <span class=\"string\">'http://api.xx.com/api/yy.php'</span>,</div><div class=\"line\">    data=reqbody)</div></pre></td></tr></table></figure>\n<p>接口无法解析params并返回错误。<br>","more":"<br>后来认真对比了一下headers和body，发现有可能是header设置不同的原因。<br>仔细查看，curl中的header有一行是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Content-Type: application/x-www-form-urlencoded</div></pre></td></tr></table></figure></p>\n<p>但在python requests中并没有对应的设置，因此加上了这一个header，其后请求能正常返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">import json</div><div class=\"line\">import requests</div><div class=\"line\"></div><div class=\"line\">headers = &#123;&apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;&#125;</div><div class=\"line\">data = &#123;&quot;sign&quot;:&quot;xxxx&quot;,&quot;data&quot;:[&#123;&quot;uid&quot;:110,&quot;remark&quot;:&quot;just4test&quot;&#125;]&#125;</div><div class=\"line\">reqbody = (&apos;params=%s&apos;%json.dumps(data))</div><div class=\"line\">res = requests.post(</div><div class=\"line\">    &apos;http://api.xx.com/api/yy.php&apos;,</div><div class=\"line\">    data=reqbody，</div><div class=\"line\">    headers=headers)</div></pre></td></tr></table></figure>"},{"title":"[python]map function","date":"2016-04-05T15:19:29.000Z","_content":"\n### 1. 内建方法map\n内建map方法可以通过一个序列的方式来实现函数之间的映射, 并且串行执行。如:\n```python\nimport time\nfrom datetime import datetime\n\ndef add(x, y):\n    print datetime.now(), \"enter add func...\"\n    time.sleep(2)\n    print datetime.now(), \"leave add func...\"\n    return x+y\n\nmap(add, [1,2,3], [4,5,6])\n```\n运行效果:\n```bash\n2016-04-05 15:01:49.382314 enter add func...\n2016-04-05 15:01:51.383387 leave add func...\n2016-04-05 15:01:51.383471 enter add func...\n2016-04-05 15:01:53.385584 leave add func...\n2016-04-05 15:01:53.385676 enter add func...\n2016-04-05 15:01:55.387388 leave add func...\n[5, 7, 9]\n```\n由上可见, 调用map, 相当于顺序调用了add(1,4), add(2,5)， add(3,6)方法; 一行代码实现了方法的迭代调用, 简单快捷。<br>那如果再优化一下，实现并行调用add方法， 应该怎么做呢？在python里也好实现, 利用multiprocessing模块就可以。\n\n<!--more-->\n### 2. multiprocessing模块与map方法\n```python\nimport time\nfrom datetime import datetime\nfrom multiprocessing.dummy import Pool as ThreadPool\nfrom functools import partial\n\n\ndef add(x, y):\n    print datetime.now(), \"enter add func...\"\n    time.sleep(2)\n    print datetime.now(), \"leave add func...\"\n    return x+y\n\n\ndef add_wrap(args):\n    return add(*args)\n\n\nif __name__ == \"__main__\":\n    pool = ThreadPool(4) # 池的大小为4\n    print pool.map(add_wrap, [(1,2),(3,4),(5,6)])\n    #close the pool and wait for the work to finish\n    pool.close()\n    pool.join()\n```\n运行效果:\n```bash\n2016-04-05 15:10:23.690059 enter add func...\n2016-04-05 15:10:23.690406 enter add func...\n2016-04-05 15:10:23.690906 enter add func...\n2016-04-05 15:10:25.693250 leave add func...\n2016-04-05 15:10:25.693409 leave add func...\n2016-04-05 15:10:25.693458 leave add func...\n[3, 7, 11]\n```\n由上可以见， 我们已经实现了并行执行add方法\n\n### 3. 关于multiprocessing中pool的大小与性能\n```python\nfrom multiprocessing import Pool\nfrom multiprocessing.dummy import Pool as ThreadPool\n```\n以上Pool和ThreadPool模块, 一个基于进程工作, 一个基于线程工作。\n<br>一般来说, 使用进程池(multiprocessing pool)来执行CPU密集型的任务, 这样可以利用到多核的好处， 理论上(池越大)核越多速度越快; <br>使用线程池(threading)来处理IO型任务, 则有个最佳线程池大小, 要根据实际情况来调节这个池的size(线程过多时, 切换线程的开销将严重影响性能)。\n","source":"_posts/python/python-map-function.md","raw":"---\ntitle: '[python]map function'\ndate: 2016-04-05 23:19:29\ntags: python\n---\n\n### 1. 内建方法map\n内建map方法可以通过一个序列的方式来实现函数之间的映射, 并且串行执行。如:\n```python\nimport time\nfrom datetime import datetime\n\ndef add(x, y):\n    print datetime.now(), \"enter add func...\"\n    time.sleep(2)\n    print datetime.now(), \"leave add func...\"\n    return x+y\n\nmap(add, [1,2,3], [4,5,6])\n```\n运行效果:\n```bash\n2016-04-05 15:01:49.382314 enter add func...\n2016-04-05 15:01:51.383387 leave add func...\n2016-04-05 15:01:51.383471 enter add func...\n2016-04-05 15:01:53.385584 leave add func...\n2016-04-05 15:01:53.385676 enter add func...\n2016-04-05 15:01:55.387388 leave add func...\n[5, 7, 9]\n```\n由上可见, 调用map, 相当于顺序调用了add(1,4), add(2,5)， add(3,6)方法; 一行代码实现了方法的迭代调用, 简单快捷。<br>那如果再优化一下，实现并行调用add方法， 应该怎么做呢？在python里也好实现, 利用multiprocessing模块就可以。\n\n<!--more-->\n### 2. multiprocessing模块与map方法\n```python\nimport time\nfrom datetime import datetime\nfrom multiprocessing.dummy import Pool as ThreadPool\nfrom functools import partial\n\n\ndef add(x, y):\n    print datetime.now(), \"enter add func...\"\n    time.sleep(2)\n    print datetime.now(), \"leave add func...\"\n    return x+y\n\n\ndef add_wrap(args):\n    return add(*args)\n\n\nif __name__ == \"__main__\":\n    pool = ThreadPool(4) # 池的大小为4\n    print pool.map(add_wrap, [(1,2),(3,4),(5,6)])\n    #close the pool and wait for the work to finish\n    pool.close()\n    pool.join()\n```\n运行效果:\n```bash\n2016-04-05 15:10:23.690059 enter add func...\n2016-04-05 15:10:23.690406 enter add func...\n2016-04-05 15:10:23.690906 enter add func...\n2016-04-05 15:10:25.693250 leave add func...\n2016-04-05 15:10:25.693409 leave add func...\n2016-04-05 15:10:25.693458 leave add func...\n[3, 7, 11]\n```\n由上可以见， 我们已经实现了并行执行add方法\n\n### 3. 关于multiprocessing中pool的大小与性能\n```python\nfrom multiprocessing import Pool\nfrom multiprocessing.dummy import Pool as ThreadPool\n```\n以上Pool和ThreadPool模块, 一个基于进程工作, 一个基于线程工作。\n<br>一般来说, 使用进程池(multiprocessing pool)来执行CPU密集型的任务, 这样可以利用到多核的好处， 理论上(池越大)核越多速度越快; <br>使用线程池(threading)来处理IO型任务, 则有个最佳线程池大小, 要根据实际情况来调节这个池的size(线程过多时, 切换线程的开销将严重影响性能)。\n","slug":"python/python-map-function","published":1,"updated":"2017-08-10T15:23:45.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dx4002l4j4d3p3qwso2","content":"<h3 id=\"1-内建方法map\"><a href=\"#1-内建方法map\" class=\"headerlink\" title=\"1. 内建方法map\"></a>1. 内建方法map</h3><p>内建map方法可以通过一个序列的方式来实现函数之间的映射, 并且串行执行。如:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">print</span> datetime.now(), <span class=\"string\">\"enter add func...\"</span></div><div class=\"line\">    time.sleep(<span class=\"number\">2</span>)</div><div class=\"line\">    <span class=\"keyword\">print</span> datetime.now(), <span class=\"string\">\"leave add func...\"</span></div><div class=\"line\">    <span class=\"keyword\">return</span> x+y</div><div class=\"line\"></div><div class=\"line\">map(add, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>], [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>])</div></pre></td></tr></table></figure></p>\n<p>运行效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-04-05 15:01:49.382314 enter add func...</div><div class=\"line\">2016-04-05 15:01:51.383387 leave add func...</div><div class=\"line\">2016-04-05 15:01:51.383471 enter add func...</div><div class=\"line\">2016-04-05 15:01:53.385584 leave add func...</div><div class=\"line\">2016-04-05 15:01:53.385676 enter add func...</div><div class=\"line\">2016-04-05 15:01:55.387388 leave add func...</div><div class=\"line\">[5, 7, 9]</div></pre></td></tr></table></figure></p>\n<p>由上可见, 调用map, 相当于顺序调用了add(1,4), add(2,5)， add(3,6)方法; 一行代码实现了方法的迭代调用, 简单快捷。<br>那如果再优化一下，实现并行调用add方法， 应该怎么做呢？在python里也好实现, 利用multiprocessing模块就可以。</p>\n<a id=\"more\"></a>\n<h3 id=\"2-multiprocessing模块与map方法\"><a href=\"#2-multiprocessing模块与map方法\" class=\"headerlink\" title=\"2. multiprocessing模块与map方法\"></a>2. multiprocessing模块与map方法</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing.dummy <span class=\"keyword\">import</span> Pool <span class=\"keyword\">as</span> ThreadPool</div><div class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> partial</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">print</span> datetime.now(), <span class=\"string\">\"enter add func...\"</span></div><div class=\"line\">    time.sleep(<span class=\"number\">2</span>)</div><div class=\"line\">    <span class=\"keyword\">print</span> datetime.now(), <span class=\"string\">\"leave add func...\"</span></div><div class=\"line\">    <span class=\"keyword\">return</span> x+y</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_wrap</span><span class=\"params\">(args)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> add(*args)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    pool = ThreadPool(<span class=\"number\">4</span>) <span class=\"comment\"># 池的大小为4</span></div><div class=\"line\">    <span class=\"keyword\">print</span> pool.map(add_wrap, [(<span class=\"number\">1</span>,<span class=\"number\">2</span>),(<span class=\"number\">3</span>,<span class=\"number\">4</span>),(<span class=\"number\">5</span>,<span class=\"number\">6</span>)])</div><div class=\"line\">    <span class=\"comment\">#close the pool and wait for the work to finish</span></div><div class=\"line\">    pool.close()</div><div class=\"line\">    pool.join()</div></pre></td></tr></table></figure>\n<p>运行效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-04-05 15:10:23.690059 enter add func...</div><div class=\"line\">2016-04-05 15:10:23.690406 enter add func...</div><div class=\"line\">2016-04-05 15:10:23.690906 enter add func...</div><div class=\"line\">2016-04-05 15:10:25.693250 leave add func...</div><div class=\"line\">2016-04-05 15:10:25.693409 leave add func...</div><div class=\"line\">2016-04-05 15:10:25.693458 leave add func...</div><div class=\"line\">[3, 7, 11]</div></pre></td></tr></table></figure></p>\n<p>由上可以见， 我们已经实现了并行执行add方法</p>\n<h3 id=\"3-关于multiprocessing中pool的大小与性能\"><a href=\"#3-关于multiprocessing中pool的大小与性能\" class=\"headerlink\" title=\"3. 关于multiprocessing中pool的大小与性能\"></a>3. 关于multiprocessing中pool的大小与性能</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Pool</div><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing.dummy <span class=\"keyword\">import</span> Pool <span class=\"keyword\">as</span> ThreadPool</div></pre></td></tr></table></figure>\n<p>以上Pool和ThreadPool模块, 一个基于进程工作, 一个基于线程工作。<br><br>一般来说, 使用进程池(multiprocessing pool)来执行CPU密集型的任务, 这样可以利用到多核的好处， 理论上(池越大)核越多速度越快; <br>使用线程池(threading)来处理IO型任务, 则有个最佳线程池大小, 要根据实际情况来调节这个池的size(线程过多时, 切换线程的开销将严重影响性能)。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-内建方法map\"><a href=\"#1-内建方法map\" class=\"headerlink\" title=\"1. 内建方法map\"></a>1. 内建方法map</h3><p>内建map方法可以通过一个序列的方式来实现函数之间的映射, 并且串行执行。如:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">print</span> datetime.now(), <span class=\"string\">\"enter add func...\"</span></div><div class=\"line\">    time.sleep(<span class=\"number\">2</span>)</div><div class=\"line\">    <span class=\"keyword\">print</span> datetime.now(), <span class=\"string\">\"leave add func...\"</span></div><div class=\"line\">    <span class=\"keyword\">return</span> x+y</div><div class=\"line\"></div><div class=\"line\">map(add, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>], [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>])</div></pre></td></tr></table></figure></p>\n<p>运行效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-04-05 15:01:49.382314 enter add func...</div><div class=\"line\">2016-04-05 15:01:51.383387 leave add func...</div><div class=\"line\">2016-04-05 15:01:51.383471 enter add func...</div><div class=\"line\">2016-04-05 15:01:53.385584 leave add func...</div><div class=\"line\">2016-04-05 15:01:53.385676 enter add func...</div><div class=\"line\">2016-04-05 15:01:55.387388 leave add func...</div><div class=\"line\">[5, 7, 9]</div></pre></td></tr></table></figure></p>\n<p>由上可见, 调用map, 相当于顺序调用了add(1,4), add(2,5)， add(3,6)方法; 一行代码实现了方法的迭代调用, 简单快捷。<br>那如果再优化一下，实现并行调用add方法， 应该怎么做呢？在python里也好实现, 利用multiprocessing模块就可以。</p>","more":"<h3 id=\"2-multiprocessing模块与map方法\"><a href=\"#2-multiprocessing模块与map方法\" class=\"headerlink\" title=\"2. multiprocessing模块与map方法\"></a>2. multiprocessing模块与map方法</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing.dummy <span class=\"keyword\">import</span> Pool <span class=\"keyword\">as</span> ThreadPool</div><div class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> partial</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">print</span> datetime.now(), <span class=\"string\">\"enter add func...\"</span></div><div class=\"line\">    time.sleep(<span class=\"number\">2</span>)</div><div class=\"line\">    <span class=\"keyword\">print</span> datetime.now(), <span class=\"string\">\"leave add func...\"</span></div><div class=\"line\">    <span class=\"keyword\">return</span> x+y</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_wrap</span><span class=\"params\">(args)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> add(*args)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    pool = ThreadPool(<span class=\"number\">4</span>) <span class=\"comment\"># 池的大小为4</span></div><div class=\"line\">    <span class=\"keyword\">print</span> pool.map(add_wrap, [(<span class=\"number\">1</span>,<span class=\"number\">2</span>),(<span class=\"number\">3</span>,<span class=\"number\">4</span>),(<span class=\"number\">5</span>,<span class=\"number\">6</span>)])</div><div class=\"line\">    <span class=\"comment\">#close the pool and wait for the work to finish</span></div><div class=\"line\">    pool.close()</div><div class=\"line\">    pool.join()</div></pre></td></tr></table></figure>\n<p>运行效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-04-05 15:10:23.690059 enter add func...</div><div class=\"line\">2016-04-05 15:10:23.690406 enter add func...</div><div class=\"line\">2016-04-05 15:10:23.690906 enter add func...</div><div class=\"line\">2016-04-05 15:10:25.693250 leave add func...</div><div class=\"line\">2016-04-05 15:10:25.693409 leave add func...</div><div class=\"line\">2016-04-05 15:10:25.693458 leave add func...</div><div class=\"line\">[3, 7, 11]</div></pre></td></tr></table></figure></p>\n<p>由上可以见， 我们已经实现了并行执行add方法</p>\n<h3 id=\"3-关于multiprocessing中pool的大小与性能\"><a href=\"#3-关于multiprocessing中pool的大小与性能\" class=\"headerlink\" title=\"3. 关于multiprocessing中pool的大小与性能\"></a>3. 关于multiprocessing中pool的大小与性能</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Pool</div><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing.dummy <span class=\"keyword\">import</span> Pool <span class=\"keyword\">as</span> ThreadPool</div></pre></td></tr></table></figure>\n<p>以上Pool和ThreadPool模块, 一个基于进程工作, 一个基于线程工作。<br><br>一般来说, 使用进程池(multiprocessing pool)来执行CPU密集型的任务, 这样可以利用到多核的好处， 理论上(池越大)核越多速度越快; <br>使用线程池(threading)来处理IO型任务, 则有个最佳线程池大小, 要根据实际情况来调节这个池的size(线程过多时, 切换线程的开销将严重影响性能)。</p>"},{"title":"python upload/download large file","date":"2017-08-19T14:39:53.000Z","_content":"\n\n对于大文件上传下载，可以通过requests库来流式处理，示例如下:\n\n```python\n\nimport requests\n\ndef upload(url, local_fpath):\n    headers = {\n        'content-type': 'application/octet-stream',\n        # ...\n    }\n    with open(local_fpath, 'rb') as f:\n        r = requests.post(url, headers=headers, data=f)\n        # deal with r.headers.xxx\n\ndef download(url, local_fpath):\n    headers = {\n        # ...\n    }\n    r = requests.get(url, stream=True, headers=headers)\n    with open(local_fpath, \"wb\") as fd:\n        for chunk in r.iter_content(chunk_size=10240):\n            if chunk:\n                fd.write(chunk)\n```\n","source":"_posts/python/python-upload-download-large-file.md","raw":"---\ntitle: python upload/download large file\ndate: 2017-08-19 22:39:53\ntags: python\n---\n\n\n对于大文件上传下载，可以通过requests库来流式处理，示例如下:\n\n```python\n\nimport requests\n\ndef upload(url, local_fpath):\n    headers = {\n        'content-type': 'application/octet-stream',\n        # ...\n    }\n    with open(local_fpath, 'rb') as f:\n        r = requests.post(url, headers=headers, data=f)\n        # deal with r.headers.xxx\n\ndef download(url, local_fpath):\n    headers = {\n        # ...\n    }\n    r = requests.get(url, stream=True, headers=headers)\n    with open(local_fpath, \"wb\") as fd:\n        for chunk in r.iter_content(chunk_size=10240):\n            if chunk:\n                fd.write(chunk)\n```\n","slug":"python/python-upload-download-large-file","published":1,"updated":"2017-08-19T14:41:55.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dx6002n4j4dh9lrq8d8","content":"<p>对于大文件上传下载，可以通过requests库来流式处理，示例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> requests</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">upload</span><span class=\"params\">(url, local_fpath)</span>:</span></div><div class=\"line\">    headers = &#123;</div><div class=\"line\">        <span class=\"string\">'content-type'</span>: <span class=\"string\">'application/octet-stream'</span>,</div><div class=\"line\">        <span class=\"comment\"># ...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">with</span> open(local_fpath, <span class=\"string\">'rb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">        r = requests.post(url, headers=headers, data=f)</div><div class=\"line\">        <span class=\"comment\"># deal with r.headers.xxx</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">download</span><span class=\"params\">(url, local_fpath)</span>:</span></div><div class=\"line\">    headers = &#123;</div><div class=\"line\">        <span class=\"comment\"># ...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    r = requests.get(url, stream=<span class=\"keyword\">True</span>, headers=headers)</div><div class=\"line\">    <span class=\"keyword\">with</span> open(local_fpath, <span class=\"string\">\"wb\"</span>) <span class=\"keyword\">as</span> fd:</div><div class=\"line\">        <span class=\"keyword\">for</span> chunk <span class=\"keyword\">in</span> r.iter_content(chunk_size=<span class=\"number\">10240</span>):</div><div class=\"line\">            <span class=\"keyword\">if</span> chunk:</div><div class=\"line\">                fd.write(chunk)</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>对于大文件上传下载，可以通过requests库来流式处理，示例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> requests</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">upload</span><span class=\"params\">(url, local_fpath)</span>:</span></div><div class=\"line\">    headers = &#123;</div><div class=\"line\">        <span class=\"string\">'content-type'</span>: <span class=\"string\">'application/octet-stream'</span>,</div><div class=\"line\">        <span class=\"comment\"># ...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">with</span> open(local_fpath, <span class=\"string\">'rb'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">        r = requests.post(url, headers=headers, data=f)</div><div class=\"line\">        <span class=\"comment\"># deal with r.headers.xxx</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">download</span><span class=\"params\">(url, local_fpath)</span>:</span></div><div class=\"line\">    headers = &#123;</div><div class=\"line\">        <span class=\"comment\"># ...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    r = requests.get(url, stream=<span class=\"keyword\">True</span>, headers=headers)</div><div class=\"line\">    <span class=\"keyword\">with</span> open(local_fpath, <span class=\"string\">\"wb\"</span>) <span class=\"keyword\">as</span> fd:</div><div class=\"line\">        <span class=\"keyword\">for</span> chunk <span class=\"keyword\">in</span> r.iter_content(chunk_size=<span class=\"number\">10240</span>):</div><div class=\"line\">            <span class=\"keyword\">if</span> chunk:</div><div class=\"line\">                fd.write(chunk)</div></pre></td></tr></table></figure>\n"},{"title":"[python3]使用aiohttp","date":"2017-09-05T10:10:02.000Z","_content":"\npython3下asyncio可实现异步并发处理IO逻辑, 而aiohttp可实现异步请求http逻辑,<br>\n因此可结合asyncio及aiohttp库实现异步并发请求http的需求,\n直接上示例代码:\n<!--more-->\n\n```python\n#! /usr/bin/python\n# -*- coding:utf-8 -*-\n\nimport aiohttp\nimport asyncio\nimport async_timeout\n\n\nasync def test(url):\n    async with aiohttp.ClientSession() as session:\n         with async_timeout.timeout(10):\n            async with session.post(url) as resp:\n                r = await resp.text()\n                print(r)\n                # r = await resp.read()  ## 用于读取字节流，不作解码\n                print(resp.headers.get('Content-Type'))\n                # TODO: do something...\n\n\ndef test_main():\n    tasks = []\n    tasks.append(\n        asyncio.ensure_future(\n            test(\"http://hostname1.com/xxx\")\n        )\n    )\n    tasks.append(\n        asyncio.ensure_future(\n            test(\"http://hostname2.com/xxx\")\n        )\n    )\n    loop.run_until_complete(asyncio.gather(*tasks))\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    test_main()\n    loop.close()\n```\n","source":"_posts/python/python3-aiohttp.md","raw":"---\ntitle: '[python3]使用aiohttp'\ndate: 2017-09-05 18:10:02\ntags: python\n---\n\npython3下asyncio可实现异步并发处理IO逻辑, 而aiohttp可实现异步请求http逻辑,<br>\n因此可结合asyncio及aiohttp库实现异步并发请求http的需求,\n直接上示例代码:\n<!--more-->\n\n```python\n#! /usr/bin/python\n# -*- coding:utf-8 -*-\n\nimport aiohttp\nimport asyncio\nimport async_timeout\n\n\nasync def test(url):\n    async with aiohttp.ClientSession() as session:\n         with async_timeout.timeout(10):\n            async with session.post(url) as resp:\n                r = await resp.text()\n                print(r)\n                # r = await resp.read()  ## 用于读取字节流，不作解码\n                print(resp.headers.get('Content-Type'))\n                # TODO: do something...\n\n\ndef test_main():\n    tasks = []\n    tasks.append(\n        asyncio.ensure_future(\n            test(\"http://hostname1.com/xxx\")\n        )\n    )\n    tasks.append(\n        asyncio.ensure_future(\n            test(\"http://hostname2.com/xxx\")\n        )\n    )\n    loop.run_until_complete(asyncio.gather(*tasks))\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    test_main()\n    loop.close()\n```\n","slug":"python/python3-aiohttp","published":1,"updated":"2017-11-15T05:54:46.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dx7002o4j4dn4zfy3k9","content":"<p>python3下asyncio可实现异步并发处理IO逻辑, 而aiohttp可实现异步请求http逻辑,<br><br>因此可结合asyncio及aiohttp库实现异步并发请求http的需求,<br>直接上示例代码:<br><a id=\"more\"></a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#! /usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> aiohttp</div><div class=\"line\"><span class=\"keyword\">import</span> asyncio</div><div class=\"line\"><span class=\"keyword\">import</span> async_timeout</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> aiohttp.ClientSession() <span class=\"keyword\">as</span> session:</div><div class=\"line\">         <span class=\"keyword\">with</span> async_timeout.timeout(<span class=\"number\">10</span>):</div><div class=\"line\">            <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> session.post(url) <span class=\"keyword\">as</span> resp:</div><div class=\"line\">                r = <span class=\"keyword\">await</span> resp.text()</div><div class=\"line\">                print(r)</div><div class=\"line\">                <span class=\"comment\"># r = await resp.read()  ## 用于读取字节流，不作解码</span></div><div class=\"line\">                print(resp.headers.get(<span class=\"string\">'Content-Type'</span>))</div><div class=\"line\">                <span class=\"comment\"># <span class=\"doctag\">TODO:</span> do something...</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    tasks = []</div><div class=\"line\">    tasks.append(</div><div class=\"line\">        asyncio.ensure_future(</div><div class=\"line\">            test(<span class=\"string\">\"http://hostname1.com/xxx\"</span>)</div><div class=\"line\">        )</div><div class=\"line\">    )</div><div class=\"line\">    tasks.append(</div><div class=\"line\">        asyncio.ensure_future(</div><div class=\"line\">            test(<span class=\"string\">\"http://hostname2.com/xxx\"</span>)</div><div class=\"line\">        )</div><div class=\"line\">    )</div><div class=\"line\">    loop.run_until_complete(asyncio.gather(*tasks))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    test_main()</div><div class=\"line\">    loop.close()</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>python3下asyncio可实现异步并发处理IO逻辑, 而aiohttp可实现异步请求http逻辑,<br><br>因此可结合asyncio及aiohttp库实现异步并发请求http的需求,<br>直接上示例代码:<br>","more":"</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#! /usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> aiohttp</div><div class=\"line\"><span class=\"keyword\">import</span> asyncio</div><div class=\"line\"><span class=\"keyword\">import</span> async_timeout</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> aiohttp.ClientSession() <span class=\"keyword\">as</span> session:</div><div class=\"line\">         <span class=\"keyword\">with</span> async_timeout.timeout(<span class=\"number\">10</span>):</div><div class=\"line\">            <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> session.post(url) <span class=\"keyword\">as</span> resp:</div><div class=\"line\">                r = <span class=\"keyword\">await</span> resp.text()</div><div class=\"line\">                print(r)</div><div class=\"line\">                <span class=\"comment\"># r = await resp.read()  ## 用于读取字节流，不作解码</span></div><div class=\"line\">                print(resp.headers.get(<span class=\"string\">'Content-Type'</span>))</div><div class=\"line\">                <span class=\"comment\"># <span class=\"doctag\">TODO:</span> do something...</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    tasks = []</div><div class=\"line\">    tasks.append(</div><div class=\"line\">        asyncio.ensure_future(</div><div class=\"line\">            test(<span class=\"string\">\"http://hostname1.com/xxx\"</span>)</div><div class=\"line\">        )</div><div class=\"line\">    )</div><div class=\"line\">    tasks.append(</div><div class=\"line\">        asyncio.ensure_future(</div><div class=\"line\">            test(<span class=\"string\">\"http://hostname2.com/xxx\"</span>)</div><div class=\"line\">        )</div><div class=\"line\">    )</div><div class=\"line\">    loop.run_until_complete(asyncio.gather(*tasks))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    test_main()</div><div class=\"line\">    loop.close()</div></pre></td></tr></table></figure>"},{"title":"Centos7安装ElasticSearch6.4","date":"2018-09-19T08:05:51.000Z","_content":"\n## centos安装ElasticSearch6.4\n\n### 节点准备\n\n节点IP      | 角色      | ES节点名称\n------------|-----------|-----------\n192.168.1.10       |master        |node1\n192.168.1.11       |data        |node2\n\n<!--more-->\n\n### 1.下载ES安装包\n\n```shell\ncd /opt\nwget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.0.tar.gz\ntar -zxvf elasticsearch-6.4.0.tar.gz\n```\n\n### 2. 添加普通用户\n\n```shell\ngroupadd elsearch\nuseradd elsearch -g elsearch -p elasticsearch\nchown -R elsearch.elsearch /opt/elasticsearch-6.4.0/\n```\n\n### 3. 修改ES配置(两个节点分别配置)\n\n```shell\n# vim config/elasticsearch.yml\n\ncluster.name: es\n\n## 节点node1\nnode.name: node1\nnode.master: true\nnetwork.host: 192.168.1.10\n\n## 节点node2\n#node.name: node2\n#node.master: false\n#network.host: 192.168.1.11\n\nnode.data: true\npath.data: /opt/elasticsearch-6.4.0/data\npath.logs: /opt/elasticsearch-6.4.0/logs\ntransport.tcp.port: 9300\nhttp.port: 9200\ndiscovery.zen.ping.unicast.hosts: [\"192.168.1.10:9300\",\"192.168.1.11:9300\"]\n```\n\n### 修改系统参数\n\n```bash\n# vim /etc/security/limits.conf \nelsearch hard nofile 655360\nelsearch soft nofile 655360\n\n# vim /etc/sysctl.conf\nvm.max_map_count=655360\n# sysctl -p\n```\n\n### 添加ES到Supervisor\n\n```\n# vim /etc/supervisor.d/es.ini\n[supervisord]\nminfds=65536\nminprocs=32768\n\n[program:es-node]\ncommand     = /opt/elasticsearch-6.4.0/bin/elasticsearch\ndirectory   = /opt/elasticsearch-6.4.0\nuser        = elsearch\nstartsecs   = 3\nredirect_stderr         = true\nstdout_logfile_maxbytes = 50MB\nstdout_logfile_backups  = 10\nstdout_logfile          = /opt/elasticsearch-6.4.0/logs/supervisor.log\n```\n\n### 通过Supervisor启动ES服务\n\n```shell\n# 两个节点分别启动\nsupervisorctl reread\nsupervisorctl add es-node\n# supervisorctl start es-node\nsupervisorctl status\n```\n\n### 浏览器测试访问\n\n![es-9200.png](/img/es-9200.png)\n\n### 下载cerebro管理资源包(假设安装在192.168.1.10)\n\n```shell\ncd /opt\nwget https://github.com/lmenezes/cerebro/releases/download/v0.8.1/cerebro-0.8.1.tgz\ntar -zxf cerebro-0.8.1.tgz\nchown -R elsearch.elsearch /opt/cerebro-0.8.1\n```\n\n### 配置cerebro\n\n```bash\n# vim conf/application.conf\nhosts = [\n  {\n    host = \"http://192.168.1.10:9200\"\n    name = \"Default ES Cluster\"\n#    auth = {\n#        username = \"xx_admin\"\n#        password = \"xx_pwd\"\n#    }\n  },\n }\n```\n \n ### 添加cerebro到Supervisor\n \n```\n [program:cerebro-node]\ncommand     = /opt/cerebro-0.8.1/bin/cerebro -Dhttp.port=12345 -Dhttp.address=192.168.1.10\ndirectory   = /opt/cerebro-0.8.1/\nuser        = elsearch\nstartsecs   = 3\n\nredirect_stderr         = true\nstdout_logfile_maxbytes = 100MB\nstdout_logfile_backups  = 10\nstdout_logfile          = /opt/cerebro-0.8.1/logs/supervisor.log\n```\n\n### 通过Supervisor启动cerebro\n\n```\nsupervisorctl reread\nsupervisorctl add cerebro-node\n# supervisorctl start cerebro-node\nsupervisorctl status\n```\n\n### 浏览器访问cerebro\n\n![es-12345.png](/img/es-12345.png)\n","source":"_posts/ops/Centos7安装ElasticSearch6.md","raw":"---\ntitle: Centos7安装ElasticSearch6.4\ndate: 2018-09-19 16:05:51\ntags: elasticsearch\n---\n\n## centos安装ElasticSearch6.4\n\n### 节点准备\n\n节点IP      | 角色      | ES节点名称\n------------|-----------|-----------\n192.168.1.10       |master        |node1\n192.168.1.11       |data        |node2\n\n<!--more-->\n\n### 1.下载ES安装包\n\n```shell\ncd /opt\nwget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.0.tar.gz\ntar -zxvf elasticsearch-6.4.0.tar.gz\n```\n\n### 2. 添加普通用户\n\n```shell\ngroupadd elsearch\nuseradd elsearch -g elsearch -p elasticsearch\nchown -R elsearch.elsearch /opt/elasticsearch-6.4.0/\n```\n\n### 3. 修改ES配置(两个节点分别配置)\n\n```shell\n# vim config/elasticsearch.yml\n\ncluster.name: es\n\n## 节点node1\nnode.name: node1\nnode.master: true\nnetwork.host: 192.168.1.10\n\n## 节点node2\n#node.name: node2\n#node.master: false\n#network.host: 192.168.1.11\n\nnode.data: true\npath.data: /opt/elasticsearch-6.4.0/data\npath.logs: /opt/elasticsearch-6.4.0/logs\ntransport.tcp.port: 9300\nhttp.port: 9200\ndiscovery.zen.ping.unicast.hosts: [\"192.168.1.10:9300\",\"192.168.1.11:9300\"]\n```\n\n### 修改系统参数\n\n```bash\n# vim /etc/security/limits.conf \nelsearch hard nofile 655360\nelsearch soft nofile 655360\n\n# vim /etc/sysctl.conf\nvm.max_map_count=655360\n# sysctl -p\n```\n\n### 添加ES到Supervisor\n\n```\n# vim /etc/supervisor.d/es.ini\n[supervisord]\nminfds=65536\nminprocs=32768\n\n[program:es-node]\ncommand     = /opt/elasticsearch-6.4.0/bin/elasticsearch\ndirectory   = /opt/elasticsearch-6.4.0\nuser        = elsearch\nstartsecs   = 3\nredirect_stderr         = true\nstdout_logfile_maxbytes = 50MB\nstdout_logfile_backups  = 10\nstdout_logfile          = /opt/elasticsearch-6.4.0/logs/supervisor.log\n```\n\n### 通过Supervisor启动ES服务\n\n```shell\n# 两个节点分别启动\nsupervisorctl reread\nsupervisorctl add es-node\n# supervisorctl start es-node\nsupervisorctl status\n```\n\n### 浏览器测试访问\n\n![es-9200.png](/img/es-9200.png)\n\n### 下载cerebro管理资源包(假设安装在192.168.1.10)\n\n```shell\ncd /opt\nwget https://github.com/lmenezes/cerebro/releases/download/v0.8.1/cerebro-0.8.1.tgz\ntar -zxf cerebro-0.8.1.tgz\nchown -R elsearch.elsearch /opt/cerebro-0.8.1\n```\n\n### 配置cerebro\n\n```bash\n# vim conf/application.conf\nhosts = [\n  {\n    host = \"http://192.168.1.10:9200\"\n    name = \"Default ES Cluster\"\n#    auth = {\n#        username = \"xx_admin\"\n#        password = \"xx_pwd\"\n#    }\n  },\n }\n```\n \n ### 添加cerebro到Supervisor\n \n```\n [program:cerebro-node]\ncommand     = /opt/cerebro-0.8.1/bin/cerebro -Dhttp.port=12345 -Dhttp.address=192.168.1.10\ndirectory   = /opt/cerebro-0.8.1/\nuser        = elsearch\nstartsecs   = 3\n\nredirect_stderr         = true\nstdout_logfile_maxbytes = 100MB\nstdout_logfile_backups  = 10\nstdout_logfile          = /opt/cerebro-0.8.1/logs/supervisor.log\n```\n\n### 通过Supervisor启动cerebro\n\n```\nsupervisorctl reread\nsupervisorctl add cerebro-node\n# supervisorctl start cerebro-node\nsupervisorctl status\n```\n\n### 浏览器访问cerebro\n\n![es-12345.png](/img/es-12345.png)\n","slug":"ops/Centos7安装ElasticSearch6","published":1,"updated":"2018-09-19T09:21:10.395Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dx9002p4j4dnj6m6l15","content":"<h2 id=\"centos安装ElasticSearch6-4\"><a href=\"#centos安装ElasticSearch6-4\" class=\"headerlink\" title=\"centos安装ElasticSearch6.4\"></a>centos安装ElasticSearch6.4</h2><h3 id=\"节点准备\"><a href=\"#节点准备\" class=\"headerlink\" title=\"节点准备\"></a>节点准备</h3><table>\n<thead>\n<tr>\n<th>节点IP</th>\n<th>角色</th>\n<th>ES节点名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>192.168.1.10</td>\n<td>master</td>\n<td>node1</td>\n</tr>\n<tr>\n<td>192.168.1.11</td>\n<td>data</td>\n<td>node2</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h3 id=\"1-下载ES安装包\"><a href=\"#1-下载ES安装包\" class=\"headerlink\" title=\"1.下载ES安装包\"></a>1.下载ES安装包</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /opt</div><div class=\"line\">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.0.tar.gz</div><div class=\"line\">tar -zxvf elasticsearch-6.4.0.tar.gz</div></pre></td></tr></table></figure>\n<h3 id=\"2-添加普通用户\"><a href=\"#2-添加普通用户\" class=\"headerlink\" title=\"2. 添加普通用户\"></a>2. 添加普通用户</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">groupadd elsearch</div><div class=\"line\">useradd elsearch -g elsearch -p elasticsearch</div><div class=\"line\">chown -R elsearch.elsearch /opt/elasticsearch-6.4.0/</div></pre></td></tr></table></figure>\n<h3 id=\"3-修改ES配置-两个节点分别配置\"><a href=\"#3-修改ES配置-两个节点分别配置\" class=\"headerlink\" title=\"3. 修改ES配置(两个节点分别配置)\"></a>3. 修改ES配置(两个节点分别配置)</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim config/elasticsearch.yml</span></div><div class=\"line\"></div><div class=\"line\">cluster.name: es</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#<span class=\"bash\"><span class=\"comment\"># 节点node1</span></span></div><div class=\"line\">node.name: node1</div><div class=\"line\">node.master: true</div><div class=\"line\">network.host: 192.168.1.10</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#<span class=\"bash\"><span class=\"comment\"># 节点node2</span></span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">node.name: node2</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">node.master: <span class=\"literal\">false</span></span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">network.host: 192.168.1.11</span></div><div class=\"line\"></div><div class=\"line\">node.data: true</div><div class=\"line\">path.data: /opt/elasticsearch-6.4.0/data</div><div class=\"line\">path.logs: /opt/elasticsearch-6.4.0/logs</div><div class=\"line\">transport.tcp.port: 9300</div><div class=\"line\">http.port: 9200</div><div class=\"line\">discovery.zen.ping.unicast.hosts: [\"192.168.1.10:9300\",\"192.168.1.11:9300\"]</div></pre></td></tr></table></figure>\n<h3 id=\"修改系统参数\"><a href=\"#修改系统参数\" class=\"headerlink\" title=\"修改系统参数\"></a>修改系统参数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># vim /etc/security/limits.conf </span></div><div class=\"line\">elsearch hard nofile 655360</div><div class=\"line\">elsearch soft nofile 655360</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># vim /etc/sysctl.conf</span></div><div class=\"line\">vm.max_map_count=655360</div><div class=\"line\"><span class=\"comment\"># sysctl -p</span></div></pre></td></tr></table></figure>\n<h3 id=\"添加ES到Supervisor\"><a href=\"#添加ES到Supervisor\" class=\"headerlink\" title=\"添加ES到Supervisor\"></a>添加ES到Supervisor</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"># vim /etc/supervisor.d/es.ini</div><div class=\"line\">[supervisord]</div><div class=\"line\">minfds=65536</div><div class=\"line\">minprocs=32768</div><div class=\"line\"></div><div class=\"line\">[program:es-node]</div><div class=\"line\">command     = /opt/elasticsearch-6.4.0/bin/elasticsearch</div><div class=\"line\">directory   = /opt/elasticsearch-6.4.0</div><div class=\"line\">user        = elsearch</div><div class=\"line\">startsecs   = 3</div><div class=\"line\">redirect_stderr         = true</div><div class=\"line\">stdout_logfile_maxbytes = 50MB</div><div class=\"line\">stdout_logfile_backups  = 10</div><div class=\"line\">stdout_logfile          = /opt/elasticsearch-6.4.0/logs/supervisor.log</div></pre></td></tr></table></figure>\n<h3 id=\"通过Supervisor启动ES服务\"><a href=\"#通过Supervisor启动ES服务\" class=\"headerlink\" title=\"通过Supervisor启动ES服务\"></a>通过Supervisor启动ES服务</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 两个节点分别启动</span></div><div class=\"line\">supervisorctl reread</div><div class=\"line\">supervisorctl add es-node</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> supervisorctl start es-node</span></div><div class=\"line\">supervisorctl status</div></pre></td></tr></table></figure>\n<h3 id=\"浏览器测试访问\"><a href=\"#浏览器测试访问\" class=\"headerlink\" title=\"浏览器测试访问\"></a>浏览器测试访问</h3><p><img src=\"/img/es-9200.png\" alt=\"es-9200.png\"></p>\n<h3 id=\"下载cerebro管理资源包-假设安装在192-168-1-10\"><a href=\"#下载cerebro管理资源包-假设安装在192-168-1-10\" class=\"headerlink\" title=\"下载cerebro管理资源包(假设安装在192.168.1.10)\"></a>下载cerebro管理资源包(假设安装在192.168.1.10)</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /opt</div><div class=\"line\">wget https://github.com/lmenezes/cerebro/releases/download/v0.8.1/cerebro-0.8.1.tgz</div><div class=\"line\">tar -zxf cerebro-0.8.1.tgz</div><div class=\"line\">chown -R elsearch.elsearch /opt/cerebro-0.8.1</div></pre></td></tr></table></figure>\n<h3 id=\"配置cerebro\"><a href=\"#配置cerebro\" class=\"headerlink\" title=\"配置cerebro\"></a>配置cerebro</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># vim conf/application.conf</span></div><div class=\"line\">hosts = [</div><div class=\"line\">  &#123;</div><div class=\"line\">    host = <span class=\"string\">\"http://192.168.1.10:9200\"</span></div><div class=\"line\">    name = <span class=\"string\">\"Default ES Cluster\"</span></div><div class=\"line\"><span class=\"comment\">#    auth = &#123;</span></div><div class=\"line\"><span class=\"comment\">#        username = \"xx_admin\"</span></div><div class=\"line\"><span class=\"comment\">#        password = \"xx_pwd\"</span></div><div class=\"line\"><span class=\"comment\">#    &#125;</span></div><div class=\"line\">  &#125;,</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"添加cerebro到Supervisor\"><a href=\"#添加cerebro到Supervisor\" class=\"headerlink\" title=\"添加cerebro到Supervisor\"></a>添加cerebro到Supervisor</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> [program:cerebro-node]</div><div class=\"line\">command     = /opt/cerebro-0.8.1/bin/cerebro -Dhttp.port=12345 -Dhttp.address=192.168.1.10</div><div class=\"line\">directory   = /opt/cerebro-0.8.1/</div><div class=\"line\">user        = elsearch</div><div class=\"line\">startsecs   = 3</div><div class=\"line\"></div><div class=\"line\">redirect_stderr         = true</div><div class=\"line\">stdout_logfile_maxbytes = 100MB</div><div class=\"line\">stdout_logfile_backups  = 10</div><div class=\"line\">stdout_logfile          = /opt/cerebro-0.8.1/logs/supervisor.log</div></pre></td></tr></table></figure>\n<h3 id=\"通过Supervisor启动cerebro\"><a href=\"#通过Supervisor启动cerebro\" class=\"headerlink\" title=\"通过Supervisor启动cerebro\"></a>通过Supervisor启动cerebro</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">supervisorctl reread</div><div class=\"line\">supervisorctl add cerebro-node</div><div class=\"line\"># supervisorctl start cerebro-node</div><div class=\"line\">supervisorctl status</div></pre></td></tr></table></figure>\n<h3 id=\"浏览器访问cerebro\"><a href=\"#浏览器访问cerebro\" class=\"headerlink\" title=\"浏览器访问cerebro\"></a>浏览器访问cerebro</h3><p><img src=\"/img/es-12345.png\" alt=\"es-12345.png\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"centos安装ElasticSearch6-4\"><a href=\"#centos安装ElasticSearch6-4\" class=\"headerlink\" title=\"centos安装ElasticSearch6.4\"></a>centos安装ElasticSearch6.4</h2><h3 id=\"节点准备\"><a href=\"#节点准备\" class=\"headerlink\" title=\"节点准备\"></a>节点准备</h3><table>\n<thead>\n<tr>\n<th>节点IP</th>\n<th>角色</th>\n<th>ES节点名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>192.168.1.10</td>\n<td>master</td>\n<td>node1</td>\n</tr>\n<tr>\n<td>192.168.1.11</td>\n<td>data</td>\n<td>node2</td>\n</tr>\n</tbody>\n</table>","more":"<h3 id=\"1-下载ES安装包\"><a href=\"#1-下载ES安装包\" class=\"headerlink\" title=\"1.下载ES安装包\"></a>1.下载ES安装包</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /opt</div><div class=\"line\">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.0.tar.gz</div><div class=\"line\">tar -zxvf elasticsearch-6.4.0.tar.gz</div></pre></td></tr></table></figure>\n<h3 id=\"2-添加普通用户\"><a href=\"#2-添加普通用户\" class=\"headerlink\" title=\"2. 添加普通用户\"></a>2. 添加普通用户</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">groupadd elsearch</div><div class=\"line\">useradd elsearch -g elsearch -p elasticsearch</div><div class=\"line\">chown -R elsearch.elsearch /opt/elasticsearch-6.4.0/</div></pre></td></tr></table></figure>\n<h3 id=\"3-修改ES配置-两个节点分别配置\"><a href=\"#3-修改ES配置-两个节点分别配置\" class=\"headerlink\" title=\"3. 修改ES配置(两个节点分别配置)\"></a>3. 修改ES配置(两个节点分别配置)</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> vim config/elasticsearch.yml</span></div><div class=\"line\"></div><div class=\"line\">cluster.name: es</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#<span class=\"bash\"><span class=\"comment\"># 节点node1</span></span></div><div class=\"line\">node.name: node1</div><div class=\"line\">node.master: true</div><div class=\"line\">network.host: 192.168.1.10</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#<span class=\"bash\"><span class=\"comment\"># 节点node2</span></span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">node.name: node2</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">node.master: <span class=\"literal\">false</span></span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">network.host: 192.168.1.11</span></div><div class=\"line\"></div><div class=\"line\">node.data: true</div><div class=\"line\">path.data: /opt/elasticsearch-6.4.0/data</div><div class=\"line\">path.logs: /opt/elasticsearch-6.4.0/logs</div><div class=\"line\">transport.tcp.port: 9300</div><div class=\"line\">http.port: 9200</div><div class=\"line\">discovery.zen.ping.unicast.hosts: [\"192.168.1.10:9300\",\"192.168.1.11:9300\"]</div></pre></td></tr></table></figure>\n<h3 id=\"修改系统参数\"><a href=\"#修改系统参数\" class=\"headerlink\" title=\"修改系统参数\"></a>修改系统参数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># vim /etc/security/limits.conf </span></div><div class=\"line\">elsearch hard nofile 655360</div><div class=\"line\">elsearch soft nofile 655360</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># vim /etc/sysctl.conf</span></div><div class=\"line\">vm.max_map_count=655360</div><div class=\"line\"><span class=\"comment\"># sysctl -p</span></div></pre></td></tr></table></figure>\n<h3 id=\"添加ES到Supervisor\"><a href=\"#添加ES到Supervisor\" class=\"headerlink\" title=\"添加ES到Supervisor\"></a>添加ES到Supervisor</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"># vim /etc/supervisor.d/es.ini</div><div class=\"line\">[supervisord]</div><div class=\"line\">minfds=65536</div><div class=\"line\">minprocs=32768</div><div class=\"line\"></div><div class=\"line\">[program:es-node]</div><div class=\"line\">command     = /opt/elasticsearch-6.4.0/bin/elasticsearch</div><div class=\"line\">directory   = /opt/elasticsearch-6.4.0</div><div class=\"line\">user        = elsearch</div><div class=\"line\">startsecs   = 3</div><div class=\"line\">redirect_stderr         = true</div><div class=\"line\">stdout_logfile_maxbytes = 50MB</div><div class=\"line\">stdout_logfile_backups  = 10</div><div class=\"line\">stdout_logfile          = /opt/elasticsearch-6.4.0/logs/supervisor.log</div></pre></td></tr></table></figure>\n<h3 id=\"通过Supervisor启动ES服务\"><a href=\"#通过Supervisor启动ES服务\" class=\"headerlink\" title=\"通过Supervisor启动ES服务\"></a>通过Supervisor启动ES服务</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 两个节点分别启动</span></div><div class=\"line\">supervisorctl reread</div><div class=\"line\">supervisorctl add es-node</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> supervisorctl start es-node</span></div><div class=\"line\">supervisorctl status</div></pre></td></tr></table></figure>\n<h3 id=\"浏览器测试访问\"><a href=\"#浏览器测试访问\" class=\"headerlink\" title=\"浏览器测试访问\"></a>浏览器测试访问</h3><p><img src=\"/img/es-9200.png\" alt=\"es-9200.png\"></p>\n<h3 id=\"下载cerebro管理资源包-假设安装在192-168-1-10\"><a href=\"#下载cerebro管理资源包-假设安装在192-168-1-10\" class=\"headerlink\" title=\"下载cerebro管理资源包(假设安装在192.168.1.10)\"></a>下载cerebro管理资源包(假设安装在192.168.1.10)</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /opt</div><div class=\"line\">wget https://github.com/lmenezes/cerebro/releases/download/v0.8.1/cerebro-0.8.1.tgz</div><div class=\"line\">tar -zxf cerebro-0.8.1.tgz</div><div class=\"line\">chown -R elsearch.elsearch /opt/cerebro-0.8.1</div></pre></td></tr></table></figure>\n<h3 id=\"配置cerebro\"><a href=\"#配置cerebro\" class=\"headerlink\" title=\"配置cerebro\"></a>配置cerebro</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># vim conf/application.conf</span></div><div class=\"line\">hosts = [</div><div class=\"line\">  &#123;</div><div class=\"line\">    host = <span class=\"string\">\"http://192.168.1.10:9200\"</span></div><div class=\"line\">    name = <span class=\"string\">\"Default ES Cluster\"</span></div><div class=\"line\"><span class=\"comment\">#    auth = &#123;</span></div><div class=\"line\"><span class=\"comment\">#        username = \"xx_admin\"</span></div><div class=\"line\"><span class=\"comment\">#        password = \"xx_pwd\"</span></div><div class=\"line\"><span class=\"comment\">#    &#125;</span></div><div class=\"line\">  &#125;,</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"添加cerebro到Supervisor\"><a href=\"#添加cerebro到Supervisor\" class=\"headerlink\" title=\"添加cerebro到Supervisor\"></a>添加cerebro到Supervisor</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> [program:cerebro-node]</div><div class=\"line\">command     = /opt/cerebro-0.8.1/bin/cerebro -Dhttp.port=12345 -Dhttp.address=192.168.1.10</div><div class=\"line\">directory   = /opt/cerebro-0.8.1/</div><div class=\"line\">user        = elsearch</div><div class=\"line\">startsecs   = 3</div><div class=\"line\"></div><div class=\"line\">redirect_stderr         = true</div><div class=\"line\">stdout_logfile_maxbytes = 100MB</div><div class=\"line\">stdout_logfile_backups  = 10</div><div class=\"line\">stdout_logfile          = /opt/cerebro-0.8.1/logs/supervisor.log</div></pre></td></tr></table></figure>\n<h3 id=\"通过Supervisor启动cerebro\"><a href=\"#通过Supervisor启动cerebro\" class=\"headerlink\" title=\"通过Supervisor启动cerebro\"></a>通过Supervisor启动cerebro</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">supervisorctl reread</div><div class=\"line\">supervisorctl add cerebro-node</div><div class=\"line\"># supervisorctl start cerebro-node</div><div class=\"line\">supervisorctl status</div></pre></td></tr></table></figure>\n<h3 id=\"浏览器访问cerebro\"><a href=\"#浏览器访问cerebro\" class=\"headerlink\" title=\"浏览器访问cerebro\"></a>浏览器访问cerebro</h3><p><img src=\"/img/es-12345.png\" alt=\"es-12345.png\"></p>"},{"title":"python pika broken pipe","date":"2017-08-19T10:46:21.000Z","_content":"\n\n## 问题描述\n\n在消费rabbitMQ队列时, 每次进入回调函数内需要进行一些比较耗时的操作;操作完成后给rabbitMQ server发送ack信号以dequeue本条消息。<br>\n问题就发生在发送ack操作时, 程序提示链接已被断开或socket error。\n<!--more-->\n\n## 源码示例\n\n```python\n#!/usr/bin\n#coding: utf-8\n\nimport pika\nimport time\n\n\nUSER = 'guest'\nPWD = 'guest'\nTEST_QUEUE = 'just4test'\n\ndef callback(ch, method, properties, body):\n    print(body)\n    time.sleep(600)\n    ch.basic_publish('', routing_key=TEST_QUEUE, body=\"fortest\")\n    ch.basic_ack(delivery_tag = method.delivery_tag)\n\ndef test_main():\n    s_conn = pika.BlockingConnection(\n        pika.ConnectionParameters('127.0.0.1', \n            credentials=pika.PlainCredentials(USER, PWD)))\n    chan = s_conn.channel()\n    chan.queue_declare(queue=TEST_QUEUE)\n\n    chan.basic_publish('', routing_key=TEST_QUEUE, body=\"fortest\")\n    chan.basic_consume(callback, queue=TEST_QUEUE)\n    chan.start_consuming()\n\nif __name__ == \"__main__\":\n    test_main()\n```\n\n运行一段时间后， 就会报错:\n\n```\n[ERROR][pika.adapters.base_connection][2017-08-18 12:33:49]Error event 25, None\n[CRITICAL][pika.adapters.base_connection][2017-08-18 12:33:49]Tried to handle an error where no error existed\n[ERROR][pika.adapters.base_connection][2017-08-18 12:33:49]Fatal Socket Error: BrokenPipeError(32, 'Broken pipe')\n```\n\n## 问题排查\n\n### 猜测：pika客户端没有及时发送心跳，连接被server断开\n\n一开始修改了heartbeat_interval参数值, 示例如下:\n\n```python\ndef test_main():\n    s_conn = pika.BlockingConnection(\n        pika.ConnectionParameters('127.0.0.1', \n            heartbeat_interval=10,\n            socket_timeout=5,\n            credentials=pika.PlainCredentials(USER, PWD)))\n    # ....\n```\n修改后运行依然报错，后来想想应该单线程被一直占用，pika无法发送心跳；<br>\n于是又加了个心跳线程, 示例如下:\n\n```python\n#!/usr/bin\n#coding: utf-8\n\nimport pika\nimport time\nimport logging\nimport threading\n\nUSER = 'guest'\nPWD = 'guest'\nTEST_QUEUE = 'just4test'\n\nclass Heartbeat(threading.Thread):\n    def __init__(self, connection):\n        super(Heartbeat, self).__init__()\n        self.lock = threading.Lock()\n        self.connection = connection\n        self.quitflag = False\n        self.stopflag = True\n        self.setDaemon(True)\n\n    def run(self):\n        while not self.quitflag:\n            time.sleep(10)\n            self.lock.acquire()\n            if self.stopflag :\n                self.lock.release()\n                continue\n            try:\n                self.connection.process_data_events()\n            except Exception as ex:\n                logging.warn(\"Error format: %s\"%(str(ex)))\n                self.lock.release()\n                return\n            self.lock.release()\n\n    def startHeartbeat(self):\n        self.lock.acquire()\n        if self.quitflag==True:\n            self.lock.release()\n            return\n        self.stopflag=False\n        self.lock.release()\n\ndef callback(ch, method, properties, body):\n    logging.info(\"recv_body:%s\" % body)\n    time.sleep(600)\n    ch.basic_ack(delivery_tag = method.delivery_tag)\n\ndef test_main():\n    s_conn = pika.BlockingConnection(\n        pika.ConnectionParameters('127.0.0.1', \n            heartbeat_interval=10,\n            socket_timeout=5,\n            credentials=pika.PlainCredentials(USER, PWD)))\n    chan = s_conn.channel()\n    chan.queue_declare(queue=TEST_QUEUE)\n    chan.basic_consume(callback,\n                       queue=TEST_QUEUE)\n\n    heartbeat = Heartbeat(s_conn)\n    heartbeat.start()          #开启心跳线程\n    heartbeat.startHeartbeat()\n    chan.start_consuming()\n\nif __name__ == \"__main__\":\n    test_main()\n```\n尝试运行，结果还是不行，不得不安静下来思考自己是不是想错了。<br>\n去看它的api，看到heartbeat_interval的解析:\n\n```\n:param int heartbeat_interval: How often to send heartbeats.\n                                  Min between this value and server's proposal\n                                  will be used. Use 0 to deactivate heartbeats\n                                  and None to accept server's proposal.\n```\n                           \n按这样说法，应该还是没有把心跳值给设置好。上面的程序期望是10秒发一次心跳，但是理论上发送心跳的间隔会比10秒多一点。所以艾玛，我应该是把*heartbeat_interval*的作用搞错了， 它是指超过这个时间间隔不发心跳或不给server任何信息，server就会断开连接, 而不是说pika会按这个间隔来发心跳。 结果我把heartbeat_interval值设置高一点(比实际发送心跳/信息的间隔更长)，比如上面设置成60秒，就正常运行了。\n\n如果不指定*heartbeat_interval*， 它默认为None， 意味着按rabbitMQ server的配置来检测心跳是否正常。<br>\n如果设置*heartbeat_interval=0*， 意味着不检测心跳，server端将不会主动断开连接。\n","source":"_posts/python/python-pika-broken-pipe.md","raw":"---\ntitle: python pika broken pipe\ndate: 2017-08-19 18:46:21\ntags: python\n---\n\n\n## 问题描述\n\n在消费rabbitMQ队列时, 每次进入回调函数内需要进行一些比较耗时的操作;操作完成后给rabbitMQ server发送ack信号以dequeue本条消息。<br>\n问题就发生在发送ack操作时, 程序提示链接已被断开或socket error。\n<!--more-->\n\n## 源码示例\n\n```python\n#!/usr/bin\n#coding: utf-8\n\nimport pika\nimport time\n\n\nUSER = 'guest'\nPWD = 'guest'\nTEST_QUEUE = 'just4test'\n\ndef callback(ch, method, properties, body):\n    print(body)\n    time.sleep(600)\n    ch.basic_publish('', routing_key=TEST_QUEUE, body=\"fortest\")\n    ch.basic_ack(delivery_tag = method.delivery_tag)\n\ndef test_main():\n    s_conn = pika.BlockingConnection(\n        pika.ConnectionParameters('127.0.0.1', \n            credentials=pika.PlainCredentials(USER, PWD)))\n    chan = s_conn.channel()\n    chan.queue_declare(queue=TEST_QUEUE)\n\n    chan.basic_publish('', routing_key=TEST_QUEUE, body=\"fortest\")\n    chan.basic_consume(callback, queue=TEST_QUEUE)\n    chan.start_consuming()\n\nif __name__ == \"__main__\":\n    test_main()\n```\n\n运行一段时间后， 就会报错:\n\n```\n[ERROR][pika.adapters.base_connection][2017-08-18 12:33:49]Error event 25, None\n[CRITICAL][pika.adapters.base_connection][2017-08-18 12:33:49]Tried to handle an error where no error existed\n[ERROR][pika.adapters.base_connection][2017-08-18 12:33:49]Fatal Socket Error: BrokenPipeError(32, 'Broken pipe')\n```\n\n## 问题排查\n\n### 猜测：pika客户端没有及时发送心跳，连接被server断开\n\n一开始修改了heartbeat_interval参数值, 示例如下:\n\n```python\ndef test_main():\n    s_conn = pika.BlockingConnection(\n        pika.ConnectionParameters('127.0.0.1', \n            heartbeat_interval=10,\n            socket_timeout=5,\n            credentials=pika.PlainCredentials(USER, PWD)))\n    # ....\n```\n修改后运行依然报错，后来想想应该单线程被一直占用，pika无法发送心跳；<br>\n于是又加了个心跳线程, 示例如下:\n\n```python\n#!/usr/bin\n#coding: utf-8\n\nimport pika\nimport time\nimport logging\nimport threading\n\nUSER = 'guest'\nPWD = 'guest'\nTEST_QUEUE = 'just4test'\n\nclass Heartbeat(threading.Thread):\n    def __init__(self, connection):\n        super(Heartbeat, self).__init__()\n        self.lock = threading.Lock()\n        self.connection = connection\n        self.quitflag = False\n        self.stopflag = True\n        self.setDaemon(True)\n\n    def run(self):\n        while not self.quitflag:\n            time.sleep(10)\n            self.lock.acquire()\n            if self.stopflag :\n                self.lock.release()\n                continue\n            try:\n                self.connection.process_data_events()\n            except Exception as ex:\n                logging.warn(\"Error format: %s\"%(str(ex)))\n                self.lock.release()\n                return\n            self.lock.release()\n\n    def startHeartbeat(self):\n        self.lock.acquire()\n        if self.quitflag==True:\n            self.lock.release()\n            return\n        self.stopflag=False\n        self.lock.release()\n\ndef callback(ch, method, properties, body):\n    logging.info(\"recv_body:%s\" % body)\n    time.sleep(600)\n    ch.basic_ack(delivery_tag = method.delivery_tag)\n\ndef test_main():\n    s_conn = pika.BlockingConnection(\n        pika.ConnectionParameters('127.0.0.1', \n            heartbeat_interval=10,\n            socket_timeout=5,\n            credentials=pika.PlainCredentials(USER, PWD)))\n    chan = s_conn.channel()\n    chan.queue_declare(queue=TEST_QUEUE)\n    chan.basic_consume(callback,\n                       queue=TEST_QUEUE)\n\n    heartbeat = Heartbeat(s_conn)\n    heartbeat.start()          #开启心跳线程\n    heartbeat.startHeartbeat()\n    chan.start_consuming()\n\nif __name__ == \"__main__\":\n    test_main()\n```\n尝试运行，结果还是不行，不得不安静下来思考自己是不是想错了。<br>\n去看它的api，看到heartbeat_interval的解析:\n\n```\n:param int heartbeat_interval: How often to send heartbeats.\n                                  Min between this value and server's proposal\n                                  will be used. Use 0 to deactivate heartbeats\n                                  and None to accept server's proposal.\n```\n                           \n按这样说法，应该还是没有把心跳值给设置好。上面的程序期望是10秒发一次心跳，但是理论上发送心跳的间隔会比10秒多一点。所以艾玛，我应该是把*heartbeat_interval*的作用搞错了， 它是指超过这个时间间隔不发心跳或不给server任何信息，server就会断开连接, 而不是说pika会按这个间隔来发心跳。 结果我把heartbeat_interval值设置高一点(比实际发送心跳/信息的间隔更长)，比如上面设置成60秒，就正常运行了。\n\n如果不指定*heartbeat_interval*， 它默认为None， 意味着按rabbitMQ server的配置来检测心跳是否正常。<br>\n如果设置*heartbeat_interval=0*， 意味着不检测心跳，server端将不会主动断开连接。\n","slug":"python/python-pika-broken-pipe","published":1,"updated":"2017-08-19T11:20:02.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dxc002s4j4d2gyoifmu","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>在消费rabbitMQ队列时, 每次进入回调函数内需要进行一些比较耗时的操作;操作完成后给rabbitMQ server发送ack信号以dequeue本条消息。<br><br>问题就发生在发送ack操作时, 程序提示链接已被断开或socket error。<br><a id=\"more\"></a></p>\n<h2 id=\"源码示例\"><a href=\"#源码示例\" class=\"headerlink\" title=\"源码示例\"></a>源码示例</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin</span></div><div class=\"line\"><span class=\"comment\">#coding: utf-8</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> pika</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">USER = <span class=\"string\">'guest'</span></div><div class=\"line\">PWD = <span class=\"string\">'guest'</span></div><div class=\"line\">TEST_QUEUE = <span class=\"string\">'just4test'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">callback</span><span class=\"params\">(ch, method, properties, body)</span>:</span></div><div class=\"line\">    print(body)</div><div class=\"line\">    time.sleep(<span class=\"number\">600</span>)</div><div class=\"line\">    ch.basic_publish(<span class=\"string\">''</span>, routing_key=TEST_QUEUE, body=<span class=\"string\">\"fortest\"</span>)</div><div class=\"line\">    ch.basic_ack(delivery_tag = method.delivery_tag)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    s_conn = pika.BlockingConnection(</div><div class=\"line\">        pika.ConnectionParameters(<span class=\"string\">'127.0.0.1'</span>, </div><div class=\"line\">            credentials=pika.PlainCredentials(USER, PWD)))</div><div class=\"line\">    chan = s_conn.channel()</div><div class=\"line\">    chan.queue_declare(queue=TEST_QUEUE)</div><div class=\"line\"></div><div class=\"line\">    chan.basic_publish(<span class=\"string\">''</span>, routing_key=TEST_QUEUE, body=<span class=\"string\">\"fortest\"</span>)</div><div class=\"line\">    chan.basic_consume(callback, queue=TEST_QUEUE)</div><div class=\"line\">    chan.start_consuming()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    test_main()</div></pre></td></tr></table></figure>\n<p>运行一段时间后， 就会报错:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ERROR][pika.adapters.base_connection][2017-08-18 12:33:49]Error event 25, None</div><div class=\"line\">[CRITICAL][pika.adapters.base_connection][2017-08-18 12:33:49]Tried to handle an error where no error existed</div><div class=\"line\">[ERROR][pika.adapters.base_connection][2017-08-18 12:33:49]Fatal Socket Error: BrokenPipeError(32, &apos;Broken pipe&apos;)</div></pre></td></tr></table></figure>\n<h2 id=\"问题排查\"><a href=\"#问题排查\" class=\"headerlink\" title=\"问题排查\"></a>问题排查</h2><h3 id=\"猜测：pika客户端没有及时发送心跳，连接被server断开\"><a href=\"#猜测：pika客户端没有及时发送心跳，连接被server断开\" class=\"headerlink\" title=\"猜测：pika客户端没有及时发送心跳，连接被server断开\"></a>猜测：pika客户端没有及时发送心跳，连接被server断开</h3><p>一开始修改了heartbeat_interval参数值, 示例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    s_conn = pika.BlockingConnection(</div><div class=\"line\">        pika.ConnectionParameters(<span class=\"string\">'127.0.0.1'</span>, </div><div class=\"line\">            heartbeat_interval=<span class=\"number\">10</span>,</div><div class=\"line\">            socket_timeout=<span class=\"number\">5</span>,</div><div class=\"line\">            credentials=pika.PlainCredentials(USER, PWD)))</div><div class=\"line\">    <span class=\"comment\"># ....</span></div></pre></td></tr></table></figure>\n<p>修改后运行依然报错，后来想想应该单线程被一直占用，pika无法发送心跳；<br><br>于是又加了个心跳线程, 示例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin</span></div><div class=\"line\"><span class=\"comment\">#coding: utf-8</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> pika</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"><span class=\"keyword\">import</span> logging</div><div class=\"line\"><span class=\"keyword\">import</span> threading</div><div class=\"line\"></div><div class=\"line\">USER = <span class=\"string\">'guest'</span></div><div class=\"line\">PWD = <span class=\"string\">'guest'</span></div><div class=\"line\">TEST_QUEUE = <span class=\"string\">'just4test'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Heartbeat</span><span class=\"params\">(threading.Thread)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, connection)</span>:</span></div><div class=\"line\">        super(Heartbeat, self).__init__()</div><div class=\"line\">        self.lock = threading.Lock()</div><div class=\"line\">        self.connection = connection</div><div class=\"line\">        self.quitflag = <span class=\"keyword\">False</span></div><div class=\"line\">        self.stopflag = <span class=\"keyword\">True</span></div><div class=\"line\">        self.setDaemon(<span class=\"keyword\">True</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> self.quitflag:</div><div class=\"line\">            time.sleep(<span class=\"number\">10</span>)</div><div class=\"line\">            self.lock.acquire()</div><div class=\"line\">            <span class=\"keyword\">if</span> self.stopflag :</div><div class=\"line\">                self.lock.release()</div><div class=\"line\">                <span class=\"keyword\">continue</span></div><div class=\"line\">            <span class=\"keyword\">try</span>:</div><div class=\"line\">                self.connection.process_data_events()</div><div class=\"line\">            <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> ex:</div><div class=\"line\">                logging.warn(<span class=\"string\">\"Error format: %s\"</span>%(str(ex)))</div><div class=\"line\">                self.lock.release()</div><div class=\"line\">                <span class=\"keyword\">return</span></div><div class=\"line\">            self.lock.release()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">startHeartbeat</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.lock.acquire()</div><div class=\"line\">        <span class=\"keyword\">if</span> self.quitflag==<span class=\"keyword\">True</span>:</div><div class=\"line\">            self.lock.release()</div><div class=\"line\">            <span class=\"keyword\">return</span></div><div class=\"line\">        self.stopflag=<span class=\"keyword\">False</span></div><div class=\"line\">        self.lock.release()</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">callback</span><span class=\"params\">(ch, method, properties, body)</span>:</span></div><div class=\"line\">    logging.info(<span class=\"string\">\"recv_body:%s\"</span> % body)</div><div class=\"line\">    time.sleep(<span class=\"number\">600</span>)</div><div class=\"line\">    ch.basic_ack(delivery_tag = method.delivery_tag)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    s_conn = pika.BlockingConnection(</div><div class=\"line\">        pika.ConnectionParameters(<span class=\"string\">'127.0.0.1'</span>, </div><div class=\"line\">            heartbeat_interval=<span class=\"number\">10</span>,</div><div class=\"line\">            socket_timeout=<span class=\"number\">5</span>,</div><div class=\"line\">            credentials=pika.PlainCredentials(USER, PWD)))</div><div class=\"line\">    chan = s_conn.channel()</div><div class=\"line\">    chan.queue_declare(queue=TEST_QUEUE)</div><div class=\"line\">    chan.basic_consume(callback,</div><div class=\"line\">                       queue=TEST_QUEUE)</div><div class=\"line\"></div><div class=\"line\">    heartbeat = Heartbeat(s_conn)</div><div class=\"line\">    heartbeat.start()          <span class=\"comment\">#开启心跳线程</span></div><div class=\"line\">    heartbeat.startHeartbeat()</div><div class=\"line\">    chan.start_consuming()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    test_main()</div></pre></td></tr></table></figure>\n<p>尝试运行，结果还是不行，不得不安静下来思考自己是不是想错了。<br><br>去看它的api，看到heartbeat_interval的解析:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">:param int heartbeat_interval: How often to send heartbeats.</div><div class=\"line\">                                  Min between this value and server&apos;s proposal</div><div class=\"line\">                                  will be used. Use 0 to deactivate heartbeats</div><div class=\"line\">                                  and None to accept server&apos;s proposal.</div></pre></td></tr></table></figure>\n<p>按这样说法，应该还是没有把心跳值给设置好。上面的程序期望是10秒发一次心跳，但是理论上发送心跳的间隔会比10秒多一点。所以艾玛，我应该是把<em>heartbeat_interval</em>的作用搞错了， 它是指超过这个时间间隔不发心跳或不给server任何信息，server就会断开连接, 而不是说pika会按这个间隔来发心跳。 结果我把heartbeat_interval值设置高一点(比实际发送心跳/信息的间隔更长)，比如上面设置成60秒，就正常运行了。</p>\n<p>如果不指定<em>heartbeat_interval</em>， 它默认为None， 意味着按rabbitMQ server的配置来检测心跳是否正常。<br><br>如果设置<em>heartbeat_interval=0</em>， 意味着不检测心跳，server端将不会主动断开连接。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>在消费rabbitMQ队列时, 每次进入回调函数内需要进行一些比较耗时的操作;操作完成后给rabbitMQ server发送ack信号以dequeue本条消息。<br><br>问题就发生在发送ack操作时, 程序提示链接已被断开或socket error。<br>","more":"</p>\n<h2 id=\"源码示例\"><a href=\"#源码示例\" class=\"headerlink\" title=\"源码示例\"></a>源码示例</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin</span></div><div class=\"line\"><span class=\"comment\">#coding: utf-8</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> pika</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">USER = <span class=\"string\">'guest'</span></div><div class=\"line\">PWD = <span class=\"string\">'guest'</span></div><div class=\"line\">TEST_QUEUE = <span class=\"string\">'just4test'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">callback</span><span class=\"params\">(ch, method, properties, body)</span>:</span></div><div class=\"line\">    print(body)</div><div class=\"line\">    time.sleep(<span class=\"number\">600</span>)</div><div class=\"line\">    ch.basic_publish(<span class=\"string\">''</span>, routing_key=TEST_QUEUE, body=<span class=\"string\">\"fortest\"</span>)</div><div class=\"line\">    ch.basic_ack(delivery_tag = method.delivery_tag)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    s_conn = pika.BlockingConnection(</div><div class=\"line\">        pika.ConnectionParameters(<span class=\"string\">'127.0.0.1'</span>, </div><div class=\"line\">            credentials=pika.PlainCredentials(USER, PWD)))</div><div class=\"line\">    chan = s_conn.channel()</div><div class=\"line\">    chan.queue_declare(queue=TEST_QUEUE)</div><div class=\"line\"></div><div class=\"line\">    chan.basic_publish(<span class=\"string\">''</span>, routing_key=TEST_QUEUE, body=<span class=\"string\">\"fortest\"</span>)</div><div class=\"line\">    chan.basic_consume(callback, queue=TEST_QUEUE)</div><div class=\"line\">    chan.start_consuming()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    test_main()</div></pre></td></tr></table></figure>\n<p>运行一段时间后， 就会报错:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ERROR][pika.adapters.base_connection][2017-08-18 12:33:49]Error event 25, None</div><div class=\"line\">[CRITICAL][pika.adapters.base_connection][2017-08-18 12:33:49]Tried to handle an error where no error existed</div><div class=\"line\">[ERROR][pika.adapters.base_connection][2017-08-18 12:33:49]Fatal Socket Error: BrokenPipeError(32, &apos;Broken pipe&apos;)</div></pre></td></tr></table></figure>\n<h2 id=\"问题排查\"><a href=\"#问题排查\" class=\"headerlink\" title=\"问题排查\"></a>问题排查</h2><h3 id=\"猜测：pika客户端没有及时发送心跳，连接被server断开\"><a href=\"#猜测：pika客户端没有及时发送心跳，连接被server断开\" class=\"headerlink\" title=\"猜测：pika客户端没有及时发送心跳，连接被server断开\"></a>猜测：pika客户端没有及时发送心跳，连接被server断开</h3><p>一开始修改了heartbeat_interval参数值, 示例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    s_conn = pika.BlockingConnection(</div><div class=\"line\">        pika.ConnectionParameters(<span class=\"string\">'127.0.0.1'</span>, </div><div class=\"line\">            heartbeat_interval=<span class=\"number\">10</span>,</div><div class=\"line\">            socket_timeout=<span class=\"number\">5</span>,</div><div class=\"line\">            credentials=pika.PlainCredentials(USER, PWD)))</div><div class=\"line\">    <span class=\"comment\"># ....</span></div></pre></td></tr></table></figure>\n<p>修改后运行依然报错，后来想想应该单线程被一直占用，pika无法发送心跳；<br><br>于是又加了个心跳线程, 示例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin</span></div><div class=\"line\"><span class=\"comment\">#coding: utf-8</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> pika</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"><span class=\"keyword\">import</span> logging</div><div class=\"line\"><span class=\"keyword\">import</span> threading</div><div class=\"line\"></div><div class=\"line\">USER = <span class=\"string\">'guest'</span></div><div class=\"line\">PWD = <span class=\"string\">'guest'</span></div><div class=\"line\">TEST_QUEUE = <span class=\"string\">'just4test'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Heartbeat</span><span class=\"params\">(threading.Thread)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, connection)</span>:</span></div><div class=\"line\">        super(Heartbeat, self).__init__()</div><div class=\"line\">        self.lock = threading.Lock()</div><div class=\"line\">        self.connection = connection</div><div class=\"line\">        self.quitflag = <span class=\"keyword\">False</span></div><div class=\"line\">        self.stopflag = <span class=\"keyword\">True</span></div><div class=\"line\">        self.setDaemon(<span class=\"keyword\">True</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> self.quitflag:</div><div class=\"line\">            time.sleep(<span class=\"number\">10</span>)</div><div class=\"line\">            self.lock.acquire()</div><div class=\"line\">            <span class=\"keyword\">if</span> self.stopflag :</div><div class=\"line\">                self.lock.release()</div><div class=\"line\">                <span class=\"keyword\">continue</span></div><div class=\"line\">            <span class=\"keyword\">try</span>:</div><div class=\"line\">                self.connection.process_data_events()</div><div class=\"line\">            <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> ex:</div><div class=\"line\">                logging.warn(<span class=\"string\">\"Error format: %s\"</span>%(str(ex)))</div><div class=\"line\">                self.lock.release()</div><div class=\"line\">                <span class=\"keyword\">return</span></div><div class=\"line\">            self.lock.release()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">startHeartbeat</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.lock.acquire()</div><div class=\"line\">        <span class=\"keyword\">if</span> self.quitflag==<span class=\"keyword\">True</span>:</div><div class=\"line\">            self.lock.release()</div><div class=\"line\">            <span class=\"keyword\">return</span></div><div class=\"line\">        self.stopflag=<span class=\"keyword\">False</span></div><div class=\"line\">        self.lock.release()</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">callback</span><span class=\"params\">(ch, method, properties, body)</span>:</span></div><div class=\"line\">    logging.info(<span class=\"string\">\"recv_body:%s\"</span> % body)</div><div class=\"line\">    time.sleep(<span class=\"number\">600</span>)</div><div class=\"line\">    ch.basic_ack(delivery_tag = method.delivery_tag)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    s_conn = pika.BlockingConnection(</div><div class=\"line\">        pika.ConnectionParameters(<span class=\"string\">'127.0.0.1'</span>, </div><div class=\"line\">            heartbeat_interval=<span class=\"number\">10</span>,</div><div class=\"line\">            socket_timeout=<span class=\"number\">5</span>,</div><div class=\"line\">            credentials=pika.PlainCredentials(USER, PWD)))</div><div class=\"line\">    chan = s_conn.channel()</div><div class=\"line\">    chan.queue_declare(queue=TEST_QUEUE)</div><div class=\"line\">    chan.basic_consume(callback,</div><div class=\"line\">                       queue=TEST_QUEUE)</div><div class=\"line\"></div><div class=\"line\">    heartbeat = Heartbeat(s_conn)</div><div class=\"line\">    heartbeat.start()          <span class=\"comment\">#开启心跳线程</span></div><div class=\"line\">    heartbeat.startHeartbeat()</div><div class=\"line\">    chan.start_consuming()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</div><div class=\"line\">    test_main()</div></pre></td></tr></table></figure>\n<p>尝试运行，结果还是不行，不得不安静下来思考自己是不是想错了。<br><br>去看它的api，看到heartbeat_interval的解析:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">:param int heartbeat_interval: How often to send heartbeats.</div><div class=\"line\">                                  Min between this value and server&apos;s proposal</div><div class=\"line\">                                  will be used. Use 0 to deactivate heartbeats</div><div class=\"line\">                                  and None to accept server&apos;s proposal.</div></pre></td></tr></table></figure>\n<p>按这样说法，应该还是没有把心跳值给设置好。上面的程序期望是10秒发一次心跳，但是理论上发送心跳的间隔会比10秒多一点。所以艾玛，我应该是把<em>heartbeat_interval</em>的作用搞错了， 它是指超过这个时间间隔不发心跳或不给server任何信息，server就会断开连接, 而不是说pika会按这个间隔来发心跳。 结果我把heartbeat_interval值设置高一点(比实际发送心跳/信息的间隔更长)，比如上面设置成60秒，就正常运行了。</p>\n<p>如果不指定<em>heartbeat_interval</em>， 它默认为None， 意味着按rabbitMQ server的配置来检测心跳是否正常。<br><br>如果设置<em>heartbeat_interval=0</em>， 意味着不检测心跳，server端将不会主动断开连接。</p>"},{"title":"Nginx如何配置跨域(多域名)","date":"2018-10-09T01:23:58.000Z","_content":"\n假设需要允许来源为`localhost`或`.*.example.com`下所有二级域名的访问，在nginx中只需要类似这样配置即可：\n<!--more-->\n\n```nginx\n    location / {\n\t\tset $match \"\";\n\t\t# 支持http及https\n\t\tif ($http_origin ~* 'https?://(localhost|.*\\.example\\.com)') {\n\t\tset $match \"true\";\n\t\t}\n\t\t\n\t\tif ($match = \"true\") {\n\t\t\tadd_header Access-Control-Allow-Origin \"$http_origin\";\n\t\t\tadd_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';\n\t\t\tadd_header Access-Control-Allow-Methods GET,POST,OPTIONS,DELETE;\n\t\t\tadd_header Access-Control-Allow-Credentials true;\n\t\t}\n\t\t# 处理OPTIONS请求\n\t\tif ($request_method = 'OPTIONS') {\n\t\t\treturn 204;\n\t\t}\n\t}\n```\n\n当然通过正则也可以详细指定若干个允许访问的域名来源。\n","source":"_posts/ops/Nginx如何配置跨域-多域名.md","raw":"---\ntitle: Nginx如何配置跨域(多域名)\ndate: 2018-10-09 09:23:58\ntags: nginx\n---\n\n假设需要允许来源为`localhost`或`.*.example.com`下所有二级域名的访问，在nginx中只需要类似这样配置即可：\n<!--more-->\n\n```nginx\n    location / {\n\t\tset $match \"\";\n\t\t# 支持http及https\n\t\tif ($http_origin ~* 'https?://(localhost|.*\\.example\\.com)') {\n\t\tset $match \"true\";\n\t\t}\n\t\t\n\t\tif ($match = \"true\") {\n\t\t\tadd_header Access-Control-Allow-Origin \"$http_origin\";\n\t\t\tadd_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';\n\t\t\tadd_header Access-Control-Allow-Methods GET,POST,OPTIONS,DELETE;\n\t\t\tadd_header Access-Control-Allow-Credentials true;\n\t\t}\n\t\t# 处理OPTIONS请求\n\t\tif ($request_method = 'OPTIONS') {\n\t\t\treturn 204;\n\t\t}\n\t}\n```\n\n当然通过正则也可以详细指定若干个允许访问的域名来源。\n","slug":"ops/Nginx如何配置跨域-多域名","published":1,"updated":"2018-10-09T01:25:56.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dxg002u4j4dtfvn8e8p","content":"<p>假设需要允许来源为<code>localhost</code>或<code>.*.example.com</code>下所有二级域名的访问，在nginx中只需要类似这样配置即可：<br><a id=\"more\"></a></p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"attribute\">location</span> / &#123;</div><div class=\"line\">\t<span class=\"attribute\">set</span> <span class=\"variable\">$match</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">\t<span class=\"comment\"># 支持http及https</span></div><div class=\"line\">\t<span class=\"attribute\">if</span> (<span class=\"variable\">$http_origin</span> <span class=\"regexp\">~* 'https?://(localhost|.*\\.example\\.com)')</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">set</span> <span class=\"variable\">$match</span> <span class=\"string\">\"true\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"attribute\">if</span> (<span class=\"variable\">$match</span> = <span class=\"string\">\"true\"</span>) &#123;</div><div class=\"line\">\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Origin <span class=\"string\">\"<span class=\"variable\">$http_origin</span>\"</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Headers <span class=\"string\">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Methods GET,POST,OPTIONS,DELETE;</div><div class=\"line\">\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Credentials <span class=\"literal\">true</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\"># 处理OPTIONS请求</span></div><div class=\"line\">\t<span class=\"attribute\">if</span> (<span class=\"variable\">$request_method</span> = <span class=\"string\">'OPTIONS'</span>) &#123;</div><div class=\"line\">\t\t<span class=\"attribute\">return</span> <span class=\"number\">204</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当然通过正则也可以详细指定若干个允许访问的域名来源。</p>\n","site":{"data":{}},"excerpt":"<p>假设需要允许来源为<code>localhost</code>或<code>.*.example.com</code>下所有二级域名的访问，在nginx中只需要类似这样配置即可：<br>","more":"</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"attribute\">location</span> / &#123;</div><div class=\"line\">\t<span class=\"attribute\">set</span> <span class=\"variable\">$match</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">\t<span class=\"comment\"># 支持http及https</span></div><div class=\"line\">\t<span class=\"attribute\">if</span> (<span class=\"variable\">$http_origin</span> <span class=\"regexp\">~* 'https?://(localhost|.*\\.example\\.com)')</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">set</span> <span class=\"variable\">$match</span> <span class=\"string\">\"true\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"attribute\">if</span> (<span class=\"variable\">$match</span> = <span class=\"string\">\"true\"</span>) &#123;</div><div class=\"line\">\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Origin <span class=\"string\">\"<span class=\"variable\">$http_origin</span>\"</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Headers <span class=\"string\">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Methods GET,POST,OPTIONS,DELETE;</div><div class=\"line\">\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Credentials <span class=\"literal\">true</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\"># 处理OPTIONS请求</span></div><div class=\"line\">\t<span class=\"attribute\">if</span> (<span class=\"variable\">$request_method</span> = <span class=\"string\">'OPTIONS'</span>) &#123;</div><div class=\"line\">\t\t<span class=\"attribute\">return</span> <span class=\"number\">204</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当然通过正则也可以详细指定若干个允许访问的域名来源。</p>"},{"title":"[Golang]另一角度理解goroutine","date":"2017-11-10T02:01:11.000Z","_content":"\n\n偶然看到一条关于goroutine有趣的QA：\nhttps://news.ycombinator.com/item?id=12459841\n发现可以以另一种方式来理解goroutine，欢迎拍砖。\n\n关键概念说明:\n```\nM: machine， M对应于内核线程;\nP: processor, P是一种在M上运行的context, 维护了goroutine的列表;\nG: goroutine核心结构, 维护了goroutine需要的栈、程序计数器以及所在的M等信息;\nsysmon: GO程序启动时创建的一个用于监控管理的线程。\n```\n<!--more-->\n\n#### 假设一开始没有M和P, 没有sysmon, 同时GOMAXPROCS=1\n\n这个时候go程序以单线程模式运行，\n每次执行一个G, 无法做到抢占，而必须由程序自己yield来让出CPU，\n让出CPU时当前G需要将相关上下文信息保存到自己的结构中，\n然后程序查找下一个等待的G并执行。\n\n遇到systemcall时, 当前线程会新开一个线程用以接管执行之后的G，\n而当前线程会阻塞知道系统调用返回， \n之后将返回结果保存到某个地方，\n最后该线程退出。\n\n#### 加入M，减少线程创建/销毁消耗，GOMAXPROCS=1不变\n\n上面的主要问题是单线程执行任务，\n遇到syscall便会在创建/销毁线程操作中消耗很多资源，\n所以这时我们想复用线程。\n\n这里我们加入了一定数量的M，每个M对应一个内核线程，\n由于GOMAXPROCS=1，同时在跑的M只有一个，其他的在sleep。\n与上面有所改进的是，\n如果当前M遇到syscall，它不用新创建一个线程，\n而是唤醒M列表中的某个M来接管执行之后的G就可以了，\n而自己负责等待系统调用，\n系统调用返回后将结果写到某个地方便sleep及等待唤醒。\n\n#### 加入调度锁，支持多线程并发，GOMAXPROCS>1\n\n上面的场景还是同时只有一个线程在运行，\n我们想利用多核同时跑几个线程，\n那应该怎么做呢？\n\n我们加入一个叫调度锁的东西，\n用于解决多线程从G列表争抢资源G发生冲突的场景，\n设置GOMAXPROCS>1, 这时可以最多同时跑GOMAXPROCS个线程。\n调度锁是一个全局锁，如果资源上锁了，那所有线程都必须等待。\n这时M数量>=GOMAXPROCS, 同时在跑的M数量==GOMAXPROCS。\n\n#### 加入P，提高并发性能\n\n上面使用了调度锁，虽然解决了多线程并发问题，\n但是由于是对列表G全局加锁，并发性能并不好。\n\n这时我们加入了P，将结构关系G:M变为了G:P:M。\n每一个M对应一个P， 而每个P维护了一个G列表，\n这时每新建一个G，会按某种顺序加到某个P的G队列末尾。\n这个时候不再用全局锁了，M也不用每次到全局G队列中争抢G，\n只需要从P的G队列中拿出一个就绪的G运行即可。\n\n同样如果一个M进入syscall，\n它会释放P以允许其他M来接管自己的P及P所维护的G队列，\n自己等待系统调用返回并保存结果后，\n进入M的空闲队列并等待唤醒。\n\n#### 加入sysmon，解决阻塞syscall问题\n\n像上面提到的，当一个M进入syscall而释放P时具体怎么实现呢？\n\n这里引入了sysmon这个在Go程序启动时就会创建的一个独立线程，\n它用于任务的监控和管理， 内部就是一个无限循环，\n它发现如果有M处于syscall状态时便将它的P及对P上的G队列抢过来，\n放到其他可用的M上运行(有可能需要新建M， 也可能是唤醒某个sleep的M)。\n\n#### 负载均衡问题\n\n如果有些M很快把手头上的G消耗完，而有些挤压了很多，\n那就会出现负载不均衡，有些任务响应太迟的问题。\n\n所以goroutine有了这么一个调度机制(stealing work)，\n当当前M发现所绑定的P上的G没有了，\n它会去尝试从全局runqueue中获取一部分G任务，\n如果全局runqueue也没有，那么就去其他M上'抢夺'一些G过来执行，\n每次大概是抢对方队列G的一半数量。\n如果最后发现没有哪个M可以'抢夺'的G任务，\n那就将自己加到M空闲队列并进入sleep状态。\n\n------------------------\n至此，很粗略的概括了goroutine的协作式调度原理。\n","source":"_posts/golang/a-way-to-understand-goroutine.md","raw":"---\ntitle: '[Golang]另一角度理解goroutine'\ndate: 2017-11-10 10:01:11\ntags: golang\n---\n\n\n偶然看到一条关于goroutine有趣的QA：\nhttps://news.ycombinator.com/item?id=12459841\n发现可以以另一种方式来理解goroutine，欢迎拍砖。\n\n关键概念说明:\n```\nM: machine， M对应于内核线程;\nP: processor, P是一种在M上运行的context, 维护了goroutine的列表;\nG: goroutine核心结构, 维护了goroutine需要的栈、程序计数器以及所在的M等信息;\nsysmon: GO程序启动时创建的一个用于监控管理的线程。\n```\n<!--more-->\n\n#### 假设一开始没有M和P, 没有sysmon, 同时GOMAXPROCS=1\n\n这个时候go程序以单线程模式运行，\n每次执行一个G, 无法做到抢占，而必须由程序自己yield来让出CPU，\n让出CPU时当前G需要将相关上下文信息保存到自己的结构中，\n然后程序查找下一个等待的G并执行。\n\n遇到systemcall时, 当前线程会新开一个线程用以接管执行之后的G，\n而当前线程会阻塞知道系统调用返回， \n之后将返回结果保存到某个地方，\n最后该线程退出。\n\n#### 加入M，减少线程创建/销毁消耗，GOMAXPROCS=1不变\n\n上面的主要问题是单线程执行任务，\n遇到syscall便会在创建/销毁线程操作中消耗很多资源，\n所以这时我们想复用线程。\n\n这里我们加入了一定数量的M，每个M对应一个内核线程，\n由于GOMAXPROCS=1，同时在跑的M只有一个，其他的在sleep。\n与上面有所改进的是，\n如果当前M遇到syscall，它不用新创建一个线程，\n而是唤醒M列表中的某个M来接管执行之后的G就可以了，\n而自己负责等待系统调用，\n系统调用返回后将结果写到某个地方便sleep及等待唤醒。\n\n#### 加入调度锁，支持多线程并发，GOMAXPROCS>1\n\n上面的场景还是同时只有一个线程在运行，\n我们想利用多核同时跑几个线程，\n那应该怎么做呢？\n\n我们加入一个叫调度锁的东西，\n用于解决多线程从G列表争抢资源G发生冲突的场景，\n设置GOMAXPROCS>1, 这时可以最多同时跑GOMAXPROCS个线程。\n调度锁是一个全局锁，如果资源上锁了，那所有线程都必须等待。\n这时M数量>=GOMAXPROCS, 同时在跑的M数量==GOMAXPROCS。\n\n#### 加入P，提高并发性能\n\n上面使用了调度锁，虽然解决了多线程并发问题，\n但是由于是对列表G全局加锁，并发性能并不好。\n\n这时我们加入了P，将结构关系G:M变为了G:P:M。\n每一个M对应一个P， 而每个P维护了一个G列表，\n这时每新建一个G，会按某种顺序加到某个P的G队列末尾。\n这个时候不再用全局锁了，M也不用每次到全局G队列中争抢G，\n只需要从P的G队列中拿出一个就绪的G运行即可。\n\n同样如果一个M进入syscall，\n它会释放P以允许其他M来接管自己的P及P所维护的G队列，\n自己等待系统调用返回并保存结果后，\n进入M的空闲队列并等待唤醒。\n\n#### 加入sysmon，解决阻塞syscall问题\n\n像上面提到的，当一个M进入syscall而释放P时具体怎么实现呢？\n\n这里引入了sysmon这个在Go程序启动时就会创建的一个独立线程，\n它用于任务的监控和管理， 内部就是一个无限循环，\n它发现如果有M处于syscall状态时便将它的P及对P上的G队列抢过来，\n放到其他可用的M上运行(有可能需要新建M， 也可能是唤醒某个sleep的M)。\n\n#### 负载均衡问题\n\n如果有些M很快把手头上的G消耗完，而有些挤压了很多，\n那就会出现负载不均衡，有些任务响应太迟的问题。\n\n所以goroutine有了这么一个调度机制(stealing work)，\n当当前M发现所绑定的P上的G没有了，\n它会去尝试从全局runqueue中获取一部分G任务，\n如果全局runqueue也没有，那么就去其他M上'抢夺'一些G过来执行，\n每次大概是抢对方队列G的一半数量。\n如果最后发现没有哪个M可以'抢夺'的G任务，\n那就将自己加到M空闲队列并进入sleep状态。\n\n------------------------\n至此，很粗略的概括了goroutine的协作式调度原理。\n","slug":"golang/a-way-to-understand-goroutine","published":1,"updated":"2017-11-10T02:02:46.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dxi002x4j4dcd7r49q6","content":"<p>偶然看到一条关于goroutine有趣的QA：<br><a href=\"https://news.ycombinator.com/item?id=12459841\" target=\"_blank\" rel=\"external\">https://news.ycombinator.com/item?id=12459841</a><br>发现可以以另一种方式来理解goroutine，欢迎拍砖。</p>\n<p>关键概念说明:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">M: machine， M对应于内核线程;</div><div class=\"line\">P: processor, P是一种在M上运行的context, 维护了goroutine的列表;</div><div class=\"line\">G: goroutine核心结构, 维护了goroutine需要的栈、程序计数器以及所在的M等信息;</div><div class=\"line\">sysmon: GO程序启动时创建的一个用于监控管理的线程。</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h4 id=\"假设一开始没有M和P-没有sysmon-同时GOMAXPROCS-1\"><a href=\"#假设一开始没有M和P-没有sysmon-同时GOMAXPROCS-1\" class=\"headerlink\" title=\"假设一开始没有M和P, 没有sysmon, 同时GOMAXPROCS=1\"></a>假设一开始没有M和P, 没有sysmon, 同时GOMAXPROCS=1</h4><p>这个时候go程序以单线程模式运行，<br>每次执行一个G, 无法做到抢占，而必须由程序自己yield来让出CPU，<br>让出CPU时当前G需要将相关上下文信息保存到自己的结构中，<br>然后程序查找下一个等待的G并执行。</p>\n<p>遇到systemcall时, 当前线程会新开一个线程用以接管执行之后的G，<br>而当前线程会阻塞知道系统调用返回，<br>之后将返回结果保存到某个地方，<br>最后该线程退出。</p>\n<h4 id=\"加入M，减少线程创建-销毁消耗，GOMAXPROCS-1不变\"><a href=\"#加入M，减少线程创建-销毁消耗，GOMAXPROCS-1不变\" class=\"headerlink\" title=\"加入M，减少线程创建/销毁消耗，GOMAXPROCS=1不变\"></a>加入M，减少线程创建/销毁消耗，GOMAXPROCS=1不变</h4><p>上面的主要问题是单线程执行任务，<br>遇到syscall便会在创建/销毁线程操作中消耗很多资源，<br>所以这时我们想复用线程。</p>\n<p>这里我们加入了一定数量的M，每个M对应一个内核线程，<br>由于GOMAXPROCS=1，同时在跑的M只有一个，其他的在sleep。<br>与上面有所改进的是，<br>如果当前M遇到syscall，它不用新创建一个线程，<br>而是唤醒M列表中的某个M来接管执行之后的G就可以了，<br>而自己负责等待系统调用，<br>系统调用返回后将结果写到某个地方便sleep及等待唤醒。</p>\n<h4 id=\"加入调度锁，支持多线程并发，GOMAXPROCS-gt-1\"><a href=\"#加入调度锁，支持多线程并发，GOMAXPROCS-gt-1\" class=\"headerlink\" title=\"加入调度锁，支持多线程并发，GOMAXPROCS&gt;1\"></a>加入调度锁，支持多线程并发，GOMAXPROCS&gt;1</h4><p>上面的场景还是同时只有一个线程在运行，<br>我们想利用多核同时跑几个线程，<br>那应该怎么做呢？</p>\n<p>我们加入一个叫调度锁的东西，<br>用于解决多线程从G列表争抢资源G发生冲突的场景，<br>设置GOMAXPROCS&gt;1, 这时可以最多同时跑GOMAXPROCS个线程。<br>调度锁是一个全局锁，如果资源上锁了，那所有线程都必须等待。<br>这时M数量&gt;=GOMAXPROCS, 同时在跑的M数量==GOMAXPROCS。</p>\n<h4 id=\"加入P，提高并发性能\"><a href=\"#加入P，提高并发性能\" class=\"headerlink\" title=\"加入P，提高并发性能\"></a>加入P，提高并发性能</h4><p>上面使用了调度锁，虽然解决了多线程并发问题，<br>但是由于是对列表G全局加锁，并发性能并不好。</p>\n<p>这时我们加入了P，将结构关系G:M变为了G:P:M。<br>每一个M对应一个P， 而每个P维护了一个G列表，<br>这时每新建一个G，会按某种顺序加到某个P的G队列末尾。<br>这个时候不再用全局锁了，M也不用每次到全局G队列中争抢G，<br>只需要从P的G队列中拿出一个就绪的G运行即可。</p>\n<p>同样如果一个M进入syscall，<br>它会释放P以允许其他M来接管自己的P及P所维护的G队列，<br>自己等待系统调用返回并保存结果后，<br>进入M的空闲队列并等待唤醒。</p>\n<h4 id=\"加入sysmon，解决阻塞syscall问题\"><a href=\"#加入sysmon，解决阻塞syscall问题\" class=\"headerlink\" title=\"加入sysmon，解决阻塞syscall问题\"></a>加入sysmon，解决阻塞syscall问题</h4><p>像上面提到的，当一个M进入syscall而释放P时具体怎么实现呢？</p>\n<p>这里引入了sysmon这个在Go程序启动时就会创建的一个独立线程，<br>它用于任务的监控和管理， 内部就是一个无限循环，<br>它发现如果有M处于syscall状态时便将它的P及对P上的G队列抢过来，<br>放到其他可用的M上运行(有可能需要新建M， 也可能是唤醒某个sleep的M)。</p>\n<h4 id=\"负载均衡问题\"><a href=\"#负载均衡问题\" class=\"headerlink\" title=\"负载均衡问题\"></a>负载均衡问题</h4><p>如果有些M很快把手头上的G消耗完，而有些挤压了很多，<br>那就会出现负载不均衡，有些任务响应太迟的问题。</p>\n<p>所以goroutine有了这么一个调度机制(stealing work)，<br>当当前M发现所绑定的P上的G没有了，<br>它会去尝试从全局runqueue中获取一部分G任务，<br>如果全局runqueue也没有，那么就去其他M上’抢夺’一些G过来执行，<br>每次大概是抢对方队列G的一半数量。<br>如果最后发现没有哪个M可以’抢夺’的G任务，<br>那就将自己加到M空闲队列并进入sleep状态。</p>\n<hr>\n<p>至此，很粗略的概括了goroutine的协作式调度原理。</p>\n","site":{"data":{}},"excerpt":"<p>偶然看到一条关于goroutine有趣的QA：<br><a href=\"https://news.ycombinator.com/item?id=12459841\" target=\"_blank\" rel=\"external\">https://news.ycombinator.com/item?id=12459841</a><br>发现可以以另一种方式来理解goroutine，欢迎拍砖。</p>\n<p>关键概念说明:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">M: machine， M对应于内核线程;</div><div class=\"line\">P: processor, P是一种在M上运行的context, 维护了goroutine的列表;</div><div class=\"line\">G: goroutine核心结构, 维护了goroutine需要的栈、程序计数器以及所在的M等信息;</div><div class=\"line\">sysmon: GO程序启动时创建的一个用于监控管理的线程。</div></pre></td></tr></table></figure></p>","more":"<h4 id=\"假设一开始没有M和P-没有sysmon-同时GOMAXPROCS-1\"><a href=\"#假设一开始没有M和P-没有sysmon-同时GOMAXPROCS-1\" class=\"headerlink\" title=\"假设一开始没有M和P, 没有sysmon, 同时GOMAXPROCS=1\"></a>假设一开始没有M和P, 没有sysmon, 同时GOMAXPROCS=1</h4><p>这个时候go程序以单线程模式运行，<br>每次执行一个G, 无法做到抢占，而必须由程序自己yield来让出CPU，<br>让出CPU时当前G需要将相关上下文信息保存到自己的结构中，<br>然后程序查找下一个等待的G并执行。</p>\n<p>遇到systemcall时, 当前线程会新开一个线程用以接管执行之后的G，<br>而当前线程会阻塞知道系统调用返回，<br>之后将返回结果保存到某个地方，<br>最后该线程退出。</p>\n<h4 id=\"加入M，减少线程创建-销毁消耗，GOMAXPROCS-1不变\"><a href=\"#加入M，减少线程创建-销毁消耗，GOMAXPROCS-1不变\" class=\"headerlink\" title=\"加入M，减少线程创建/销毁消耗，GOMAXPROCS=1不变\"></a>加入M，减少线程创建/销毁消耗，GOMAXPROCS=1不变</h4><p>上面的主要问题是单线程执行任务，<br>遇到syscall便会在创建/销毁线程操作中消耗很多资源，<br>所以这时我们想复用线程。</p>\n<p>这里我们加入了一定数量的M，每个M对应一个内核线程，<br>由于GOMAXPROCS=1，同时在跑的M只有一个，其他的在sleep。<br>与上面有所改进的是，<br>如果当前M遇到syscall，它不用新创建一个线程，<br>而是唤醒M列表中的某个M来接管执行之后的G就可以了，<br>而自己负责等待系统调用，<br>系统调用返回后将结果写到某个地方便sleep及等待唤醒。</p>\n<h4 id=\"加入调度锁，支持多线程并发，GOMAXPROCS-gt-1\"><a href=\"#加入调度锁，支持多线程并发，GOMAXPROCS-gt-1\" class=\"headerlink\" title=\"加入调度锁，支持多线程并发，GOMAXPROCS&gt;1\"></a>加入调度锁，支持多线程并发，GOMAXPROCS&gt;1</h4><p>上面的场景还是同时只有一个线程在运行，<br>我们想利用多核同时跑几个线程，<br>那应该怎么做呢？</p>\n<p>我们加入一个叫调度锁的东西，<br>用于解决多线程从G列表争抢资源G发生冲突的场景，<br>设置GOMAXPROCS&gt;1, 这时可以最多同时跑GOMAXPROCS个线程。<br>调度锁是一个全局锁，如果资源上锁了，那所有线程都必须等待。<br>这时M数量&gt;=GOMAXPROCS, 同时在跑的M数量==GOMAXPROCS。</p>\n<h4 id=\"加入P，提高并发性能\"><a href=\"#加入P，提高并发性能\" class=\"headerlink\" title=\"加入P，提高并发性能\"></a>加入P，提高并发性能</h4><p>上面使用了调度锁，虽然解决了多线程并发问题，<br>但是由于是对列表G全局加锁，并发性能并不好。</p>\n<p>这时我们加入了P，将结构关系G:M变为了G:P:M。<br>每一个M对应一个P， 而每个P维护了一个G列表，<br>这时每新建一个G，会按某种顺序加到某个P的G队列末尾。<br>这个时候不再用全局锁了，M也不用每次到全局G队列中争抢G，<br>只需要从P的G队列中拿出一个就绪的G运行即可。</p>\n<p>同样如果一个M进入syscall，<br>它会释放P以允许其他M来接管自己的P及P所维护的G队列，<br>自己等待系统调用返回并保存结果后，<br>进入M的空闲队列并等待唤醒。</p>\n<h4 id=\"加入sysmon，解决阻塞syscall问题\"><a href=\"#加入sysmon，解决阻塞syscall问题\" class=\"headerlink\" title=\"加入sysmon，解决阻塞syscall问题\"></a>加入sysmon，解决阻塞syscall问题</h4><p>像上面提到的，当一个M进入syscall而释放P时具体怎么实现呢？</p>\n<p>这里引入了sysmon这个在Go程序启动时就会创建的一个独立线程，<br>它用于任务的监控和管理， 内部就是一个无限循环，<br>它发现如果有M处于syscall状态时便将它的P及对P上的G队列抢过来，<br>放到其他可用的M上运行(有可能需要新建M， 也可能是唤醒某个sleep的M)。</p>\n<h4 id=\"负载均衡问题\"><a href=\"#负载均衡问题\" class=\"headerlink\" title=\"负载均衡问题\"></a>负载均衡问题</h4><p>如果有些M很快把手头上的G消耗完，而有些挤压了很多，<br>那就会出现负载不均衡，有些任务响应太迟的问题。</p>\n<p>所以goroutine有了这么一个调度机制(stealing work)，<br>当当前M发现所绑定的P上的G没有了，<br>它会去尝试从全局runqueue中获取一部分G任务，<br>如果全局runqueue也没有，那么就去其他M上’抢夺’一些G过来执行，<br>每次大概是抢对方队列G的一半数量。<br>如果最后发现没有哪个M可以’抢夺’的G任务，<br>那就将自己加到M空闲队列并进入sleep状态。</p>\n<hr>\n<p>至此，很粗略的概括了goroutine的协作式调度原理。</p>"},{"title":"[golang]json-rpc","date":"2016-03-12T10:09:09.000Z","_content":"\n#### 关于JSON-RPC\nJSON-RPC是一个远程调用协议, 还是轻量级的, 简单易用。\n在请求远程调用的时候, 我们可以这样定义请求体:\n```json\n{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"login\",\n    \"params\": {\"name\":\"momo\", \"passwd\":\"xxxxxx\"},\n    \"id\": 0\n}\n```\n<!--more-->\n关于其中几个参数, 有如下说明:\n```\njsonrpc: 协议的版本号(1.0版本是不带该参数, 2.0版带该参数并且值为\"2.0\")\nmethod:  所要调用的方法名\nparams:  所调用方法接收的参数(/列表)\nid:      当次请求的标识码(服务端响应体内应包含相同的id)\n```\n更详细的说明, 可以参考这里: http://wiki.geekdream.com/Specification/json-rpc_2.0.html\n\n#### Golang JSON-RPC\n\ngolang中有rpc包:<br>\n***net/rpc*** <br>实现了最基本的rpc调用，默认通过HTTP协议传输gob数据来实现远程调用。<br>\n***net/rpc/jsonrpc*** <br>实现了JSON-RPC协议， 也就实现了对json数据的序列化和反序列化。\n\n- 服务端示例\n\n```golang\npackage main\n\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"net\"\n\t\"net/rpc\"\n\t\"net/rpc/jsonrpc\"\n)\n\n// RpcObj和ReplyObj为服务端/客户端之间传输的数据结构体\n// C/S双方都能处理这两个数据类型\ntype RpcObj struct {\n\tA, B int\n}\n\ntype ReplyObj struct {\n\tC int\n}\n\ntype Arith int\n\n// 服务端的响应结构体\ntype ArithAddResp struct {\n\tId     interface{} `json:\"id\"`\n\tResult ReplyObj    `json:\"result\"`\n\tError  interface{} `json:\"error\"`\n}\n\n// 符合 func (t T) funname(t1 *T1, t2 *T2) error 类型的方法都可以注册到rpc中\nfunc (t *Arith) Add(args *RpcObj, reply *ReplyObj) error {\n\treply.C = args.A + args.B\n\treturn nil\n}\n\nfunc (t *Arith) Mul(args *RpcObj, reply *ReplyObj) error {\n\treply.C = args.A * args.B\n\treturn nil\n}\n\nfunc (t *Arith) Div(args *RpcObj, reply *ReplyObj) error {\n\tif args.B == 0 {\n\t\treturn errors.New(\"divide by zero\")\n\t}\n\treply.C = args.A / args.B\n\treturn nil\n}\n\nfunc (t *Arith) Error(args *RpcObj, reply *ReplyObj) error {\n\tpanic(\"ERROR\")\n}\n\nfunc main() {\n\tarith := new(Arith)\n\t// 新建rpc server\n\tserver := rpc.NewServer()\n\t// 注册handler处理器\n\tserver.Register(arith)\n\t// 监听8080端口\n\tl, e := net.Listen(\"tcp\", \":8080\")\n\tif e != nil {\n\t\tlog.Fatal(\"listen error:\", e)\n\t}\n\n\tlog.Println(\"RPC server started...\")\n\tfor {\n\t\t// 接收客户端请求\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// 在goroutine中处理请求\n\t\t// 通过http.Conn创建一个jsonrpc编码器, 并将其传递到rpc编码器\n\t\tgo server.ServeCodec(jsonrpc.NewServerCodec(conn))\n\t}\n\tlog.Println(\"RPC server is shutdown...\")\n}\n\n```\n\n- 客户端示例\n\n```golang\npackage main\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"net/rpc/jsonrpc\"\n)\n\ntype RpcObj struct {\n\tA, B int\n}\n\ntype ReplyObj struct {\n\tC int\n}\n\ntype Arith int\n\ntype ArithAddResp struct {\n\tId     interface{} `json:\"id\"`\n\tResult ReplyObj    `json:\"result\"`\n\tError  interface{} `json:\"error\"`\n}\n\nfunc main() {\n\tconn, err := net.Dial(\"tcp\", \"localhost:8080\")\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\tc := jsonrpc.NewClient(conn)\n\n\tvar reply ReplyObj\n\tvar args *RpcObj\n\tfor i := 5; i >= 0; i-- {\n\t\t// 往RPC调用传递参数\n\t\targs = &RpcObj{5, i}\n\n\t\t// 远程调用Arith.Mul方法\n\t\terr = c.Call(\"Arith.Mul\", args, &reply)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Exited as arith error:\", err)\n\t\t}\n\t\tlog.Printf(\"Arith: %d * %d = %v\\n\", args.A, args.B, reply.C)\n\n\t\t// 远程调用Arith.Div方法\n\t\terr = c.Call(\"Arith.Div\", args, &reply)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Exited as arith error:\", err)\n\t\t}\n\t\tlog.Printf(\"Arith: %d / %d = %v\\n\", args.A, args.B, reply.C)\n\n\t\t// 华丽的分割线\n\t\tlog.Printf(\"\\033[33m%s\\033[m\\n\", \"---------------\")\n\t}\n}\n```\n\n- 示例效果\n\n```bash\nroot@XIAOMO:/data/apps/demo# go run rpccli.go\n2016/03/28 16:17:41 Arith: 5 * 5 = 25\n2016/03/28 16:17:41 Arith: 5 / 5 = 1\n2016/03/28 16:17:41 ---------------\n2016/03/28 16:17:41 Arith: 5 * 4 = 20\n2016/03/28 16:17:41 Arith: 5 / 4 = 1\n2016/03/28 16:17:41 ---------------\n2016/03/28 16:17:41 Arith: 5 * 3 = 15\n2016/03/28 16:17:41 Arith: 5 / 3 = 1\n2016/03/28 16:17:41 ---------------\n2016/03/28 16:17:41 Arith: 5 * 2 = 10\n2016/03/28 16:17:41 Arith: 5 / 2 = 2\n2016/03/28 16:17:41 ---------------\n2016/03/28 16:17:41 Arith: 5 * 1 = 5\n2016/03/28 16:17:41 Arith: 5 / 1 = 5\n2016/03/28 16:17:41 ---------------\n2016/03/28 16:17:41 Arith: 5 * 0 = 0\n2016/03/28 16:17:41 Exited as arith error:divide by zero\nexit status 1\n```\n","source":"_posts/golang/golang-json-rpc.md","raw":"---\ntitle: '[golang]json-rpc'\ndate: 2016-03-12 18:09:09\ntags: golang\n---\n\n#### 关于JSON-RPC\nJSON-RPC是一个远程调用协议, 还是轻量级的, 简单易用。\n在请求远程调用的时候, 我们可以这样定义请求体:\n```json\n{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"login\",\n    \"params\": {\"name\":\"momo\", \"passwd\":\"xxxxxx\"},\n    \"id\": 0\n}\n```\n<!--more-->\n关于其中几个参数, 有如下说明:\n```\njsonrpc: 协议的版本号(1.0版本是不带该参数, 2.0版带该参数并且值为\"2.0\")\nmethod:  所要调用的方法名\nparams:  所调用方法接收的参数(/列表)\nid:      当次请求的标识码(服务端响应体内应包含相同的id)\n```\n更详细的说明, 可以参考这里: http://wiki.geekdream.com/Specification/json-rpc_2.0.html\n\n#### Golang JSON-RPC\n\ngolang中有rpc包:<br>\n***net/rpc*** <br>实现了最基本的rpc调用，默认通过HTTP协议传输gob数据来实现远程调用。<br>\n***net/rpc/jsonrpc*** <br>实现了JSON-RPC协议， 也就实现了对json数据的序列化和反序列化。\n\n- 服务端示例\n\n```golang\npackage main\n\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"net\"\n\t\"net/rpc\"\n\t\"net/rpc/jsonrpc\"\n)\n\n// RpcObj和ReplyObj为服务端/客户端之间传输的数据结构体\n// C/S双方都能处理这两个数据类型\ntype RpcObj struct {\n\tA, B int\n}\n\ntype ReplyObj struct {\n\tC int\n}\n\ntype Arith int\n\n// 服务端的响应结构体\ntype ArithAddResp struct {\n\tId     interface{} `json:\"id\"`\n\tResult ReplyObj    `json:\"result\"`\n\tError  interface{} `json:\"error\"`\n}\n\n// 符合 func (t T) funname(t1 *T1, t2 *T2) error 类型的方法都可以注册到rpc中\nfunc (t *Arith) Add(args *RpcObj, reply *ReplyObj) error {\n\treply.C = args.A + args.B\n\treturn nil\n}\n\nfunc (t *Arith) Mul(args *RpcObj, reply *ReplyObj) error {\n\treply.C = args.A * args.B\n\treturn nil\n}\n\nfunc (t *Arith) Div(args *RpcObj, reply *ReplyObj) error {\n\tif args.B == 0 {\n\t\treturn errors.New(\"divide by zero\")\n\t}\n\treply.C = args.A / args.B\n\treturn nil\n}\n\nfunc (t *Arith) Error(args *RpcObj, reply *ReplyObj) error {\n\tpanic(\"ERROR\")\n}\n\nfunc main() {\n\tarith := new(Arith)\n\t// 新建rpc server\n\tserver := rpc.NewServer()\n\t// 注册handler处理器\n\tserver.Register(arith)\n\t// 监听8080端口\n\tl, e := net.Listen(\"tcp\", \":8080\")\n\tif e != nil {\n\t\tlog.Fatal(\"listen error:\", e)\n\t}\n\n\tlog.Println(\"RPC server started...\")\n\tfor {\n\t\t// 接收客户端请求\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// 在goroutine中处理请求\n\t\t// 通过http.Conn创建一个jsonrpc编码器, 并将其传递到rpc编码器\n\t\tgo server.ServeCodec(jsonrpc.NewServerCodec(conn))\n\t}\n\tlog.Println(\"RPC server is shutdown...\")\n}\n\n```\n\n- 客户端示例\n\n```golang\npackage main\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"net/rpc/jsonrpc\"\n)\n\ntype RpcObj struct {\n\tA, B int\n}\n\ntype ReplyObj struct {\n\tC int\n}\n\ntype Arith int\n\ntype ArithAddResp struct {\n\tId     interface{} `json:\"id\"`\n\tResult ReplyObj    `json:\"result\"`\n\tError  interface{} `json:\"error\"`\n}\n\nfunc main() {\n\tconn, err := net.Dial(\"tcp\", \"localhost:8080\")\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\tc := jsonrpc.NewClient(conn)\n\n\tvar reply ReplyObj\n\tvar args *RpcObj\n\tfor i := 5; i >= 0; i-- {\n\t\t// 往RPC调用传递参数\n\t\targs = &RpcObj{5, i}\n\n\t\t// 远程调用Arith.Mul方法\n\t\terr = c.Call(\"Arith.Mul\", args, &reply)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Exited as arith error:\", err)\n\t\t}\n\t\tlog.Printf(\"Arith: %d * %d = %v\\n\", args.A, args.B, reply.C)\n\n\t\t// 远程调用Arith.Div方法\n\t\terr = c.Call(\"Arith.Div\", args, &reply)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Exited as arith error:\", err)\n\t\t}\n\t\tlog.Printf(\"Arith: %d / %d = %v\\n\", args.A, args.B, reply.C)\n\n\t\t// 华丽的分割线\n\t\tlog.Printf(\"\\033[33m%s\\033[m\\n\", \"---------------\")\n\t}\n}\n```\n\n- 示例效果\n\n```bash\nroot@XIAOMO:/data/apps/demo# go run rpccli.go\n2016/03/28 16:17:41 Arith: 5 * 5 = 25\n2016/03/28 16:17:41 Arith: 5 / 5 = 1\n2016/03/28 16:17:41 ---------------\n2016/03/28 16:17:41 Arith: 5 * 4 = 20\n2016/03/28 16:17:41 Arith: 5 / 4 = 1\n2016/03/28 16:17:41 ---------------\n2016/03/28 16:17:41 Arith: 5 * 3 = 15\n2016/03/28 16:17:41 Arith: 5 / 3 = 1\n2016/03/28 16:17:41 ---------------\n2016/03/28 16:17:41 Arith: 5 * 2 = 10\n2016/03/28 16:17:41 Arith: 5 / 2 = 2\n2016/03/28 16:17:41 ---------------\n2016/03/28 16:17:41 Arith: 5 * 1 = 5\n2016/03/28 16:17:41 Arith: 5 / 1 = 5\n2016/03/28 16:17:41 ---------------\n2016/03/28 16:17:41 Arith: 5 * 0 = 0\n2016/03/28 16:17:41 Exited as arith error:divide by zero\nexit status 1\n```\n","slug":"golang/golang-json-rpc","published":1,"updated":"2017-08-10T10:10:16.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dxj002z4j4d0ekjjzjl","content":"<h4 id=\"关于JSON-RPC\"><a href=\"#关于JSON-RPC\" class=\"headerlink\" title=\"关于JSON-RPC\"></a>关于JSON-RPC</h4><p>JSON-RPC是一个远程调用协议, 还是轻量级的, 简单易用。<br>在请求远程调用的时候, 我们可以这样定义请求体:<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"jsonrpc\"</span>: <span class=\"string\">\"2.0\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"method\"</span>: <span class=\"string\">\"login\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"params\"</span>: &#123;<span class=\"attr\">\"name\"</span>:<span class=\"string\">\"momo\"</span>, <span class=\"attr\">\"passwd\"</span>:<span class=\"string\">\"xxxxxx\"</span>&#125;,</div><div class=\"line\">    <span class=\"attr\">\"id\"</span>: <span class=\"number\">0</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>关于其中几个参数, 有如下说明:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">jsonrpc: 协议的版本号(1.0版本是不带该参数, 2.0版带该参数并且值为&quot;2.0&quot;)</div><div class=\"line\">method:  所要调用的方法名</div><div class=\"line\">params:  所调用方法接收的参数(/列表)</div><div class=\"line\">id:      当次请求的标识码(服务端响应体内应包含相同的id)</div></pre></td></tr></table></figure></p>\n<p>更详细的说明, 可以参考这里: <a href=\"http://wiki.geekdream.com/Specification/json-rpc_2.0.html\" target=\"_blank\" rel=\"external\">http://wiki.geekdream.com/Specification/json-rpc_2.0.html</a></p>\n<h4 id=\"Golang-JSON-RPC\"><a href=\"#Golang-JSON-RPC\" class=\"headerlink\" title=\"Golang JSON-RPC\"></a>Golang JSON-RPC</h4><p>golang中有rpc包:<br><br><strong><em>net/rpc</em></strong> <br>实现了最基本的rpc调用，默认通过HTTP协议传输gob数据来实现远程调用。<br><br><strong><em>net/rpc/jsonrpc</em></strong> <br>实现了JSON-RPC协议， 也就实现了对json数据的序列化和反序列化。</p>\n<ul>\n<li>服务端示例</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"errors\"</span></div><div class=\"line\">\t<span class=\"string\">\"log\"</span></div><div class=\"line\">\t<span class=\"string\">\"net\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/rpc\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/rpc/jsonrpc\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// RpcObj和ReplyObj为服务端/客户端之间传输的数据结构体</span></div><div class=\"line\"><span class=\"comment\">// C/S双方都能处理这两个数据类型</span></div><div class=\"line\"><span class=\"keyword\">type</span> RpcObj <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tA, B <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> ReplyObj <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tC <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> Arith <span class=\"keyword\">int</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 服务端的响应结构体</span></div><div class=\"line\"><span class=\"keyword\">type</span> ArithAddResp <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tId     <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:\"id\"`</span></div><div class=\"line\">\tResult ReplyObj    <span class=\"string\">`json:\"result\"`</span></div><div class=\"line\">\tError  <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:\"error\"`</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 符合 func (t T) funname(t1 *T1, t2 *T2) error 类型的方法都可以注册到rpc中</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Arith)</span> <span class=\"title\">Add</span><span class=\"params\">(args *RpcObj, reply *ReplyObj)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">\treply.C = args.A + args.B</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Arith)</span> <span class=\"title\">Mul</span><span class=\"params\">(args *RpcObj, reply *ReplyObj)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">\treply.C = args.A * args.B</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Arith)</span> <span class=\"title\">Div</span><span class=\"params\">(args *RpcObj, reply *ReplyObj)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> args.B == <span class=\"number\">0</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> errors.New(<span class=\"string\">\"divide by zero\"</span>)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treply.C = args.A / args.B</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Arith)</span> <span class=\"title\">Error</span><span class=\"params\">(args *RpcObj, reply *ReplyObj)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"ERROR\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tarith := <span class=\"built_in\">new</span>(Arith)</div><div class=\"line\">\t<span class=\"comment\">// 新建rpc server</span></div><div class=\"line\">\tserver := rpc.NewServer()</div><div class=\"line\">\t<span class=\"comment\">// 注册handler处理器</span></div><div class=\"line\">\tserver.Register(arith)</div><div class=\"line\">\t<span class=\"comment\">// 监听8080端口</span></div><div class=\"line\">\tl, e := net.Listen(<span class=\"string\">\"tcp\"</span>, <span class=\"string\">\":8080\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tlog.Fatal(<span class=\"string\">\"listen error:\"</span>, e)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tlog.Println(<span class=\"string\">\"RPC server started...\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">for</span> &#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 接收客户端请求</span></div><div class=\"line\">\t\tconn, err := l.Accept()</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\tlog.Fatal(err)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// 在goroutine中处理请求</span></div><div class=\"line\">\t\t<span class=\"comment\">// 通过http.Conn创建一个jsonrpc编码器, 并将其传递到rpc编码器</span></div><div class=\"line\">\t\t<span class=\"keyword\">go</span> server.ServeCodec(jsonrpc.NewServerCodec(conn))</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tlog.Println(<span class=\"string\">\"RPC server is shutdown...\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>客户端示例</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"log\"</span></div><div class=\"line\">\t<span class=\"string\">\"net\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/rpc/jsonrpc\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> RpcObj <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tA, B <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> ReplyObj <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tC <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> Arith <span class=\"keyword\">int</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> ArithAddResp <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tId     <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:\"id\"`</span></div><div class=\"line\">\tResult ReplyObj    <span class=\"string\">`json:\"result\"`</span></div><div class=\"line\">\tError  <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:\"error\"`</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tconn, err := net.Dial(<span class=\"string\">\"tcp\"</span>, <span class=\"string\">\"localhost:8080\"</span>)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</div><div class=\"line\"></div><div class=\"line\">\tc := jsonrpc.NewClient(conn)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> reply ReplyObj</div><div class=\"line\">\t<span class=\"keyword\">var</span> args *RpcObj</div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">5</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 往RPC调用传递参数</span></div><div class=\"line\">\t\targs = &amp;RpcObj&#123;<span class=\"number\">5</span>, i&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// 远程调用Arith.Mul方法</span></div><div class=\"line\">\t\terr = c.Call(<span class=\"string\">\"Arith.Mul\"</span>, args, &amp;reply)</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\tlog.Fatal(<span class=\"string\">\"Exited as arith error:\"</span>, err)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"Arith: %d * %d = %v\\n\"</span>, args.A, args.B, reply.C)</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// 远程调用Arith.Div方法</span></div><div class=\"line\">\t\terr = c.Call(<span class=\"string\">\"Arith.Div\"</span>, args, &amp;reply)</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\tlog.Fatal(<span class=\"string\">\"Exited as arith error:\"</span>, err)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"Arith: %d / %d = %v\\n\"</span>, args.A, args.B, reply.C)</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// 华丽的分割线</span></div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"\\033[33m%s\\033[m\\n\"</span>, <span class=\"string\">\"---------------\"</span>)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>示例效果</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:/data/apps/demo<span class=\"comment\"># go run rpccli.go</span></div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 * 5 = 25</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 / 5 = 1</div><div class=\"line\">2016/03/28 16:17:41 ---------------</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 * 4 = 20</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 / 4 = 1</div><div class=\"line\">2016/03/28 16:17:41 ---------------</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 * 3 = 15</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 / 3 = 1</div><div class=\"line\">2016/03/28 16:17:41 ---------------</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 * 2 = 10</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 / 2 = 2</div><div class=\"line\">2016/03/28 16:17:41 ---------------</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 * 1 = 5</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 / 1 = 5</div><div class=\"line\">2016/03/28 16:17:41 ---------------</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 * 0 = 0</div><div class=\"line\">2016/03/28 16:17:41 Exited as arith error:divide by zero</div><div class=\"line\"><span class=\"built_in\">exit</span> status 1</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h4 id=\"关于JSON-RPC\"><a href=\"#关于JSON-RPC\" class=\"headerlink\" title=\"关于JSON-RPC\"></a>关于JSON-RPC</h4><p>JSON-RPC是一个远程调用协议, 还是轻量级的, 简单易用。<br>在请求远程调用的时候, 我们可以这样定义请求体:<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"jsonrpc\"</span>: <span class=\"string\">\"2.0\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"method\"</span>: <span class=\"string\">\"login\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"params\"</span>: &#123;<span class=\"attr\">\"name\"</span>:<span class=\"string\">\"momo\"</span>, <span class=\"attr\">\"passwd\"</span>:<span class=\"string\">\"xxxxxx\"</span>&#125;,</div><div class=\"line\">    <span class=\"attr\">\"id\"</span>: <span class=\"number\">0</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>","more":"<p>关于其中几个参数, 有如下说明:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">jsonrpc: 协议的版本号(1.0版本是不带该参数, 2.0版带该参数并且值为&quot;2.0&quot;)</div><div class=\"line\">method:  所要调用的方法名</div><div class=\"line\">params:  所调用方法接收的参数(/列表)</div><div class=\"line\">id:      当次请求的标识码(服务端响应体内应包含相同的id)</div></pre></td></tr></table></figure></p>\n<p>更详细的说明, 可以参考这里: <a href=\"http://wiki.geekdream.com/Specification/json-rpc_2.0.html\" target=\"_blank\" rel=\"external\">http://wiki.geekdream.com/Specification/json-rpc_2.0.html</a></p>\n<h4 id=\"Golang-JSON-RPC\"><a href=\"#Golang-JSON-RPC\" class=\"headerlink\" title=\"Golang JSON-RPC\"></a>Golang JSON-RPC</h4><p>golang中有rpc包:<br><br><strong><em>net/rpc</em></strong> <br>实现了最基本的rpc调用，默认通过HTTP协议传输gob数据来实现远程调用。<br><br><strong><em>net/rpc/jsonrpc</em></strong> <br>实现了JSON-RPC协议， 也就实现了对json数据的序列化和反序列化。</p>\n<ul>\n<li>服务端示例</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"errors\"</span></div><div class=\"line\">\t<span class=\"string\">\"log\"</span></div><div class=\"line\">\t<span class=\"string\">\"net\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/rpc\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/rpc/jsonrpc\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// RpcObj和ReplyObj为服务端/客户端之间传输的数据结构体</span></div><div class=\"line\"><span class=\"comment\">// C/S双方都能处理这两个数据类型</span></div><div class=\"line\"><span class=\"keyword\">type</span> RpcObj <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tA, B <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> ReplyObj <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tC <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> Arith <span class=\"keyword\">int</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 服务端的响应结构体</span></div><div class=\"line\"><span class=\"keyword\">type</span> ArithAddResp <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tId     <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:\"id\"`</span></div><div class=\"line\">\tResult ReplyObj    <span class=\"string\">`json:\"result\"`</span></div><div class=\"line\">\tError  <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:\"error\"`</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 符合 func (t T) funname(t1 *T1, t2 *T2) error 类型的方法都可以注册到rpc中</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Arith)</span> <span class=\"title\">Add</span><span class=\"params\">(args *RpcObj, reply *ReplyObj)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">\treply.C = args.A + args.B</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Arith)</span> <span class=\"title\">Mul</span><span class=\"params\">(args *RpcObj, reply *ReplyObj)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">\treply.C = args.A * args.B</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Arith)</span> <span class=\"title\">Div</span><span class=\"params\">(args *RpcObj, reply *ReplyObj)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> args.B == <span class=\"number\">0</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> errors.New(<span class=\"string\">\"divide by zero\"</span>)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treply.C = args.A / args.B</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Arith)</span> <span class=\"title\">Error</span><span class=\"params\">(args *RpcObj, reply *ReplyObj)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"ERROR\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tarith := <span class=\"built_in\">new</span>(Arith)</div><div class=\"line\">\t<span class=\"comment\">// 新建rpc server</span></div><div class=\"line\">\tserver := rpc.NewServer()</div><div class=\"line\">\t<span class=\"comment\">// 注册handler处理器</span></div><div class=\"line\">\tserver.Register(arith)</div><div class=\"line\">\t<span class=\"comment\">// 监听8080端口</span></div><div class=\"line\">\tl, e := net.Listen(<span class=\"string\">\"tcp\"</span>, <span class=\"string\">\":8080\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tlog.Fatal(<span class=\"string\">\"listen error:\"</span>, e)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tlog.Println(<span class=\"string\">\"RPC server started...\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">for</span> &#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 接收客户端请求</span></div><div class=\"line\">\t\tconn, err := l.Accept()</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\tlog.Fatal(err)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// 在goroutine中处理请求</span></div><div class=\"line\">\t\t<span class=\"comment\">// 通过http.Conn创建一个jsonrpc编码器, 并将其传递到rpc编码器</span></div><div class=\"line\">\t\t<span class=\"keyword\">go</span> server.ServeCodec(jsonrpc.NewServerCodec(conn))</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tlog.Println(<span class=\"string\">\"RPC server is shutdown...\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>客户端示例</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"log\"</span></div><div class=\"line\">\t<span class=\"string\">\"net\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/rpc/jsonrpc\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> RpcObj <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tA, B <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> ReplyObj <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tC <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> Arith <span class=\"keyword\">int</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> ArithAddResp <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tId     <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:\"id\"`</span></div><div class=\"line\">\tResult ReplyObj    <span class=\"string\">`json:\"result\"`</span></div><div class=\"line\">\tError  <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"string\">`json:\"error\"`</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tconn, err := net.Dial(<span class=\"string\">\"tcp\"</span>, <span class=\"string\">\"localhost:8080\"</span>)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</div><div class=\"line\"></div><div class=\"line\">\tc := jsonrpc.NewClient(conn)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> reply ReplyObj</div><div class=\"line\">\t<span class=\"keyword\">var</span> args *RpcObj</div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">5</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 往RPC调用传递参数</span></div><div class=\"line\">\t\targs = &amp;RpcObj&#123;<span class=\"number\">5</span>, i&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// 远程调用Arith.Mul方法</span></div><div class=\"line\">\t\terr = c.Call(<span class=\"string\">\"Arith.Mul\"</span>, args, &amp;reply)</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\tlog.Fatal(<span class=\"string\">\"Exited as arith error:\"</span>, err)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"Arith: %d * %d = %v\\n\"</span>, args.A, args.B, reply.C)</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// 远程调用Arith.Div方法</span></div><div class=\"line\">\t\terr = c.Call(<span class=\"string\">\"Arith.Div\"</span>, args, &amp;reply)</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\tlog.Fatal(<span class=\"string\">\"Exited as arith error:\"</span>, err)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"Arith: %d / %d = %v\\n\"</span>, args.A, args.B, reply.C)</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// 华丽的分割线</span></div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"\\033[33m%s\\033[m\\n\"</span>, <span class=\"string\">\"---------------\"</span>)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>示例效果</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:/data/apps/demo<span class=\"comment\"># go run rpccli.go</span></div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 * 5 = 25</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 / 5 = 1</div><div class=\"line\">2016/03/28 16:17:41 ---------------</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 * 4 = 20</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 / 4 = 1</div><div class=\"line\">2016/03/28 16:17:41 ---------------</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 * 3 = 15</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 / 3 = 1</div><div class=\"line\">2016/03/28 16:17:41 ---------------</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 * 2 = 10</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 / 2 = 2</div><div class=\"line\">2016/03/28 16:17:41 ---------------</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 * 1 = 5</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 / 1 = 5</div><div class=\"line\">2016/03/28 16:17:41 ---------------</div><div class=\"line\">2016/03/28 16:17:41 Arith: 5 * 0 = 0</div><div class=\"line\">2016/03/28 16:17:41 Exited as arith error:divide by zero</div><div class=\"line\"><span class=\"built_in\">exit</span> status 1</div></pre></td></tr></table></figure>"},{"title":"[golang]golang内存管理","date":"2017-11-16T02:04:16.000Z","_content":"\n\n最近粗略看了下golang内存初始化相关的代码，结合大牛们的一些源码分析，自己整理了一下学习总结。\n#### 几个关键数据结构\n- mspan\n由mheap管理的页面，记录了所分配的块大小和起始地址等\n- mcache\n与P(可看做cpu)绑定的线程级别的本地缓存\n- mcenter\n全局空间的缓存，收集了各种大小(67种)的span列表\n- mheap\n分配内存的堆分配器，以8kb进行页管理\n- fixalloc\n固定尺寸的堆外对象空闲列表分配器，用来管理分配器的存储\n<!--more-->\n\n#### 内存分配逻辑\n- 如果object size>32KB, 则直接使用mheap来分配空间；\n- 如果object size<16Byte, 则通过mcache的tiny分配器来分配(tiny可看作是一个指针offset)；\n- 如果object size在上面两者之间，首先尝试通过sizeclass对应的分配器分配;\n- 如果mcache没有空闲的span， 则向mcentral申请空闲块；\n- 如果mcentral也没空闲块，则向mheap申请并进行切分；\n- 如果mheap也没合适的span，则向系统申请新的内存空间。\n\n#### 内存回收逻辑\n- 如果object size>32KB, 直接将span返还给mheap的自由链；\n- 如果object size<32KB, 查找object对应sizeclass， 归还到mcache自由链；\n- 如果mcache自由链过长或内存过大，将部分span归还到mcentral；\n- 如果某个范围的mspan都已经归还到mcentral，则将这部分mspan归还到mheap页堆；\n- 而mheap不会定时将内存归还到系统，但会归还虚拟地址到物理内存的映射关系，当系统需要的时候可以回收这部分内存，否则暂时先留着给Go使用。\n\n#### 图解结构关系与内存布局\n其他想说明的情况，我基本都放在图里了(画个图好累，很可能还画不准确, 窘迫...)\n(图片来自我的csdn博客: <a href='http://blog.csdn.net/moxiaomomo/article/details/78546513'>blog.csdn.net/moxiaomomo<a/>)\n<span style=\"font-szie:15px\">\n<img src=\"http://img.blog.csdn.net/20171116001110283?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbW94aWFvbW9tbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:1000px;\">\n</span>\n\n#### 其他知识点\n- 标示内存可用的常用两种方法\n(1) 将所有可用内存块通过链表连接起来；\n(2) 通过位图标志；\n- mcentral中用到的pad字段\n主要是为了避免false sharing(伪共享)的性能问题；\n- 内存分配和tcmalloc理论类似\n","source":"_posts/golang/golang-memory-management.md","raw":"---\ntitle: '[golang]golang内存管理'\ndate: 2017-11-16 10:04:16\ntags: golang\n---\n\n\n最近粗略看了下golang内存初始化相关的代码，结合大牛们的一些源码分析，自己整理了一下学习总结。\n#### 几个关键数据结构\n- mspan\n由mheap管理的页面，记录了所分配的块大小和起始地址等\n- mcache\n与P(可看做cpu)绑定的线程级别的本地缓存\n- mcenter\n全局空间的缓存，收集了各种大小(67种)的span列表\n- mheap\n分配内存的堆分配器，以8kb进行页管理\n- fixalloc\n固定尺寸的堆外对象空闲列表分配器，用来管理分配器的存储\n<!--more-->\n\n#### 内存分配逻辑\n- 如果object size>32KB, 则直接使用mheap来分配空间；\n- 如果object size<16Byte, 则通过mcache的tiny分配器来分配(tiny可看作是一个指针offset)；\n- 如果object size在上面两者之间，首先尝试通过sizeclass对应的分配器分配;\n- 如果mcache没有空闲的span， 则向mcentral申请空闲块；\n- 如果mcentral也没空闲块，则向mheap申请并进行切分；\n- 如果mheap也没合适的span，则向系统申请新的内存空间。\n\n#### 内存回收逻辑\n- 如果object size>32KB, 直接将span返还给mheap的自由链；\n- 如果object size<32KB, 查找object对应sizeclass， 归还到mcache自由链；\n- 如果mcache自由链过长或内存过大，将部分span归还到mcentral；\n- 如果某个范围的mspan都已经归还到mcentral，则将这部分mspan归还到mheap页堆；\n- 而mheap不会定时将内存归还到系统，但会归还虚拟地址到物理内存的映射关系，当系统需要的时候可以回收这部分内存，否则暂时先留着给Go使用。\n\n#### 图解结构关系与内存布局\n其他想说明的情况，我基本都放在图里了(画个图好累，很可能还画不准确, 窘迫...)\n(图片来自我的csdn博客: <a href='http://blog.csdn.net/moxiaomomo/article/details/78546513'>blog.csdn.net/moxiaomomo<a/>)\n<span style=\"font-szie:15px\">\n<img src=\"http://img.blog.csdn.net/20171116001110283?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbW94aWFvbW9tbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:1000px;\">\n</span>\n\n#### 其他知识点\n- 标示内存可用的常用两种方法\n(1) 将所有可用内存块通过链表连接起来；\n(2) 通过位图标志；\n- mcentral中用到的pad字段\n主要是为了避免false sharing(伪共享)的性能问题；\n- 内存分配和tcmalloc理论类似\n","slug":"golang/golang-memory-management","published":1,"updated":"2017-11-16T02:11:05.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dxl00324j4dozec2d3h","content":"<p>最近粗略看了下golang内存初始化相关的代码，结合大牛们的一些源码分析，自己整理了一下学习总结。</p>\n<h4 id=\"几个关键数据结构\"><a href=\"#几个关键数据结构\" class=\"headerlink\" title=\"几个关键数据结构\"></a>几个关键数据结构</h4><ul>\n<li>mspan<br>由mheap管理的页面，记录了所分配的块大小和起始地址等</li>\n<li>mcache<br>与P(可看做cpu)绑定的线程级别的本地缓存</li>\n<li>mcenter<br>全局空间的缓存，收集了各种大小(67种)的span列表</li>\n<li>mheap<br>分配内存的堆分配器，以8kb进行页管理</li>\n<li>fixalloc<br>固定尺寸的堆外对象空闲列表分配器，用来管理分配器的存储<a id=\"more\"></a>\n</li>\n</ul>\n<h4 id=\"内存分配逻辑\"><a href=\"#内存分配逻辑\" class=\"headerlink\" title=\"内存分配逻辑\"></a>内存分配逻辑</h4><ul>\n<li>如果object size&gt;32KB, 则直接使用mheap来分配空间；</li>\n<li>如果object size&lt;16Byte, 则通过mcache的tiny分配器来分配(tiny可看作是一个指针offset)；</li>\n<li>如果object size在上面两者之间，首先尝试通过sizeclass对应的分配器分配;</li>\n<li>如果mcache没有空闲的span， 则向mcentral申请空闲块；</li>\n<li>如果mcentral也没空闲块，则向mheap申请并进行切分；</li>\n<li>如果mheap也没合适的span，则向系统申请新的内存空间。</li>\n</ul>\n<h4 id=\"内存回收逻辑\"><a href=\"#内存回收逻辑\" class=\"headerlink\" title=\"内存回收逻辑\"></a>内存回收逻辑</h4><ul>\n<li>如果object size&gt;32KB, 直接将span返还给mheap的自由链；</li>\n<li>如果object size&lt;32KB, 查找object对应sizeclass， 归还到mcache自由链；</li>\n<li>如果mcache自由链过长或内存过大，将部分span归还到mcentral；</li>\n<li>如果某个范围的mspan都已经归还到mcentral，则将这部分mspan归还到mheap页堆；</li>\n<li>而mheap不会定时将内存归还到系统，但会归还虚拟地址到物理内存的映射关系，当系统需要的时候可以回收这部分内存，否则暂时先留着给Go使用。</li>\n</ul>\n<h4 id=\"图解结构关系与内存布局\"><a href=\"#图解结构关系与内存布局\" class=\"headerlink\" title=\"图解结构关系与内存布局\"></a>图解结构关系与内存布局</h4><p>其他想说明的情况，我基本都放在图里了(画个图好累，很可能还画不准确, 窘迫…)<br>(图片来自我的csdn博客: <a href=\"http://blog.csdn.net/moxiaomomo/article/details/78546513\" target=\"_blank\" rel=\"external\">blog.csdn.net/moxiaomomo<a>)<br><span style=\"font-szie:15px\"><br><img src=\"http://img.blog.csdn.net/20171116001110283?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbW94aWFvbW9tbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:1000px;\"><br></span></a></a></p>\n<h4 id=\"其他知识点\"><a href=\"#其他知识点\" class=\"headerlink\" title=\"其他知识点\"></a>其他知识点</h4><ul>\n<li>标示内存可用的常用两种方法<br>(1) 将所有可用内存块通过链表连接起来；<br>(2) 通过位图标志；</li>\n<li>mcentral中用到的pad字段<br>主要是为了避免false sharing(伪共享)的性能问题；</li>\n<li>内存分配和tcmalloc理论类似</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近粗略看了下golang内存初始化相关的代码，结合大牛们的一些源码分析，自己整理了一下学习总结。</p>\n<h4 id=\"几个关键数据结构\"><a href=\"#几个关键数据结构\" class=\"headerlink\" title=\"几个关键数据结构\"></a>几个关键数据结构</h4><ul>\n<li>mspan<br>由mheap管理的页面，记录了所分配的块大小和起始地址等</li>\n<li>mcache<br>与P(可看做cpu)绑定的线程级别的本地缓存</li>\n<li>mcenter<br>全局空间的缓存，收集了各种大小(67种)的span列表</li>\n<li>mheap<br>分配内存的堆分配器，以8kb进行页管理</li>\n<li>fixalloc<br>固定尺寸的堆外对象空闲列表分配器，用来管理分配器的存储","more":"</li>\n</ul>\n<h4 id=\"内存分配逻辑\"><a href=\"#内存分配逻辑\" class=\"headerlink\" title=\"内存分配逻辑\"></a>内存分配逻辑</h4><ul>\n<li>如果object size&gt;32KB, 则直接使用mheap来分配空间；</li>\n<li>如果object size&lt;16Byte, 则通过mcache的tiny分配器来分配(tiny可看作是一个指针offset)；</li>\n<li>如果object size在上面两者之间，首先尝试通过sizeclass对应的分配器分配;</li>\n<li>如果mcache没有空闲的span， 则向mcentral申请空闲块；</li>\n<li>如果mcentral也没空闲块，则向mheap申请并进行切分；</li>\n<li>如果mheap也没合适的span，则向系统申请新的内存空间。</li>\n</ul>\n<h4 id=\"内存回收逻辑\"><a href=\"#内存回收逻辑\" class=\"headerlink\" title=\"内存回收逻辑\"></a>内存回收逻辑</h4><ul>\n<li>如果object size&gt;32KB, 直接将span返还给mheap的自由链；</li>\n<li>如果object size&lt;32KB, 查找object对应sizeclass， 归还到mcache自由链；</li>\n<li>如果mcache自由链过长或内存过大，将部分span归还到mcentral；</li>\n<li>如果某个范围的mspan都已经归还到mcentral，则将这部分mspan归还到mheap页堆；</li>\n<li>而mheap不会定时将内存归还到系统，但会归还虚拟地址到物理内存的映射关系，当系统需要的时候可以回收这部分内存，否则暂时先留着给Go使用。</li>\n</ul>\n<h4 id=\"图解结构关系与内存布局\"><a href=\"#图解结构关系与内存布局\" class=\"headerlink\" title=\"图解结构关系与内存布局\"></a>图解结构关系与内存布局</h4><p>其他想说明的情况，我基本都放在图里了(画个图好累，很可能还画不准确, 窘迫…)<br>(图片来自我的csdn博客: <a href=\"http://blog.csdn.net/moxiaomomo/article/details/78546513\" target=\"_blank\" rel=\"external\">blog.csdn.net/moxiaomomo<a>)<br><span style=\"font-szie:15px\"><br><img src=\"http://img.blog.csdn.net/20171116001110283?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbW94aWFvbW9tbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:1000px;\"><br></span></a></a></p>\n<h4 id=\"其他知识点\"><a href=\"#其他知识点\" class=\"headerlink\" title=\"其他知识点\"></a>其他知识点</h4><ul>\n<li>标示内存可用的常用两种方法<br>(1) 将所有可用内存块通过链表连接起来；<br>(2) 通过位图标志；</li>\n<li>mcentral中用到的pad字段<br>主要是为了避免false sharing(伪共享)的性能问题；</li>\n<li>内存分配和tcmalloc理论类似</li>\n</ul>"},{"title":"[golang]pprof性能分析工具","date":"2016-08-11T10:53:57.000Z","_content":"\n### 1. 关于pprof\npprof是golang程序一个性能分析的工具，可以查看堆栈、cpu信息等。\n\n### 2. 源码示例\n<!--more-->\n```golang\npackage main\n\nimport (\n\t\"flag\"\n\t\"log\"\n\t\"net/http\"\n\t_ \"net/http/pprof\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc Counter(wg *sync.WaitGroup) {\n\ttime.Sleep(time.Second)\n\n\tvar counter int\n\tfor i := 0; i < 1000000; i++ {\n\t\ttime.Sleep(time.Millisecond * 200)\n\t\tcounter++\n\t}\n\twg.Done()\n}\n\nfunc main() {\n\tflag.Parse()\n\n\t//远程获取pprof数据\n\tgo func() {\n\t\tlog.Println(http.ListenAndServe(\"localhost:8080\", nil))\n\t}()\n\n\tvar wg sync.WaitGroup\n\twg.Add(10)\n\tfor i := 0; i < 10; i++ {\n\t\tgo Counter(&wg)\n\t}\n\twg.Wait()\n\n\t// sleep 10mins, 在程序退出之前可以查看性能参数.\n\ttime.Sleep(60 * time.Second)\n}\n```\n\n### 3. 编译运行\n```bash\ngo run test_pprof.go\n```\n\n### 4. 通过网页查看overview\n![golang pprof](/img/golang_pprof.png)\n\n### 5. 通过终端命令查看各参数\n**查看堆栈信息**\n```bash\nroot@XIAOMO:~# go tool pprof http://localhost:8080/debug/pprof/heap\nFetching profile from http://localhost:8080/debug/pprof/heap\nSaved profile in /root/pprof/pprof.localhost:8080.inuse_objects.inuse_space.003.pb.gz\nEntering interactive mode (type \"help\" for commands)\n(pprof) top10\n1069.45kB of 1069.45kB total (  100%)\nShowing top 10 nodes out of 11 (cum >= 512.19kB)\n      flat  flat%   sum%        cum   cum%\n  557.26kB 52.11% 52.11%   557.26kB 52.11%  html.init\n  512.19kB 47.89%   100%   512.19kB 47.89%  runtime.malg\n         0     0%   100%   557.26kB 52.11%  html/template.init\n         0     0%   100%   557.26kB 52.11%  main.init\n         0     0%   100%   557.26kB 52.11%  net/http/pprof.init\n         0     0%   100%   557.26kB 52.11%  runtime.goexit\n         0     0%   100%   557.26kB 52.11%  runtime.main\n         0     0%   100%   512.19kB 47.89%  runtime.mcommoninit\n         0     0%   100%   512.19kB 47.89%  runtime.mpreinit\n         0     0%   100%   512.19kB 47.89%  runtime.rt0_go\n(pprof) web\n```\ntop10命令查看了堆栈空间最大的10个函数调用;<br>\nweb明令则生成了很详细的图, 如下:<br>\n![golang pprof](/img/golang_pprof_heap.png)\n\n<br>**查看cpu性能信息**\n```bash\nroot@xiaomo:~$ go tool pprof http://localhost:8080/debug/pprof/profile\nFetching profile from http://localhost:8080/debug/pprof/profile\nPlease wait... (30s)\nSaved profile in /home/xiaomo/pprof/pprof.pprof.localhost:8080.samples.cpu.001.pb.gz\nEntering interactive mode (type \"help\" for commands)\n(pprof) web\n```\n输入命令web后生成详细结果，如下图所示:<br>\n![pprof_cpu](/img/golang_pprof_cpu.png)\n\n","source":"_posts/golang/golang-pprof性能分析工具.md","raw":"---\ntitle: '[golang]pprof性能分析工具'\ndate: 2016-08-11 18:53:57\ntags: golang\n---\n\n### 1. 关于pprof\npprof是golang程序一个性能分析的工具，可以查看堆栈、cpu信息等。\n\n### 2. 源码示例\n<!--more-->\n```golang\npackage main\n\nimport (\n\t\"flag\"\n\t\"log\"\n\t\"net/http\"\n\t_ \"net/http/pprof\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc Counter(wg *sync.WaitGroup) {\n\ttime.Sleep(time.Second)\n\n\tvar counter int\n\tfor i := 0; i < 1000000; i++ {\n\t\ttime.Sleep(time.Millisecond * 200)\n\t\tcounter++\n\t}\n\twg.Done()\n}\n\nfunc main() {\n\tflag.Parse()\n\n\t//远程获取pprof数据\n\tgo func() {\n\t\tlog.Println(http.ListenAndServe(\"localhost:8080\", nil))\n\t}()\n\n\tvar wg sync.WaitGroup\n\twg.Add(10)\n\tfor i := 0; i < 10; i++ {\n\t\tgo Counter(&wg)\n\t}\n\twg.Wait()\n\n\t// sleep 10mins, 在程序退出之前可以查看性能参数.\n\ttime.Sleep(60 * time.Second)\n}\n```\n\n### 3. 编译运行\n```bash\ngo run test_pprof.go\n```\n\n### 4. 通过网页查看overview\n![golang pprof](/img/golang_pprof.png)\n\n### 5. 通过终端命令查看各参数\n**查看堆栈信息**\n```bash\nroot@XIAOMO:~# go tool pprof http://localhost:8080/debug/pprof/heap\nFetching profile from http://localhost:8080/debug/pprof/heap\nSaved profile in /root/pprof/pprof.localhost:8080.inuse_objects.inuse_space.003.pb.gz\nEntering interactive mode (type \"help\" for commands)\n(pprof) top10\n1069.45kB of 1069.45kB total (  100%)\nShowing top 10 nodes out of 11 (cum >= 512.19kB)\n      flat  flat%   sum%        cum   cum%\n  557.26kB 52.11% 52.11%   557.26kB 52.11%  html.init\n  512.19kB 47.89%   100%   512.19kB 47.89%  runtime.malg\n         0     0%   100%   557.26kB 52.11%  html/template.init\n         0     0%   100%   557.26kB 52.11%  main.init\n         0     0%   100%   557.26kB 52.11%  net/http/pprof.init\n         0     0%   100%   557.26kB 52.11%  runtime.goexit\n         0     0%   100%   557.26kB 52.11%  runtime.main\n         0     0%   100%   512.19kB 47.89%  runtime.mcommoninit\n         0     0%   100%   512.19kB 47.89%  runtime.mpreinit\n         0     0%   100%   512.19kB 47.89%  runtime.rt0_go\n(pprof) web\n```\ntop10命令查看了堆栈空间最大的10个函数调用;<br>\nweb明令则生成了很详细的图, 如下:<br>\n![golang pprof](/img/golang_pprof_heap.png)\n\n<br>**查看cpu性能信息**\n```bash\nroot@xiaomo:~$ go tool pprof http://localhost:8080/debug/pprof/profile\nFetching profile from http://localhost:8080/debug/pprof/profile\nPlease wait... (30s)\nSaved profile in /home/xiaomo/pprof/pprof.pprof.localhost:8080.samples.cpu.001.pb.gz\nEntering interactive mode (type \"help\" for commands)\n(pprof) web\n```\n输入命令web后生成详细结果，如下图所示:<br>\n![pprof_cpu](/img/golang_pprof_cpu.png)\n\n","slug":"golang/golang-pprof性能分析工具","published":1,"updated":"2017-08-11T11:00:14.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dxm00344j4dni61ykuf","content":"<h3 id=\"1-关于pprof\"><a href=\"#1-关于pprof\" class=\"headerlink\" title=\"1. 关于pprof\"></a>1. 关于pprof</h3><p>pprof是golang程序一个性能分析的工具，可以查看堆栈、cpu信息等。</p>\n<h3 id=\"2-源码示例\"><a href=\"#2-源码示例\" class=\"headerlink\" title=\"2. 源码示例\"></a>2. 源码示例</h3><a id=\"more\"></a>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"flag\"</span></div><div class=\"line\">\t<span class=\"string\">\"log\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/http\"</span></div><div class=\"line\">\t_ <span class=\"string\">\"net/http/pprof\"</span></div><div class=\"line\">\t<span class=\"string\">\"sync\"</span></div><div class=\"line\">\t<span class=\"string\">\"time\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Counter</span><span class=\"params\">(wg *sync.WaitGroup)</span></span> &#123;</div><div class=\"line\">\ttime.Sleep(time.Second)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> counter <span class=\"keyword\">int</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++ &#123;</div><div class=\"line\">\t\ttime.Sleep(time.Millisecond * <span class=\"number\">200</span>)</div><div class=\"line\">\t\tcounter++</div><div class=\"line\">\t&#125;</div><div class=\"line\">\twg.Done()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tflag.Parse()</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//远程获取pprof数据</span></div><div class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t\tlog.Println(http.ListenAndServe(<span class=\"string\">\"localhost:8080\"</span>, <span class=\"literal\">nil</span>))</div><div class=\"line\">\t&#125;()</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</div><div class=\"line\">\twg.Add(<span class=\"number\">10</span>)</div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">go</span> Counter(&amp;wg)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\twg.Wait()</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// sleep 10mins, 在程序退出之前可以查看性能参数.</span></div><div class=\"line\">\ttime.Sleep(<span class=\"number\">60</span> * time.Second)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-编译运行\"><a href=\"#3-编译运行\" class=\"headerlink\" title=\"3. 编译运行\"></a>3. 编译运行</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">go run test_pprof.go</div></pre></td></tr></table></figure>\n<h3 id=\"4-通过网页查看overview\"><a href=\"#4-通过网页查看overview\" class=\"headerlink\" title=\"4. 通过网页查看overview\"></a>4. 通过网页查看overview</h3><p><img src=\"/img/golang_pprof.png\" alt=\"golang pprof\"></p>\n<h3 id=\"5-通过终端命令查看各参数\"><a href=\"#5-通过终端命令查看各参数\" class=\"headerlink\" title=\"5. 通过终端命令查看各参数\"></a>5. 通过终端命令查看各参数</h3><p><strong>查看堆栈信息</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~<span class=\"comment\"># go tool pprof http://localhost:8080/debug/pprof/heap</span></div><div class=\"line\">Fetching profile from http://localhost:8080/debug/pprof/heap</div><div class=\"line\">Saved profile <span class=\"keyword\">in</span> /root/pprof/pprof.localhost:8080.inuse_objects.inuse_space.003.pb.gz</div><div class=\"line\">Entering interactive mode (<span class=\"built_in\">type</span> <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> commands)</div><div class=\"line\">(pprof) top10</div><div class=\"line\">1069.45kB of 1069.45kB total (  100%)</div><div class=\"line\">Showing top 10 nodes out of 11 (cum &gt;= 512.19kB)</div><div class=\"line\">      flat  flat%   sum%        cum   cum%</div><div class=\"line\">  557.26kB 52.11% 52.11%   557.26kB 52.11%  html.init</div><div class=\"line\">  512.19kB 47.89%   100%   512.19kB 47.89%  runtime.malg</div><div class=\"line\">         0     0%   100%   557.26kB 52.11%  html/template.init</div><div class=\"line\">         0     0%   100%   557.26kB 52.11%  main.init</div><div class=\"line\">         0     0%   100%   557.26kB 52.11%  net/http/pprof.init</div><div class=\"line\">         0     0%   100%   557.26kB 52.11%  runtime.goexit</div><div class=\"line\">         0     0%   100%   557.26kB 52.11%  runtime.main</div><div class=\"line\">         0     0%   100%   512.19kB 47.89%  runtime.mcommoninit</div><div class=\"line\">         0     0%   100%   512.19kB 47.89%  runtime.mpreinit</div><div class=\"line\">         0     0%   100%   512.19kB 47.89%  runtime.rt0_go</div><div class=\"line\">(pprof) web</div></pre></td></tr></table></figure></p>\n<p>top10命令查看了堆栈空间最大的10个函数调用;<br><br>web明令则生成了很详细的图, 如下:<br><br><img src=\"/img/golang_pprof_heap.png\" alt=\"golang pprof\"></p>\n<p><br><strong>查看cpu性能信息</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@xiaomo:~$ go tool pprof http://localhost:8080/debug/pprof/profile</div><div class=\"line\">Fetching profile from http://localhost:8080/debug/pprof/profile</div><div class=\"line\">Please <span class=\"built_in\">wait</span>... (30s)</div><div class=\"line\">Saved profile <span class=\"keyword\">in</span> /home/xiaomo/pprof/pprof.pprof.localhost:8080.samples.cpu.001.pb.gz</div><div class=\"line\">Entering interactive mode (<span class=\"built_in\">type</span> <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> commands)</div><div class=\"line\">(pprof) web</div></pre></td></tr></table></figure></p>\n<p>输入命令web后生成详细结果，如下图所示:<br><br><img src=\"/img/golang_pprof_cpu.png\" alt=\"pprof_cpu\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-关于pprof\"><a href=\"#1-关于pprof\" class=\"headerlink\" title=\"1. 关于pprof\"></a>1. 关于pprof</h3><p>pprof是golang程序一个性能分析的工具，可以查看堆栈、cpu信息等。</p>\n<h3 id=\"2-源码示例\"><a href=\"#2-源码示例\" class=\"headerlink\" title=\"2. 源码示例\"></a>2. 源码示例</h3>","more":"<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"flag\"</span></div><div class=\"line\">\t<span class=\"string\">\"log\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/http\"</span></div><div class=\"line\">\t_ <span class=\"string\">\"net/http/pprof\"</span></div><div class=\"line\">\t<span class=\"string\">\"sync\"</span></div><div class=\"line\">\t<span class=\"string\">\"time\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Counter</span><span class=\"params\">(wg *sync.WaitGroup)</span></span> &#123;</div><div class=\"line\">\ttime.Sleep(time.Second)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> counter <span class=\"keyword\">int</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++ &#123;</div><div class=\"line\">\t\ttime.Sleep(time.Millisecond * <span class=\"number\">200</span>)</div><div class=\"line\">\t\tcounter++</div><div class=\"line\">\t&#125;</div><div class=\"line\">\twg.Done()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tflag.Parse()</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//远程获取pprof数据</span></div><div class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t\tlog.Println(http.ListenAndServe(<span class=\"string\">\"localhost:8080\"</span>, <span class=\"literal\">nil</span>))</div><div class=\"line\">\t&#125;()</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</div><div class=\"line\">\twg.Add(<span class=\"number\">10</span>)</div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">go</span> Counter(&amp;wg)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\twg.Wait()</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// sleep 10mins, 在程序退出之前可以查看性能参数.</span></div><div class=\"line\">\ttime.Sleep(<span class=\"number\">60</span> * time.Second)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-编译运行\"><a href=\"#3-编译运行\" class=\"headerlink\" title=\"3. 编译运行\"></a>3. 编译运行</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">go run test_pprof.go</div></pre></td></tr></table></figure>\n<h3 id=\"4-通过网页查看overview\"><a href=\"#4-通过网页查看overview\" class=\"headerlink\" title=\"4. 通过网页查看overview\"></a>4. 通过网页查看overview</h3><p><img src=\"/img/golang_pprof.png\" alt=\"golang pprof\"></p>\n<h3 id=\"5-通过终端命令查看各参数\"><a href=\"#5-通过终端命令查看各参数\" class=\"headerlink\" title=\"5. 通过终端命令查看各参数\"></a>5. 通过终端命令查看各参数</h3><p><strong>查看堆栈信息</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~<span class=\"comment\"># go tool pprof http://localhost:8080/debug/pprof/heap</span></div><div class=\"line\">Fetching profile from http://localhost:8080/debug/pprof/heap</div><div class=\"line\">Saved profile <span class=\"keyword\">in</span> /root/pprof/pprof.localhost:8080.inuse_objects.inuse_space.003.pb.gz</div><div class=\"line\">Entering interactive mode (<span class=\"built_in\">type</span> <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> commands)</div><div class=\"line\">(pprof) top10</div><div class=\"line\">1069.45kB of 1069.45kB total (  100%)</div><div class=\"line\">Showing top 10 nodes out of 11 (cum &gt;= 512.19kB)</div><div class=\"line\">      flat  flat%   sum%        cum   cum%</div><div class=\"line\">  557.26kB 52.11% 52.11%   557.26kB 52.11%  html.init</div><div class=\"line\">  512.19kB 47.89%   100%   512.19kB 47.89%  runtime.malg</div><div class=\"line\">         0     0%   100%   557.26kB 52.11%  html/template.init</div><div class=\"line\">         0     0%   100%   557.26kB 52.11%  main.init</div><div class=\"line\">         0     0%   100%   557.26kB 52.11%  net/http/pprof.init</div><div class=\"line\">         0     0%   100%   557.26kB 52.11%  runtime.goexit</div><div class=\"line\">         0     0%   100%   557.26kB 52.11%  runtime.main</div><div class=\"line\">         0     0%   100%   512.19kB 47.89%  runtime.mcommoninit</div><div class=\"line\">         0     0%   100%   512.19kB 47.89%  runtime.mpreinit</div><div class=\"line\">         0     0%   100%   512.19kB 47.89%  runtime.rt0_go</div><div class=\"line\">(pprof) web</div></pre></td></tr></table></figure></p>\n<p>top10命令查看了堆栈空间最大的10个函数调用;<br><br>web明令则生成了很详细的图, 如下:<br><br><img src=\"/img/golang_pprof_heap.png\" alt=\"golang pprof\"></p>\n<p><br><strong>查看cpu性能信息</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@xiaomo:~$ go tool pprof http://localhost:8080/debug/pprof/profile</div><div class=\"line\">Fetching profile from http://localhost:8080/debug/pprof/profile</div><div class=\"line\">Please <span class=\"built_in\">wait</span>... (30s)</div><div class=\"line\">Saved profile <span class=\"keyword\">in</span> /home/xiaomo/pprof/pprof.pprof.localhost:8080.samples.cpu.001.pb.gz</div><div class=\"line\">Entering interactive mode (<span class=\"built_in\">type</span> <span class=\"string\">\"help\"</span> <span class=\"keyword\">for</span> commands)</div><div class=\"line\">(pprof) web</div></pre></td></tr></table></figure></p>\n<p>输入命令web后生成详细结果，如下图所示:<br><br><img src=\"/img/golang_pprof_cpu.png\" alt=\"pprof_cpu\"></p>"},{"title":"[golang]简单文件上传服务","date":"2017-09-07T10:51:21.000Z","_content":"\n利用net/http库及gorilla/mux库实现了一个简单的文件上传服务,<br>\n示例如下:\n<!--more-->\n\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gorilla/mux\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nconst uploadHTML = `\n<html>  \n  <head>  \n    <title>选择文件</title>\n  </head>  \n  <body>  \n    <form enctype=\"multipart/form-data\" action=\"/\" method=\"post\">  \n      <input type=\"file\" name=\"uploadfile\" />  \n      <input type=\"submit\" value=\"上传文件\" />  \n    </form>  \n  </body>  \n</html>`\n\nconst destLocalPath = \"/data/files/\"\n\nfunc index(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(uploadHTML))\n}\n\nfunc upload(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == \"GET\" {\n\t\tindex(w, r)\n\t\treturn\n\t}\n\n\tr.ParseMultipartForm(32 << 20) // max memory is set to 32MB\n\tclientfd, handler, err := r.FormFile(\"uploadfile\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tw.Write([]byte(\"upload failed.\"))\n\t\treturn\n\t}\n\tdefer clientfd.Close()\n\n\tlocalpath := fmt.Sprintf(\"%s%s\", destLocalPath, handler.Filename)\n\tlocalfd, err := os.OpenFile(localpath, os.O_WRONLY|os.O_CREATE, 0666)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tw.Write([]byte(\"upload failed.\"))\n\t\treturn\n\t}\n\tdefer localfd.Close()\n\n\tio.Copy(localfd, clientfd)\n\tw.Write([]byte(\"upload finish.\"))\n}\n\nfunc newRouter() http.Handler {\n\thdl := mux.NewRouter()\n\thdl.HandleFunc(\"/\", upload)\n\n\treturn hdl\n}\n\nfunc main() {\n\thttp.ListenAndServe(\":8877\", newRouter())\n}\n```\n\n假如需要在接收文件的时候计算文件hash值， 应该如何做呢？<br>\n根据io.TeeReader库，可以在文件上传过程中自动计算hash值, 完整代码修改为:\n\n```golang\npackage main\n\nimport (\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"github.com/gorilla/mux\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nconst uploadHTML = `\n<html>  \n  <head>  \n    <title>选择文件</title>\n  </head>  \n  <body>  \n    <form enctype=\"multipart/form-data\" action=\"/\" method=\"post\">  \n      <input type=\"file\" name=\"uploadfile\" />  \n      <input type=\"submit\" value=\"上传文件\" />  \n    </form>  \n  </body>  \n</html>`\n\nconst destLocalPath = \"/data/files/\"\n\nfunc index(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(uploadHTML))\n}\n\nfunc upload(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == \"GET\" {\n\t\tindex(w, r)\n\t\treturn\n\t}\n\n\tr.ParseMultipartForm(32 << 20) // max memory is set to 32MB\n\tclientfd, handler, err := r.FormFile(\"uploadfile\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tw.Write([]byte(\"upload failed.\"))\n\t\treturn\n\t}\n\tdefer clientfd.Close()\n\n\tlocalpath := fmt.Sprintf(\"%s%s\", destLocalPath, handler.Filename)\n\tlocalfd, err := os.OpenFile(localpath, os.O_WRONLY|os.O_CREATE, 0666)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tw.Write([]byte(\"upload failed.\"))\n\t\treturn\n\t}\n\tdefer localfd.Close()\n\n\t// 利用io.TeeReader在读取文件内容时计算hash值\n\tfhash := sha1.New()\n\tio.Copy(localfd, io.TeeReader(clientfd, fhash))\n\thstr := hex.EncodeToString(fhash.Sum(nil))\n\tw.Write([]byte(fmt.Sprintf(\"upload finish:%s\", hstr)))\n}\n\nfunc newRouter() http.Handler {\n\thdl := mux.NewRouter()\n\thdl.HandleFunc(\"/\", upload)\n\n\treturn hdl\n}\n\nfunc main() {\n\thttp.ListenAndServe(\":8877\", newRouter())\n}\n```\n","source":"_posts/golang/golang-simple-uploadsrv.md","raw":"---\ntitle: '[golang]简单文件上传服务'\ndate: 2017-09-07 18:51:21\ntags: golang\n---\n\n利用net/http库及gorilla/mux库实现了一个简单的文件上传服务,<br>\n示例如下:\n<!--more-->\n\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gorilla/mux\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nconst uploadHTML = `\n<html>  \n  <head>  \n    <title>选择文件</title>\n  </head>  \n  <body>  \n    <form enctype=\"multipart/form-data\" action=\"/\" method=\"post\">  \n      <input type=\"file\" name=\"uploadfile\" />  \n      <input type=\"submit\" value=\"上传文件\" />  \n    </form>  \n  </body>  \n</html>`\n\nconst destLocalPath = \"/data/files/\"\n\nfunc index(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(uploadHTML))\n}\n\nfunc upload(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == \"GET\" {\n\t\tindex(w, r)\n\t\treturn\n\t}\n\n\tr.ParseMultipartForm(32 << 20) // max memory is set to 32MB\n\tclientfd, handler, err := r.FormFile(\"uploadfile\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tw.Write([]byte(\"upload failed.\"))\n\t\treturn\n\t}\n\tdefer clientfd.Close()\n\n\tlocalpath := fmt.Sprintf(\"%s%s\", destLocalPath, handler.Filename)\n\tlocalfd, err := os.OpenFile(localpath, os.O_WRONLY|os.O_CREATE, 0666)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tw.Write([]byte(\"upload failed.\"))\n\t\treturn\n\t}\n\tdefer localfd.Close()\n\n\tio.Copy(localfd, clientfd)\n\tw.Write([]byte(\"upload finish.\"))\n}\n\nfunc newRouter() http.Handler {\n\thdl := mux.NewRouter()\n\thdl.HandleFunc(\"/\", upload)\n\n\treturn hdl\n}\n\nfunc main() {\n\thttp.ListenAndServe(\":8877\", newRouter())\n}\n```\n\n假如需要在接收文件的时候计算文件hash值， 应该如何做呢？<br>\n根据io.TeeReader库，可以在文件上传过程中自动计算hash值, 完整代码修改为:\n\n```golang\npackage main\n\nimport (\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"github.com/gorilla/mux\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nconst uploadHTML = `\n<html>  \n  <head>  \n    <title>选择文件</title>\n  </head>  \n  <body>  \n    <form enctype=\"multipart/form-data\" action=\"/\" method=\"post\">  \n      <input type=\"file\" name=\"uploadfile\" />  \n      <input type=\"submit\" value=\"上传文件\" />  \n    </form>  \n  </body>  \n</html>`\n\nconst destLocalPath = \"/data/files/\"\n\nfunc index(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(uploadHTML))\n}\n\nfunc upload(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == \"GET\" {\n\t\tindex(w, r)\n\t\treturn\n\t}\n\n\tr.ParseMultipartForm(32 << 20) // max memory is set to 32MB\n\tclientfd, handler, err := r.FormFile(\"uploadfile\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tw.Write([]byte(\"upload failed.\"))\n\t\treturn\n\t}\n\tdefer clientfd.Close()\n\n\tlocalpath := fmt.Sprintf(\"%s%s\", destLocalPath, handler.Filename)\n\tlocalfd, err := os.OpenFile(localpath, os.O_WRONLY|os.O_CREATE, 0666)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tw.Write([]byte(\"upload failed.\"))\n\t\treturn\n\t}\n\tdefer localfd.Close()\n\n\t// 利用io.TeeReader在读取文件内容时计算hash值\n\tfhash := sha1.New()\n\tio.Copy(localfd, io.TeeReader(clientfd, fhash))\n\thstr := hex.EncodeToString(fhash.Sum(nil))\n\tw.Write([]byte(fmt.Sprintf(\"upload finish:%s\", hstr)))\n}\n\nfunc newRouter() http.Handler {\n\thdl := mux.NewRouter()\n\thdl.HandleFunc(\"/\", upload)\n\n\treturn hdl\n}\n\nfunc main() {\n\thttp.ListenAndServe(\":8877\", newRouter())\n}\n```\n","slug":"golang/golang-simple-uploadsrv","published":1,"updated":"2017-09-08T04:19:20.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dxw00374j4dc6vxf1gz","content":"<p>利用net/http库及gorilla/mux库实现了一个简单的文件上传服务,<br><br>示例如下:<br><a id=\"more\"></a></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"github.com/gorilla/mux\"</span></div><div class=\"line\">\t<span class=\"string\">\"io\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/http\"</span></div><div class=\"line\">\t<span class=\"string\">\"os\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> uploadHTML = <span class=\"string\">`</span></div><div class=\"line\">&lt;html&gt;  </div><div class=\"line\">  &lt;head&gt;  </div><div class=\"line\">    &lt;title&gt;选择文件&lt;/title&gt;</div><div class=\"line\">  &lt;/head&gt;  </div><div class=\"line\">  &lt;body&gt;  </div><div class=\"line\">    &lt;form enctype=\"multipart/form-data\" action=\"/\" method=\"post\"&gt;  </div><div class=\"line\">      &lt;input type=\"file\" name=\"uploadfile\" /&gt;  </div><div class=\"line\">      &lt;input type=\"submit\" value=\"上传文件\" /&gt;  </div><div class=\"line\">    &lt;/form&gt;  </div><div class=\"line\">  &lt;/body&gt;  </div><div class=\"line\">&lt;/html&gt;`</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> destLocalPath = <span class=\"string\">\"/data/files/\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">index</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class=\"line\">\tw.Write([]<span class=\"keyword\">byte</span>(uploadHTML))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">upload</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> r.Method == <span class=\"string\">\"GET\"</span> &#123;</div><div class=\"line\">\t\tindex(w, r)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tr.ParseMultipartForm(<span class=\"number\">32</span> &lt;&lt; <span class=\"number\">20</span>) <span class=\"comment\">// max memory is set to 32MB</span></div><div class=\"line\">\tclientfd, handler, err := r.FormFile(<span class=\"string\">\"uploadfile\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t\tw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"upload failed.\"</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> clientfd.Close()</div><div class=\"line\"></div><div class=\"line\">\tlocalpath := fmt.Sprintf(<span class=\"string\">\"%s%s\"</span>, destLocalPath, handler.Filename)</div><div class=\"line\">\tlocalfd, err := os.OpenFile(localpath, os.O_WRONLY|os.O_CREATE, <span class=\"number\">0666</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t\tw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"upload failed.\"</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> localfd.Close()</div><div class=\"line\"></div><div class=\"line\">\tio.Copy(localfd, clientfd)</div><div class=\"line\">\tw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"upload finish.\"</span>))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newRouter</span><span class=\"params\">()</span> <span class=\"title\">http</span>.<span class=\"title\">Handler</span></span> &#123;</div><div class=\"line\">\thdl := mux.NewRouter()</div><div class=\"line\">\thdl.HandleFunc(<span class=\"string\">\"/\"</span>, upload)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> hdl</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\thttp.ListenAndServe(<span class=\"string\">\":8877\"</span>, newRouter())</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假如需要在接收文件的时候计算文件hash值， 应该如何做呢？<br><br>根据io.TeeReader库，可以在文件上传过程中自动计算hash值, 完整代码修改为:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"crypto/sha1\"</span></div><div class=\"line\">\t<span class=\"string\">\"encoding/hex\"</span></div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"github.com/gorilla/mux\"</span></div><div class=\"line\">\t<span class=\"string\">\"io\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/http\"</span></div><div class=\"line\">\t<span class=\"string\">\"os\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> uploadHTML = <span class=\"string\">`</span></div><div class=\"line\">&lt;html&gt;  </div><div class=\"line\">  &lt;head&gt;  </div><div class=\"line\">    &lt;title&gt;选择文件&lt;/title&gt;</div><div class=\"line\">  &lt;/head&gt;  </div><div class=\"line\">  &lt;body&gt;  </div><div class=\"line\">    &lt;form enctype=\"multipart/form-data\" action=\"/\" method=\"post\"&gt;  </div><div class=\"line\">      &lt;input type=\"file\" name=\"uploadfile\" /&gt;  </div><div class=\"line\">      &lt;input type=\"submit\" value=\"上传文件\" /&gt;  </div><div class=\"line\">    &lt;/form&gt;  </div><div class=\"line\">  &lt;/body&gt;  </div><div class=\"line\">&lt;/html&gt;`</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> destLocalPath = <span class=\"string\">\"/data/files/\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">index</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class=\"line\">\tw.Write([]<span class=\"keyword\">byte</span>(uploadHTML))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">upload</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> r.Method == <span class=\"string\">\"GET\"</span> &#123;</div><div class=\"line\">\t\tindex(w, r)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tr.ParseMultipartForm(<span class=\"number\">32</span> &lt;&lt; <span class=\"number\">20</span>) <span class=\"comment\">// max memory is set to 32MB</span></div><div class=\"line\">\tclientfd, handler, err := r.FormFile(<span class=\"string\">\"uploadfile\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t\tw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"upload failed.\"</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> clientfd.Close()</div><div class=\"line\"></div><div class=\"line\">\tlocalpath := fmt.Sprintf(<span class=\"string\">\"%s%s\"</span>, destLocalPath, handler.Filename)</div><div class=\"line\">\tlocalfd, err := os.OpenFile(localpath, os.O_WRONLY|os.O_CREATE, <span class=\"number\">0666</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t\tw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"upload failed.\"</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> localfd.Close()</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 利用io.TeeReader在读取文件内容时计算hash值</span></div><div class=\"line\">\tfhash := sha1.New()</div><div class=\"line\">\tio.Copy(localfd, io.TeeReader(clientfd, fhash))</div><div class=\"line\">\thstr := hex.EncodeToString(fhash.Sum(<span class=\"literal\">nil</span>))</div><div class=\"line\">\tw.Write([]<span class=\"keyword\">byte</span>(fmt.Sprintf(<span class=\"string\">\"upload finish:%s\"</span>, hstr)))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newRouter</span><span class=\"params\">()</span> <span class=\"title\">http</span>.<span class=\"title\">Handler</span></span> &#123;</div><div class=\"line\">\thdl := mux.NewRouter()</div><div class=\"line\">\thdl.HandleFunc(<span class=\"string\">\"/\"</span>, upload)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> hdl</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\thttp.ListenAndServe(<span class=\"string\">\":8877\"</span>, newRouter())</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>利用net/http库及gorilla/mux库实现了一个简单的文件上传服务,<br><br>示例如下:<br>","more":"</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"github.com/gorilla/mux\"</span></div><div class=\"line\">\t<span class=\"string\">\"io\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/http\"</span></div><div class=\"line\">\t<span class=\"string\">\"os\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> uploadHTML = <span class=\"string\">`</span></div><div class=\"line\">&lt;html&gt;  </div><div class=\"line\">  &lt;head&gt;  </div><div class=\"line\">    &lt;title&gt;选择文件&lt;/title&gt;</div><div class=\"line\">  &lt;/head&gt;  </div><div class=\"line\">  &lt;body&gt;  </div><div class=\"line\">    &lt;form enctype=\"multipart/form-data\" action=\"/\" method=\"post\"&gt;  </div><div class=\"line\">      &lt;input type=\"file\" name=\"uploadfile\" /&gt;  </div><div class=\"line\">      &lt;input type=\"submit\" value=\"上传文件\" /&gt;  </div><div class=\"line\">    &lt;/form&gt;  </div><div class=\"line\">  &lt;/body&gt;  </div><div class=\"line\">&lt;/html&gt;`</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> destLocalPath = <span class=\"string\">\"/data/files/\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">index</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class=\"line\">\tw.Write([]<span class=\"keyword\">byte</span>(uploadHTML))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">upload</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> r.Method == <span class=\"string\">\"GET\"</span> &#123;</div><div class=\"line\">\t\tindex(w, r)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tr.ParseMultipartForm(<span class=\"number\">32</span> &lt;&lt; <span class=\"number\">20</span>) <span class=\"comment\">// max memory is set to 32MB</span></div><div class=\"line\">\tclientfd, handler, err := r.FormFile(<span class=\"string\">\"uploadfile\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t\tw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"upload failed.\"</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> clientfd.Close()</div><div class=\"line\"></div><div class=\"line\">\tlocalpath := fmt.Sprintf(<span class=\"string\">\"%s%s\"</span>, destLocalPath, handler.Filename)</div><div class=\"line\">\tlocalfd, err := os.OpenFile(localpath, os.O_WRONLY|os.O_CREATE, <span class=\"number\">0666</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t\tw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"upload failed.\"</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> localfd.Close()</div><div class=\"line\"></div><div class=\"line\">\tio.Copy(localfd, clientfd)</div><div class=\"line\">\tw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"upload finish.\"</span>))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newRouter</span><span class=\"params\">()</span> <span class=\"title\">http</span>.<span class=\"title\">Handler</span></span> &#123;</div><div class=\"line\">\thdl := mux.NewRouter()</div><div class=\"line\">\thdl.HandleFunc(<span class=\"string\">\"/\"</span>, upload)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> hdl</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\thttp.ListenAndServe(<span class=\"string\">\":8877\"</span>, newRouter())</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假如需要在接收文件的时候计算文件hash值， 应该如何做呢？<br><br>根据io.TeeReader库，可以在文件上传过程中自动计算hash值, 完整代码修改为:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"crypto/sha1\"</span></div><div class=\"line\">\t<span class=\"string\">\"encoding/hex\"</span></div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"github.com/gorilla/mux\"</span></div><div class=\"line\">\t<span class=\"string\">\"io\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/http\"</span></div><div class=\"line\">\t<span class=\"string\">\"os\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> uploadHTML = <span class=\"string\">`</span></div><div class=\"line\">&lt;html&gt;  </div><div class=\"line\">  &lt;head&gt;  </div><div class=\"line\">    &lt;title&gt;选择文件&lt;/title&gt;</div><div class=\"line\">  &lt;/head&gt;  </div><div class=\"line\">  &lt;body&gt;  </div><div class=\"line\">    &lt;form enctype=\"multipart/form-data\" action=\"/\" method=\"post\"&gt;  </div><div class=\"line\">      &lt;input type=\"file\" name=\"uploadfile\" /&gt;  </div><div class=\"line\">      &lt;input type=\"submit\" value=\"上传文件\" /&gt;  </div><div class=\"line\">    &lt;/form&gt;  </div><div class=\"line\">  &lt;/body&gt;  </div><div class=\"line\">&lt;/html&gt;`</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> destLocalPath = <span class=\"string\">\"/data/files/\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">index</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class=\"line\">\tw.Write([]<span class=\"keyword\">byte</span>(uploadHTML))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">upload</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> r.Method == <span class=\"string\">\"GET\"</span> &#123;</div><div class=\"line\">\t\tindex(w, r)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tr.ParseMultipartForm(<span class=\"number\">32</span> &lt;&lt; <span class=\"number\">20</span>) <span class=\"comment\">// max memory is set to 32MB</span></div><div class=\"line\">\tclientfd, handler, err := r.FormFile(<span class=\"string\">\"uploadfile\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t\tw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"upload failed.\"</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> clientfd.Close()</div><div class=\"line\"></div><div class=\"line\">\tlocalpath := fmt.Sprintf(<span class=\"string\">\"%s%s\"</span>, destLocalPath, handler.Filename)</div><div class=\"line\">\tlocalfd, err := os.OpenFile(localpath, os.O_WRONLY|os.O_CREATE, <span class=\"number\">0666</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t\tw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"upload failed.\"</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> localfd.Close()</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 利用io.TeeReader在读取文件内容时计算hash值</span></div><div class=\"line\">\tfhash := sha1.New()</div><div class=\"line\">\tio.Copy(localfd, io.TeeReader(clientfd, fhash))</div><div class=\"line\">\thstr := hex.EncodeToString(fhash.Sum(<span class=\"literal\">nil</span>))</div><div class=\"line\">\tw.Write([]<span class=\"keyword\">byte</span>(fmt.Sprintf(<span class=\"string\">\"upload finish:%s\"</span>, hstr)))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newRouter</span><span class=\"params\">()</span> <span class=\"title\">http</span>.<span class=\"title\">Handler</span></span> &#123;</div><div class=\"line\">\thdl := mux.NewRouter()</div><div class=\"line\">\thdl.HandleFunc(<span class=\"string\">\"/\"</span>, upload)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> hdl</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\thttp.ListenAndServe(<span class=\"string\">\":8877\"</span>, newRouter())</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"golang笔试题整理","date":"2017-11-14T00:44:28.000Z","_content":"\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc f1() (result int) {\n\tdefer func() {\n\t\tresult++\n\t}()\n\treturn 0\n}\n\nfunc f2() (r int) {\n\tt := 3\n\tdefer func() {\n\t\tt = t + 3\n\t}()\n\treturn t\n}\n\nfunc f3() (r int) {\n\tdefer func(r int) {\n\t\tr = r + 2\n\t}(r)\n\treturn 1\n}\n\nfunc main() {\n\tfmt.Println(f1())\n\tfmt.Println(f2())\n\tfmt.Println(f3())\n}\n\n// 考点：defer的一些坑\n// return xxx可以改写成一下规则：\n// 返回值 = xxx\n// 调用defer函数\n// 空的return\n\n// 输出：\n// 1\n// 3\n// 1\n```\n<!--more-->\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc loop() {\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Printf(\"%d \", i)\n\t}\n}\n\nfunc main() {\n\tgo loop()\n\tloop()\n}\n\n// 考点: 线程的执行顺序\n// 主线程首先退出，goroutine无法执行\n\n// 输出:\n// 0 1 2 3 4 5 6 7 8 9\n```\n\n```golang\npackage main\n\nimport \"fmt\"\n\nvar ch1 chan int = make(chan int)\nvar ch2 chan int = make(chan int)\n\nfunc worker1(s string) {\n\tfmt.Println(s)\n\tch1 <- <-ch2\n}\n\nfunc worker2(s string) {\n\tch1 <- <-ch2\n\tfmt.Println(s)\n}\n\nfunc main() {\n\tgo worker1(\"work hard.\")\n\tgo worker2(\"just for fun!\")\n\t<-ch1\n}\n\n// 考点：channel的执行顺序\n// ch1 <- <-ch2会引起当前goroutine阻塞,\n// <-ch1 会引起主线程阻塞,\n// 所有goroutine都在阻塞，引起死锁\n\n// 输出:\n// work hard.\n// fatal error: all goroutines are asleep - deadlock!\n```\n\n```golang\npackage main\n\ntype student struct {\n\tName string\n\tAge  int\n}\n\nfunc main() {\n\tm := make(map[string]*student)\n\tstus := []student{\n\t\t{Name: \"zhao\", Age: 24},\n\t\t{Name: \"chen\", Age: 23},\n\t\t{Name: \"wang\", Age: 22},\n\t}\n\tfor _, stu := range stus {\n\t\tm[stu.Name] = &stu\n\t}\n\n\tfor k, v := range m {\n\t\tprintln(k, \"--\", v.Name)\n\t}\n}\n\n// 考点：遍历与指针\n// m[stu.Name] = &stu： 每次赋值的&stu其实指向同一个地址,\n// 最后打印的值为最后一次遍历的student对象的值。\n\n// 输出:\n// zhao -- wang\n// chen -- wang\n// wang -- wang\n```\n\n```golang\npackage main\n\nimport \"fmt\"\n\ntype People struct{}\ntype Teacher struct {\n\tPeople\n}\n\nfunc (p *People) Walk() {\n\tfmt.Println(\"People Walk\")\n\tp.Work()\n}\n\nfunc (p *People) Work() {\n\tfmt.Println(\"People Work\")\n}\n\nfunc (t *Teacher) Work() {\n\tfmt.Println(\"Teacher Work\")\n}\n\nfunc main() {\n\tt := Teacher{}\n\tt.Walk()\n}\n\n// 考点: golang的组合继承\n// 虽然被组合的People类的方法升级成为外部Teacher组合类型的方法，\n// 但p.Work()调用时接收者仍然是People, 因此打印\"People Work\"\n\n// 输出:\n// People Walk\n// People Work\n```\n\n```golang\npackage main\n\nfunc test() []func()  {\n    var funs []func()\n    for i:=0;i<2 ;i++  {\n        funs = append(funs, func() {\n            println(&i,i)\n        })\n    }\n    return funs\n}\n\nfunc main(){\n    funs:=test()\n    for _,f:=range funs{\n        f()\n    }\n}\n\n// 考点：闭包延迟求值\n\n// 输出：\n// 0xc42000e110 2\n// 0xc42000e110 2\n```\n\n```golang\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc main1()  {\n    defer func() {\n       if err:=recover();err!=nil{\n           fmt.Println(err)\n       }else {\n           fmt.Println(\"fatal\")\n       }\n    }()\n\n    defer func() {\n        panic(\"defer panic\")\n    }()\n    panic(\"panic\")\n}\n\n// 考点：panic仅有最后一个被捕获\n\n// 输出：\n// defer panic\n```\n\n```golang\npackage main\n\nimport (\n\t\"sync\"\n)\n\ntype UserAges struct {\n\tages map[string]int\n\tsync.Mutex\n}\n\nfunc (ua *UserAges) Add(name string, age int) {\n\tua.Lock()\n\tdefer ua.Unlock()\n\tua.ages[name] = age\n}\n\nfunc (ua *UserAges) Get(name string) int {\n\tif age, ok := ua.ages[name]; ok {\n\t\treturn age\n\t}\n\treturn -1\n}\n\nfunc main() {\n\tua := UserAges{}\n\tua.Get(\"yourname\")\n}\n\n// 考点：map线程安全\n// 有可能出现：fatal error: concurrent map read and map write\n// 修改， Get方法加锁：\n//func (ua *UserAges) Get(name string) int {\n//    ua.Lock()\n//    defer ua.Unlock()\n//    if age, ok := ua.ages[name]; ok {\n//        return age\n//    }\n//    return -1\n//}\n```\n\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype People interface {\n\tSpeak(string) string\n}\n\ntype Stduent struct{}\n\nfunc (stu *Stduent) Speak(name string) (talk string) {\n\tif name == \"xiaoming\" {\n\t\ttalk = \"xiaoming is a good boy.\"\n\t} else {\n\t\ttalk = \"who's that guy?\"\n\t}\n\treturn\n}\n\nfunc main() {\n\tvar peo People = Stduent{}\n\tfmt.Println(peo.Speak(\"xiaoming\"))\n}\n\n// 考点: 接口实现与类型检查\n// 对于赋值给接口的类型，会有严格的类型检查，不允许做A到A*的转换\n// 类型A的方法集（method set）是类型*A的一个子集\n\n// 输出:\n// ./p7.go:23: cannot use Stduent literal (type Stduent) as type People in assignment:\n//\tStduent does not implement People (Speak method has pointer receiver)\n\n```\n","source":"_posts/golang/golang-tech-examination.md","raw":"---\ntitle: 'golang笔试题整理'\ndate: 2017-11-14 08:44:28\ntags: golang\n---\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc f1() (result int) {\n\tdefer func() {\n\t\tresult++\n\t}()\n\treturn 0\n}\n\nfunc f2() (r int) {\n\tt := 3\n\tdefer func() {\n\t\tt = t + 3\n\t}()\n\treturn t\n}\n\nfunc f3() (r int) {\n\tdefer func(r int) {\n\t\tr = r + 2\n\t}(r)\n\treturn 1\n}\n\nfunc main() {\n\tfmt.Println(f1())\n\tfmt.Println(f2())\n\tfmt.Println(f3())\n}\n\n// 考点：defer的一些坑\n// return xxx可以改写成一下规则：\n// 返回值 = xxx\n// 调用defer函数\n// 空的return\n\n// 输出：\n// 1\n// 3\n// 1\n```\n<!--more-->\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc loop() {\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Printf(\"%d \", i)\n\t}\n}\n\nfunc main() {\n\tgo loop()\n\tloop()\n}\n\n// 考点: 线程的执行顺序\n// 主线程首先退出，goroutine无法执行\n\n// 输出:\n// 0 1 2 3 4 5 6 7 8 9\n```\n\n```golang\npackage main\n\nimport \"fmt\"\n\nvar ch1 chan int = make(chan int)\nvar ch2 chan int = make(chan int)\n\nfunc worker1(s string) {\n\tfmt.Println(s)\n\tch1 <- <-ch2\n}\n\nfunc worker2(s string) {\n\tch1 <- <-ch2\n\tfmt.Println(s)\n}\n\nfunc main() {\n\tgo worker1(\"work hard.\")\n\tgo worker2(\"just for fun!\")\n\t<-ch1\n}\n\n// 考点：channel的执行顺序\n// ch1 <- <-ch2会引起当前goroutine阻塞,\n// <-ch1 会引起主线程阻塞,\n// 所有goroutine都在阻塞，引起死锁\n\n// 输出:\n// work hard.\n// fatal error: all goroutines are asleep - deadlock!\n```\n\n```golang\npackage main\n\ntype student struct {\n\tName string\n\tAge  int\n}\n\nfunc main() {\n\tm := make(map[string]*student)\n\tstus := []student{\n\t\t{Name: \"zhao\", Age: 24},\n\t\t{Name: \"chen\", Age: 23},\n\t\t{Name: \"wang\", Age: 22},\n\t}\n\tfor _, stu := range stus {\n\t\tm[stu.Name] = &stu\n\t}\n\n\tfor k, v := range m {\n\t\tprintln(k, \"--\", v.Name)\n\t}\n}\n\n// 考点：遍历与指针\n// m[stu.Name] = &stu： 每次赋值的&stu其实指向同一个地址,\n// 最后打印的值为最后一次遍历的student对象的值。\n\n// 输出:\n// zhao -- wang\n// chen -- wang\n// wang -- wang\n```\n\n```golang\npackage main\n\nimport \"fmt\"\n\ntype People struct{}\ntype Teacher struct {\n\tPeople\n}\n\nfunc (p *People) Walk() {\n\tfmt.Println(\"People Walk\")\n\tp.Work()\n}\n\nfunc (p *People) Work() {\n\tfmt.Println(\"People Work\")\n}\n\nfunc (t *Teacher) Work() {\n\tfmt.Println(\"Teacher Work\")\n}\n\nfunc main() {\n\tt := Teacher{}\n\tt.Walk()\n}\n\n// 考点: golang的组合继承\n// 虽然被组合的People类的方法升级成为外部Teacher组合类型的方法，\n// 但p.Work()调用时接收者仍然是People, 因此打印\"People Work\"\n\n// 输出:\n// People Walk\n// People Work\n```\n\n```golang\npackage main\n\nfunc test() []func()  {\n    var funs []func()\n    for i:=0;i<2 ;i++  {\n        funs = append(funs, func() {\n            println(&i,i)\n        })\n    }\n    return funs\n}\n\nfunc main(){\n    funs:=test()\n    for _,f:=range funs{\n        f()\n    }\n}\n\n// 考点：闭包延迟求值\n\n// 输出：\n// 0xc42000e110 2\n// 0xc42000e110 2\n```\n\n```golang\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc main1()  {\n    defer func() {\n       if err:=recover();err!=nil{\n           fmt.Println(err)\n       }else {\n           fmt.Println(\"fatal\")\n       }\n    }()\n\n    defer func() {\n        panic(\"defer panic\")\n    }()\n    panic(\"panic\")\n}\n\n// 考点：panic仅有最后一个被捕获\n\n// 输出：\n// defer panic\n```\n\n```golang\npackage main\n\nimport (\n\t\"sync\"\n)\n\ntype UserAges struct {\n\tages map[string]int\n\tsync.Mutex\n}\n\nfunc (ua *UserAges) Add(name string, age int) {\n\tua.Lock()\n\tdefer ua.Unlock()\n\tua.ages[name] = age\n}\n\nfunc (ua *UserAges) Get(name string) int {\n\tif age, ok := ua.ages[name]; ok {\n\t\treturn age\n\t}\n\treturn -1\n}\n\nfunc main() {\n\tua := UserAges{}\n\tua.Get(\"yourname\")\n}\n\n// 考点：map线程安全\n// 有可能出现：fatal error: concurrent map read and map write\n// 修改， Get方法加锁：\n//func (ua *UserAges) Get(name string) int {\n//    ua.Lock()\n//    defer ua.Unlock()\n//    if age, ok := ua.ages[name]; ok {\n//        return age\n//    }\n//    return -1\n//}\n```\n\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype People interface {\n\tSpeak(string) string\n}\n\ntype Stduent struct{}\n\nfunc (stu *Stduent) Speak(name string) (talk string) {\n\tif name == \"xiaoming\" {\n\t\ttalk = \"xiaoming is a good boy.\"\n\t} else {\n\t\ttalk = \"who's that guy?\"\n\t}\n\treturn\n}\n\nfunc main() {\n\tvar peo People = Stduent{}\n\tfmt.Println(peo.Speak(\"xiaoming\"))\n}\n\n// 考点: 接口实现与类型检查\n// 对于赋值给接口的类型，会有严格的类型检查，不允许做A到A*的转换\n// 类型A的方法集（method set）是类型*A的一个子集\n\n// 输出:\n// ./p7.go:23: cannot use Stduent literal (type Stduent) as type People in assignment:\n//\tStduent does not implement People (Speak method has pointer receiver)\n\n```\n","slug":"golang/golang-tech-examination","published":1,"updated":"2017-11-14T00:46:41.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dxy00394j4dvbxowmv4","content":"<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span> <span class=\"params\">(result <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t\tresult++</div><div class=\"line\">\t&#125;()</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">()</span> <span class=\"params\">(r <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">\tt := <span class=\"number\">3</span></div><div class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t\tt = t + <span class=\"number\">3</span></div><div class=\"line\">\t&#125;()</div><div class=\"line\">\t<span class=\"keyword\">return</span> t</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f3</span><span class=\"params\">()</span> <span class=\"params\">(r <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(r <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">\t\tr = r + <span class=\"number\">2</span></div><div class=\"line\">\t&#125;(r)</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tfmt.Println(f1())</div><div class=\"line\">\tfmt.Println(f2())</div><div class=\"line\">\tfmt.Println(f3())</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点：defer的一些坑</span></div><div class=\"line\"><span class=\"comment\">// return xxx可以改写成一下规则：</span></div><div class=\"line\"><span class=\"comment\">// 返回值 = xxx</span></div><div class=\"line\"><span class=\"comment\">// 调用defer函数</span></div><div class=\"line\"><span class=\"comment\">// 空的return</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出：</span></div><div class=\"line\"><span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"comment\">// 3</span></div><div class=\"line\"><span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</div><div class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"%d \"</span>, i)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">go</span> loop()</div><div class=\"line\">\tloop()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点: 线程的执行顺序</span></div><div class=\"line\"><span class=\"comment\">// 主线程首先退出，goroutine无法执行</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出:</span></div><div class=\"line\"><span class=\"comment\">// 0 1 2 3 4 5 6 7 8 9</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> ch1 <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span> = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> ch2 <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span> = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">worker1</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">\tfmt.Println(s)</div><div class=\"line\">\tch1 &lt;- &lt;-ch2</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">worker2</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">\tch1 &lt;- &lt;-ch2</div><div class=\"line\">\tfmt.Println(s)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">go</span> worker1(<span class=\"string\">\"work hard.\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">go</span> worker2(<span class=\"string\">\"just for fun!\"</span>)</div><div class=\"line\">\t&lt;-ch1</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点：channel的执行顺序</span></div><div class=\"line\"><span class=\"comment\">// ch1 &lt;- &lt;-ch2会引起当前goroutine阻塞,</span></div><div class=\"line\"><span class=\"comment\">// &lt;-ch1 会引起主线程阻塞,</span></div><div class=\"line\"><span class=\"comment\">// 所有goroutine都在阻塞，引起死锁</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出:</span></div><div class=\"line\"><span class=\"comment\">// work hard.</span></div><div class=\"line\"><span class=\"comment\">// fatal error: all goroutines are asleep - deadlock!</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> student <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tName <span class=\"keyword\">string</span></div><div class=\"line\">\tAge  <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tm := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*student)</div><div class=\"line\">\tstus := []student&#123;</div><div class=\"line\">\t\t&#123;Name: <span class=\"string\">\"zhao\"</span>, Age: <span class=\"number\">24</span>&#125;,</div><div class=\"line\">\t\t&#123;Name: <span class=\"string\">\"chen\"</span>, Age: <span class=\"number\">23</span>&#125;,</div><div class=\"line\">\t\t&#123;Name: <span class=\"string\">\"wang\"</span>, Age: <span class=\"number\">22</span>&#125;,</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">for</span> _, stu := <span class=\"keyword\">range</span> stus &#123;</div><div class=\"line\">\t\tm[stu.Name] = &amp;stu</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> m &#123;</div><div class=\"line\">\t\t<span class=\"built_in\">println</span>(k, <span class=\"string\">\"--\"</span>, v.Name)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点：遍历与指针</span></div><div class=\"line\"><span class=\"comment\">// m[stu.Name] = &amp;stu： 每次赋值的&amp;stu其实指向同一个地址,</span></div><div class=\"line\"><span class=\"comment\">// 最后打印的值为最后一次遍历的student对象的值。</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出:</span></div><div class=\"line\"><span class=\"comment\">// zhao -- wang</span></div><div class=\"line\"><span class=\"comment\">// chen -- wang</span></div><div class=\"line\"><span class=\"comment\">// wang -- wang</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> People <span class=\"keyword\">struct</span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> Teacher <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tPeople</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *People)</span> <span class=\"title\">Walk</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tfmt.Println(<span class=\"string\">\"People Walk\"</span>)</div><div class=\"line\">\tp.Work()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *People)</span> <span class=\"title\">Work</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tfmt.Println(<span class=\"string\">\"People Work\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Teacher)</span> <span class=\"title\">Work</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tfmt.Println(<span class=\"string\">\"Teacher Work\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tt := Teacher&#123;&#125;</div><div class=\"line\">\tt.Walk()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点: golang的组合继承</span></div><div class=\"line\"><span class=\"comment\">// 虽然被组合的People类的方法升级成为外部Teacher组合类型的方法，</span></div><div class=\"line\"><span class=\"comment\">// 但p.Work()调用时接收者仍然是People, 因此打印\"People Work\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出:</span></div><div class=\"line\"><span class=\"comment\">// People Walk</span></div><div class=\"line\"><span class=\"comment\">// People Work</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test</span><span class=\"params\">()</span> []<span class=\"title\">func</span><span class=\"params\">()</span></span>  &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> funs []<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span></div><div class=\"line\">    <span class=\"title\">for</span> <span class=\"title\">i</span>:=0;<span class=\"title\">i</span>&lt;2 ;<span class=\"title\">i</span>++  &#123;</div><div class=\"line\">        funs = <span class=\"built_in\">append</span>(funs, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">            <span class=\"built_in\">println</span>(&amp;i,i)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> funs</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    funs:=test()</div><div class=\"line\">    <span class=\"keyword\">for</span> _,f:=<span class=\"keyword\">range</span> funs&#123;</div><div class=\"line\">        f()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点：闭包延迟求值</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出：</span></div><div class=\"line\"><span class=\"comment\">// 0xc42000e110 2</span></div><div class=\"line\"><span class=\"comment\">// 0xc42000e110 2</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">    <span class=\"string\">\"reflect\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main1</span><span class=\"params\">()</span></span>  &#123;</div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> err:=<span class=\"built_in\">recover</span>();err!=<span class=\"literal\">nil</span>&#123;</div><div class=\"line\">           fmt.Println(err)</div><div class=\"line\">       &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           fmt.Println(<span class=\"string\">\"fatal\"</span>)</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">\"defer panic\"</span>)</div><div class=\"line\">    &#125;()</div><div class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"panic\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点：panic仅有最后一个被捕获</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出：</span></div><div class=\"line\"><span class=\"comment\">// defer panic</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"sync\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> UserAges <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tages <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></div><div class=\"line\">\tsync.Mutex</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ua *UserAges)</span> <span class=\"title\">Add</span><span class=\"params\">(name <span class=\"keyword\">string</span>, age <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">\tua.Lock()</div><div class=\"line\">\t<span class=\"keyword\">defer</span> ua.Unlock()</div><div class=\"line\">\tua.ages[name] = age</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ua *UserAges)</span> <span class=\"title\">Get</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> age, ok := ua.ages[name]; ok &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> age</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tua := UserAges&#123;&#125;</div><div class=\"line\">\tua.Get(<span class=\"string\">\"yourname\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点：map线程安全</span></div><div class=\"line\"><span class=\"comment\">// 有可能出现：fatal error: concurrent map read and map write</span></div><div class=\"line\"><span class=\"comment\">// 修改， Get方法加锁：</span></div><div class=\"line\"><span class=\"comment\">//func (ua *UserAges) Get(name string) int &#123;</span></div><div class=\"line\"><span class=\"comment\">//    ua.Lock()</span></div><div class=\"line\"><span class=\"comment\">//    defer ua.Unlock()</span></div><div class=\"line\"><span class=\"comment\">//    if age, ok := ua.ages[name]; ok &#123;</span></div><div class=\"line\"><span class=\"comment\">//        return age</span></div><div class=\"line\"><span class=\"comment\">//    &#125;</span></div><div class=\"line\"><span class=\"comment\">//    return -1</span></div><div class=\"line\"><span class=\"comment\">//&#125;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> People <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">\tSpeak(<span class=\"keyword\">string</span>) <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> Stduent <span class=\"keyword\">struct</span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(stu *Stduent)</span> <span class=\"title\">Speak</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(talk <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> name == <span class=\"string\">\"xiaoming\"</span> &#123;</div><div class=\"line\">\t\ttalk = <span class=\"string\">\"xiaoming is a good boy.\"</span></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\ttalk = <span class=\"string\">\"who's that guy?\"</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> peo People = Stduent&#123;&#125;</div><div class=\"line\">\tfmt.Println(peo.Speak(<span class=\"string\">\"xiaoming\"</span>))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点: 接口实现与类型检查</span></div><div class=\"line\"><span class=\"comment\">// 对于赋值给接口的类型，会有严格的类型检查，不允许做A到A*的转换</span></div><div class=\"line\"><span class=\"comment\">// 类型A的方法集（method set）是类型*A的一个子集</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出:</span></div><div class=\"line\"><span class=\"comment\">// ./p7.go:23: cannot use Stduent literal (type Stduent) as type People in assignment:</span></div><div class=\"line\"><span class=\"comment\">//\tStduent does not implement People (Speak method has pointer receiver)</span></div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span> <span class=\"params\">(result <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t\tresult++</div><div class=\"line\">\t&#125;()</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">()</span> <span class=\"params\">(r <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">\tt := <span class=\"number\">3</span></div><div class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t\tt = t + <span class=\"number\">3</span></div><div class=\"line\">\t&#125;()</div><div class=\"line\">\t<span class=\"keyword\">return</span> t</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f3</span><span class=\"params\">()</span> <span class=\"params\">(r <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(r <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">\t\tr = r + <span class=\"number\">2</span></div><div class=\"line\">\t&#125;(r)</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tfmt.Println(f1())</div><div class=\"line\">\tfmt.Println(f2())</div><div class=\"line\">\tfmt.Println(f3())</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点：defer的一些坑</span></div><div class=\"line\"><span class=\"comment\">// return xxx可以改写成一下规则：</span></div><div class=\"line\"><span class=\"comment\">// 返回值 = xxx</span></div><div class=\"line\"><span class=\"comment\">// 调用defer函数</span></div><div class=\"line\"><span class=\"comment\">// 空的return</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出：</span></div><div class=\"line\"><span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"comment\">// 3</span></div><div class=\"line\"><span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>","more":"<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</div><div class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"%d \"</span>, i)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">go</span> loop()</div><div class=\"line\">\tloop()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点: 线程的执行顺序</span></div><div class=\"line\"><span class=\"comment\">// 主线程首先退出，goroutine无法执行</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出:</span></div><div class=\"line\"><span class=\"comment\">// 0 1 2 3 4 5 6 7 8 9</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> ch1 <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span> = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> ch2 <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span> = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">worker1</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">\tfmt.Println(s)</div><div class=\"line\">\tch1 &lt;- &lt;-ch2</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">worker2</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">\tch1 &lt;- &lt;-ch2</div><div class=\"line\">\tfmt.Println(s)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">go</span> worker1(<span class=\"string\">\"work hard.\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">go</span> worker2(<span class=\"string\">\"just for fun!\"</span>)</div><div class=\"line\">\t&lt;-ch1</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点：channel的执行顺序</span></div><div class=\"line\"><span class=\"comment\">// ch1 &lt;- &lt;-ch2会引起当前goroutine阻塞,</span></div><div class=\"line\"><span class=\"comment\">// &lt;-ch1 会引起主线程阻塞,</span></div><div class=\"line\"><span class=\"comment\">// 所有goroutine都在阻塞，引起死锁</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出:</span></div><div class=\"line\"><span class=\"comment\">// work hard.</span></div><div class=\"line\"><span class=\"comment\">// fatal error: all goroutines are asleep - deadlock!</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> student <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tName <span class=\"keyword\">string</span></div><div class=\"line\">\tAge  <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tm := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*student)</div><div class=\"line\">\tstus := []student&#123;</div><div class=\"line\">\t\t&#123;Name: <span class=\"string\">\"zhao\"</span>, Age: <span class=\"number\">24</span>&#125;,</div><div class=\"line\">\t\t&#123;Name: <span class=\"string\">\"chen\"</span>, Age: <span class=\"number\">23</span>&#125;,</div><div class=\"line\">\t\t&#123;Name: <span class=\"string\">\"wang\"</span>, Age: <span class=\"number\">22</span>&#125;,</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">for</span> _, stu := <span class=\"keyword\">range</span> stus &#123;</div><div class=\"line\">\t\tm[stu.Name] = &amp;stu</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> m &#123;</div><div class=\"line\">\t\t<span class=\"built_in\">println</span>(k, <span class=\"string\">\"--\"</span>, v.Name)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点：遍历与指针</span></div><div class=\"line\"><span class=\"comment\">// m[stu.Name] = &amp;stu： 每次赋值的&amp;stu其实指向同一个地址,</span></div><div class=\"line\"><span class=\"comment\">// 最后打印的值为最后一次遍历的student对象的值。</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出:</span></div><div class=\"line\"><span class=\"comment\">// zhao -- wang</span></div><div class=\"line\"><span class=\"comment\">// chen -- wang</span></div><div class=\"line\"><span class=\"comment\">// wang -- wang</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> People <span class=\"keyword\">struct</span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> Teacher <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tPeople</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *People)</span> <span class=\"title\">Walk</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tfmt.Println(<span class=\"string\">\"People Walk\"</span>)</div><div class=\"line\">\tp.Work()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *People)</span> <span class=\"title\">Work</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tfmt.Println(<span class=\"string\">\"People Work\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Teacher)</span> <span class=\"title\">Work</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tfmt.Println(<span class=\"string\">\"Teacher Work\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tt := Teacher&#123;&#125;</div><div class=\"line\">\tt.Walk()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点: golang的组合继承</span></div><div class=\"line\"><span class=\"comment\">// 虽然被组合的People类的方法升级成为外部Teacher组合类型的方法，</span></div><div class=\"line\"><span class=\"comment\">// 但p.Work()调用时接收者仍然是People, 因此打印\"People Work\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出:</span></div><div class=\"line\"><span class=\"comment\">// People Walk</span></div><div class=\"line\"><span class=\"comment\">// People Work</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test</span><span class=\"params\">()</span> []<span class=\"title\">func</span><span class=\"params\">()</span></span>  &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> funs []<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span></div><div class=\"line\">    <span class=\"title\">for</span> <span class=\"title\">i</span>:=0;<span class=\"title\">i</span>&lt;2 ;<span class=\"title\">i</span>++  &#123;</div><div class=\"line\">        funs = <span class=\"built_in\">append</span>(funs, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">            <span class=\"built_in\">println</span>(&amp;i,i)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> funs</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    funs:=test()</div><div class=\"line\">    <span class=\"keyword\">for</span> _,f:=<span class=\"keyword\">range</span> funs&#123;</div><div class=\"line\">        f()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点：闭包延迟求值</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出：</span></div><div class=\"line\"><span class=\"comment\">// 0xc42000e110 2</span></div><div class=\"line\"><span class=\"comment\">// 0xc42000e110 2</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">    <span class=\"string\">\"reflect\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main1</span><span class=\"params\">()</span></span>  &#123;</div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> err:=<span class=\"built_in\">recover</span>();err!=<span class=\"literal\">nil</span>&#123;</div><div class=\"line\">           fmt.Println(err)</div><div class=\"line\">       &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           fmt.Println(<span class=\"string\">\"fatal\"</span>)</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">\"defer panic\"</span>)</div><div class=\"line\">    &#125;()</div><div class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"panic\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点：panic仅有最后一个被捕获</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出：</span></div><div class=\"line\"><span class=\"comment\">// defer panic</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"sync\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> UserAges <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tages <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></div><div class=\"line\">\tsync.Mutex</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ua *UserAges)</span> <span class=\"title\">Add</span><span class=\"params\">(name <span class=\"keyword\">string</span>, age <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">\tua.Lock()</div><div class=\"line\">\t<span class=\"keyword\">defer</span> ua.Unlock()</div><div class=\"line\">\tua.ages[name] = age</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ua *UserAges)</span> <span class=\"title\">Get</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> age, ok := ua.ages[name]; ok &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> age</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tua := UserAges&#123;&#125;</div><div class=\"line\">\tua.Get(<span class=\"string\">\"yourname\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点：map线程安全</span></div><div class=\"line\"><span class=\"comment\">// 有可能出现：fatal error: concurrent map read and map write</span></div><div class=\"line\"><span class=\"comment\">// 修改， Get方法加锁：</span></div><div class=\"line\"><span class=\"comment\">//func (ua *UserAges) Get(name string) int &#123;</span></div><div class=\"line\"><span class=\"comment\">//    ua.Lock()</span></div><div class=\"line\"><span class=\"comment\">//    defer ua.Unlock()</span></div><div class=\"line\"><span class=\"comment\">//    if age, ok := ua.ages[name]; ok &#123;</span></div><div class=\"line\"><span class=\"comment\">//        return age</span></div><div class=\"line\"><span class=\"comment\">//    &#125;</span></div><div class=\"line\"><span class=\"comment\">//    return -1</span></div><div class=\"line\"><span class=\"comment\">//&#125;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> People <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">\tSpeak(<span class=\"keyword\">string</span>) <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> Stduent <span class=\"keyword\">struct</span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(stu *Stduent)</span> <span class=\"title\">Speak</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(talk <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> name == <span class=\"string\">\"xiaoming\"</span> &#123;</div><div class=\"line\">\t\ttalk = <span class=\"string\">\"xiaoming is a good boy.\"</span></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\ttalk = <span class=\"string\">\"who's that guy?\"</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> peo People = Stduent&#123;&#125;</div><div class=\"line\">\tfmt.Println(peo.Speak(<span class=\"string\">\"xiaoming\"</span>))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 考点: 接口实现与类型检查</span></div><div class=\"line\"><span class=\"comment\">// 对于赋值给接口的类型，会有严格的类型检查，不允许做A到A*的转换</span></div><div class=\"line\"><span class=\"comment\">// 类型A的方法集（method set）是类型*A的一个子集</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出:</span></div><div class=\"line\"><span class=\"comment\">// ./p7.go:23: cannot use Stduent literal (type Stduent) as type People in assignment:</span></div><div class=\"line\"><span class=\"comment\">//\tStduent does not implement People (Speak method has pointer receiver)</span></div></pre></td></tr></table></figure>"},{"title":"golang知识点整理(持续更新)","date":"2017-11-14T05:41:50.000Z","_content":"\n- 对golang的整体理解\n```\nGo是一种编译型语言，结合了解释型语言的优点(如调试效率，跨平台)，动态类型语言的优点(如开发效率)，以及静态类型的优点(如安全性)；\nGo是静态类型语言，类型系统没有层级，因此无需在类型关系定义上耗费过多时间；\nGo是垃圾回收型的语言，并为并发执行与通信提供了基本的支持；\nGo目标是要成为一种现在的系统语言，不过目前更多用来构建支持高性能高并发web服务。\n```\n<!--more-->\n\n- 列出常用的一些built-int包\n```\nweb server: /net/http\ndatabase: database/sql\ncompress: compress/gzip\ncryptography: Crypto/md5, crypto/sha1\nencoding: encoding/json\n```\n\n- 如何理解goroutine? 如何停止一个goroutine?\n```\ngoroutine是Golang实现并发的最小逻辑单元；\n非常轻量级，是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈；\n是一种用户态线程，不被linux内核识别，运行在内核线程之上；\ngoroutine在cpu上换入换出，不断上下文切换的时候，必须要保证的事情就是保存现场和恢复现场。\n可以通过设置信号channel来阻塞和退出一个goroutine。\n```\n- 如果gorouting中有很多阻塞系统调用，那是不是会创建很多内核线程?\n```\n是的，处于等待系统调用中M不会占用mcpu数量， 只有在运行中的M才会占用mcpu数量并对应到一条系统线程。\nsysmon线程会将进入系统调用的M上的G队列移到其他M上等待执行。\nP(最开始只有G和M，Processor可看作是后来加入的一种优化)用于解决之前并发执行中加锁的性能问题, 是N：1调度器转到M：N调度器的重要部分。\n```\n\n- Go中的channel和mutex锁机制的比较\n```\n程序间通讯两种模型： 1）共享内存 2）消息传递\nchannel是消息传递在Go上的具体实现， 四个基本操作：打开/关闭/写/读channel。\n\nchannel与mutex重要区别： 一件任务是在“调用处”还是“被调用处”执行。\n\nchannel典型应用场景：一个goroutine负责处理某个任务或资源，其他goroutine通过channel向它发送相关指令。\nmutex典型应用场景：goroutine访问一个共享资源前进行加锁，然后自己处理完相关操作后再释放资源。\n\nchannel会消耗更多成本，因为涉及到上下文切换；而mutex通常只是一个原子操作。\n\n无法通过mutex控制并发的goroutine数量， 但是可以通过带缓存的channel来指定并发goroutine数。\n```\n\n- Go中的数组和C中的数组有什么区别？\n```\n1. Go中数组是值类型，数组赋值给另一个变量会对所有元素进行拷贝；\n2. 向函数传递数组参数，传递的是该数组的拷贝而不是指针；\n3. 数组的长度也是数组类型的一部分，[2]int和[4]int是两种不同的类型。\n```\n\n- 谈谈Go中的接口？\n```\n接口可以看作是一种对象的行为集合，一系列函数的集合；\n要实现一个接口，需要实现该接口中的所有方法；\n实现接口是非侵入式的，去掉复杂继承体系。\ninterface具体数据结构：\nstruct Eface    // 空interface\n{\n    Type*    type;\n    void*    data;\n};\n\nstruct Iface    // 带方法的interface\n{\n    Itab*    tab;\n    void*    data;\n};\n```\n\n- 谈谈Go中的类型转换和类型断言？\n```\n普通类型转接口类型是隐式的，接口类型转普通类型需要进行类型断言；\n类型断言前一般要做些判断，避免panic: value, ok := a.(string)\n```\n\n- 谈谈Go中的闭包？\n```\n闭包：函数+引用变量， 引用变量是不能在栈上分配的；\n逃逸分析：go编译器可以分析出变量的作用范围，自动决定是在栈还是对分配内存，将闭包环境变量在堆上分配是Go实现闭包的基础；\n结构体：返回闭包并不仅仅是返回一个函数，而是返回一个结构体，包含函数返回地址和所引用环境的变量地址等信息。\n```\n\n- Go中实现非阻塞IO的原理是怎样的\n```\n在Go程序初始化时， 会启动一个后台线程sysmon（主要角色称为poller）。\n当某个goroutine进行IO操作而此刻IO还没准备好，那它就会被放到等待队列中，\n此时该goroutine被阻塞了，但系统继续运行其他goroutine。\n\n这样，所有发生阻塞的文件描述符fd会添加到这个poller上，\n而poller不停的进行poll，一旦获取到就绪的fd描述符，\n就会唤醒之前因它而阻塞的goroutine\t。\n\npoller比gc更高级，前者是一个物理线程，而后者只是线程池里的一个goroutine任务。\n```\n\n- 关于Go中的栈管理技术（分段栈和连续栈）\n```\n分段栈： \nGo1.4之前的栈管理技术，运行时给每个goroutine分配8K的初始化栈内存；\n在每个go函数之前有个代码块，检查已分配栈空间已不足，\n不足的话会调用morestack函数来分配一段新的内存作栈空间，\n然后将包括上一个栈地址等信息的struct和lessmore函数写入栈底，\n接着重启gorouine，从将原来栈空间用光的函数开始执行(这里称为stack split)。\n等该函数执行返回时，通过lessstack函数查找栈底部struct来调整栈指针，\n使得返回原来栈空间，同时将该新栈段释放掉。\n连续栈：\nGo1.4之后使用连续栈，同样在每个函数入口进行栈溢出检查，\n只是在栈溢出时会申请一个两倍于当前栈空间的内存空间，\n然后把当前旧栈拷贝到新栈，释放旧栈空间，\n最后程序重启goroutine并从引起重新分配栈段的函数继续执行。\n实现栈拷贝的关键：\n1. 只有在栈上分配的指针才能指向栈上的地址；\n2. 需要知道栈上哪部分是指针，因为移动栈时需要把所有的指针指向新的目标地址；\n原来Go运行时很多是C写的，大量运行时调用没有指针信息可用，这也是Go runtime被大规模重构的主要原因。\n```\n\n- 关于Go的内存池\n```\nGo 初始化时申请一大块的虚拟内存空间，所有对象的内存回收时不会释放虚拟地址空间，但是虚拟地址空间和物理内存的映射会还给操作系统。\n如果系统还有空余空间，这些物理内存暂时就先留着给 Go 使用，避免频繁分配内存；当系统真正需要时则可以则回收这部分内存。\n\n其参考tcmalloc，分级内存池管理，几个关键数据结构：\n- mspan\n由mheap管理的页面，记录了所分配的块大小和起始地址等\n- mcache\n与P(可看做cpu)绑定的线程级别的本地缓存\n- mcenter\n全局空间的缓存，收集了各种大小(67种)的span列表\n- mheap\n分配内存的堆分配器，以8kb进行页管理\n- fixalloc\n固定尺寸的堆外(直接由系统管理的内存)对象空闲列表分配器，用来管理分配器的存储\n```\n\n- 浅谈Go的垃圾回收机制\n```\n常见算法： 引用计数，标记清扫， 三色标记清扫，分代回收\nGo1.5后至目前主要用了并发三色标记清扫算法，有效减少停顿时间。\n垃圾回收触发：由一个gcpercent变量控制，比如gcpercent=100，\n假设当前使用内存=100M，那么等到使用内存分配达到200MB时将触发GC；假设GC后的内存回到了120MB，那下次触发GC将在分配内存达到240MB的时候。\n```\n","source":"_posts/golang/golang-tech-keys.md","raw":"---\ntitle: 'golang知识点整理(持续更新)'\ndate: 2017-11-14 13:41:50\ntags: golang\n---\n\n- 对golang的整体理解\n```\nGo是一种编译型语言，结合了解释型语言的优点(如调试效率，跨平台)，动态类型语言的优点(如开发效率)，以及静态类型的优点(如安全性)；\nGo是静态类型语言，类型系统没有层级，因此无需在类型关系定义上耗费过多时间；\nGo是垃圾回收型的语言，并为并发执行与通信提供了基本的支持；\nGo目标是要成为一种现在的系统语言，不过目前更多用来构建支持高性能高并发web服务。\n```\n<!--more-->\n\n- 列出常用的一些built-int包\n```\nweb server: /net/http\ndatabase: database/sql\ncompress: compress/gzip\ncryptography: Crypto/md5, crypto/sha1\nencoding: encoding/json\n```\n\n- 如何理解goroutine? 如何停止一个goroutine?\n```\ngoroutine是Golang实现并发的最小逻辑单元；\n非常轻量级，是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈；\n是一种用户态线程，不被linux内核识别，运行在内核线程之上；\ngoroutine在cpu上换入换出，不断上下文切换的时候，必须要保证的事情就是保存现场和恢复现场。\n可以通过设置信号channel来阻塞和退出一个goroutine。\n```\n- 如果gorouting中有很多阻塞系统调用，那是不是会创建很多内核线程?\n```\n是的，处于等待系统调用中M不会占用mcpu数量， 只有在运行中的M才会占用mcpu数量并对应到一条系统线程。\nsysmon线程会将进入系统调用的M上的G队列移到其他M上等待执行。\nP(最开始只有G和M，Processor可看作是后来加入的一种优化)用于解决之前并发执行中加锁的性能问题, 是N：1调度器转到M：N调度器的重要部分。\n```\n\n- Go中的channel和mutex锁机制的比较\n```\n程序间通讯两种模型： 1）共享内存 2）消息传递\nchannel是消息传递在Go上的具体实现， 四个基本操作：打开/关闭/写/读channel。\n\nchannel与mutex重要区别： 一件任务是在“调用处”还是“被调用处”执行。\n\nchannel典型应用场景：一个goroutine负责处理某个任务或资源，其他goroutine通过channel向它发送相关指令。\nmutex典型应用场景：goroutine访问一个共享资源前进行加锁，然后自己处理完相关操作后再释放资源。\n\nchannel会消耗更多成本，因为涉及到上下文切换；而mutex通常只是一个原子操作。\n\n无法通过mutex控制并发的goroutine数量， 但是可以通过带缓存的channel来指定并发goroutine数。\n```\n\n- Go中的数组和C中的数组有什么区别？\n```\n1. Go中数组是值类型，数组赋值给另一个变量会对所有元素进行拷贝；\n2. 向函数传递数组参数，传递的是该数组的拷贝而不是指针；\n3. 数组的长度也是数组类型的一部分，[2]int和[4]int是两种不同的类型。\n```\n\n- 谈谈Go中的接口？\n```\n接口可以看作是一种对象的行为集合，一系列函数的集合；\n要实现一个接口，需要实现该接口中的所有方法；\n实现接口是非侵入式的，去掉复杂继承体系。\ninterface具体数据结构：\nstruct Eface    // 空interface\n{\n    Type*    type;\n    void*    data;\n};\n\nstruct Iface    // 带方法的interface\n{\n    Itab*    tab;\n    void*    data;\n};\n```\n\n- 谈谈Go中的类型转换和类型断言？\n```\n普通类型转接口类型是隐式的，接口类型转普通类型需要进行类型断言；\n类型断言前一般要做些判断，避免panic: value, ok := a.(string)\n```\n\n- 谈谈Go中的闭包？\n```\n闭包：函数+引用变量， 引用变量是不能在栈上分配的；\n逃逸分析：go编译器可以分析出变量的作用范围，自动决定是在栈还是对分配内存，将闭包环境变量在堆上分配是Go实现闭包的基础；\n结构体：返回闭包并不仅仅是返回一个函数，而是返回一个结构体，包含函数返回地址和所引用环境的变量地址等信息。\n```\n\n- Go中实现非阻塞IO的原理是怎样的\n```\n在Go程序初始化时， 会启动一个后台线程sysmon（主要角色称为poller）。\n当某个goroutine进行IO操作而此刻IO还没准备好，那它就会被放到等待队列中，\n此时该goroutine被阻塞了，但系统继续运行其他goroutine。\n\n这样，所有发生阻塞的文件描述符fd会添加到这个poller上，\n而poller不停的进行poll，一旦获取到就绪的fd描述符，\n就会唤醒之前因它而阻塞的goroutine\t。\n\npoller比gc更高级，前者是一个物理线程，而后者只是线程池里的一个goroutine任务。\n```\n\n- 关于Go中的栈管理技术（分段栈和连续栈）\n```\n分段栈： \nGo1.4之前的栈管理技术，运行时给每个goroutine分配8K的初始化栈内存；\n在每个go函数之前有个代码块，检查已分配栈空间已不足，\n不足的话会调用morestack函数来分配一段新的内存作栈空间，\n然后将包括上一个栈地址等信息的struct和lessmore函数写入栈底，\n接着重启gorouine，从将原来栈空间用光的函数开始执行(这里称为stack split)。\n等该函数执行返回时，通过lessstack函数查找栈底部struct来调整栈指针，\n使得返回原来栈空间，同时将该新栈段释放掉。\n连续栈：\nGo1.4之后使用连续栈，同样在每个函数入口进行栈溢出检查，\n只是在栈溢出时会申请一个两倍于当前栈空间的内存空间，\n然后把当前旧栈拷贝到新栈，释放旧栈空间，\n最后程序重启goroutine并从引起重新分配栈段的函数继续执行。\n实现栈拷贝的关键：\n1. 只有在栈上分配的指针才能指向栈上的地址；\n2. 需要知道栈上哪部分是指针，因为移动栈时需要把所有的指针指向新的目标地址；\n原来Go运行时很多是C写的，大量运行时调用没有指针信息可用，这也是Go runtime被大规模重构的主要原因。\n```\n\n- 关于Go的内存池\n```\nGo 初始化时申请一大块的虚拟内存空间，所有对象的内存回收时不会释放虚拟地址空间，但是虚拟地址空间和物理内存的映射会还给操作系统。\n如果系统还有空余空间，这些物理内存暂时就先留着给 Go 使用，避免频繁分配内存；当系统真正需要时则可以则回收这部分内存。\n\n其参考tcmalloc，分级内存池管理，几个关键数据结构：\n- mspan\n由mheap管理的页面，记录了所分配的块大小和起始地址等\n- mcache\n与P(可看做cpu)绑定的线程级别的本地缓存\n- mcenter\n全局空间的缓存，收集了各种大小(67种)的span列表\n- mheap\n分配内存的堆分配器，以8kb进行页管理\n- fixalloc\n固定尺寸的堆外(直接由系统管理的内存)对象空闲列表分配器，用来管理分配器的存储\n```\n\n- 浅谈Go的垃圾回收机制\n```\n常见算法： 引用计数，标记清扫， 三色标记清扫，分代回收\nGo1.5后至目前主要用了并发三色标记清扫算法，有效减少停顿时间。\n垃圾回收触发：由一个gcpercent变量控制，比如gcpercent=100，\n假设当前使用内存=100M，那么等到使用内存分配达到200MB时将触发GC；假设GC后的内存回到了120MB，那下次触发GC将在分配内存达到240MB的时候。\n```\n","slug":"golang/golang-tech-keys","published":1,"updated":"2017-11-16T08:38:03.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dy0003b4j4dl1xl33i3","content":"<ul>\n<li>对golang的整体理解<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Go是一种编译型语言，结合了解释型语言的优点(如调试效率，跨平台)，动态类型语言的优点(如开发效率)，以及静态类型的优点(如安全性)；</div><div class=\"line\">Go是静态类型语言，类型系统没有层级，因此无需在类型关系定义上耗费过多时间；</div><div class=\"line\">Go是垃圾回收型的语言，并为并发执行与通信提供了基本的支持；</div><div class=\"line\">Go目标是要成为一种现在的系统语言，不过目前更多用来构建支持高性能高并发web服务。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>列出常用的一些built-int包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">web server: /net/http</div><div class=\"line\">database: database/sql</div><div class=\"line\">compress: compress/gzip</div><div class=\"line\">cryptography: Crypto/md5, crypto/sha1</div><div class=\"line\">encoding: encoding/json</div></pre></td></tr></table></figure>\n</li>\n<li><p>如何理解goroutine? 如何停止一个goroutine?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">goroutine是Golang实现并发的最小逻辑单元；</div><div class=\"line\">非常轻量级，是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈；</div><div class=\"line\">是一种用户态线程，不被linux内核识别，运行在内核线程之上；</div><div class=\"line\">goroutine在cpu上换入换出，不断上下文切换的时候，必须要保证的事情就是保存现场和恢复现场。</div><div class=\"line\">可以通过设置信号channel来阻塞和退出一个goroutine。</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果gorouting中有很多阻塞系统调用，那是不是会创建很多内核线程?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">是的，处于等待系统调用中M不会占用mcpu数量， 只有在运行中的M才会占用mcpu数量并对应到一条系统线程。</div><div class=\"line\">sysmon线程会将进入系统调用的M上的G队列移到其他M上等待执行。</div><div class=\"line\">P(最开始只有G和M，Processor可看作是后来加入的一种优化)用于解决之前并发执行中加锁的性能问题, 是N：1调度器转到M：N调度器的重要部分。</div></pre></td></tr></table></figure>\n</li>\n<li><p>Go中的channel和mutex锁机制的比较</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">程序间通讯两种模型： 1）共享内存 2）消息传递</div><div class=\"line\">channel是消息传递在Go上的具体实现， 四个基本操作：打开/关闭/写/读channel。</div><div class=\"line\"></div><div class=\"line\">channel与mutex重要区别： 一件任务是在“调用处”还是“被调用处”执行。</div><div class=\"line\"></div><div class=\"line\">channel典型应用场景：一个goroutine负责处理某个任务或资源，其他goroutine通过channel向它发送相关指令。</div><div class=\"line\">mutex典型应用场景：goroutine访问一个共享资源前进行加锁，然后自己处理完相关操作后再释放资源。</div><div class=\"line\"></div><div class=\"line\">channel会消耗更多成本，因为涉及到上下文切换；而mutex通常只是一个原子操作。</div><div class=\"line\"></div><div class=\"line\">无法通过mutex控制并发的goroutine数量， 但是可以通过带缓存的channel来指定并发goroutine数。</div></pre></td></tr></table></figure>\n</li>\n<li><p>Go中的数组和C中的数组有什么区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. Go中数组是值类型，数组赋值给另一个变量会对所有元素进行拷贝；</div><div class=\"line\">2. 向函数传递数组参数，传递的是该数组的拷贝而不是指针；</div><div class=\"line\">3. 数组的长度也是数组类型的一部分，[2]int和[4]int是两种不同的类型。</div></pre></td></tr></table></figure>\n</li>\n<li><p>谈谈Go中的接口？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">接口可以看作是一种对象的行为集合，一系列函数的集合；</div><div class=\"line\">要实现一个接口，需要实现该接口中的所有方法；</div><div class=\"line\">实现接口是非侵入式的，去掉复杂继承体系。</div><div class=\"line\">interface具体数据结构：</div><div class=\"line\">struct Eface    // 空interface</div><div class=\"line\">&#123;</div><div class=\"line\">    Type*    type;</div><div class=\"line\">    void*    data;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct Iface    // 带方法的interface</div><div class=\"line\">&#123;</div><div class=\"line\">    Itab*    tab;</div><div class=\"line\">    void*    data;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>谈谈Go中的类型转换和类型断言？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">普通类型转接口类型是隐式的，接口类型转普通类型需要进行类型断言；</div><div class=\"line\">类型断言前一般要做些判断，避免panic: value, ok := a.(string)</div></pre></td></tr></table></figure>\n</li>\n<li><p>谈谈Go中的闭包？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">闭包：函数+引用变量， 引用变量是不能在栈上分配的；</div><div class=\"line\">逃逸分析：go编译器可以分析出变量的作用范围，自动决定是在栈还是对分配内存，将闭包环境变量在堆上分配是Go实现闭包的基础；</div><div class=\"line\">结构体：返回闭包并不仅仅是返回一个函数，而是返回一个结构体，包含函数返回地址和所引用环境的变量地址等信息。</div></pre></td></tr></table></figure>\n</li>\n<li><p>Go中实现非阻塞IO的原理是怎样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">在Go程序初始化时， 会启动一个后台线程sysmon（主要角色称为poller）。</div><div class=\"line\">当某个goroutine进行IO操作而此刻IO还没准备好，那它就会被放到等待队列中，</div><div class=\"line\">此时该goroutine被阻塞了，但系统继续运行其他goroutine。</div><div class=\"line\"></div><div class=\"line\">这样，所有发生阻塞的文件描述符fd会添加到这个poller上，</div><div class=\"line\">而poller不停的进行poll，一旦获取到就绪的fd描述符，</div><div class=\"line\">就会唤醒之前因它而阻塞的goroutine\t。</div><div class=\"line\"></div><div class=\"line\">poller比gc更高级，前者是一个物理线程，而后者只是线程池里的一个goroutine任务。</div></pre></td></tr></table></figure>\n</li>\n<li><p>关于Go中的栈管理技术（分段栈和连续栈）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">分段栈： </div><div class=\"line\">Go1.4之前的栈管理技术，运行时给每个goroutine分配8K的初始化栈内存；</div><div class=\"line\">在每个go函数之前有个代码块，检查已分配栈空间已不足，</div><div class=\"line\">不足的话会调用morestack函数来分配一段新的内存作栈空间，</div><div class=\"line\">然后将包括上一个栈地址等信息的struct和lessmore函数写入栈底，</div><div class=\"line\">接着重启gorouine，从将原来栈空间用光的函数开始执行(这里称为stack split)。</div><div class=\"line\">等该函数执行返回时，通过lessstack函数查找栈底部struct来调整栈指针，</div><div class=\"line\">使得返回原来栈空间，同时将该新栈段释放掉。</div><div class=\"line\">连续栈：</div><div class=\"line\">Go1.4之后使用连续栈，同样在每个函数入口进行栈溢出检查，</div><div class=\"line\">只是在栈溢出时会申请一个两倍于当前栈空间的内存空间，</div><div class=\"line\">然后把当前旧栈拷贝到新栈，释放旧栈空间，</div><div class=\"line\">最后程序重启goroutine并从引起重新分配栈段的函数继续执行。</div><div class=\"line\">实现栈拷贝的关键：</div><div class=\"line\">1. 只有在栈上分配的指针才能指向栈上的地址；</div><div class=\"line\">2. 需要知道栈上哪部分是指针，因为移动栈时需要把所有的指针指向新的目标地址；</div><div class=\"line\">原来Go运行时很多是C写的，大量运行时调用没有指针信息可用，这也是Go runtime被大规模重构的主要原因。</div></pre></td></tr></table></figure>\n</li>\n<li><p>关于Go的内存池</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">Go 初始化时申请一大块的虚拟内存空间，所有对象的内存回收时不会释放虚拟地址空间，但是虚拟地址空间和物理内存的映射会还给操作系统。</div><div class=\"line\">如果系统还有空余空间，这些物理内存暂时就先留着给 Go 使用，避免频繁分配内存；当系统真正需要时则可以则回收这部分内存。</div><div class=\"line\"></div><div class=\"line\">其参考tcmalloc，分级内存池管理，几个关键数据结构：</div><div class=\"line\">- mspan</div><div class=\"line\">由mheap管理的页面，记录了所分配的块大小和起始地址等</div><div class=\"line\">- mcache</div><div class=\"line\">与P(可看做cpu)绑定的线程级别的本地缓存</div><div class=\"line\">- mcenter</div><div class=\"line\">全局空间的缓存，收集了各种大小(67种)的span列表</div><div class=\"line\">- mheap</div><div class=\"line\">分配内存的堆分配器，以8kb进行页管理</div><div class=\"line\">- fixalloc</div><div class=\"line\">固定尺寸的堆外(直接由系统管理的内存)对象空闲列表分配器，用来管理分配器的存储</div></pre></td></tr></table></figure>\n</li>\n<li><p>浅谈Go的垃圾回收机制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">常见算法： 引用计数，标记清扫， 三色标记清扫，分代回收</div><div class=\"line\">Go1.5后至目前主要用了并发三色标记清扫算法，有效减少停顿时间。</div><div class=\"line\">垃圾回收触发：由一个gcpercent变量控制，比如gcpercent=100，</div><div class=\"line\">假设当前使用内存=100M，那么等到使用内存分配达到200MB时将触发GC；假设GC后的内存回到了120MB，那下次触发GC将在分配内存达到240MB的时候。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>对golang的整体理解<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Go是一种编译型语言，结合了解释型语言的优点(如调试效率，跨平台)，动态类型语言的优点(如开发效率)，以及静态类型的优点(如安全性)；</div><div class=\"line\">Go是静态类型语言，类型系统没有层级，因此无需在类型关系定义上耗费过多时间；</div><div class=\"line\">Go是垃圾回收型的语言，并为并发执行与通信提供了基本的支持；</div><div class=\"line\">Go目标是要成为一种现在的系统语言，不过目前更多用来构建支持高性能高并发web服务。</div></pre></td></tr></table></figure>\n</li>\n</ul>","more":"<ul>\n<li><p>列出常用的一些built-int包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">web server: /net/http</div><div class=\"line\">database: database/sql</div><div class=\"line\">compress: compress/gzip</div><div class=\"line\">cryptography: Crypto/md5, crypto/sha1</div><div class=\"line\">encoding: encoding/json</div></pre></td></tr></table></figure>\n</li>\n<li><p>如何理解goroutine? 如何停止一个goroutine?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">goroutine是Golang实现并发的最小逻辑单元；</div><div class=\"line\">非常轻量级，是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈；</div><div class=\"line\">是一种用户态线程，不被linux内核识别，运行在内核线程之上；</div><div class=\"line\">goroutine在cpu上换入换出，不断上下文切换的时候，必须要保证的事情就是保存现场和恢复现场。</div><div class=\"line\">可以通过设置信号channel来阻塞和退出一个goroutine。</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果gorouting中有很多阻塞系统调用，那是不是会创建很多内核线程?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">是的，处于等待系统调用中M不会占用mcpu数量， 只有在运行中的M才会占用mcpu数量并对应到一条系统线程。</div><div class=\"line\">sysmon线程会将进入系统调用的M上的G队列移到其他M上等待执行。</div><div class=\"line\">P(最开始只有G和M，Processor可看作是后来加入的一种优化)用于解决之前并发执行中加锁的性能问题, 是N：1调度器转到M：N调度器的重要部分。</div></pre></td></tr></table></figure>\n</li>\n<li><p>Go中的channel和mutex锁机制的比较</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">程序间通讯两种模型： 1）共享内存 2）消息传递</div><div class=\"line\">channel是消息传递在Go上的具体实现， 四个基本操作：打开/关闭/写/读channel。</div><div class=\"line\"></div><div class=\"line\">channel与mutex重要区别： 一件任务是在“调用处”还是“被调用处”执行。</div><div class=\"line\"></div><div class=\"line\">channel典型应用场景：一个goroutine负责处理某个任务或资源，其他goroutine通过channel向它发送相关指令。</div><div class=\"line\">mutex典型应用场景：goroutine访问一个共享资源前进行加锁，然后自己处理完相关操作后再释放资源。</div><div class=\"line\"></div><div class=\"line\">channel会消耗更多成本，因为涉及到上下文切换；而mutex通常只是一个原子操作。</div><div class=\"line\"></div><div class=\"line\">无法通过mutex控制并发的goroutine数量， 但是可以通过带缓存的channel来指定并发goroutine数。</div></pre></td></tr></table></figure>\n</li>\n<li><p>Go中的数组和C中的数组有什么区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. Go中数组是值类型，数组赋值给另一个变量会对所有元素进行拷贝；</div><div class=\"line\">2. 向函数传递数组参数，传递的是该数组的拷贝而不是指针；</div><div class=\"line\">3. 数组的长度也是数组类型的一部分，[2]int和[4]int是两种不同的类型。</div></pre></td></tr></table></figure>\n</li>\n<li><p>谈谈Go中的接口？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">接口可以看作是一种对象的行为集合，一系列函数的集合；</div><div class=\"line\">要实现一个接口，需要实现该接口中的所有方法；</div><div class=\"line\">实现接口是非侵入式的，去掉复杂继承体系。</div><div class=\"line\">interface具体数据结构：</div><div class=\"line\">struct Eface    // 空interface</div><div class=\"line\">&#123;</div><div class=\"line\">    Type*    type;</div><div class=\"line\">    void*    data;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct Iface    // 带方法的interface</div><div class=\"line\">&#123;</div><div class=\"line\">    Itab*    tab;</div><div class=\"line\">    void*    data;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>谈谈Go中的类型转换和类型断言？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">普通类型转接口类型是隐式的，接口类型转普通类型需要进行类型断言；</div><div class=\"line\">类型断言前一般要做些判断，避免panic: value, ok := a.(string)</div></pre></td></tr></table></figure>\n</li>\n<li><p>谈谈Go中的闭包？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">闭包：函数+引用变量， 引用变量是不能在栈上分配的；</div><div class=\"line\">逃逸分析：go编译器可以分析出变量的作用范围，自动决定是在栈还是对分配内存，将闭包环境变量在堆上分配是Go实现闭包的基础；</div><div class=\"line\">结构体：返回闭包并不仅仅是返回一个函数，而是返回一个结构体，包含函数返回地址和所引用环境的变量地址等信息。</div></pre></td></tr></table></figure>\n</li>\n<li><p>Go中实现非阻塞IO的原理是怎样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">在Go程序初始化时， 会启动一个后台线程sysmon（主要角色称为poller）。</div><div class=\"line\">当某个goroutine进行IO操作而此刻IO还没准备好，那它就会被放到等待队列中，</div><div class=\"line\">此时该goroutine被阻塞了，但系统继续运行其他goroutine。</div><div class=\"line\"></div><div class=\"line\">这样，所有发生阻塞的文件描述符fd会添加到这个poller上，</div><div class=\"line\">而poller不停的进行poll，一旦获取到就绪的fd描述符，</div><div class=\"line\">就会唤醒之前因它而阻塞的goroutine\t。</div><div class=\"line\"></div><div class=\"line\">poller比gc更高级，前者是一个物理线程，而后者只是线程池里的一个goroutine任务。</div></pre></td></tr></table></figure>\n</li>\n<li><p>关于Go中的栈管理技术（分段栈和连续栈）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">分段栈： </div><div class=\"line\">Go1.4之前的栈管理技术，运行时给每个goroutine分配8K的初始化栈内存；</div><div class=\"line\">在每个go函数之前有个代码块，检查已分配栈空间已不足，</div><div class=\"line\">不足的话会调用morestack函数来分配一段新的内存作栈空间，</div><div class=\"line\">然后将包括上一个栈地址等信息的struct和lessmore函数写入栈底，</div><div class=\"line\">接着重启gorouine，从将原来栈空间用光的函数开始执行(这里称为stack split)。</div><div class=\"line\">等该函数执行返回时，通过lessstack函数查找栈底部struct来调整栈指针，</div><div class=\"line\">使得返回原来栈空间，同时将该新栈段释放掉。</div><div class=\"line\">连续栈：</div><div class=\"line\">Go1.4之后使用连续栈，同样在每个函数入口进行栈溢出检查，</div><div class=\"line\">只是在栈溢出时会申请一个两倍于当前栈空间的内存空间，</div><div class=\"line\">然后把当前旧栈拷贝到新栈，释放旧栈空间，</div><div class=\"line\">最后程序重启goroutine并从引起重新分配栈段的函数继续执行。</div><div class=\"line\">实现栈拷贝的关键：</div><div class=\"line\">1. 只有在栈上分配的指针才能指向栈上的地址；</div><div class=\"line\">2. 需要知道栈上哪部分是指针，因为移动栈时需要把所有的指针指向新的目标地址；</div><div class=\"line\">原来Go运行时很多是C写的，大量运行时调用没有指针信息可用，这也是Go runtime被大规模重构的主要原因。</div></pre></td></tr></table></figure>\n</li>\n<li><p>关于Go的内存池</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">Go 初始化时申请一大块的虚拟内存空间，所有对象的内存回收时不会释放虚拟地址空间，但是虚拟地址空间和物理内存的映射会还给操作系统。</div><div class=\"line\">如果系统还有空余空间，这些物理内存暂时就先留着给 Go 使用，避免频繁分配内存；当系统真正需要时则可以则回收这部分内存。</div><div class=\"line\"></div><div class=\"line\">其参考tcmalloc，分级内存池管理，几个关键数据结构：</div><div class=\"line\">- mspan</div><div class=\"line\">由mheap管理的页面，记录了所分配的块大小和起始地址等</div><div class=\"line\">- mcache</div><div class=\"line\">与P(可看做cpu)绑定的线程级别的本地缓存</div><div class=\"line\">- mcenter</div><div class=\"line\">全局空间的缓存，收集了各种大小(67种)的span列表</div><div class=\"line\">- mheap</div><div class=\"line\">分配内存的堆分配器，以8kb进行页管理</div><div class=\"line\">- fixalloc</div><div class=\"line\">固定尺寸的堆外(直接由系统管理的内存)对象空闲列表分配器，用来管理分配器的存储</div></pre></td></tr></table></figure>\n</li>\n<li><p>浅谈Go的垃圾回收机制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">常见算法： 引用计数，标记清扫， 三色标记清扫，分代回收</div><div class=\"line\">Go1.5后至目前主要用了并发三色标记清扫算法，有效减少停顿时间。</div><div class=\"line\">垃圾回收触发：由一个gcpercent变量控制，比如gcpercent=100，</div><div class=\"line\">假设当前使用内存=100M，那么等到使用内存分配达到200MB时将触发GC；假设GC后的内存回到了120MB，那下次触发GC将在分配内存达到240MB的时候。</div></pre></td></tr></table></figure>\n</li>\n</ul>"},{"layout":"[golang]array-slice","title":"golang数组与切片","date":"2017-01-30T01:00:18.000Z","_content":"\n### array类型\n#### 1)基础特性\n- array为固定长度的数组, 其内存分配为连续的, 使用前需确定长度;\n- 数组为值类型, 赋值操作的新变量是原数组的一份完整拷贝;\n- 作为函数的传递参数, 实际也是数组的一份拷贝, 效率也就比传递指针低;\n- 数组长度也是Type一部分, 如[4]int和[2]int类型不一样.\n\n<!--more-->\n\n#### 2)声明与初始化\n```golang\npackage main\nimport \"fmt\"\n\n// 只声明, 不作初始化\nvar a1 [3]int         //一维, [0 0 0]\nvar a2 [2][2]int      //二维, [[0,0],[0,0]]\n\n// 声明并初始化\nvar b1 [5]int = [5]int{1,2,3,4,5}\nvar b2 [4]string = [4]string{\"Red\", \"Blue\", \"Green\", \"Yellow\"}\nvar b3 [2][2]int = [2][2]int{[2]int{5,6}, [2]int{7,8}}\n// 不能在顶层进行快速声明和初始化, 需用: var b4 [3]string = ...\n//b4 := [3]string{\"a\", \"b\", \"c\"}\n\n// 几种常用初始化方法(在函数内使用)\nfunc arrInFunc(){\n    a := [3]int{1,2,3}    // 所有元素赋值\n    b := [5]int{1,2,3}    // 前三个元素赋值，其他默认0\n    c := [15]int{10:3}    // 指定第11个元素初始化为3，其他默认0\n    d := [...]int{4,5,6}  // 编译器自动推断长度\n    e := [...]int{0:1, 1:2, 5:7} //自动推断长度\n    fmt.Printf(\"%v\\n\", a)\n    fmt.Printf(\"%v\\n\", b)\n    fmt.Printf(\"%v\\n\", c)\n    fmt.Printf(\"%v\\n\", d)\n    fmt.Printf(\"%v\\n\", e)\n}\n\nfunc main(){\n    arrInFunc()\n}\n```\nmain.go演示效果如下:\n```bash\nroot@XIAOMO:~/gopro# ./main\n[1 2 3]\n[1 2 3 0 0]\n[0 0 0 0 0 0 0 0 0 0 3 0 0 0 0]\n[4 5 6]\n[1 2 0 0 0 7]\n```\n\n#### 3)元素访问\nmain.go示例\n```golang\npackage main\n\nfunc accessElem() {\n    array := [3]int{1, 3, 9}\n\n    // 通过下标访问\n    for i:=0; i < len(array); i++ {\n        fmt.Println(i, array[i])\n    }\n\n    // 迭代方式访问\n    for i, v := range array {\n        fmt.Println(i, v)\n    }\n\n    // 使用new创建数组,零值填充, 返回数组指针\n    p := new([5]int)\n    fmt.Println(*p)\n}\n\nfunc main(){\n    accessElem()\n}\n```\n\n示例演示效果:\n```bash\nroot@XIAOMO:~/gopro# ./main\n0 1\n1 3\n2 9\n0 1\n1 3\n2 9\n[0 0 0 0 0]\n```\n\n#### 4)在函数中传递数组\n和C++类似, 函数参数传递中可以传值或传指针:\n\n```golang\n// 传值, 每次调用foo1, 系统将分配16字节内存在栈上\n// 函数运行结束时, 会弹栈并释放16字节内存\nfunc foo1(arr [16]int) {\n   // ...\n}\nvar a [16]int\nfoo1(a)\n\n// 传指针, 每次调用foo2, 系统将只分配指针需要的内存空间\nfunc foo2(arr *[16]int){\n    // ...\n}\nvar b [16]int\nfoo2(&b)\n```\n\n### slice类型\n#### 1)基础特性\n+ slice是一种动态数组, 可以认为是指向数组的指针; 但其并不只是指针，本身有其数据结构, 该结构包含三个元素:\n    - 指向原生数组的指针(pointer)\n    - 数组切片的元素个数(len)\n    - 数组切片已分配的空间(cap)\n+ slice作为一个引用类型, 声明是不需要指定长度;\n+ 增长操作通过内建方法append实现, 内部实现自动扩容.\n\n#### 2)创建和初始化\nmain.go\n```golang\npackage main\n\nfunc createSlice() {\n    // 通过array创建slice, 用法神似python\n    arr := [5]int{1,2,3,4,5}\n    sli1 := arr[:3]  // 切出前三个元素\n    sli2 := arr[:4]  // 切出前四个元素\n    sli1[1] = 8\n    sli2[1] = 9\n    // 将打印 9 9 9, 可见修改的是同一个元素\n    println(arr[1], sli1[1], sli2[1])\n\n    // 通过make创建slice\n    sli3 := make([]int, 3)\n    sli4 := make([]int, 4, 8) //初始4个元素，预留8个元素的空间\n    sli5 := []int{1,2,3,4,5}  //初始化赋值\n    fmt.Printf(\"%v\\n\", sli3)\n    fmt.Printf(\"%v\\n\", sli4)\n    fmt.Printf(\"%v\\n\", sli5)\n}\n\nfunc main(){\n    createSlice()\n}\n```\n#### 3)元素访问\n```golang\npackage main\n\nfunc useSlice() {\n    slice := []int{10, 20, 30, 40, 50}\n    for index, value := range slice {\n        fmt.Printf(\"Index: %d  Value: %d\\n\", index, value)\n    }\n\n    for i := 0; i < len(slice); i++ {\n        fmt.Printf(\"Index: %d  Value: %d\\n\", i, slice[i])\n    }\n}\n\nfunc main(){\n    useSlice()\n}\n```\n#### 4)在函数间传递slice\n由于slice是指向底层数组的指针, 在函数间传递slice是开销很小的。\n在64位机器中, slice对象占24个字节, 三个元素分别占8个字节。\n作为参数在函数中传递的方式和数组类似。\n\n### 关于new与make的区别探讨\n主要区别:\n\n- new可以用来创建各种类型对象, 也即是各类型的空间分配;\n- make用来处理内建类型(slice, channel, map等)的内存分配.\n","source":"_posts/golang/golang_array-slice.md","raw":"---\nlayout: '[golang]array-slice'\ntitle: golang数组与切片\ndate: 2017-01-30 09:00:18\ntags: golang\n---\n\n### array类型\n#### 1)基础特性\n- array为固定长度的数组, 其内存分配为连续的, 使用前需确定长度;\n- 数组为值类型, 赋值操作的新变量是原数组的一份完整拷贝;\n- 作为函数的传递参数, 实际也是数组的一份拷贝, 效率也就比传递指针低;\n- 数组长度也是Type一部分, 如[4]int和[2]int类型不一样.\n\n<!--more-->\n\n#### 2)声明与初始化\n```golang\npackage main\nimport \"fmt\"\n\n// 只声明, 不作初始化\nvar a1 [3]int         //一维, [0 0 0]\nvar a2 [2][2]int      //二维, [[0,0],[0,0]]\n\n// 声明并初始化\nvar b1 [5]int = [5]int{1,2,3,4,5}\nvar b2 [4]string = [4]string{\"Red\", \"Blue\", \"Green\", \"Yellow\"}\nvar b3 [2][2]int = [2][2]int{[2]int{5,6}, [2]int{7,8}}\n// 不能在顶层进行快速声明和初始化, 需用: var b4 [3]string = ...\n//b4 := [3]string{\"a\", \"b\", \"c\"}\n\n// 几种常用初始化方法(在函数内使用)\nfunc arrInFunc(){\n    a := [3]int{1,2,3}    // 所有元素赋值\n    b := [5]int{1,2,3}    // 前三个元素赋值，其他默认0\n    c := [15]int{10:3}    // 指定第11个元素初始化为3，其他默认0\n    d := [...]int{4,5,6}  // 编译器自动推断长度\n    e := [...]int{0:1, 1:2, 5:7} //自动推断长度\n    fmt.Printf(\"%v\\n\", a)\n    fmt.Printf(\"%v\\n\", b)\n    fmt.Printf(\"%v\\n\", c)\n    fmt.Printf(\"%v\\n\", d)\n    fmt.Printf(\"%v\\n\", e)\n}\n\nfunc main(){\n    arrInFunc()\n}\n```\nmain.go演示效果如下:\n```bash\nroot@XIAOMO:~/gopro# ./main\n[1 2 3]\n[1 2 3 0 0]\n[0 0 0 0 0 0 0 0 0 0 3 0 0 0 0]\n[4 5 6]\n[1 2 0 0 0 7]\n```\n\n#### 3)元素访问\nmain.go示例\n```golang\npackage main\n\nfunc accessElem() {\n    array := [3]int{1, 3, 9}\n\n    // 通过下标访问\n    for i:=0; i < len(array); i++ {\n        fmt.Println(i, array[i])\n    }\n\n    // 迭代方式访问\n    for i, v := range array {\n        fmt.Println(i, v)\n    }\n\n    // 使用new创建数组,零值填充, 返回数组指针\n    p := new([5]int)\n    fmt.Println(*p)\n}\n\nfunc main(){\n    accessElem()\n}\n```\n\n示例演示效果:\n```bash\nroot@XIAOMO:~/gopro# ./main\n0 1\n1 3\n2 9\n0 1\n1 3\n2 9\n[0 0 0 0 0]\n```\n\n#### 4)在函数中传递数组\n和C++类似, 函数参数传递中可以传值或传指针:\n\n```golang\n// 传值, 每次调用foo1, 系统将分配16字节内存在栈上\n// 函数运行结束时, 会弹栈并释放16字节内存\nfunc foo1(arr [16]int) {\n   // ...\n}\nvar a [16]int\nfoo1(a)\n\n// 传指针, 每次调用foo2, 系统将只分配指针需要的内存空间\nfunc foo2(arr *[16]int){\n    // ...\n}\nvar b [16]int\nfoo2(&b)\n```\n\n### slice类型\n#### 1)基础特性\n+ slice是一种动态数组, 可以认为是指向数组的指针; 但其并不只是指针，本身有其数据结构, 该结构包含三个元素:\n    - 指向原生数组的指针(pointer)\n    - 数组切片的元素个数(len)\n    - 数组切片已分配的空间(cap)\n+ slice作为一个引用类型, 声明是不需要指定长度;\n+ 增长操作通过内建方法append实现, 内部实现自动扩容.\n\n#### 2)创建和初始化\nmain.go\n```golang\npackage main\n\nfunc createSlice() {\n    // 通过array创建slice, 用法神似python\n    arr := [5]int{1,2,3,4,5}\n    sli1 := arr[:3]  // 切出前三个元素\n    sli2 := arr[:4]  // 切出前四个元素\n    sli1[1] = 8\n    sli2[1] = 9\n    // 将打印 9 9 9, 可见修改的是同一个元素\n    println(arr[1], sli1[1], sli2[1])\n\n    // 通过make创建slice\n    sli3 := make([]int, 3)\n    sli4 := make([]int, 4, 8) //初始4个元素，预留8个元素的空间\n    sli5 := []int{1,2,3,4,5}  //初始化赋值\n    fmt.Printf(\"%v\\n\", sli3)\n    fmt.Printf(\"%v\\n\", sli4)\n    fmt.Printf(\"%v\\n\", sli5)\n}\n\nfunc main(){\n    createSlice()\n}\n```\n#### 3)元素访问\n```golang\npackage main\n\nfunc useSlice() {\n    slice := []int{10, 20, 30, 40, 50}\n    for index, value := range slice {\n        fmt.Printf(\"Index: %d  Value: %d\\n\", index, value)\n    }\n\n    for i := 0; i < len(slice); i++ {\n        fmt.Printf(\"Index: %d  Value: %d\\n\", i, slice[i])\n    }\n}\n\nfunc main(){\n    useSlice()\n}\n```\n#### 4)在函数间传递slice\n由于slice是指向底层数组的指针, 在函数间传递slice是开销很小的。\n在64位机器中, slice对象占24个字节, 三个元素分别占8个字节。\n作为参数在函数中传递的方式和数组类似。\n\n### 关于new与make的区别探讨\n主要区别:\n\n- new可以用来创建各种类型对象, 也即是各类型的空间分配;\n- make用来处理内建类型(slice, channel, map等)的内存分配.\n","slug":"golang/golang_array-slice","published":1,"updated":"2017-08-07T05:47:10.146Z","comments":1,"photos":[],"link":"","_id":"ck2c00dy1003d4j4datnhhz2l","content":"<h3 id=\"array类型\"><a href=\"#array类型\" class=\"headerlink\" title=\"array类型\"></a>array类型</h3><h4 id=\"1-基础特性\"><a href=\"#1-基础特性\" class=\"headerlink\" title=\"1)基础特性\"></a>1)基础特性</h4><ul>\n<li>array为固定长度的数组, 其内存分配为连续的, 使用前需确定长度;</li>\n<li>数组为值类型, 赋值操作的新变量是原数组的一份完整拷贝;</li>\n<li>作为函数的传递参数, 实际也是数组的一份拷贝, 效率也就比传递指针低;</li>\n<li>数组长度也是Type一部分, 如[4]int和[2]int类型不一样.</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"2-声明与初始化\"><a href=\"#2-声明与初始化\" class=\"headerlink\" title=\"2)声明与初始化\"></a>2)声明与初始化</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 只声明, 不作初始化</span></div><div class=\"line\"><span class=\"keyword\">var</span> a1 [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>         <span class=\"comment\">//一维, [0 0 0]</span></div><div class=\"line\"><span class=\"keyword\">var</span> a2 [<span class=\"number\">2</span>][<span class=\"number\">2</span>]<span class=\"keyword\">int</span>      <span class=\"comment\">//二维, [[0,0],[0,0]]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明并初始化</span></div><div class=\"line\"><span class=\"keyword\">var</span> b1 [<span class=\"number\">5</span>]<span class=\"keyword\">int</span> = [<span class=\"number\">5</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> b2 [<span class=\"number\">4</span>]<span class=\"keyword\">string</span> = [<span class=\"number\">4</span>]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Red\"</span>, <span class=\"string\">\"Blue\"</span>, <span class=\"string\">\"Green\"</span>, <span class=\"string\">\"Yellow\"</span>&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> b3 [<span class=\"number\">2</span>][<span class=\"number\">2</span>]<span class=\"keyword\">int</span> = [<span class=\"number\">2</span>][<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;[<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;, [<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;&#125;</div><div class=\"line\"><span class=\"comment\">// 不能在顶层进行快速声明和初始化, 需用: var b4 [3]string = ...</span></div><div class=\"line\"><span class=\"comment\">//b4 := [3]string&#123;\"a\", \"b\", \"c\"&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 几种常用初始化方法(在函数内使用)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">arrInFunc</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    a := [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;    <span class=\"comment\">// 所有元素赋值</span></div><div class=\"line\">    b := [<span class=\"number\">5</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;    <span class=\"comment\">// 前三个元素赋值，其他默认0</span></div><div class=\"line\">    c := [<span class=\"number\">15</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">10</span>:<span class=\"number\">3</span>&#125;    <span class=\"comment\">// 指定第11个元素初始化为3，其他默认0</span></div><div class=\"line\">    d := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;  <span class=\"comment\">// 编译器自动推断长度</span></div><div class=\"line\">    e := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>:<span class=\"number\">1</span>, <span class=\"number\">1</span>:<span class=\"number\">2</span>, <span class=\"number\">5</span>:<span class=\"number\">7</span>&#125; <span class=\"comment\">//自动推断长度</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, a)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, b)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, c)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, d)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, e)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    arrInFunc()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>main.go演示效果如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># ./main</span></div><div class=\"line\">[1 2 3]</div><div class=\"line\">[1 2 3 0 0]</div><div class=\"line\">[0 0 0 0 0 0 0 0 0 0 3 0 0 0 0]</div><div class=\"line\">[4 5 6]</div><div class=\"line\">[1 2 0 0 0 7]</div></pre></td></tr></table></figure></p>\n<h4 id=\"3-元素访问\"><a href=\"#3-元素访问\" class=\"headerlink\" title=\"3)元素访问\"></a>3)元素访问</h4><p>main.go示例<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">accessElem</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    array := [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 通过下标访问</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(array); i++ &#123;</div><div class=\"line\">        fmt.Println(i, array[i])</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 迭代方式访问</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> array &#123;</div><div class=\"line\">        fmt.Println(i, v)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 使用new创建数组,零值填充, 返回数组指针</span></div><div class=\"line\">    p := <span class=\"built_in\">new</span>([<span class=\"number\">5</span>]<span class=\"keyword\">int</span>)</div><div class=\"line\">    fmt.Println(*p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    accessElem()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>示例演示效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># ./main</span></div><div class=\"line\">0 1</div><div class=\"line\">1 3</div><div class=\"line\">2 9</div><div class=\"line\">0 1</div><div class=\"line\">1 3</div><div class=\"line\">2 9</div><div class=\"line\">[0 0 0 0 0]</div></pre></td></tr></table></figure></p>\n<h4 id=\"4-在函数中传递数组\"><a href=\"#4-在函数中传递数组\" class=\"headerlink\" title=\"4)在函数中传递数组\"></a>4)在函数中传递数组</h4><p>和C++类似, 函数参数传递中可以传值或传指针:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 传值, 每次调用foo1, 系统将分配16字节内存在栈上</span></div><div class=\"line\"><span class=\"comment\">// 函数运行结束时, 会弹栈并释放16字节内存</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo1</span><span class=\"params\">(arr [16]<span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">16</span>]<span class=\"keyword\">int</span></div><div class=\"line\">foo1(a)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 传指针, 每次调用foo2, 系统将只分配指针需要的内存空间</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo2</span><span class=\"params\">(arr *[16]<span class=\"keyword\">int</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> b [<span class=\"number\">16</span>]<span class=\"keyword\">int</span></div><div class=\"line\">foo2(&amp;b)</div></pre></td></tr></table></figure>\n<h3 id=\"slice类型\"><a href=\"#slice类型\" class=\"headerlink\" title=\"slice类型\"></a>slice类型</h3><h4 id=\"1-基础特性-1\"><a href=\"#1-基础特性-1\" class=\"headerlink\" title=\"1)基础特性\"></a>1)基础特性</h4><ul>\n<li>slice是一种动态数组, 可以认为是指向数组的指针; 但其并不只是指针，本身有其数据结构, 该结构包含三个元素:<ul>\n<li>指向原生数组的指针(pointer)</li>\n<li>数组切片的元素个数(len)</li>\n<li>数组切片已分配的空间(cap)</li>\n</ul>\n</li>\n<li>slice作为一个引用类型, 声明是不需要指定长度;</li>\n<li>增长操作通过内建方法append实现, 内部实现自动扩容.</li>\n</ul>\n<h4 id=\"2-创建和初始化\"><a href=\"#2-创建和初始化\" class=\"headerlink\" title=\"2)创建和初始化\"></a>2)创建和初始化</h4><p>main.go<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createSlice</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 通过array创建slice, 用法神似python</span></div><div class=\"line\">    arr := [<span class=\"number\">5</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div><div class=\"line\">    sli1 := arr[:<span class=\"number\">3</span>]  <span class=\"comment\">// 切出前三个元素</span></div><div class=\"line\">    sli2 := arr[:<span class=\"number\">4</span>]  <span class=\"comment\">// 切出前四个元素</span></div><div class=\"line\">    sli1[<span class=\"number\">1</span>] = <span class=\"number\">8</span></div><div class=\"line\">    sli2[<span class=\"number\">1</span>] = <span class=\"number\">9</span></div><div class=\"line\">    <span class=\"comment\">// 将打印 9 9 9, 可见修改的是同一个元素</span></div><div class=\"line\">    <span class=\"built_in\">println</span>(arr[<span class=\"number\">1</span>], sli1[<span class=\"number\">1</span>], sli2[<span class=\"number\">1</span>])</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 通过make创建slice</span></div><div class=\"line\">    sli3 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">3</span>)</div><div class=\"line\">    sli4 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>) <span class=\"comment\">//初始4个元素，预留8个元素的空间</span></div><div class=\"line\">    sli5 := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;  <span class=\"comment\">//初始化赋值</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, sli3)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, sli4)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, sli5)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    createSlice()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"3-元素访问-1\"><a href=\"#3-元素访问-1\" class=\"headerlink\" title=\"3)元素访问\"></a>3)元素访问</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">useSlice</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    slice := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>&#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> index, value := <span class=\"keyword\">range</span> slice &#123;</div><div class=\"line\">        fmt.Printf(<span class=\"string\">\"Index: %d  Value: %d\\n\"</span>, index, value)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(slice); i++ &#123;</div><div class=\"line\">        fmt.Printf(<span class=\"string\">\"Index: %d  Value: %d\\n\"</span>, i, slice[i])</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    useSlice()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"4-在函数间传递slice\"><a href=\"#4-在函数间传递slice\" class=\"headerlink\" title=\"4)在函数间传递slice\"></a>4)在函数间传递slice</h4><p>由于slice是指向底层数组的指针, 在函数间传递slice是开销很小的。<br>在64位机器中, slice对象占24个字节, 三个元素分别占8个字节。<br>作为参数在函数中传递的方式和数组类似。</p>\n<h3 id=\"关于new与make的区别探讨\"><a href=\"#关于new与make的区别探讨\" class=\"headerlink\" title=\"关于new与make的区别探讨\"></a>关于new与make的区别探讨</h3><p>主要区别:</p>\n<ul>\n<li>new可以用来创建各种类型对象, 也即是各类型的空间分配;</li>\n<li>make用来处理内建类型(slice, channel, map等)的内存分配.</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"array类型\"><a href=\"#array类型\" class=\"headerlink\" title=\"array类型\"></a>array类型</h3><h4 id=\"1-基础特性\"><a href=\"#1-基础特性\" class=\"headerlink\" title=\"1)基础特性\"></a>1)基础特性</h4><ul>\n<li>array为固定长度的数组, 其内存分配为连续的, 使用前需确定长度;</li>\n<li>数组为值类型, 赋值操作的新变量是原数组的一份完整拷贝;</li>\n<li>作为函数的传递参数, 实际也是数组的一份拷贝, 效率也就比传递指针低;</li>\n<li>数组长度也是Type一部分, 如[4]int和[2]int类型不一样.</li>\n</ul>","more":"<h4 id=\"2-声明与初始化\"><a href=\"#2-声明与初始化\" class=\"headerlink\" title=\"2)声明与初始化\"></a>2)声明与初始化</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 只声明, 不作初始化</span></div><div class=\"line\"><span class=\"keyword\">var</span> a1 [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>         <span class=\"comment\">//一维, [0 0 0]</span></div><div class=\"line\"><span class=\"keyword\">var</span> a2 [<span class=\"number\">2</span>][<span class=\"number\">2</span>]<span class=\"keyword\">int</span>      <span class=\"comment\">//二维, [[0,0],[0,0]]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明并初始化</span></div><div class=\"line\"><span class=\"keyword\">var</span> b1 [<span class=\"number\">5</span>]<span class=\"keyword\">int</span> = [<span class=\"number\">5</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> b2 [<span class=\"number\">4</span>]<span class=\"keyword\">string</span> = [<span class=\"number\">4</span>]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Red\"</span>, <span class=\"string\">\"Blue\"</span>, <span class=\"string\">\"Green\"</span>, <span class=\"string\">\"Yellow\"</span>&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> b3 [<span class=\"number\">2</span>][<span class=\"number\">2</span>]<span class=\"keyword\">int</span> = [<span class=\"number\">2</span>][<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;[<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;, [<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;&#125;</div><div class=\"line\"><span class=\"comment\">// 不能在顶层进行快速声明和初始化, 需用: var b4 [3]string = ...</span></div><div class=\"line\"><span class=\"comment\">//b4 := [3]string&#123;\"a\", \"b\", \"c\"&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 几种常用初始化方法(在函数内使用)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">arrInFunc</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    a := [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;    <span class=\"comment\">// 所有元素赋值</span></div><div class=\"line\">    b := [<span class=\"number\">5</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;    <span class=\"comment\">// 前三个元素赋值，其他默认0</span></div><div class=\"line\">    c := [<span class=\"number\">15</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">10</span>:<span class=\"number\">3</span>&#125;    <span class=\"comment\">// 指定第11个元素初始化为3，其他默认0</span></div><div class=\"line\">    d := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;  <span class=\"comment\">// 编译器自动推断长度</span></div><div class=\"line\">    e := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>:<span class=\"number\">1</span>, <span class=\"number\">1</span>:<span class=\"number\">2</span>, <span class=\"number\">5</span>:<span class=\"number\">7</span>&#125; <span class=\"comment\">//自动推断长度</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, a)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, b)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, c)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, d)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, e)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    arrInFunc()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>main.go演示效果如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># ./main</span></div><div class=\"line\">[1 2 3]</div><div class=\"line\">[1 2 3 0 0]</div><div class=\"line\">[0 0 0 0 0 0 0 0 0 0 3 0 0 0 0]</div><div class=\"line\">[4 5 6]</div><div class=\"line\">[1 2 0 0 0 7]</div></pre></td></tr></table></figure></p>\n<h4 id=\"3-元素访问\"><a href=\"#3-元素访问\" class=\"headerlink\" title=\"3)元素访问\"></a>3)元素访问</h4><p>main.go示例<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">accessElem</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    array := [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 通过下标访问</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(array); i++ &#123;</div><div class=\"line\">        fmt.Println(i, array[i])</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 迭代方式访问</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> array &#123;</div><div class=\"line\">        fmt.Println(i, v)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 使用new创建数组,零值填充, 返回数组指针</span></div><div class=\"line\">    p := <span class=\"built_in\">new</span>([<span class=\"number\">5</span>]<span class=\"keyword\">int</span>)</div><div class=\"line\">    fmt.Println(*p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    accessElem()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>示例演示效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># ./main</span></div><div class=\"line\">0 1</div><div class=\"line\">1 3</div><div class=\"line\">2 9</div><div class=\"line\">0 1</div><div class=\"line\">1 3</div><div class=\"line\">2 9</div><div class=\"line\">[0 0 0 0 0]</div></pre></td></tr></table></figure></p>\n<h4 id=\"4-在函数中传递数组\"><a href=\"#4-在函数中传递数组\" class=\"headerlink\" title=\"4)在函数中传递数组\"></a>4)在函数中传递数组</h4><p>和C++类似, 函数参数传递中可以传值或传指针:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 传值, 每次调用foo1, 系统将分配16字节内存在栈上</span></div><div class=\"line\"><span class=\"comment\">// 函数运行结束时, 会弹栈并释放16字节内存</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo1</span><span class=\"params\">(arr [16]<span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">16</span>]<span class=\"keyword\">int</span></div><div class=\"line\">foo1(a)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 传指针, 每次调用foo2, 系统将只分配指针需要的内存空间</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo2</span><span class=\"params\">(arr *[16]<span class=\"keyword\">int</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> b [<span class=\"number\">16</span>]<span class=\"keyword\">int</span></div><div class=\"line\">foo2(&amp;b)</div></pre></td></tr></table></figure>\n<h3 id=\"slice类型\"><a href=\"#slice类型\" class=\"headerlink\" title=\"slice类型\"></a>slice类型</h3><h4 id=\"1-基础特性-1\"><a href=\"#1-基础特性-1\" class=\"headerlink\" title=\"1)基础特性\"></a>1)基础特性</h4><ul>\n<li>slice是一种动态数组, 可以认为是指向数组的指针; 但其并不只是指针，本身有其数据结构, 该结构包含三个元素:<ul>\n<li>指向原生数组的指针(pointer)</li>\n<li>数组切片的元素个数(len)</li>\n<li>数组切片已分配的空间(cap)</li>\n</ul>\n</li>\n<li>slice作为一个引用类型, 声明是不需要指定长度;</li>\n<li>增长操作通过内建方法append实现, 内部实现自动扩容.</li>\n</ul>\n<h4 id=\"2-创建和初始化\"><a href=\"#2-创建和初始化\" class=\"headerlink\" title=\"2)创建和初始化\"></a>2)创建和初始化</h4><p>main.go<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createSlice</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 通过array创建slice, 用法神似python</span></div><div class=\"line\">    arr := [<span class=\"number\">5</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div><div class=\"line\">    sli1 := arr[:<span class=\"number\">3</span>]  <span class=\"comment\">// 切出前三个元素</span></div><div class=\"line\">    sli2 := arr[:<span class=\"number\">4</span>]  <span class=\"comment\">// 切出前四个元素</span></div><div class=\"line\">    sli1[<span class=\"number\">1</span>] = <span class=\"number\">8</span></div><div class=\"line\">    sli2[<span class=\"number\">1</span>] = <span class=\"number\">9</span></div><div class=\"line\">    <span class=\"comment\">// 将打印 9 9 9, 可见修改的是同一个元素</span></div><div class=\"line\">    <span class=\"built_in\">println</span>(arr[<span class=\"number\">1</span>], sli1[<span class=\"number\">1</span>], sli2[<span class=\"number\">1</span>])</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 通过make创建slice</span></div><div class=\"line\">    sli3 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">3</span>)</div><div class=\"line\">    sli4 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>) <span class=\"comment\">//初始4个元素，预留8个元素的空间</span></div><div class=\"line\">    sli5 := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;  <span class=\"comment\">//初始化赋值</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, sli3)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, sli4)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, sli5)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    createSlice()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"3-元素访问-1\"><a href=\"#3-元素访问-1\" class=\"headerlink\" title=\"3)元素访问\"></a>3)元素访问</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">useSlice</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    slice := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>&#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> index, value := <span class=\"keyword\">range</span> slice &#123;</div><div class=\"line\">        fmt.Printf(<span class=\"string\">\"Index: %d  Value: %d\\n\"</span>, index, value)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(slice); i++ &#123;</div><div class=\"line\">        fmt.Printf(<span class=\"string\">\"Index: %d  Value: %d\\n\"</span>, i, slice[i])</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    useSlice()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"4-在函数间传递slice\"><a href=\"#4-在函数间传递slice\" class=\"headerlink\" title=\"4)在函数间传递slice\"></a>4)在函数间传递slice</h4><p>由于slice是指向底层数组的指针, 在函数间传递slice是开销很小的。<br>在64位机器中, slice对象占24个字节, 三个元素分别占8个字节。<br>作为参数在函数中传递的方式和数组类似。</p>\n<h3 id=\"关于new与make的区别探讨\"><a href=\"#关于new与make的区别探讨\" class=\"headerlink\" title=\"关于new与make的区别探讨\"></a>关于new与make的区别探讨</h3><p>主要区别:</p>\n<ul>\n<li>new可以用来创建各种类型对象, 也即是各类型的空间分配;</li>\n<li>make用来处理内建类型(slice, channel, map等)的内存分配.</li>\n</ul>"},{"title":"[golang]channel管道类型","date":"2016-03-04T01:00:11.000Z","_content":"\n在unix系统中, 管道是进程间通信的一种方式。那golang的channel和系统的管道有什么区别？\n\n### 什么是channel\n官方文档有个channel的定义:\n\n\n>    A channel provides a mechanism for concurrently executing functions to communicate\n>    by sending and receiving values of a specified element type.\n>    The value of an uninitialized channel is nil.\n\nchannel应该可以理解为: 一种为并行执行而提供函数间通信的机制, 通过传递send和recieve特定类型的值来实现。没有初始化值的channel对象, 默认为nil。\n<!--more-->\n\n也就是: 在管道的两端, 一个对象可以在一端进行写/读/读写的操作, 另一个对象可以在另一端进行读/写/读写的操作；能否读写, 取决于管道是否是双向的。默认情况下, 管道是双向的。\n\n### channel的基础特性\n- channel是一个作为队列queue的值。 当queue满时, 写操作是阻塞的; 当queue为空时, 读操作是阻塞的\n- 向一个nil channel读数据或写数据, 会造成一直阻塞\n- 向一个close了的channel写数据, 会引起panic\n- 向一个close了的channel读数据, 会立刻获取到一个零值\n\n### 一些用法示例\n#### 1.没有缓冲的channel\n当我们没有为channel指定容量时, 我们称这个channel是没有缓冲的。\n```golang\nfunc test_deadlock() {\n     c := make(chan string)\n     c <- \"test\"    // 写入channel\n     s := <-c       // 读取channel\n     println(s)\n}\n```\n运行效果:\n```bash\nfatal error: all goroutines are asleep - deadlock!\n\ngoroutine 1 [chan send]:\nmain.test_deadlock\n\t/root/gopro/channel.go:10\nmain.main\n\t/root/gopro/channel.go:53\n```\n提示出现了死锁。这是因为处在同一个单线程环境中, 两个goroutine互相等待对方释放资源, 造成双方都无法继续运行下去。Go运行时检测到了死锁并给出了错误报告。指定容量后可解决这个问题:\n```golang\nc := make(chan string, 3)  // 长度为3\n```\n\n#### 2. 使用range来进行读取操作\n- range会在close channel后读取完所有数据并自动结束循环\n- 有/无缓冲的channel在使用range时效果是一样的\n- range方法, 不需要知道channel中消息的准确数目, 使用人性化\n\n使用range示例:\n```golang\nfunc main() {\n     message := make(chan int)\n     count := 3\n\n     go func() {\n          for i := 1; i <= count; i++ {\n               fmt.Printf(\"send %v\\n\", i)\n               message <- i\n          }\n          //完成写入后, 需要关闭channel, 否则主goroutine会因一直等待而死锁\n          close(message)\n     }()\n     time.Sleep(time.Second * 3)\n\n     for msg := range message {\n          fmt.Printf(\"recieve: %v\\n\", msg)\n     }\n}\n```\n运行效果:\n```golang\nroot@XIAOMO:~/gopro# go build channel.go\nroot@XIAOMO:~/gopro# ./channel\nsend 1\n// 此处等待3秒\nrecieve: 1\nsend 2\nsend 3\nrecieve: 2\nrecieve: 3\n```\n\n#### 3. 多channel模式\n在程序中需要用到多个channel时, 我们可以使用select(类似于switch)来实现对channel的支持。\n\n以下示例中方法CreateMsgChannel()创建了一个channel和goroutine, 并向该channel中分三次写入数据; 在main()方法中通过select来读取三个channel中的数据:\n```golang\nfunc CreateMsgChannel(msg string, delay time.Duration) <-chan string {\n     c := make(chan string)\n     go func() {\n          for i := 1; i <= 3; i++ {\n               c <- fmt.Sprintf(\"%s\\tcur_loop:%d\", msg, i)\n               // 模拟处理时间\n               time.Sleep(time.Millisecond * delay)\n          }\n     }()\n     return c\n}\n\nfunc main() {\n    c1 := CreateMsgChannel(\"msg in channel 1\", 500)\n    c2 := CreateMsgChannel(\"msg in channel 2\", 260)\n    c3 := CreateMsgChannel(\"msg in channel 3\", 50)\n\n    for i := 1; i <= 9; i++ {\n        select {\n            case msg := <-c1:\n                println(msg)\n            case msg := <-c2:\n                println(msg)\n            case msg := <-c3:\n                println(msg)\n        }\n    }\n}\n```\n运行效果:\n```golang\nroot@XIAOMO:~/gopro# go build channel.go\nroot@XIAOMO:~/gopro# ./channel\nmsg in channel 1\tcur_loop:1\nmsg in channel 2\tcur_loop:1\nmsg in channel 3\tcur_loop:1\nmsg in channel 3\tcur_loop:2\nmsg in channel 3\tcur_loop:3\nmsg in channel 2\tcur_loop:2\nmsg in channel 1\tcur_loop:2\nmsg in channel 2\tcur_loop:3\nmsg in channel 1\tcur_loop:3\n```\n由结果可见, 每个channel中的消息都能尽快的被读取, 而不会因为一个channel的阻塞而导致了其他channel的消息无法被读取。","source":"_posts/golang/golang_channel.md","raw":"---\ntitle: '[golang]channel管道类型'\ndate: 2016-03-04 09:00:11\ntags: golang\n---\n\n在unix系统中, 管道是进程间通信的一种方式。那golang的channel和系统的管道有什么区别？\n\n### 什么是channel\n官方文档有个channel的定义:\n\n\n>    A channel provides a mechanism for concurrently executing functions to communicate\n>    by sending and receiving values of a specified element type.\n>    The value of an uninitialized channel is nil.\n\nchannel应该可以理解为: 一种为并行执行而提供函数间通信的机制, 通过传递send和recieve特定类型的值来实现。没有初始化值的channel对象, 默认为nil。\n<!--more-->\n\n也就是: 在管道的两端, 一个对象可以在一端进行写/读/读写的操作, 另一个对象可以在另一端进行读/写/读写的操作；能否读写, 取决于管道是否是双向的。默认情况下, 管道是双向的。\n\n### channel的基础特性\n- channel是一个作为队列queue的值。 当queue满时, 写操作是阻塞的; 当queue为空时, 读操作是阻塞的\n- 向一个nil channel读数据或写数据, 会造成一直阻塞\n- 向一个close了的channel写数据, 会引起panic\n- 向一个close了的channel读数据, 会立刻获取到一个零值\n\n### 一些用法示例\n#### 1.没有缓冲的channel\n当我们没有为channel指定容量时, 我们称这个channel是没有缓冲的。\n```golang\nfunc test_deadlock() {\n     c := make(chan string)\n     c <- \"test\"    // 写入channel\n     s := <-c       // 读取channel\n     println(s)\n}\n```\n运行效果:\n```bash\nfatal error: all goroutines are asleep - deadlock!\n\ngoroutine 1 [chan send]:\nmain.test_deadlock\n\t/root/gopro/channel.go:10\nmain.main\n\t/root/gopro/channel.go:53\n```\n提示出现了死锁。这是因为处在同一个单线程环境中, 两个goroutine互相等待对方释放资源, 造成双方都无法继续运行下去。Go运行时检测到了死锁并给出了错误报告。指定容量后可解决这个问题:\n```golang\nc := make(chan string, 3)  // 长度为3\n```\n\n#### 2. 使用range来进行读取操作\n- range会在close channel后读取完所有数据并自动结束循环\n- 有/无缓冲的channel在使用range时效果是一样的\n- range方法, 不需要知道channel中消息的准确数目, 使用人性化\n\n使用range示例:\n```golang\nfunc main() {\n     message := make(chan int)\n     count := 3\n\n     go func() {\n          for i := 1; i <= count; i++ {\n               fmt.Printf(\"send %v\\n\", i)\n               message <- i\n          }\n          //完成写入后, 需要关闭channel, 否则主goroutine会因一直等待而死锁\n          close(message)\n     }()\n     time.Sleep(time.Second * 3)\n\n     for msg := range message {\n          fmt.Printf(\"recieve: %v\\n\", msg)\n     }\n}\n```\n运行效果:\n```golang\nroot@XIAOMO:~/gopro# go build channel.go\nroot@XIAOMO:~/gopro# ./channel\nsend 1\n// 此处等待3秒\nrecieve: 1\nsend 2\nsend 3\nrecieve: 2\nrecieve: 3\n```\n\n#### 3. 多channel模式\n在程序中需要用到多个channel时, 我们可以使用select(类似于switch)来实现对channel的支持。\n\n以下示例中方法CreateMsgChannel()创建了一个channel和goroutine, 并向该channel中分三次写入数据; 在main()方法中通过select来读取三个channel中的数据:\n```golang\nfunc CreateMsgChannel(msg string, delay time.Duration) <-chan string {\n     c := make(chan string)\n     go func() {\n          for i := 1; i <= 3; i++ {\n               c <- fmt.Sprintf(\"%s\\tcur_loop:%d\", msg, i)\n               // 模拟处理时间\n               time.Sleep(time.Millisecond * delay)\n          }\n     }()\n     return c\n}\n\nfunc main() {\n    c1 := CreateMsgChannel(\"msg in channel 1\", 500)\n    c2 := CreateMsgChannel(\"msg in channel 2\", 260)\n    c3 := CreateMsgChannel(\"msg in channel 3\", 50)\n\n    for i := 1; i <= 9; i++ {\n        select {\n            case msg := <-c1:\n                println(msg)\n            case msg := <-c2:\n                println(msg)\n            case msg := <-c3:\n                println(msg)\n        }\n    }\n}\n```\n运行效果:\n```golang\nroot@XIAOMO:~/gopro# go build channel.go\nroot@XIAOMO:~/gopro# ./channel\nmsg in channel 1\tcur_loop:1\nmsg in channel 2\tcur_loop:1\nmsg in channel 3\tcur_loop:1\nmsg in channel 3\tcur_loop:2\nmsg in channel 3\tcur_loop:3\nmsg in channel 2\tcur_loop:2\nmsg in channel 1\tcur_loop:2\nmsg in channel 2\tcur_loop:3\nmsg in channel 1\tcur_loop:3\n```\n由结果可见, 每个channel中的消息都能尽快的被读取, 而不会因为一个channel的阻塞而导致了其他channel的消息无法被读取。","slug":"golang/golang_channel","published":1,"updated":"2017-08-07T05:47:10.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dy5003f4j4dqr0q03f8","content":"<p>在unix系统中, 管道是进程间通信的一种方式。那golang的channel和系统的管道有什么区别？</p>\n<h3 id=\"什么是channel\"><a href=\"#什么是channel\" class=\"headerlink\" title=\"什么是channel\"></a>什么是channel</h3><p>官方文档有个channel的定义:</p>\n<blockquote>\n<p>   A channel provides a mechanism for concurrently executing functions to communicate<br>   by sending and receiving values of a specified element type.<br>   The value of an uninitialized channel is nil.</p>\n</blockquote>\n<p>channel应该可以理解为: 一种为并行执行而提供函数间通信的机制, 通过传递send和recieve特定类型的值来实现。没有初始化值的channel对象, 默认为nil。<br><a id=\"more\"></a></p>\n<p>也就是: 在管道的两端, 一个对象可以在一端进行写/读/读写的操作, 另一个对象可以在另一端进行读/写/读写的操作；能否读写, 取决于管道是否是双向的。默认情况下, 管道是双向的。</p>\n<h3 id=\"channel的基础特性\"><a href=\"#channel的基础特性\" class=\"headerlink\" title=\"channel的基础特性\"></a>channel的基础特性</h3><ul>\n<li>channel是一个作为队列queue的值。 当queue满时, 写操作是阻塞的; 当queue为空时, 读操作是阻塞的</li>\n<li>向一个nil channel读数据或写数据, 会造成一直阻塞</li>\n<li>向一个close了的channel写数据, 会引起panic</li>\n<li>向一个close了的channel读数据, 会立刻获取到一个零值</li>\n</ul>\n<h3 id=\"一些用法示例\"><a href=\"#一些用法示例\" class=\"headerlink\" title=\"一些用法示例\"></a>一些用法示例</h3><h4 id=\"1-没有缓冲的channel\"><a href=\"#1-没有缓冲的channel\" class=\"headerlink\" title=\"1.没有缓冲的channel\"></a>1.没有缓冲的channel</h4><p>当我们没有为channel指定容量时, 我们称这个channel是没有缓冲的。<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test_deadlock</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">     c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>)</div><div class=\"line\">     c &lt;- <span class=\"string\">\"test\"</span>    <span class=\"comment\">// 写入channel</span></div><div class=\"line\">     s := &lt;-c       <span class=\"comment\">// 读取channel</span></div><div class=\"line\">     <span class=\"built_in\">println</span>(s)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">fatal error: all goroutines are asleep - deadlock!</div><div class=\"line\"></div><div class=\"line\">goroutine 1 [chan send]:</div><div class=\"line\">main.test_deadlock</div><div class=\"line\">\t/root/gopro/channel.go:10</div><div class=\"line\">main.main</div><div class=\"line\">\t/root/gopro/channel.go:53</div></pre></td></tr></table></figure></p>\n<p>提示出现了死锁。这是因为处在同一个单线程环境中, 两个goroutine互相等待对方释放资源, 造成双方都无法继续运行下去。Go运行时检测到了死锁并给出了错误报告。指定容量后可解决这个问题:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>, <span class=\"number\">3</span>)  <span class=\"comment\">// 长度为3</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"2-使用range来进行读取操作\"><a href=\"#2-使用range来进行读取操作\" class=\"headerlink\" title=\"2. 使用range来进行读取操作\"></a>2. 使用range来进行读取操作</h4><ul>\n<li>range会在close channel后读取完所有数据并自动结束循环</li>\n<li>有/无缓冲的channel在使用range时效果是一样的</li>\n<li>range方法, 不需要知道channel中消息的准确数目, 使用人性化</li>\n</ul>\n<p>使用range示例:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">     message := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</div><div class=\"line\">     count := <span class=\"number\">3</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">          <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= count; i++ &#123;</div><div class=\"line\">               fmt.Printf(<span class=\"string\">\"send %v\\n\"</span>, i)</div><div class=\"line\">               message &lt;- i</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"comment\">//完成写入后, 需要关闭channel, 否则主goroutine会因一直等待而死锁</span></div><div class=\"line\">          <span class=\"built_in\">close</span>(message)</div><div class=\"line\">     &#125;()</div><div class=\"line\">     time.Sleep(time.Second * <span class=\"number\">3</span>)</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">for</span> msg := <span class=\"keyword\">range</span> message &#123;</div><div class=\"line\">          fmt.Printf(<span class=\"string\">\"recieve: %v\\n\"</span>, msg)</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行效果:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro# <span class=\"keyword\">go</span> build channel.<span class=\"keyword\">go</span></div><div class=\"line\">root@XIAOMO:~/gopro# ./channel</div><div class=\"line\">send <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">// 此处等待3秒</span></div><div class=\"line\">recieve: <span class=\"number\">1</span></div><div class=\"line\">send <span class=\"number\">2</span></div><div class=\"line\">send <span class=\"number\">3</span></div><div class=\"line\">recieve: <span class=\"number\">2</span></div><div class=\"line\">recieve: <span class=\"number\">3</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"3-多channel模式\"><a href=\"#3-多channel模式\" class=\"headerlink\" title=\"3. 多channel模式\"></a>3. 多channel模式</h4><p>在程序中需要用到多个channel时, 我们可以使用select(类似于switch)来实现对channel的支持。</p>\n<p>以下示例中方法CreateMsgChannel()创建了一个channel和goroutine, 并向该channel中分三次写入数据; 在main()方法中通过select来读取三个channel中的数据:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CreateMsgChannel</span><span class=\"params\">(msg <span class=\"keyword\">string</span>, delay time.Duration)</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">     c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>)</div><div class=\"line\">     <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">          <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"number\">3</span>; i++ &#123;</div><div class=\"line\">               c &lt;- fmt.Sprintf(<span class=\"string\">\"%s\\tcur_loop:%d\"</span>, msg, i)</div><div class=\"line\">               <span class=\"comment\">// 模拟处理时间</span></div><div class=\"line\">               time.Sleep(time.Millisecond * delay)</div><div class=\"line\">          &#125;</div><div class=\"line\">     &#125;()</div><div class=\"line\">     <span class=\"keyword\">return</span> c</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    c1 := CreateMsgChannel(<span class=\"string\">\"msg in channel 1\"</span>, <span class=\"number\">500</span>)</div><div class=\"line\">    c2 := CreateMsgChannel(<span class=\"string\">\"msg in channel 2\"</span>, <span class=\"number\">260</span>)</div><div class=\"line\">    c3 := CreateMsgChannel(<span class=\"string\">\"msg in channel 3\"</span>, <span class=\"number\">50</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"number\">9</span>; i++ &#123;</div><div class=\"line\">        <span class=\"keyword\">select</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> msg := &lt;-c1:</div><div class=\"line\">                <span class=\"built_in\">println</span>(msg)</div><div class=\"line\">            <span class=\"keyword\">case</span> msg := &lt;-c2:</div><div class=\"line\">                <span class=\"built_in\">println</span>(msg)</div><div class=\"line\">            <span class=\"keyword\">case</span> msg := &lt;-c3:</div><div class=\"line\">                <span class=\"built_in\">println</span>(msg)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行效果:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro# <span class=\"keyword\">go</span> build channel.<span class=\"keyword\">go</span></div><div class=\"line\">root@XIAOMO:~/gopro# ./channel</div><div class=\"line\">msg in channel <span class=\"number\">1</span>\tcur_loop:<span class=\"number\">1</span></div><div class=\"line\">msg in channel <span class=\"number\">2</span>\tcur_loop:<span class=\"number\">1</span></div><div class=\"line\">msg in channel <span class=\"number\">3</span>\tcur_loop:<span class=\"number\">1</span></div><div class=\"line\">msg in channel <span class=\"number\">3</span>\tcur_loop:<span class=\"number\">2</span></div><div class=\"line\">msg in channel <span class=\"number\">3</span>\tcur_loop:<span class=\"number\">3</span></div><div class=\"line\">msg in channel <span class=\"number\">2</span>\tcur_loop:<span class=\"number\">2</span></div><div class=\"line\">msg in channel <span class=\"number\">1</span>\tcur_loop:<span class=\"number\">2</span></div><div class=\"line\">msg in channel <span class=\"number\">2</span>\tcur_loop:<span class=\"number\">3</span></div><div class=\"line\">msg in channel <span class=\"number\">1</span>\tcur_loop:<span class=\"number\">3</span></div></pre></td></tr></table></figure></p>\n<p>由结果可见, 每个channel中的消息都能尽快的被读取, 而不会因为一个channel的阻塞而导致了其他channel的消息无法被读取。</p>\n","site":{"data":{}},"excerpt":"<p>在unix系统中, 管道是进程间通信的一种方式。那golang的channel和系统的管道有什么区别？</p>\n<h3 id=\"什么是channel\"><a href=\"#什么是channel\" class=\"headerlink\" title=\"什么是channel\"></a>什么是channel</h3><p>官方文档有个channel的定义:</p>\n<blockquote>\n<p>   A channel provides a mechanism for concurrently executing functions to communicate<br>   by sending and receiving values of a specified element type.<br>   The value of an uninitialized channel is nil.</p>\n</blockquote>\n<p>channel应该可以理解为: 一种为并行执行而提供函数间通信的机制, 通过传递send和recieve特定类型的值来实现。没有初始化值的channel对象, 默认为nil。<br>","more":"</p>\n<p>也就是: 在管道的两端, 一个对象可以在一端进行写/读/读写的操作, 另一个对象可以在另一端进行读/写/读写的操作；能否读写, 取决于管道是否是双向的。默认情况下, 管道是双向的。</p>\n<h3 id=\"channel的基础特性\"><a href=\"#channel的基础特性\" class=\"headerlink\" title=\"channel的基础特性\"></a>channel的基础特性</h3><ul>\n<li>channel是一个作为队列queue的值。 当queue满时, 写操作是阻塞的; 当queue为空时, 读操作是阻塞的</li>\n<li>向一个nil channel读数据或写数据, 会造成一直阻塞</li>\n<li>向一个close了的channel写数据, 会引起panic</li>\n<li>向一个close了的channel读数据, 会立刻获取到一个零值</li>\n</ul>\n<h3 id=\"一些用法示例\"><a href=\"#一些用法示例\" class=\"headerlink\" title=\"一些用法示例\"></a>一些用法示例</h3><h4 id=\"1-没有缓冲的channel\"><a href=\"#1-没有缓冲的channel\" class=\"headerlink\" title=\"1.没有缓冲的channel\"></a>1.没有缓冲的channel</h4><p>当我们没有为channel指定容量时, 我们称这个channel是没有缓冲的。<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test_deadlock</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">     c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>)</div><div class=\"line\">     c &lt;- <span class=\"string\">\"test\"</span>    <span class=\"comment\">// 写入channel</span></div><div class=\"line\">     s := &lt;-c       <span class=\"comment\">// 读取channel</span></div><div class=\"line\">     <span class=\"built_in\">println</span>(s)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">fatal error: all goroutines are asleep - deadlock!</div><div class=\"line\"></div><div class=\"line\">goroutine 1 [chan send]:</div><div class=\"line\">main.test_deadlock</div><div class=\"line\">\t/root/gopro/channel.go:10</div><div class=\"line\">main.main</div><div class=\"line\">\t/root/gopro/channel.go:53</div></pre></td></tr></table></figure></p>\n<p>提示出现了死锁。这是因为处在同一个单线程环境中, 两个goroutine互相等待对方释放资源, 造成双方都无法继续运行下去。Go运行时检测到了死锁并给出了错误报告。指定容量后可解决这个问题:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>, <span class=\"number\">3</span>)  <span class=\"comment\">// 长度为3</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"2-使用range来进行读取操作\"><a href=\"#2-使用range来进行读取操作\" class=\"headerlink\" title=\"2. 使用range来进行读取操作\"></a>2. 使用range来进行读取操作</h4><ul>\n<li>range会在close channel后读取完所有数据并自动结束循环</li>\n<li>有/无缓冲的channel在使用range时效果是一样的</li>\n<li>range方法, 不需要知道channel中消息的准确数目, 使用人性化</li>\n</ul>\n<p>使用range示例:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">     message := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</div><div class=\"line\">     count := <span class=\"number\">3</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">          <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= count; i++ &#123;</div><div class=\"line\">               fmt.Printf(<span class=\"string\">\"send %v\\n\"</span>, i)</div><div class=\"line\">               message &lt;- i</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"comment\">//完成写入后, 需要关闭channel, 否则主goroutine会因一直等待而死锁</span></div><div class=\"line\">          <span class=\"built_in\">close</span>(message)</div><div class=\"line\">     &#125;()</div><div class=\"line\">     time.Sleep(time.Second * <span class=\"number\">3</span>)</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">for</span> msg := <span class=\"keyword\">range</span> message &#123;</div><div class=\"line\">          fmt.Printf(<span class=\"string\">\"recieve: %v\\n\"</span>, msg)</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行效果:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro# <span class=\"keyword\">go</span> build channel.<span class=\"keyword\">go</span></div><div class=\"line\">root@XIAOMO:~/gopro# ./channel</div><div class=\"line\">send <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">// 此处等待3秒</span></div><div class=\"line\">recieve: <span class=\"number\">1</span></div><div class=\"line\">send <span class=\"number\">2</span></div><div class=\"line\">send <span class=\"number\">3</span></div><div class=\"line\">recieve: <span class=\"number\">2</span></div><div class=\"line\">recieve: <span class=\"number\">3</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"3-多channel模式\"><a href=\"#3-多channel模式\" class=\"headerlink\" title=\"3. 多channel模式\"></a>3. 多channel模式</h4><p>在程序中需要用到多个channel时, 我们可以使用select(类似于switch)来实现对channel的支持。</p>\n<p>以下示例中方法CreateMsgChannel()创建了一个channel和goroutine, 并向该channel中分三次写入数据; 在main()方法中通过select来读取三个channel中的数据:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CreateMsgChannel</span><span class=\"params\">(msg <span class=\"keyword\">string</span>, delay time.Duration)</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">     c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>)</div><div class=\"line\">     <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">          <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"number\">3</span>; i++ &#123;</div><div class=\"line\">               c &lt;- fmt.Sprintf(<span class=\"string\">\"%s\\tcur_loop:%d\"</span>, msg, i)</div><div class=\"line\">               <span class=\"comment\">// 模拟处理时间</span></div><div class=\"line\">               time.Sleep(time.Millisecond * delay)</div><div class=\"line\">          &#125;</div><div class=\"line\">     &#125;()</div><div class=\"line\">     <span class=\"keyword\">return</span> c</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    c1 := CreateMsgChannel(<span class=\"string\">\"msg in channel 1\"</span>, <span class=\"number\">500</span>)</div><div class=\"line\">    c2 := CreateMsgChannel(<span class=\"string\">\"msg in channel 2\"</span>, <span class=\"number\">260</span>)</div><div class=\"line\">    c3 := CreateMsgChannel(<span class=\"string\">\"msg in channel 3\"</span>, <span class=\"number\">50</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"number\">9</span>; i++ &#123;</div><div class=\"line\">        <span class=\"keyword\">select</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> msg := &lt;-c1:</div><div class=\"line\">                <span class=\"built_in\">println</span>(msg)</div><div class=\"line\">            <span class=\"keyword\">case</span> msg := &lt;-c2:</div><div class=\"line\">                <span class=\"built_in\">println</span>(msg)</div><div class=\"line\">            <span class=\"keyword\">case</span> msg := &lt;-c3:</div><div class=\"line\">                <span class=\"built_in\">println</span>(msg)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行效果:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro# <span class=\"keyword\">go</span> build channel.<span class=\"keyword\">go</span></div><div class=\"line\">root@XIAOMO:~/gopro# ./channel</div><div class=\"line\">msg in channel <span class=\"number\">1</span>\tcur_loop:<span class=\"number\">1</span></div><div class=\"line\">msg in channel <span class=\"number\">2</span>\tcur_loop:<span class=\"number\">1</span></div><div class=\"line\">msg in channel <span class=\"number\">3</span>\tcur_loop:<span class=\"number\">1</span></div><div class=\"line\">msg in channel <span class=\"number\">3</span>\tcur_loop:<span class=\"number\">2</span></div><div class=\"line\">msg in channel <span class=\"number\">3</span>\tcur_loop:<span class=\"number\">3</span></div><div class=\"line\">msg in channel <span class=\"number\">2</span>\tcur_loop:<span class=\"number\">2</span></div><div class=\"line\">msg in channel <span class=\"number\">1</span>\tcur_loop:<span class=\"number\">2</span></div><div class=\"line\">msg in channel <span class=\"number\">2</span>\tcur_loop:<span class=\"number\">3</span></div><div class=\"line\">msg in channel <span class=\"number\">1</span>\tcur_loop:<span class=\"number\">3</span></div></pre></td></tr></table></figure></p>\n<p>由结果可见, 每个channel中的消息都能尽快的被读取, 而不会因为一个channel的阻塞而导致了其他channel的消息无法被读取。</p>"},{"title":"[golang]function","date":"2016-02-07T02:07:46.000Z","_content":"\n### 基本用法\ngolang函数是不支持嵌套(但是可以使用匿名函数实现嵌套)、默认参数、重载, 但支持:\n- 不定长度的变参\n- 多返回值(类似python的返回元组?)\n- 显式命名返回值参数\n- 匿名函数\n- 函数闭包\n\n<!--more-->\n\n以下是一些基本用法示例:\n```golang\n// 一般用法, 无返回值\nfunc funcName1(input1 type1){\n    //do something\n}\n\n// 多参数, 一个返回值\nfunc funcName2(input1 type1, input2 type2) (output1 type1) {\n    //do something\n    return value1\n}\n\n// 多参数, 多返回值\nfunc funcName3(input1 type1, input2 type2) (output1 type1, output2 type2) {\n    //do something\n    return value1, value2\n}\n\n// 传入参数同类型\nfunc funcName4(i, j int) int {\n    return i*j\n}\n\n// 命名返回参数\nfunc funcName5(a, b int) (x, y int) {\n    x = a+b\n    y = a*b\n    return          // 返回 x, y\n    // return x, y  // 返回的结果和函数头声明一样: x,y,  可以不写\n    // return y, x  // 返回的结果就是y,x 而不是x, y\n}\n\n```\n### 参数传递\n#### 1.传递可变参数\n- 可变参数实际为一个slice, 必须作为一个形参放在最后的位置.\n- python中变参可用**dict方式传递; golang中需要用 ... 来展开, 否则会被当做一个参数传递\n\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc testListArg(x int, args ...string) {\n    str := \"\"\n    for _, s := range args {\n        str += s\n    }\n    fmt.Printf(\"%v %v\\n\", x, str)\n}\n\nfunc main() {\n    a := []string{\"a\", \"d\", \"v\", \"m\"}\n    testListArg(5, a...)\n    testListArg(6, a[:3]...)\n}\n\n```\n演示效果:\n```bash\nroot@XIAOMO:~/gopro# go build main.go\nroot@XIAOMO:~/gopro# ./main\n5 advm\n6 adv\n```\n#### 2.传递指针类型\n- string, slice, map的传递实际为指针方式传递, 无需取值后显式传递指针\n- C/C++指针通过 -> 来获取指针对象成员, golang则通过 . 来实现操作。\n\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc testPointer(user *User) {\n    fmt.Printf(\"name: %v, id: %v\\n\", (*user).name, (*user).id)\n}\n\nfunc main() {\n    user := User{name:\"xiaomo\",id:1}\n    testPointer(&user)\n}\n```\n#### 3.匿名函数与闭包\n匿名方法经常和闭包配套使用\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// 匿名方法\nvar f1 = func(a,b int) int {\n    return (a+b)*2\n}\n\n// 匿名方法与闭包\nfunc f2(name string) {\n    f_inner := func (x,y int) int {\n        return x+y\n    }\n    sum := f_inner(7, 8)\n    fmt.Printf(\"name:%v sum:%v\\n\", name, sum)\n\n    // 匿名函数访问外部方法局部变量\n    extra := 15\n    f_inner2 := func(x,y int) int {\n        return x+y+extra\n    }\n    sum2 := f_inner2(9, 10)\n    fmt.Printf(\"name:%v sum2:%v\\n\", name, sum2)\n}\n\nfunc main() {\n    res := f1(3,4)\n    fmt.Printf(\"%v\\n\", res)\n\n    f2(\"xiaomo\")\n}\n```\n演示效果:\n```golang\nroot@XIAOMO:~/gopro# go build main.go\nroot@XIAOMO:~/gopro# ./main\n14\nname:xiaomo sum:15\nname:xiaomo sum2:34\n\n```","source":"_posts/golang/golang_function.md","raw":"---\ntitle: '[golang]function'\ndate: 2016-02-07 10:07:46\ntags: golang\n---\n\n### 基本用法\ngolang函数是不支持嵌套(但是可以使用匿名函数实现嵌套)、默认参数、重载, 但支持:\n- 不定长度的变参\n- 多返回值(类似python的返回元组?)\n- 显式命名返回值参数\n- 匿名函数\n- 函数闭包\n\n<!--more-->\n\n以下是一些基本用法示例:\n```golang\n// 一般用法, 无返回值\nfunc funcName1(input1 type1){\n    //do something\n}\n\n// 多参数, 一个返回值\nfunc funcName2(input1 type1, input2 type2) (output1 type1) {\n    //do something\n    return value1\n}\n\n// 多参数, 多返回值\nfunc funcName3(input1 type1, input2 type2) (output1 type1, output2 type2) {\n    //do something\n    return value1, value2\n}\n\n// 传入参数同类型\nfunc funcName4(i, j int) int {\n    return i*j\n}\n\n// 命名返回参数\nfunc funcName5(a, b int) (x, y int) {\n    x = a+b\n    y = a*b\n    return          // 返回 x, y\n    // return x, y  // 返回的结果和函数头声明一样: x,y,  可以不写\n    // return y, x  // 返回的结果就是y,x 而不是x, y\n}\n\n```\n### 参数传递\n#### 1.传递可变参数\n- 可变参数实际为一个slice, 必须作为一个形参放在最后的位置.\n- python中变参可用**dict方式传递; golang中需要用 ... 来展开, 否则会被当做一个参数传递\n\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc testListArg(x int, args ...string) {\n    str := \"\"\n    for _, s := range args {\n        str += s\n    }\n    fmt.Printf(\"%v %v\\n\", x, str)\n}\n\nfunc main() {\n    a := []string{\"a\", \"d\", \"v\", \"m\"}\n    testListArg(5, a...)\n    testListArg(6, a[:3]...)\n}\n\n```\n演示效果:\n```bash\nroot@XIAOMO:~/gopro# go build main.go\nroot@XIAOMO:~/gopro# ./main\n5 advm\n6 adv\n```\n#### 2.传递指针类型\n- string, slice, map的传递实际为指针方式传递, 无需取值后显式传递指针\n- C/C++指针通过 -> 来获取指针对象成员, golang则通过 . 来实现操作。\n\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc testPointer(user *User) {\n    fmt.Printf(\"name: %v, id: %v\\n\", (*user).name, (*user).id)\n}\n\nfunc main() {\n    user := User{name:\"xiaomo\",id:1}\n    testPointer(&user)\n}\n```\n#### 3.匿名函数与闭包\n匿名方法经常和闭包配套使用\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// 匿名方法\nvar f1 = func(a,b int) int {\n    return (a+b)*2\n}\n\n// 匿名方法与闭包\nfunc f2(name string) {\n    f_inner := func (x,y int) int {\n        return x+y\n    }\n    sum := f_inner(7, 8)\n    fmt.Printf(\"name:%v sum:%v\\n\", name, sum)\n\n    // 匿名函数访问外部方法局部变量\n    extra := 15\n    f_inner2 := func(x,y int) int {\n        return x+y+extra\n    }\n    sum2 := f_inner2(9, 10)\n    fmt.Printf(\"name:%v sum2:%v\\n\", name, sum2)\n}\n\nfunc main() {\n    res := f1(3,4)\n    fmt.Printf(\"%v\\n\", res)\n\n    f2(\"xiaomo\")\n}\n```\n演示效果:\n```golang\nroot@XIAOMO:~/gopro# go build main.go\nroot@XIAOMO:~/gopro# ./main\n14\nname:xiaomo sum:15\nname:xiaomo sum2:34\n\n```","slug":"golang/golang_function","published":1,"updated":"2017-08-07T05:47:10.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dy8003h4j4d003duzn0","content":"<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>golang函数是不支持嵌套(但是可以使用匿名函数实现嵌套)、默认参数、重载, 但支持:</p>\n<ul>\n<li>不定长度的变参</li>\n<li>多返回值(类似python的返回元组?)</li>\n<li>显式命名返回值参数</li>\n<li>匿名函数</li>\n<li>函数闭包</li>\n</ul>\n<a id=\"more\"></a>\n<p>以下是一些基本用法示例:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 一般用法, 无返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">funcName1</span><span class=\"params\">(input1 type1)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//do something</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 多参数, 一个返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">funcName2</span><span class=\"params\">(input1 type1, input2 type2)</span> <span class=\"params\">(output1 type1)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">//do something</span></div><div class=\"line\">    <span class=\"keyword\">return</span> value1</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 多参数, 多返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">funcName3</span><span class=\"params\">(input1 type1, input2 type2)</span> <span class=\"params\">(output1 type1, output2 type2)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">//do something</span></div><div class=\"line\">    <span class=\"keyword\">return</span> value1, value2</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 传入参数同类型</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">funcName4</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> i*j</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 命名返回参数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">funcName5</span><span class=\"params\">(a, b <span class=\"keyword\">int</span>)</span> <span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">    x = a+b</div><div class=\"line\">    y = a*b</div><div class=\"line\">    <span class=\"keyword\">return</span>          <span class=\"comment\">// 返回 x, y</span></div><div class=\"line\">    <span class=\"comment\">// return x, y  // 返回的结果和函数头声明一样: x,y,  可以不写</span></div><div class=\"line\">    <span class=\"comment\">// return y, x  // 返回的结果就是y,x 而不是x, y</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><h4 id=\"1-传递可变参数\"><a href=\"#1-传递可变参数\" class=\"headerlink\" title=\"1.传递可变参数\"></a>1.传递可变参数</h4><ul>\n<li>可变参数实际为一个slice, 必须作为一个形参放在最后的位置.</li>\n<li>python中变参可用**dict方式传递; golang中需要用 … 来展开, 否则会被当做一个参数传递</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testListArg</span><span class=\"params\">(x <span class=\"keyword\">int</span>, args ...<span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">    str := <span class=\"string\">\"\"</span></div><div class=\"line\">    <span class=\"keyword\">for</span> _, s := <span class=\"keyword\">range</span> args &#123;</div><div class=\"line\">        str += s</div><div class=\"line\">    &#125;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v %v\\n\"</span>, x, str)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    a := []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"v\"</span>, <span class=\"string\">\"m\"</span>&#125;</div><div class=\"line\">    testListArg(<span class=\"number\">5</span>, a...)</div><div class=\"line\">    testListArg(<span class=\"number\">6</span>, a[:<span class=\"number\">3</span>]...)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>演示效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># go build main.go</span></div><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># ./main</span></div><div class=\"line\">5 advm</div><div class=\"line\">6 adv</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-传递指针类型\"><a href=\"#2-传递指针类型\" class=\"headerlink\" title=\"2.传递指针类型\"></a>2.传递指针类型</h4><ul>\n<li>string, slice, map的传递实际为指针方式传递, 无需取值后显式传递指针</li>\n<li>C/C++指针通过 -&gt; 来获取指针对象成员, golang则通过 . 来实现操作。</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testPointer</span><span class=\"params\">(user *User)</span></span> &#123;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"name: %v, id: %v\\n\"</span>, (*user).name, (*user).id)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    user := User&#123;name:<span class=\"string\">\"xiaomo\"</span>,id:<span class=\"number\">1</span>&#125;</div><div class=\"line\">    testPointer(&amp;user)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-匿名函数与闭包\"><a href=\"#3-匿名函数与闭包\" class=\"headerlink\" title=\"3.匿名函数与闭包\"></a>3.匿名函数与闭包</h4><p>匿名方法经常和闭包配套使用<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 匿名方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(a,b <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (a+b)*<span class=\"number\">2</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 匿名方法与闭包</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">    f_inner := <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(x,y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x+y</div><div class=\"line\">    &#125;</div><div class=\"line\">    sum := f_inner(<span class=\"number\">7</span>, <span class=\"number\">8</span>)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"name:%v sum:%v\\n\"</span>, name, sum)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 匿名函数访问外部方法局部变量</span></div><div class=\"line\">    extra := <span class=\"number\">15</span></div><div class=\"line\">    f_inner2 := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x,y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x+y+extra</div><div class=\"line\">    &#125;</div><div class=\"line\">    sum2 := f_inner2(<span class=\"number\">9</span>, <span class=\"number\">10</span>)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"name:%v sum2:%v\\n\"</span>, name, sum2)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    res := f1(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, res)</div><div class=\"line\"></div><div class=\"line\">    f2(<span class=\"string\">\"xiaomo\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>演示效果:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro# <span class=\"keyword\">go</span> build main.<span class=\"keyword\">go</span></div><div class=\"line\">root@XIAOMO:~/gopro# ./main</div><div class=\"line\"><span class=\"number\">14</span></div><div class=\"line\">name:xiaomo sum:<span class=\"number\">15</span></div><div class=\"line\">name:xiaomo sum2:<span class=\"number\">34</span></div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>golang函数是不支持嵌套(但是可以使用匿名函数实现嵌套)、默认参数、重载, 但支持:</p>\n<ul>\n<li>不定长度的变参</li>\n<li>多返回值(类似python的返回元组?)</li>\n<li>显式命名返回值参数</li>\n<li>匿名函数</li>\n<li>函数闭包</li>\n</ul>","more":"<p>以下是一些基本用法示例:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 一般用法, 无返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">funcName1</span><span class=\"params\">(input1 type1)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//do something</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 多参数, 一个返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">funcName2</span><span class=\"params\">(input1 type1, input2 type2)</span> <span class=\"params\">(output1 type1)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">//do something</span></div><div class=\"line\">    <span class=\"keyword\">return</span> value1</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 多参数, 多返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">funcName3</span><span class=\"params\">(input1 type1, input2 type2)</span> <span class=\"params\">(output1 type1, output2 type2)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">//do something</span></div><div class=\"line\">    <span class=\"keyword\">return</span> value1, value2</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 传入参数同类型</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">funcName4</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> i*j</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 命名返回参数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">funcName5</span><span class=\"params\">(a, b <span class=\"keyword\">int</span>)</span> <span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">    x = a+b</div><div class=\"line\">    y = a*b</div><div class=\"line\">    <span class=\"keyword\">return</span>          <span class=\"comment\">// 返回 x, y</span></div><div class=\"line\">    <span class=\"comment\">// return x, y  // 返回的结果和函数头声明一样: x,y,  可以不写</span></div><div class=\"line\">    <span class=\"comment\">// return y, x  // 返回的结果就是y,x 而不是x, y</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><h4 id=\"1-传递可变参数\"><a href=\"#1-传递可变参数\" class=\"headerlink\" title=\"1.传递可变参数\"></a>1.传递可变参数</h4><ul>\n<li>可变参数实际为一个slice, 必须作为一个形参放在最后的位置.</li>\n<li>python中变参可用**dict方式传递; golang中需要用 … 来展开, 否则会被当做一个参数传递</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testListArg</span><span class=\"params\">(x <span class=\"keyword\">int</span>, args ...<span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">    str := <span class=\"string\">\"\"</span></div><div class=\"line\">    <span class=\"keyword\">for</span> _, s := <span class=\"keyword\">range</span> args &#123;</div><div class=\"line\">        str += s</div><div class=\"line\">    &#125;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v %v\\n\"</span>, x, str)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    a := []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"v\"</span>, <span class=\"string\">\"m\"</span>&#125;</div><div class=\"line\">    testListArg(<span class=\"number\">5</span>, a...)</div><div class=\"line\">    testListArg(<span class=\"number\">6</span>, a[:<span class=\"number\">3</span>]...)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>演示效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># go build main.go</span></div><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># ./main</span></div><div class=\"line\">5 advm</div><div class=\"line\">6 adv</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-传递指针类型\"><a href=\"#2-传递指针类型\" class=\"headerlink\" title=\"2.传递指针类型\"></a>2.传递指针类型</h4><ul>\n<li>string, slice, map的传递实际为指针方式传递, 无需取值后显式传递指针</li>\n<li>C/C++指针通过 -&gt; 来获取指针对象成员, golang则通过 . 来实现操作。</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testPointer</span><span class=\"params\">(user *User)</span></span> &#123;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"name: %v, id: %v\\n\"</span>, (*user).name, (*user).id)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    user := User&#123;name:<span class=\"string\">\"xiaomo\"</span>,id:<span class=\"number\">1</span>&#125;</div><div class=\"line\">    testPointer(&amp;user)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-匿名函数与闭包\"><a href=\"#3-匿名函数与闭包\" class=\"headerlink\" title=\"3.匿名函数与闭包\"></a>3.匿名函数与闭包</h4><p>匿名方法经常和闭包配套使用<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 匿名方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(a,b <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (a+b)*<span class=\"number\">2</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 匿名方法与闭包</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">    f_inner := <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(x,y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x+y</div><div class=\"line\">    &#125;</div><div class=\"line\">    sum := f_inner(<span class=\"number\">7</span>, <span class=\"number\">8</span>)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"name:%v sum:%v\\n\"</span>, name, sum)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 匿名函数访问外部方法局部变量</span></div><div class=\"line\">    extra := <span class=\"number\">15</span></div><div class=\"line\">    f_inner2 := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x,y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x+y+extra</div><div class=\"line\">    &#125;</div><div class=\"line\">    sum2 := f_inner2(<span class=\"number\">9</span>, <span class=\"number\">10</span>)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"name:%v sum2:%v\\n\"</span>, name, sum2)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    res := f1(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, res)</div><div class=\"line\"></div><div class=\"line\">    f2(<span class=\"string\">\"xiaomo\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>演示效果:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro# <span class=\"keyword\">go</span> build main.<span class=\"keyword\">go</span></div><div class=\"line\">root@XIAOMO:~/gopro# ./main</div><div class=\"line\"><span class=\"number\">14</span></div><div class=\"line\">name:xiaomo sum:<span class=\"number\">15</span></div><div class=\"line\">name:xiaomo sum2:<span class=\"number\">34</span></div></pre></td></tr></table></figure></p>"},{"title":"[golang]gRPC通信协议","date":"2017-02-09T02:10:53.000Z","_content":"\n#### 关于gRPC\ngRPC是google公司面向移动应用, 基于http2.0协议标准而设计, 基于Protocol Buffers而开发的一种开源RPC框架。<br>\nProtoBuf可以用于通讯协议、数据存储等一些语言/平台无关的数据序列化, 号称高性能, 通用性强, 具体可以看下这里的分析：\n[Google Protocol Buffer 的使用和原理](https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/)\n<br>gRPC提供了一种相对简单的方法来精确地定义服务, 和为ios/andoird/后台服务自动生成可靠的数据结构功能库; 通过它可以节省带宽和CPU资源, 降低TCP连接次数, 和延长电池寿命。\n<!--more-->\n\n#### 1.安装protobuf与gRPC of go\n去到[Protocol Buffers](https://github.com/google/protobuf/releases)下载器最新版。 笔者当前获取的版本为3.0.0, 安装过程如下：\n```\ntar -zxf protobuf-cpp-3.0.0-beta-2.tar.gz\ncd protobuf-3.0.0-beta-2/\n./configure\nmake && sudo make install\ngo get -u github.com/golang/protobuf/protoc-gen-go   # proto for golang\ngo get -u google.golang.org/grpc                     # grpc for golang\n```\n#### 2.定义proto文件\n```protobuf\n//protobuf3 protocol\nsyntax = \"proto3\";\npackage account;\n\n// request struct\nmessage UserRq {\n    int32 id = 1;\n}\n\n// response struct\nmessage UserRp {\n    string name = 1;\n}\n\n// service\nservice Data {\n    rpc GetUser(UserRq) returns (UserRp);\n}\n```\n上面定义了一个服务Data，有一个API叫GetUser，接收参数类型UserRq, 返回参数类型UserRp。\n\n<br>在proto中, service可以定义server， 有四种实现方式:(参考http://www.jianshu.com/p/774b38306c30)\n\n- rpc GetFeature(Point) returns (Feature) {}\n  <br>类似普通的函数调用，客户端发送请求Point到服务器，服务器返回相应Feature.\n\n- rpc ListFeatures(Rectangle) returns (stream Feature) {}\n  <br>客户端发起一次请求，服务器端返回一个流式数据，比如一个数组中的逐个元素\n\n- rpc RecordRoute(stream Point) returns (RouteSummary) {}\n  <br>客户端发起的请求是一个流式的数据，比如数组中的逐个元素，服务器返回一个相应\n\n- rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}\n  <br>客户端发起的请求是一个流式数据，比如数组中的逐个元素，二服务器返回的也是一个类似的数据结构\n\n上面的proto定义实现的是第一种方式。\n\n#### 3.使用protoc command生成go源文件\n```bash\nprotoc --go_out=plugins=grpc:. account.proto\nls\naccount.pb.go  account.proto\n```\n通过protoc生成了account.pb.go，其源码看起来是这样子的:\n```golang\n// Code generated by protoc-gen-go.\n// source: account.proto\n// DO NOT EDIT!\n\n/*\nPackage account is a generated protocol buffer package.\n\nIt is generated from these files:\n\taccount.proto\n\nIt has these top-level messages:\n\tUserRq\n\tUserRp\n*/\npackage account\n\nimport proto \"github.com/golang/protobuf/proto\"\nimport fmt \"fmt\"\nimport math \"math\"\n\nimport (\n\tcontext \"golang.org/x/net/context\"\n\tgrpc \"google.golang.org/grpc\"\n)\n\n// Reference imports to suppress errors if they are not otherwise used.\nvar _ = proto.Marshal\nvar _ = fmt.Errorf\nvar _ = math.Inf\n\n// This is a compile-time assertion to ensure that this generated file\n// is compatible with the proto package it is being compiled against.\nconst _ = proto.ProtoPackageIsVersion1\n\n// request struct\ntype UserRq struct {\n\tId int32 `protobuf:\"varint,1,opt,name=id\" json:\"id,omitempty\"`\n}\n\nfunc (m *UserRq) Reset()                    { *m = UserRq{} }\nfunc (m *UserRq) String() string            { return proto.CompactTextString(m) }\nfunc (*UserRq) ProtoMessage()               {}\nfunc (*UserRq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }\n\n// response struct\ntype UserRp struct {\n\tName string `protobuf:\"bytes,1,opt,name=name\" json:\"name,omitempty\"`\n}\n\nfunc (m *UserRp) Reset()                    { *m = UserRp{} }\nfunc (m *UserRp) String() string            { return proto.CompactTextString(m) }\nfunc (*UserRp) ProtoMessage()               {}\nfunc (*UserRp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }\n\nfunc init() {\n\tproto.RegisterType((*UserRq)(nil), \"account.UserRq\")\n\tproto.RegisterType((*UserRp)(nil), \"account.UserRp\")\n}\n\n// Reference imports to suppress errors if they are not otherwise used.\nvar _ context.Context\nvar _ grpc.ClientConn\n\n// This is a compile-time assertion to ensure that this generated file\n// is compatible with the grpc package it is being compiled against.\nconst _ = grpc.SupportPackageIsVersion1\n\n// Client API for Data service\n\ntype DataClient interface {\n\tGetUser(ctx context.Context, in *UserRq, opts ...grpc.CallOption) (*UserRp, error)\n}\n\ntype dataClient struct {\n\tcc *grpc.ClientConn\n}\n\nfunc NewDataClient(cc *grpc.ClientConn) DataClient {\n\treturn &dataClient{cc}\n}\n\nfunc (c *dataClient) GetUser(ctx context.Context, in *UserRq, opts ...grpc.CallOption) (*UserRp, error) {\n\tout := new(UserRp)\n\terr := grpc.Invoke(ctx, \"/account.Data/GetUser\", in, out, c.cc, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// Server API for Data service\n\ntype DataServer interface {\n\tGetUser(context.Context, *UserRq) (*UserRp, error)\n}\n\nfunc RegisterDataServer(s *grpc.Server, srv DataServer) {\n\ts.RegisterService(&_Data_serviceDesc, srv)\n}\n\nfunc _Data_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {\n\tin := new(UserRq)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tout, err := srv.(DataServer).GetUser(ctx, in)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\nvar _Data_serviceDesc = grpc.ServiceDesc{\n\tServiceName: \"account.Data\",\n\tHandlerType: (*DataServer)(nil),\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"GetUser\",\n\t\t\tHandler:    _Data_GetUser_Handler,\n\t\t},\n\t},\n\tStreams: []grpc.StreamDesc{},\n}\n\nvar fileDescriptor0 = []byte{\n\t// 119 bytes of a gzipped FileDescriptorProto\n\t0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0xe2, 0x4d, 0x4c, 0x4e, 0xce,\n\t0x2f, 0xcd, 0x2b, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x87, 0x72, 0x95, 0x24, 0xb8,\n\t0xd8, 0x42, 0x8b, 0x53, 0x8b, 0x82, 0x0a, 0x85, 0xf8, 0xb8, 0x98, 0x32, 0x53, 0x24, 0x18, 0x15,\n\t0x18, 0x35, 0x58, 0x83, 0x80, 0x2c, 0x25, 0x19, 0xa8, 0x4c, 0x81, 0x90, 0x10, 0x17, 0x4b, 0x5e,\n\t0x62, 0x6e, 0x2a, 0x58, 0x8e, 0x33, 0x08, 0xcc, 0x36, 0x32, 0xe6, 0x62, 0x71, 0x49, 0x2c, 0x49,\n\t0x14, 0xd2, 0xe6, 0x62, 0x77, 0x4f, 0x2d, 0x01, 0x29, 0x14, 0xe2, 0xd7, 0x83, 0xd9, 0x01, 0x31,\n\t0x51, 0x0a, 0x4d, 0xa0, 0x20, 0x89, 0x0d, 0x6c, 0xb9, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0xa6,\n\t0x63, 0xe9, 0x2f, 0x8d, 0x00, 0x00, 0x00,\n}\n```\n\n#### 4. 服务端svr.go\n```\npackage main\n\n// created by moguang(moxiaomomo@gmail.com)\n// created at 2016-01-10\n\nimport (\n\t\"account\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n)\n\ntype Data struct{}\n\nfunc main() {\n\thost := \"127.0.0.1:8080\"\n\t//listen on port\n\tlis, err := net.Listen(\"tcp\", host)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\taccount.RegisterDataServer(s, &Data{})\n\t// accept message\n\tlog.Printf(\"Begin to serve on %v\", host)\n\ts.Serve(lis)\n\tlog.Println(\"Server is shutdown.\")\n}\n\n// 给Data类型定义方法\nfunc (t *Data) GetUser(ctx context.Context, request *account.UserRq) (response *account.UserRp, err error) {\n\tlog.Printf(\"To get user, request.Id: %v\", request.Id)\n\tresponse = &account.UserRp{\n\t\tName: strconv.Itoa(int(request.Id)) + \"_test\",\n\t}\n\treturn response, err\n}\n```\n\n#### 5. 客户端cli.go\n```golang\npackage main\n\n// created by moguang(moxiaomomo@gmail.com)\n// created at 2016-01-10\n\nimport (\n\t\"account\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"log\"\n\t\"math/rand\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar (\n\twg sync.WaitGroup\n)\n\nconst (\n\tserver      = \"127.0.0.1\"\n\tport        = \"8080\"\n\tparallel    = 10 //连接并行数\n\ttimes       = 10 //每连接请求次数\n)\n\nfunc main() {\n\tbeginTime := time.Now()\n\t//结合WaitGroup, 实现并行请求\n\tfor i := 0; i < int(parallel); i++ {\n\t\twg.Add(1)\n\t\tgo execRPC(&wg)\n\t}\n\twg.Wait()\n\n\tendTime := time.Now()\n\tlog.Printf(\"Exec time secs: %.2f \", endTime.Sub(beginTime).Seconds())\n}\n\nfunc execRPC(wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\t// 建立连接\n\thost := server + \":\" + port\n\tconn, err := grpc.Dial(host, grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Printf(\"Dial Err: %v\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tclient := account.NewDataClient(conn)\n\t// 连续发起多次请求\n\tfor i := 0; i < int(times); i++ {\n\t\tgetUser(client)\n\t}\n}\n\nfunc getUser(client account.DataClient) {\n\tvar request account.UserRq\n\tr := rand.Intn(parallel)\n\trequest.Id = int32(r)\n\n\t// 调用远程方法\n\tresponse, _ := client.GetUser(context.Background(), &request)\n\t// 判断返回结果\n\tif id, _ := strconv.Atoi(strings.Split(response.Name, \":\")[0]); id != r {\n\t\tlog.Printf(\"Response error %#v\", response)\n\t} else {\n\t\tlog.Printf(\"Response ok %#v\", response)\n\t}\n}\n```\n","source":"_posts/golang/golang_gRPC.md","raw":"---\ntitle: '[golang]gRPC通信协议'\ndate: 2017-02-09 10:10:53\ntags: golang\n---\n\n#### 关于gRPC\ngRPC是google公司面向移动应用, 基于http2.0协议标准而设计, 基于Protocol Buffers而开发的一种开源RPC框架。<br>\nProtoBuf可以用于通讯协议、数据存储等一些语言/平台无关的数据序列化, 号称高性能, 通用性强, 具体可以看下这里的分析：\n[Google Protocol Buffer 的使用和原理](https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/)\n<br>gRPC提供了一种相对简单的方法来精确地定义服务, 和为ios/andoird/后台服务自动生成可靠的数据结构功能库; 通过它可以节省带宽和CPU资源, 降低TCP连接次数, 和延长电池寿命。\n<!--more-->\n\n#### 1.安装protobuf与gRPC of go\n去到[Protocol Buffers](https://github.com/google/protobuf/releases)下载器最新版。 笔者当前获取的版本为3.0.0, 安装过程如下：\n```\ntar -zxf protobuf-cpp-3.0.0-beta-2.tar.gz\ncd protobuf-3.0.0-beta-2/\n./configure\nmake && sudo make install\ngo get -u github.com/golang/protobuf/protoc-gen-go   # proto for golang\ngo get -u google.golang.org/grpc                     # grpc for golang\n```\n#### 2.定义proto文件\n```protobuf\n//protobuf3 protocol\nsyntax = \"proto3\";\npackage account;\n\n// request struct\nmessage UserRq {\n    int32 id = 1;\n}\n\n// response struct\nmessage UserRp {\n    string name = 1;\n}\n\n// service\nservice Data {\n    rpc GetUser(UserRq) returns (UserRp);\n}\n```\n上面定义了一个服务Data，有一个API叫GetUser，接收参数类型UserRq, 返回参数类型UserRp。\n\n<br>在proto中, service可以定义server， 有四种实现方式:(参考http://www.jianshu.com/p/774b38306c30)\n\n- rpc GetFeature(Point) returns (Feature) {}\n  <br>类似普通的函数调用，客户端发送请求Point到服务器，服务器返回相应Feature.\n\n- rpc ListFeatures(Rectangle) returns (stream Feature) {}\n  <br>客户端发起一次请求，服务器端返回一个流式数据，比如一个数组中的逐个元素\n\n- rpc RecordRoute(stream Point) returns (RouteSummary) {}\n  <br>客户端发起的请求是一个流式的数据，比如数组中的逐个元素，服务器返回一个相应\n\n- rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}\n  <br>客户端发起的请求是一个流式数据，比如数组中的逐个元素，二服务器返回的也是一个类似的数据结构\n\n上面的proto定义实现的是第一种方式。\n\n#### 3.使用protoc command生成go源文件\n```bash\nprotoc --go_out=plugins=grpc:. account.proto\nls\naccount.pb.go  account.proto\n```\n通过protoc生成了account.pb.go，其源码看起来是这样子的:\n```golang\n// Code generated by protoc-gen-go.\n// source: account.proto\n// DO NOT EDIT!\n\n/*\nPackage account is a generated protocol buffer package.\n\nIt is generated from these files:\n\taccount.proto\n\nIt has these top-level messages:\n\tUserRq\n\tUserRp\n*/\npackage account\n\nimport proto \"github.com/golang/protobuf/proto\"\nimport fmt \"fmt\"\nimport math \"math\"\n\nimport (\n\tcontext \"golang.org/x/net/context\"\n\tgrpc \"google.golang.org/grpc\"\n)\n\n// Reference imports to suppress errors if they are not otherwise used.\nvar _ = proto.Marshal\nvar _ = fmt.Errorf\nvar _ = math.Inf\n\n// This is a compile-time assertion to ensure that this generated file\n// is compatible with the proto package it is being compiled against.\nconst _ = proto.ProtoPackageIsVersion1\n\n// request struct\ntype UserRq struct {\n\tId int32 `protobuf:\"varint,1,opt,name=id\" json:\"id,omitempty\"`\n}\n\nfunc (m *UserRq) Reset()                    { *m = UserRq{} }\nfunc (m *UserRq) String() string            { return proto.CompactTextString(m) }\nfunc (*UserRq) ProtoMessage()               {}\nfunc (*UserRq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }\n\n// response struct\ntype UserRp struct {\n\tName string `protobuf:\"bytes,1,opt,name=name\" json:\"name,omitempty\"`\n}\n\nfunc (m *UserRp) Reset()                    { *m = UserRp{} }\nfunc (m *UserRp) String() string            { return proto.CompactTextString(m) }\nfunc (*UserRp) ProtoMessage()               {}\nfunc (*UserRp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }\n\nfunc init() {\n\tproto.RegisterType((*UserRq)(nil), \"account.UserRq\")\n\tproto.RegisterType((*UserRp)(nil), \"account.UserRp\")\n}\n\n// Reference imports to suppress errors if they are not otherwise used.\nvar _ context.Context\nvar _ grpc.ClientConn\n\n// This is a compile-time assertion to ensure that this generated file\n// is compatible with the grpc package it is being compiled against.\nconst _ = grpc.SupportPackageIsVersion1\n\n// Client API for Data service\n\ntype DataClient interface {\n\tGetUser(ctx context.Context, in *UserRq, opts ...grpc.CallOption) (*UserRp, error)\n}\n\ntype dataClient struct {\n\tcc *grpc.ClientConn\n}\n\nfunc NewDataClient(cc *grpc.ClientConn) DataClient {\n\treturn &dataClient{cc}\n}\n\nfunc (c *dataClient) GetUser(ctx context.Context, in *UserRq, opts ...grpc.CallOption) (*UserRp, error) {\n\tout := new(UserRp)\n\terr := grpc.Invoke(ctx, \"/account.Data/GetUser\", in, out, c.cc, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n// Server API for Data service\n\ntype DataServer interface {\n\tGetUser(context.Context, *UserRq) (*UserRp, error)\n}\n\nfunc RegisterDataServer(s *grpc.Server, srv DataServer) {\n\ts.RegisterService(&_Data_serviceDesc, srv)\n}\n\nfunc _Data_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {\n\tin := new(UserRq)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tout, err := srv.(DataServer).GetUser(ctx, in)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\nvar _Data_serviceDesc = grpc.ServiceDesc{\n\tServiceName: \"account.Data\",\n\tHandlerType: (*DataServer)(nil),\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"GetUser\",\n\t\t\tHandler:    _Data_GetUser_Handler,\n\t\t},\n\t},\n\tStreams: []grpc.StreamDesc{},\n}\n\nvar fileDescriptor0 = []byte{\n\t// 119 bytes of a gzipped FileDescriptorProto\n\t0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0xe2, 0x4d, 0x4c, 0x4e, 0xce,\n\t0x2f, 0xcd, 0x2b, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x87, 0x72, 0x95, 0x24, 0xb8,\n\t0xd8, 0x42, 0x8b, 0x53, 0x8b, 0x82, 0x0a, 0x85, 0xf8, 0xb8, 0x98, 0x32, 0x53, 0x24, 0x18, 0x15,\n\t0x18, 0x35, 0x58, 0x83, 0x80, 0x2c, 0x25, 0x19, 0xa8, 0x4c, 0x81, 0x90, 0x10, 0x17, 0x4b, 0x5e,\n\t0x62, 0x6e, 0x2a, 0x58, 0x8e, 0x33, 0x08, 0xcc, 0x36, 0x32, 0xe6, 0x62, 0x71, 0x49, 0x2c, 0x49,\n\t0x14, 0xd2, 0xe6, 0x62, 0x77, 0x4f, 0x2d, 0x01, 0x29, 0x14, 0xe2, 0xd7, 0x83, 0xd9, 0x01, 0x31,\n\t0x51, 0x0a, 0x4d, 0xa0, 0x20, 0x89, 0x0d, 0x6c, 0xb9, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0xa6,\n\t0x63, 0xe9, 0x2f, 0x8d, 0x00, 0x00, 0x00,\n}\n```\n\n#### 4. 服务端svr.go\n```\npackage main\n\n// created by moguang(moxiaomomo@gmail.com)\n// created at 2016-01-10\n\nimport (\n\t\"account\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n)\n\ntype Data struct{}\n\nfunc main() {\n\thost := \"127.0.0.1:8080\"\n\t//listen on port\n\tlis, err := net.Listen(\"tcp\", host)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\taccount.RegisterDataServer(s, &Data{})\n\t// accept message\n\tlog.Printf(\"Begin to serve on %v\", host)\n\ts.Serve(lis)\n\tlog.Println(\"Server is shutdown.\")\n}\n\n// 给Data类型定义方法\nfunc (t *Data) GetUser(ctx context.Context, request *account.UserRq) (response *account.UserRp, err error) {\n\tlog.Printf(\"To get user, request.Id: %v\", request.Id)\n\tresponse = &account.UserRp{\n\t\tName: strconv.Itoa(int(request.Id)) + \"_test\",\n\t}\n\treturn response, err\n}\n```\n\n#### 5. 客户端cli.go\n```golang\npackage main\n\n// created by moguang(moxiaomomo@gmail.com)\n// created at 2016-01-10\n\nimport (\n\t\"account\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"log\"\n\t\"math/rand\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar (\n\twg sync.WaitGroup\n)\n\nconst (\n\tserver      = \"127.0.0.1\"\n\tport        = \"8080\"\n\tparallel    = 10 //连接并行数\n\ttimes       = 10 //每连接请求次数\n)\n\nfunc main() {\n\tbeginTime := time.Now()\n\t//结合WaitGroup, 实现并行请求\n\tfor i := 0; i < int(parallel); i++ {\n\t\twg.Add(1)\n\t\tgo execRPC(&wg)\n\t}\n\twg.Wait()\n\n\tendTime := time.Now()\n\tlog.Printf(\"Exec time secs: %.2f \", endTime.Sub(beginTime).Seconds())\n}\n\nfunc execRPC(wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\t// 建立连接\n\thost := server + \":\" + port\n\tconn, err := grpc.Dial(host, grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Printf(\"Dial Err: %v\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tclient := account.NewDataClient(conn)\n\t// 连续发起多次请求\n\tfor i := 0; i < int(times); i++ {\n\t\tgetUser(client)\n\t}\n}\n\nfunc getUser(client account.DataClient) {\n\tvar request account.UserRq\n\tr := rand.Intn(parallel)\n\trequest.Id = int32(r)\n\n\t// 调用远程方法\n\tresponse, _ := client.GetUser(context.Background(), &request)\n\t// 判断返回结果\n\tif id, _ := strconv.Atoi(strings.Split(response.Name, \":\")[0]); id != r {\n\t\tlog.Printf(\"Response error %#v\", response)\n\t} else {\n\t\tlog.Printf(\"Response ok %#v\", response)\n\t}\n}\n```\n","slug":"golang/golang_gRPC","published":1,"updated":"2017-08-07T05:47:10.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dy9003j4j4d9pwynzbg","content":"<h4 id=\"关于gRPC\"><a href=\"#关于gRPC\" class=\"headerlink\" title=\"关于gRPC\"></a>关于gRPC</h4><p>gRPC是google公司面向移动应用, 基于http2.0协议标准而设计, 基于Protocol Buffers而开发的一种开源RPC框架。<br><br>ProtoBuf可以用于通讯协议、数据存储等一些语言/平台无关的数据序列化, 号称高性能, 通用性强, 具体可以看下这里的分析：<br><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/\" target=\"_blank\" rel=\"external\">Google Protocol Buffer 的使用和原理</a><br><br>gRPC提供了一种相对简单的方法来精确地定义服务, 和为ios/andoird/后台服务自动生成可靠的数据结构功能库; 通过它可以节省带宽和CPU资源, 降低TCP连接次数, 和延长电池寿命。<br><a id=\"more\"></a></p>\n<h4 id=\"1-安装protobuf与gRPC-of-go\"><a href=\"#1-安装protobuf与gRPC-of-go\" class=\"headerlink\" title=\"1.安装protobuf与gRPC of go\"></a>1.安装protobuf与gRPC of go</h4><p>去到<a href=\"https://github.com/google/protobuf/releases\" target=\"_blank\" rel=\"external\">Protocol Buffers</a>下载器最新版。 笔者当前获取的版本为3.0.0, 安装过程如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">tar -zxf protobuf-cpp-3.0.0-beta-2.tar.gz</div><div class=\"line\">cd protobuf-3.0.0-beta-2/</div><div class=\"line\">./configure</div><div class=\"line\">make &amp;&amp; sudo make install</div><div class=\"line\">go get -u github.com/golang/protobuf/protoc-gen-go   # proto for golang</div><div class=\"line\">go get -u google.golang.org/grpc                     # grpc for golang</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-定义proto文件\"><a href=\"#2-定义proto文件\" class=\"headerlink\" title=\"2.定义proto文件\"></a>2.定义proto文件</h4><figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">//protobuf3 protocol</div><div class=\"line\">syntax = &quot;proto3&quot;;</div><div class=\"line\">package account;</div><div class=\"line\"></div><div class=\"line\">// request struct</div><div class=\"line\">message UserRq &#123;</div><div class=\"line\">    int32 id = 1;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// response struct</div><div class=\"line\">message UserRp &#123;</div><div class=\"line\">    string name = 1;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// service</div><div class=\"line\">service Data &#123;</div><div class=\"line\">    rpc GetUser(UserRq) returns (UserRp);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面定义了一个服务Data，有一个API叫GetUser，接收参数类型UserRq, 返回参数类型UserRp。</p>\n<p><br>在proto中, service可以定义server， 有四种实现方式:(参考<a href=\"http://www.jianshu.com/p/774b38306c30\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/774b38306c30</a>)</p>\n<ul>\n<li><p>rpc GetFeature(Point) returns (Feature) {}<br><br>类似普通的函数调用，客户端发送请求Point到服务器，服务器返回相应Feature.</p>\n</li>\n<li><p>rpc ListFeatures(Rectangle) returns (stream Feature) {}<br><br>客户端发起一次请求，服务器端返回一个流式数据，比如一个数组中的逐个元素</p>\n</li>\n<li><p>rpc RecordRoute(stream Point) returns (RouteSummary) {}<br><br>客户端发起的请求是一个流式的数据，比如数组中的逐个元素，服务器返回一个相应</p>\n</li>\n<li><p>rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}<br><br>客户端发起的请求是一个流式数据，比如数组中的逐个元素，二服务器返回的也是一个类似的数据结构</p>\n</li>\n</ul>\n<p>上面的proto定义实现的是第一种方式。</p>\n<h4 id=\"3-使用protoc-command生成go源文件\"><a href=\"#3-使用protoc-command生成go源文件\" class=\"headerlink\" title=\"3.使用protoc command生成go源文件\"></a>3.使用protoc command生成go源文件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">protoc --go_out=plugins=grpc:. account.proto</div><div class=\"line\">ls</div><div class=\"line\">account.pb.go  account.proto</div></pre></td></tr></table></figure>\n<p>通过protoc生成了account.pb.go，其源码看起来是这样子的:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Code generated by protoc-gen-go.</span></div><div class=\"line\"><span class=\"comment\">// source: account.proto</span></div><div class=\"line\"><span class=\"comment\">// DO NOT EDIT!</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">Package account is a generated protocol buffer package.</div><div class=\"line\"></div><div class=\"line\">It is generated from these files:</div><div class=\"line\">\taccount.proto</div><div class=\"line\"></div><div class=\"line\">It has these top-level messages:</div><div class=\"line\">\tUserRq</div><div class=\"line\">\tUserRp</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">package</span> account</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> proto <span class=\"string\">\"github.com/golang/protobuf/proto\"</span></div><div class=\"line\"><span class=\"keyword\">import</span> fmt <span class=\"string\">\"fmt\"</span></div><div class=\"line\"><span class=\"keyword\">import</span> math <span class=\"string\">\"math\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\tcontext <span class=\"string\">\"golang.org/x/net/context\"</span></div><div class=\"line\">\tgrpc <span class=\"string\">\"google.golang.org/grpc\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Reference imports to suppress errors if they are not otherwise used.</span></div><div class=\"line\"><span class=\"keyword\">var</span> _ = proto.Marshal</div><div class=\"line\"><span class=\"keyword\">var</span> _ = fmt.Errorf</div><div class=\"line\"><span class=\"keyword\">var</span> _ = math.Inf</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// This is a compile-time assertion to ensure that this generated file</span></div><div class=\"line\"><span class=\"comment\">// is compatible with the proto package it is being compiled against.</span></div><div class=\"line\"><span class=\"keyword\">const</span> _ = proto.ProtoPackageIsVersion1</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// request struct</span></div><div class=\"line\"><span class=\"keyword\">type</span> UserRq <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tId <span class=\"keyword\">int32</span> <span class=\"string\">`protobuf:\"varint,1,opt,name=id\" json:\"id,omitempty\"`</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *UserRq)</span> <span class=\"title\">Reset</span><span class=\"params\">()</span></span>                    &#123; *m = UserRq&#123;&#125; &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *UserRq)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span>            &#123; <span class=\"keyword\">return</span> proto.CompactTextString(m) &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*UserRq)</span> <span class=\"title\">ProtoMessage</span><span class=\"params\">()</span></span>               &#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*UserRq)</span> <span class=\"title\">Descriptor</span><span class=\"params\">()</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, []<span class=\"keyword\">int</span>)</span></span> &#123; <span class=\"keyword\">return</span> fileDescriptor0, []<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>&#125; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// response struct</span></div><div class=\"line\"><span class=\"keyword\">type</span> UserRp <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tName <span class=\"keyword\">string</span> <span class=\"string\">`protobuf:\"bytes,1,opt,name=name\" json:\"name,omitempty\"`</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *UserRp)</span> <span class=\"title\">Reset</span><span class=\"params\">()</span></span>                    &#123; *m = UserRp&#123;&#125; &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *UserRp)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span>            &#123; <span class=\"keyword\">return</span> proto.CompactTextString(m) &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*UserRp)</span> <span class=\"title\">ProtoMessage</span><span class=\"params\">()</span></span>               &#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*UserRp)</span> <span class=\"title\">Descriptor</span><span class=\"params\">()</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, []<span class=\"keyword\">int</span>)</span></span> &#123; <span class=\"keyword\">return</span> fileDescriptor0, []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>&#125; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tproto.RegisterType((*UserRq)(<span class=\"literal\">nil</span>), <span class=\"string\">\"account.UserRq\"</span>)</div><div class=\"line\">\tproto.RegisterType((*UserRp)(<span class=\"literal\">nil</span>), <span class=\"string\">\"account.UserRp\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Reference imports to suppress errors if they are not otherwise used.</span></div><div class=\"line\"><span class=\"keyword\">var</span> _ context.Context</div><div class=\"line\"><span class=\"keyword\">var</span> _ grpc.ClientConn</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// This is a compile-time assertion to ensure that this generated file</span></div><div class=\"line\"><span class=\"comment\">// is compatible with the grpc package it is being compiled against.</span></div><div class=\"line\"><span class=\"keyword\">const</span> _ = grpc.SupportPackageIsVersion1</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Client API for Data service</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> DataClient <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">\tGetUser(ctx context.Context, in *UserRq, opts ...grpc.CallOption) (*UserRp, error)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> dataClient <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tcc *grpc.ClientConn</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewDataClient</span><span class=\"params\">(cc *grpc.ClientConn)</span> <span class=\"title\">DataClient</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> &amp;dataClient&#123;cc&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *dataClient)</span> <span class=\"title\">GetUser</span><span class=\"params\">(ctx context.Context, in *UserRq, opts ...grpc.CallOption)</span> <span class=\"params\">(*UserRp, error)</span></span> &#123;</div><div class=\"line\">\tout := <span class=\"built_in\">new</span>(UserRp)</div><div class=\"line\">\terr := grpc.Invoke(ctx, <span class=\"string\">\"/account.Data/GetUser\"</span>, in, out, c.cc, opts...)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> out, <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Server API for Data service</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> DataServer <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">\tGetUser(context.Context, *UserRq) (*UserRp, error)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RegisterDataServer</span><span class=\"params\">(s *grpc.Server, srv DataServer)</span></span> &#123;</div><div class=\"line\">\ts.RegisterService(&amp;_Data_serviceDesc, srv)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> _<span class=\"title\">Data_GetUser_Handler</span><span class=\"params\">(srv <span class=\"keyword\">interface</span>&#123;&#125;, ctx context.Context, dec <span class=\"keyword\">func</span>(<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span>) <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class=\"line\">\tin := <span class=\"built_in\">new</span>(UserRq)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err := dec(in); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tout, err := srv.(DataServer).GetUser(ctx, in)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> out, <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> _Data_serviceDesc = grpc.ServiceDesc&#123;</div><div class=\"line\">\tServiceName: <span class=\"string\">\"account.Data\"</span>,</div><div class=\"line\">\tHandlerType: (*DataServer)(<span class=\"literal\">nil</span>),</div><div class=\"line\">\tMethods: []grpc.MethodDesc&#123;</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tMethodName: <span class=\"string\">\"GetUser\"</span>,</div><div class=\"line\">\t\t\tHandler:    _Data_GetUser_Handler,</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tStreams: []grpc.StreamDesc&#123;&#125;,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> fileDescriptor0 = []<span class=\"keyword\">byte</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 119 bytes of a gzipped FileDescriptorProto</span></div><div class=\"line\">\t<span class=\"number\">0x1f</span>, <span class=\"number\">0x8b</span>, <span class=\"number\">0x08</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x09</span>, <span class=\"number\">0x6e</span>, <span class=\"number\">0x88</span>, <span class=\"number\">0x02</span>, <span class=\"number\">0xff</span>, <span class=\"number\">0xe2</span>, <span class=\"number\">0xe2</span>, <span class=\"number\">0x4d</span>, <span class=\"number\">0x4c</span>, <span class=\"number\">0x4e</span>, <span class=\"number\">0xce</span>,</div><div class=\"line\">\t<span class=\"number\">0x2f</span>, <span class=\"number\">0xcd</span>, <span class=\"number\">0x2b</span>, <span class=\"number\">0xd1</span>, <span class=\"number\">0x2b</span>, <span class=\"number\">0x28</span>, <span class=\"number\">0xca</span>, <span class=\"number\">0x2f</span>, <span class=\"number\">0xc9</span>, <span class=\"number\">0x17</span>, <span class=\"number\">0x62</span>, <span class=\"number\">0x87</span>, <span class=\"number\">0x72</span>, <span class=\"number\">0x95</span>, <span class=\"number\">0x24</span>, <span class=\"number\">0xb8</span>,</div><div class=\"line\">\t<span class=\"number\">0xd8</span>, <span class=\"number\">0x42</span>, <span class=\"number\">0x8b</span>, <span class=\"number\">0x53</span>, <span class=\"number\">0x8b</span>, <span class=\"number\">0x82</span>, <span class=\"number\">0x0a</span>, <span class=\"number\">0x85</span>, <span class=\"number\">0xf8</span>, <span class=\"number\">0xb8</span>, <span class=\"number\">0x98</span>, <span class=\"number\">0x32</span>, <span class=\"number\">0x53</span>, <span class=\"number\">0x24</span>, <span class=\"number\">0x18</span>, <span class=\"number\">0x15</span>,</div><div class=\"line\">\t<span class=\"number\">0x18</span>, <span class=\"number\">0x35</span>, <span class=\"number\">0x58</span>, <span class=\"number\">0x83</span>, <span class=\"number\">0x80</span>, <span class=\"number\">0x2c</span>, <span class=\"number\">0x25</span>, <span class=\"number\">0x19</span>, <span class=\"number\">0xa8</span>, <span class=\"number\">0x4c</span>, <span class=\"number\">0x81</span>, <span class=\"number\">0x90</span>, <span class=\"number\">0x10</span>, <span class=\"number\">0x17</span>, <span class=\"number\">0x4b</span>, <span class=\"number\">0x5e</span>,</div><div class=\"line\">\t<span class=\"number\">0x62</span>, <span class=\"number\">0x6e</span>, <span class=\"number\">0x2a</span>, <span class=\"number\">0x58</span>, <span class=\"number\">0x8e</span>, <span class=\"number\">0x33</span>, <span class=\"number\">0x08</span>, <span class=\"number\">0xcc</span>, <span class=\"number\">0x36</span>, <span class=\"number\">0x32</span>, <span class=\"number\">0xe6</span>, <span class=\"number\">0x62</span>, <span class=\"number\">0x71</span>, <span class=\"number\">0x49</span>, <span class=\"number\">0x2c</span>, <span class=\"number\">0x49</span>,</div><div class=\"line\">\t<span class=\"number\">0x14</span>, <span class=\"number\">0xd2</span>, <span class=\"number\">0xe6</span>, <span class=\"number\">0x62</span>, <span class=\"number\">0x77</span>, <span class=\"number\">0x4f</span>, <span class=\"number\">0x2d</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x29</span>, <span class=\"number\">0x14</span>, <span class=\"number\">0xe2</span>, <span class=\"number\">0xd7</span>, <span class=\"number\">0x83</span>, <span class=\"number\">0xd9</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x31</span>,</div><div class=\"line\">\t<span class=\"number\">0x51</span>, <span class=\"number\">0x0a</span>, <span class=\"number\">0x4d</span>, <span class=\"number\">0xa0</span>, <span class=\"number\">0x20</span>, <span class=\"number\">0x89</span>, <span class=\"number\">0x0d</span>, <span class=\"number\">0x6c</span>, <span class=\"number\">0xb9</span>, <span class=\"number\">0x31</span>, <span class=\"number\">0x20</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0xff</span>, <span class=\"number\">0xff</span>, <span class=\"number\">0xa6</span>,</div><div class=\"line\">\t<span class=\"number\">0x63</span>, <span class=\"number\">0xe9</span>, <span class=\"number\">0x2f</span>, <span class=\"number\">0x8d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"4-服务端svr-go\"><a href=\"#4-服务端svr-go\" class=\"headerlink\" title=\"4. 服务端svr.go\"></a>4. 服务端svr.go</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">// created by moguang(moxiaomomo@gmail.com)</div><div class=\"line\">// created at 2016-01-10</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;account&quot;</div><div class=\"line\">\t&quot;golang.org/x/net/context&quot;</div><div class=\"line\">\t&quot;google.golang.org/grpc&quot;</div><div class=\"line\">\t&quot;log&quot;</div><div class=\"line\">\t&quot;net&quot;</div><div class=\"line\">\t&quot;strconv&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">type Data struct&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">func main() &#123;</div><div class=\"line\">\thost := &quot;127.0.0.1:8080&quot;</div><div class=\"line\">\t//listen on port</div><div class=\"line\">\tlis, err := net.Listen(&quot;tcp&quot;, host)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tlog.Fatalf(&quot;Failed to listen: %v&quot;, err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\ts := grpc.NewServer()</div><div class=\"line\">\taccount.RegisterDataServer(s, &amp;Data&#123;&#125;)</div><div class=\"line\">\t// accept message</div><div class=\"line\">\tlog.Printf(&quot;Begin to serve on %v&quot;, host)</div><div class=\"line\">\ts.Serve(lis)</div><div class=\"line\">\tlog.Println(&quot;Server is shutdown.&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 给Data类型定义方法</div><div class=\"line\">func (t *Data) GetUser(ctx context.Context, request *account.UserRq) (response *account.UserRp, err error) &#123;</div><div class=\"line\">\tlog.Printf(&quot;To get user, request.Id: %v&quot;, request.Id)</div><div class=\"line\">\tresponse = &amp;account.UserRp&#123;</div><div class=\"line\">\t\tName: strconv.Itoa(int(request.Id)) + &quot;_test&quot;,</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn response, err</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"5-客户端cli-go\"><a href=\"#5-客户端cli-go\" class=\"headerlink\" title=\"5. 客户端cli.go\"></a>5. 客户端cli.go</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// created by moguang(moxiaomomo@gmail.com)</span></div><div class=\"line\"><span class=\"comment\">// created at 2016-01-10</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"account\"</span></div><div class=\"line\">\t<span class=\"string\">\"golang.org/x/net/context\"</span></div><div class=\"line\">\t<span class=\"string\">\"google.golang.org/grpc\"</span></div><div class=\"line\">\t<span class=\"string\">\"log\"</span></div><div class=\"line\">\t<span class=\"string\">\"math/rand\"</span></div><div class=\"line\">\t<span class=\"string\">\"strconv\"</span></div><div class=\"line\">\t<span class=\"string\">\"strings\"</span></div><div class=\"line\">\t<span class=\"string\">\"sync\"</span></div><div class=\"line\">\t<span class=\"string\">\"time\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">\twg sync.WaitGroup</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> (</div><div class=\"line\">\tserver      = <span class=\"string\">\"127.0.0.1\"</span></div><div class=\"line\">\tport        = <span class=\"string\">\"8080\"</span></div><div class=\"line\">\tparallel    = <span class=\"number\">10</span> <span class=\"comment\">//连接并行数</span></div><div class=\"line\">\ttimes       = <span class=\"number\">10</span> <span class=\"comment\">//每连接请求次数</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tbeginTime := time.Now()</div><div class=\"line\">\t<span class=\"comment\">//结合WaitGroup, 实现并行请求</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">int</span>(parallel); i++ &#123;</div><div class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</div><div class=\"line\">\t\t<span class=\"keyword\">go</span> execRPC(&amp;wg)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\twg.Wait()</div><div class=\"line\"></div><div class=\"line\">\tendTime := time.Now()</div><div class=\"line\">\tlog.Printf(<span class=\"string\">\"Exec time secs: %.2f \"</span>, endTime.Sub(beginTime).Seconds())</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">execRPC</span><span class=\"params\">(wg *sync.WaitGroup)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> wg.Done()</div><div class=\"line\">\t<span class=\"comment\">// 建立连接</span></div><div class=\"line\">\thost := server + <span class=\"string\">\":\"</span> + port</div><div class=\"line\">\tconn, err := grpc.Dial(host, grpc.WithInsecure())</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"Dial Err: %v\"</span>, err)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</div><div class=\"line\"></div><div class=\"line\">\tclient := account.NewDataClient(conn)</div><div class=\"line\">\t<span class=\"comment\">// 连续发起多次请求</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">int</span>(times); i++ &#123;</div><div class=\"line\">\t\tgetUser(client)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getUser</span><span class=\"params\">(client account.DataClient)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> request account.UserRq</div><div class=\"line\">\tr := rand.Intn(parallel)</div><div class=\"line\">\trequest.Id = <span class=\"keyword\">int32</span>(r)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 调用远程方法</span></div><div class=\"line\">\tresponse, _ := client.GetUser(context.Background(), &amp;request)</div><div class=\"line\">\t<span class=\"comment\">// 判断返回结果</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> id, _ := strconv.Atoi(strings.Split(response.Name, <span class=\"string\">\":\"</span>)[<span class=\"number\">0</span>]); id != r &#123;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"Response error %#v\"</span>, response)</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"Response ok %#v\"</span>, response)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h4 id=\"关于gRPC\"><a href=\"#关于gRPC\" class=\"headerlink\" title=\"关于gRPC\"></a>关于gRPC</h4><p>gRPC是google公司面向移动应用, 基于http2.0协议标准而设计, 基于Protocol Buffers而开发的一种开源RPC框架。<br><br>ProtoBuf可以用于通讯协议、数据存储等一些语言/平台无关的数据序列化, 号称高性能, 通用性强, 具体可以看下这里的分析：<br><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/\" target=\"_blank\" rel=\"external\">Google Protocol Buffer 的使用和原理</a><br><br>gRPC提供了一种相对简单的方法来精确地定义服务, 和为ios/andoird/后台服务自动生成可靠的数据结构功能库; 通过它可以节省带宽和CPU资源, 降低TCP连接次数, 和延长电池寿命。<br>","more":"</p>\n<h4 id=\"1-安装protobuf与gRPC-of-go\"><a href=\"#1-安装protobuf与gRPC-of-go\" class=\"headerlink\" title=\"1.安装protobuf与gRPC of go\"></a>1.安装protobuf与gRPC of go</h4><p>去到<a href=\"https://github.com/google/protobuf/releases\" target=\"_blank\" rel=\"external\">Protocol Buffers</a>下载器最新版。 笔者当前获取的版本为3.0.0, 安装过程如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">tar -zxf protobuf-cpp-3.0.0-beta-2.tar.gz</div><div class=\"line\">cd protobuf-3.0.0-beta-2/</div><div class=\"line\">./configure</div><div class=\"line\">make &amp;&amp; sudo make install</div><div class=\"line\">go get -u github.com/golang/protobuf/protoc-gen-go   # proto for golang</div><div class=\"line\">go get -u google.golang.org/grpc                     # grpc for golang</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-定义proto文件\"><a href=\"#2-定义proto文件\" class=\"headerlink\" title=\"2.定义proto文件\"></a>2.定义proto文件</h4><figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">//protobuf3 protocol</div><div class=\"line\">syntax = &quot;proto3&quot;;</div><div class=\"line\">package account;</div><div class=\"line\"></div><div class=\"line\">// request struct</div><div class=\"line\">message UserRq &#123;</div><div class=\"line\">    int32 id = 1;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// response struct</div><div class=\"line\">message UserRp &#123;</div><div class=\"line\">    string name = 1;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// service</div><div class=\"line\">service Data &#123;</div><div class=\"line\">    rpc GetUser(UserRq) returns (UserRp);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面定义了一个服务Data，有一个API叫GetUser，接收参数类型UserRq, 返回参数类型UserRp。</p>\n<p><br>在proto中, service可以定义server， 有四种实现方式:(参考<a href=\"http://www.jianshu.com/p/774b38306c30\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/774b38306c30</a>)</p>\n<ul>\n<li><p>rpc GetFeature(Point) returns (Feature) {}<br><br>类似普通的函数调用，客户端发送请求Point到服务器，服务器返回相应Feature.</p>\n</li>\n<li><p>rpc ListFeatures(Rectangle) returns (stream Feature) {}<br><br>客户端发起一次请求，服务器端返回一个流式数据，比如一个数组中的逐个元素</p>\n</li>\n<li><p>rpc RecordRoute(stream Point) returns (RouteSummary) {}<br><br>客户端发起的请求是一个流式的数据，比如数组中的逐个元素，服务器返回一个相应</p>\n</li>\n<li><p>rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}<br><br>客户端发起的请求是一个流式数据，比如数组中的逐个元素，二服务器返回的也是一个类似的数据结构</p>\n</li>\n</ul>\n<p>上面的proto定义实现的是第一种方式。</p>\n<h4 id=\"3-使用protoc-command生成go源文件\"><a href=\"#3-使用protoc-command生成go源文件\" class=\"headerlink\" title=\"3.使用protoc command生成go源文件\"></a>3.使用protoc command生成go源文件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">protoc --go_out=plugins=grpc:. account.proto</div><div class=\"line\">ls</div><div class=\"line\">account.pb.go  account.proto</div></pre></td></tr></table></figure>\n<p>通过protoc生成了account.pb.go，其源码看起来是这样子的:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Code generated by protoc-gen-go.</span></div><div class=\"line\"><span class=\"comment\">// source: account.proto</span></div><div class=\"line\"><span class=\"comment\">// DO NOT EDIT!</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">Package account is a generated protocol buffer package.</div><div class=\"line\"></div><div class=\"line\">It is generated from these files:</div><div class=\"line\">\taccount.proto</div><div class=\"line\"></div><div class=\"line\">It has these top-level messages:</div><div class=\"line\">\tUserRq</div><div class=\"line\">\tUserRp</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">package</span> account</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> proto <span class=\"string\">\"github.com/golang/protobuf/proto\"</span></div><div class=\"line\"><span class=\"keyword\">import</span> fmt <span class=\"string\">\"fmt\"</span></div><div class=\"line\"><span class=\"keyword\">import</span> math <span class=\"string\">\"math\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\tcontext <span class=\"string\">\"golang.org/x/net/context\"</span></div><div class=\"line\">\tgrpc <span class=\"string\">\"google.golang.org/grpc\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Reference imports to suppress errors if they are not otherwise used.</span></div><div class=\"line\"><span class=\"keyword\">var</span> _ = proto.Marshal</div><div class=\"line\"><span class=\"keyword\">var</span> _ = fmt.Errorf</div><div class=\"line\"><span class=\"keyword\">var</span> _ = math.Inf</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// This is a compile-time assertion to ensure that this generated file</span></div><div class=\"line\"><span class=\"comment\">// is compatible with the proto package it is being compiled against.</span></div><div class=\"line\"><span class=\"keyword\">const</span> _ = proto.ProtoPackageIsVersion1</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// request struct</span></div><div class=\"line\"><span class=\"keyword\">type</span> UserRq <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tId <span class=\"keyword\">int32</span> <span class=\"string\">`protobuf:\"varint,1,opt,name=id\" json:\"id,omitempty\"`</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *UserRq)</span> <span class=\"title\">Reset</span><span class=\"params\">()</span></span>                    &#123; *m = UserRq&#123;&#125; &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *UserRq)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span>            &#123; <span class=\"keyword\">return</span> proto.CompactTextString(m) &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*UserRq)</span> <span class=\"title\">ProtoMessage</span><span class=\"params\">()</span></span>               &#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*UserRq)</span> <span class=\"title\">Descriptor</span><span class=\"params\">()</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, []<span class=\"keyword\">int</span>)</span></span> &#123; <span class=\"keyword\">return</span> fileDescriptor0, []<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>&#125; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// response struct</span></div><div class=\"line\"><span class=\"keyword\">type</span> UserRp <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tName <span class=\"keyword\">string</span> <span class=\"string\">`protobuf:\"bytes,1,opt,name=name\" json:\"name,omitempty\"`</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *UserRp)</span> <span class=\"title\">Reset</span><span class=\"params\">()</span></span>                    &#123; *m = UserRp&#123;&#125; &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *UserRp)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span>            &#123; <span class=\"keyword\">return</span> proto.CompactTextString(m) &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*UserRp)</span> <span class=\"title\">ProtoMessage</span><span class=\"params\">()</span></span>               &#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*UserRp)</span> <span class=\"title\">Descriptor</span><span class=\"params\">()</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, []<span class=\"keyword\">int</span>)</span></span> &#123; <span class=\"keyword\">return</span> fileDescriptor0, []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>&#125; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tproto.RegisterType((*UserRq)(<span class=\"literal\">nil</span>), <span class=\"string\">\"account.UserRq\"</span>)</div><div class=\"line\">\tproto.RegisterType((*UserRp)(<span class=\"literal\">nil</span>), <span class=\"string\">\"account.UserRp\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Reference imports to suppress errors if they are not otherwise used.</span></div><div class=\"line\"><span class=\"keyword\">var</span> _ context.Context</div><div class=\"line\"><span class=\"keyword\">var</span> _ grpc.ClientConn</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// This is a compile-time assertion to ensure that this generated file</span></div><div class=\"line\"><span class=\"comment\">// is compatible with the grpc package it is being compiled against.</span></div><div class=\"line\"><span class=\"keyword\">const</span> _ = grpc.SupportPackageIsVersion1</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Client API for Data service</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> DataClient <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">\tGetUser(ctx context.Context, in *UserRq, opts ...grpc.CallOption) (*UserRp, error)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> dataClient <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tcc *grpc.ClientConn</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewDataClient</span><span class=\"params\">(cc *grpc.ClientConn)</span> <span class=\"title\">DataClient</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> &amp;dataClient&#123;cc&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *dataClient)</span> <span class=\"title\">GetUser</span><span class=\"params\">(ctx context.Context, in *UserRq, opts ...grpc.CallOption)</span> <span class=\"params\">(*UserRp, error)</span></span> &#123;</div><div class=\"line\">\tout := <span class=\"built_in\">new</span>(UserRp)</div><div class=\"line\">\terr := grpc.Invoke(ctx, <span class=\"string\">\"/account.Data/GetUser\"</span>, in, out, c.cc, opts...)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> out, <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Server API for Data service</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> DataServer <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">\tGetUser(context.Context, *UserRq) (*UserRp, error)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RegisterDataServer</span><span class=\"params\">(s *grpc.Server, srv DataServer)</span></span> &#123;</div><div class=\"line\">\ts.RegisterService(&amp;_Data_serviceDesc, srv)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> _<span class=\"title\">Data_GetUser_Handler</span><span class=\"params\">(srv <span class=\"keyword\">interface</span>&#123;&#125;, ctx context.Context, dec <span class=\"keyword\">func</span>(<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span>) <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class=\"line\">\tin := <span class=\"built_in\">new</span>(UserRq)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err := dec(in); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tout, err := srv.(DataServer).GetUser(ctx, in)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> out, <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> _Data_serviceDesc = grpc.ServiceDesc&#123;</div><div class=\"line\">\tServiceName: <span class=\"string\">\"account.Data\"</span>,</div><div class=\"line\">\tHandlerType: (*DataServer)(<span class=\"literal\">nil</span>),</div><div class=\"line\">\tMethods: []grpc.MethodDesc&#123;</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tMethodName: <span class=\"string\">\"GetUser\"</span>,</div><div class=\"line\">\t\t\tHandler:    _Data_GetUser_Handler,</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tStreams: []grpc.StreamDesc&#123;&#125;,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> fileDescriptor0 = []<span class=\"keyword\">byte</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 119 bytes of a gzipped FileDescriptorProto</span></div><div class=\"line\">\t<span class=\"number\">0x1f</span>, <span class=\"number\">0x8b</span>, <span class=\"number\">0x08</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x09</span>, <span class=\"number\">0x6e</span>, <span class=\"number\">0x88</span>, <span class=\"number\">0x02</span>, <span class=\"number\">0xff</span>, <span class=\"number\">0xe2</span>, <span class=\"number\">0xe2</span>, <span class=\"number\">0x4d</span>, <span class=\"number\">0x4c</span>, <span class=\"number\">0x4e</span>, <span class=\"number\">0xce</span>,</div><div class=\"line\">\t<span class=\"number\">0x2f</span>, <span class=\"number\">0xcd</span>, <span class=\"number\">0x2b</span>, <span class=\"number\">0xd1</span>, <span class=\"number\">0x2b</span>, <span class=\"number\">0x28</span>, <span class=\"number\">0xca</span>, <span class=\"number\">0x2f</span>, <span class=\"number\">0xc9</span>, <span class=\"number\">0x17</span>, <span class=\"number\">0x62</span>, <span class=\"number\">0x87</span>, <span class=\"number\">0x72</span>, <span class=\"number\">0x95</span>, <span class=\"number\">0x24</span>, <span class=\"number\">0xb8</span>,</div><div class=\"line\">\t<span class=\"number\">0xd8</span>, <span class=\"number\">0x42</span>, <span class=\"number\">0x8b</span>, <span class=\"number\">0x53</span>, <span class=\"number\">0x8b</span>, <span class=\"number\">0x82</span>, <span class=\"number\">0x0a</span>, <span class=\"number\">0x85</span>, <span class=\"number\">0xf8</span>, <span class=\"number\">0xb8</span>, <span class=\"number\">0x98</span>, <span class=\"number\">0x32</span>, <span class=\"number\">0x53</span>, <span class=\"number\">0x24</span>, <span class=\"number\">0x18</span>, <span class=\"number\">0x15</span>,</div><div class=\"line\">\t<span class=\"number\">0x18</span>, <span class=\"number\">0x35</span>, <span class=\"number\">0x58</span>, <span class=\"number\">0x83</span>, <span class=\"number\">0x80</span>, <span class=\"number\">0x2c</span>, <span class=\"number\">0x25</span>, <span class=\"number\">0x19</span>, <span class=\"number\">0xa8</span>, <span class=\"number\">0x4c</span>, <span class=\"number\">0x81</span>, <span class=\"number\">0x90</span>, <span class=\"number\">0x10</span>, <span class=\"number\">0x17</span>, <span class=\"number\">0x4b</span>, <span class=\"number\">0x5e</span>,</div><div class=\"line\">\t<span class=\"number\">0x62</span>, <span class=\"number\">0x6e</span>, <span class=\"number\">0x2a</span>, <span class=\"number\">0x58</span>, <span class=\"number\">0x8e</span>, <span class=\"number\">0x33</span>, <span class=\"number\">0x08</span>, <span class=\"number\">0xcc</span>, <span class=\"number\">0x36</span>, <span class=\"number\">0x32</span>, <span class=\"number\">0xe6</span>, <span class=\"number\">0x62</span>, <span class=\"number\">0x71</span>, <span class=\"number\">0x49</span>, <span class=\"number\">0x2c</span>, <span class=\"number\">0x49</span>,</div><div class=\"line\">\t<span class=\"number\">0x14</span>, <span class=\"number\">0xd2</span>, <span class=\"number\">0xe6</span>, <span class=\"number\">0x62</span>, <span class=\"number\">0x77</span>, <span class=\"number\">0x4f</span>, <span class=\"number\">0x2d</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x29</span>, <span class=\"number\">0x14</span>, <span class=\"number\">0xe2</span>, <span class=\"number\">0xd7</span>, <span class=\"number\">0x83</span>, <span class=\"number\">0xd9</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x31</span>,</div><div class=\"line\">\t<span class=\"number\">0x51</span>, <span class=\"number\">0x0a</span>, <span class=\"number\">0x4d</span>, <span class=\"number\">0xa0</span>, <span class=\"number\">0x20</span>, <span class=\"number\">0x89</span>, <span class=\"number\">0x0d</span>, <span class=\"number\">0x6c</span>, <span class=\"number\">0xb9</span>, <span class=\"number\">0x31</span>, <span class=\"number\">0x20</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0xff</span>, <span class=\"number\">0xff</span>, <span class=\"number\">0xa6</span>,</div><div class=\"line\">\t<span class=\"number\">0x63</span>, <span class=\"number\">0xe9</span>, <span class=\"number\">0x2f</span>, <span class=\"number\">0x8d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"4-服务端svr-go\"><a href=\"#4-服务端svr-go\" class=\"headerlink\" title=\"4. 服务端svr.go\"></a>4. 服务端svr.go</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">// created by moguang(moxiaomomo@gmail.com)</div><div class=\"line\">// created at 2016-01-10</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;account&quot;</div><div class=\"line\">\t&quot;golang.org/x/net/context&quot;</div><div class=\"line\">\t&quot;google.golang.org/grpc&quot;</div><div class=\"line\">\t&quot;log&quot;</div><div class=\"line\">\t&quot;net&quot;</div><div class=\"line\">\t&quot;strconv&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">type Data struct&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">func main() &#123;</div><div class=\"line\">\thost := &quot;127.0.0.1:8080&quot;</div><div class=\"line\">\t//listen on port</div><div class=\"line\">\tlis, err := net.Listen(&quot;tcp&quot;, host)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tlog.Fatalf(&quot;Failed to listen: %v&quot;, err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\ts := grpc.NewServer()</div><div class=\"line\">\taccount.RegisterDataServer(s, &amp;Data&#123;&#125;)</div><div class=\"line\">\t// accept message</div><div class=\"line\">\tlog.Printf(&quot;Begin to serve on %v&quot;, host)</div><div class=\"line\">\ts.Serve(lis)</div><div class=\"line\">\tlog.Println(&quot;Server is shutdown.&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 给Data类型定义方法</div><div class=\"line\">func (t *Data) GetUser(ctx context.Context, request *account.UserRq) (response *account.UserRp, err error) &#123;</div><div class=\"line\">\tlog.Printf(&quot;To get user, request.Id: %v&quot;, request.Id)</div><div class=\"line\">\tresponse = &amp;account.UserRp&#123;</div><div class=\"line\">\t\tName: strconv.Itoa(int(request.Id)) + &quot;_test&quot;,</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn response, err</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"5-客户端cli-go\"><a href=\"#5-客户端cli-go\" class=\"headerlink\" title=\"5. 客户端cli.go\"></a>5. 客户端cli.go</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// created by moguang(moxiaomomo@gmail.com)</span></div><div class=\"line\"><span class=\"comment\">// created at 2016-01-10</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"account\"</span></div><div class=\"line\">\t<span class=\"string\">\"golang.org/x/net/context\"</span></div><div class=\"line\">\t<span class=\"string\">\"google.golang.org/grpc\"</span></div><div class=\"line\">\t<span class=\"string\">\"log\"</span></div><div class=\"line\">\t<span class=\"string\">\"math/rand\"</span></div><div class=\"line\">\t<span class=\"string\">\"strconv\"</span></div><div class=\"line\">\t<span class=\"string\">\"strings\"</span></div><div class=\"line\">\t<span class=\"string\">\"sync\"</span></div><div class=\"line\">\t<span class=\"string\">\"time\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">\twg sync.WaitGroup</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> (</div><div class=\"line\">\tserver      = <span class=\"string\">\"127.0.0.1\"</span></div><div class=\"line\">\tport        = <span class=\"string\">\"8080\"</span></div><div class=\"line\">\tparallel    = <span class=\"number\">10</span> <span class=\"comment\">//连接并行数</span></div><div class=\"line\">\ttimes       = <span class=\"number\">10</span> <span class=\"comment\">//每连接请求次数</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tbeginTime := time.Now()</div><div class=\"line\">\t<span class=\"comment\">//结合WaitGroup, 实现并行请求</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">int</span>(parallel); i++ &#123;</div><div class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</div><div class=\"line\">\t\t<span class=\"keyword\">go</span> execRPC(&amp;wg)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\twg.Wait()</div><div class=\"line\"></div><div class=\"line\">\tendTime := time.Now()</div><div class=\"line\">\tlog.Printf(<span class=\"string\">\"Exec time secs: %.2f \"</span>, endTime.Sub(beginTime).Seconds())</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">execRPC</span><span class=\"params\">(wg *sync.WaitGroup)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> wg.Done()</div><div class=\"line\">\t<span class=\"comment\">// 建立连接</span></div><div class=\"line\">\thost := server + <span class=\"string\">\":\"</span> + port</div><div class=\"line\">\tconn, err := grpc.Dial(host, grpc.WithInsecure())</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"Dial Err: %v\"</span>, err)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</div><div class=\"line\"></div><div class=\"line\">\tclient := account.NewDataClient(conn)</div><div class=\"line\">\t<span class=\"comment\">// 连续发起多次请求</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">int</span>(times); i++ &#123;</div><div class=\"line\">\t\tgetUser(client)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getUser</span><span class=\"params\">(client account.DataClient)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> request account.UserRq</div><div class=\"line\">\tr := rand.Intn(parallel)</div><div class=\"line\">\trequest.Id = <span class=\"keyword\">int32</span>(r)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 调用远程方法</span></div><div class=\"line\">\tresponse, _ := client.GetUser(context.Background(), &amp;request)</div><div class=\"line\">\t<span class=\"comment\">// 判断返回结果</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> id, _ := strconv.Atoi(strings.Split(response.Name, <span class=\"string\">\":\"</span>)[<span class=\"number\">0</span>]); id != r &#123;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"Response error %#v\"</span>, response)</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"Response ok %#v\"</span>, response)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"[golang]goroutine学习小结","date":"2016-03-03T01:34:55.000Z","_content":"\n关于gorountine的特性, 我还是借鉴以下这篇文章来学习和总结一下, 至于一些用法在下一节channel再进行小结。\n\n源地址:\n[goroutine背后的系统知识](http://www.infoq.com/cn/articles/knowledge-behind-goroutine \"goroutine\")\n\n节选(goroutine的特性):\n\n>1.Go语言通过goroutine提供了目前为止所有(我所了解的)语言里对于并发编程的最清晰最直接的支持，Go语言的文档里对其特性也描述的非常全面甚至超过了，在这里，基于我们上面的系统知识介绍，列举一下goroutine的特性，算是小结：\n<!--more-->\n\n>2.goroutine是Go语言运行库的功能，不是操作系统提供的功能，goroutine不是用线程实现的。具体可参见Go语言源码里的pkg/runtime/proc.c\n\n>3.goroutine就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个goroutine，但它们并不是被操作系统所调度执行\n\n>4.除了被系统调用阻塞的线程外，Go运行库最多会启动$GOMAXPROCS个线程来运行goroutine\n\n>5.goroutine是协作式调度的，如果goroutine会执行很长时间，而且不是通过等待读取或写入channel的数据来同步的话，就需要主动调用Gosched()来让出CPU\n\n>6.和所有其他并发框架里的协程一样，goroutine里所谓“无锁”的优点只在单线程下有效，如果$GOMAXPROCS > 1并且协程间需要通信，Go运行库会负责加锁保护数据，这也是为什么sieve.go这样的例子在多CPU多线程时反而更慢的原因\n\n>7.Web等服务端程序要处理的请求从本质上来讲是并行处理的问题，每个请求基本独立，互不依赖，几乎没有数据交互，这不是一个并发编程的模型，而并发编程框架只是解决了其语义表述的复杂性，并不是从根本上提高处理的效率，也许是并发连接和并发编程的英文都是concurrent吧，很容易产生“并发编程框架和coroutine可以高效处理大量并发连接”的误解。\n\n>8.Go语言运行库封装了异步IO，所以可以写出貌似并发数很多的服务端，可即使我们通过调整$GOMAXPROCS来充分利用多核CPU并行处理，其效率也不如我们利用IO事件驱动设计的、按照事务类型划分好合适比例的线程池。在响应时间上，协作式调度是硬伤。\n\n>9.goroutine最大的价值是其实现了并发协程和实际并行执行的线程的映射以及动态扩展，随着其运行库的不断发展和完善，其性能一定会越来越好，尤其是在CPU核数越来越多的未来，终有一天我们会为了代码的简洁和可维护性而放弃那一点点性能的差别。\n","source":"_posts/golang/golang_goroutine.md","raw":"---\ntitle: '[golang]goroutine学习小结'\ndate: 2016-03-03 09:34:55\ntags: golang\n---\n\n关于gorountine的特性, 我还是借鉴以下这篇文章来学习和总结一下, 至于一些用法在下一节channel再进行小结。\n\n源地址:\n[goroutine背后的系统知识](http://www.infoq.com/cn/articles/knowledge-behind-goroutine \"goroutine\")\n\n节选(goroutine的特性):\n\n>1.Go语言通过goroutine提供了目前为止所有(我所了解的)语言里对于并发编程的最清晰最直接的支持，Go语言的文档里对其特性也描述的非常全面甚至超过了，在这里，基于我们上面的系统知识介绍，列举一下goroutine的特性，算是小结：\n<!--more-->\n\n>2.goroutine是Go语言运行库的功能，不是操作系统提供的功能，goroutine不是用线程实现的。具体可参见Go语言源码里的pkg/runtime/proc.c\n\n>3.goroutine就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个goroutine，但它们并不是被操作系统所调度执行\n\n>4.除了被系统调用阻塞的线程外，Go运行库最多会启动$GOMAXPROCS个线程来运行goroutine\n\n>5.goroutine是协作式调度的，如果goroutine会执行很长时间，而且不是通过等待读取或写入channel的数据来同步的话，就需要主动调用Gosched()来让出CPU\n\n>6.和所有其他并发框架里的协程一样，goroutine里所谓“无锁”的优点只在单线程下有效，如果$GOMAXPROCS > 1并且协程间需要通信，Go运行库会负责加锁保护数据，这也是为什么sieve.go这样的例子在多CPU多线程时反而更慢的原因\n\n>7.Web等服务端程序要处理的请求从本质上来讲是并行处理的问题，每个请求基本独立，互不依赖，几乎没有数据交互，这不是一个并发编程的模型，而并发编程框架只是解决了其语义表述的复杂性，并不是从根本上提高处理的效率，也许是并发连接和并发编程的英文都是concurrent吧，很容易产生“并发编程框架和coroutine可以高效处理大量并发连接”的误解。\n\n>8.Go语言运行库封装了异步IO，所以可以写出貌似并发数很多的服务端，可即使我们通过调整$GOMAXPROCS来充分利用多核CPU并行处理，其效率也不如我们利用IO事件驱动设计的、按照事务类型划分好合适比例的线程池。在响应时间上，协作式调度是硬伤。\n\n>9.goroutine最大的价值是其实现了并发协程和实际并行执行的线程的映射以及动态扩展，随着其运行库的不断发展和完善，其性能一定会越来越好，尤其是在CPU核数越来越多的未来，终有一天我们会为了代码的简洁和可维护性而放弃那一点点性能的差别。\n","slug":"golang/golang_goroutine","published":1,"updated":"2017-08-07T05:47:10.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dyb003l4j4dvyn1eyq6","content":"<p>关于gorountine的特性, 我还是借鉴以下这篇文章来学习和总结一下, 至于一些用法在下一节channel再进行小结。</p>\n<p>源地址:<br><a href=\"http://www.infoq.com/cn/articles/knowledge-behind-goroutine\" title=\"goroutine\" target=\"_blank\" rel=\"external\">goroutine背后的系统知识</a></p>\n<p>节选(goroutine的特性):</p>\n<blockquote>\n<p>1.Go语言通过goroutine提供了目前为止所有(我所了解的)语言里对于并发编程的最清晰最直接的支持，Go语言的文档里对其特性也描述的非常全面甚至超过了，在这里，基于我们上面的系统知识介绍，列举一下goroutine的特性，算是小结：<br><a id=\"more\"></a></p>\n<p>2.goroutine是Go语言运行库的功能，不是操作系统提供的功能，goroutine不是用线程实现的。具体可参见Go语言源码里的pkg/runtime/proc.c</p>\n<p>3.goroutine就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个goroutine，但它们并不是被操作系统所调度执行</p>\n<p>4.除了被系统调用阻塞的线程外，Go运行库最多会启动$GOMAXPROCS个线程来运行goroutine</p>\n<p>5.goroutine是协作式调度的，如果goroutine会执行很长时间，而且不是通过等待读取或写入channel的数据来同步的话，就需要主动调用Gosched()来让出CPU</p>\n<p>6.和所有其他并发框架里的协程一样，goroutine里所谓“无锁”的优点只在单线程下有效，如果$GOMAXPROCS &gt; 1并且协程间需要通信，Go运行库会负责加锁保护数据，这也是为什么sieve.go这样的例子在多CPU多线程时反而更慢的原因</p>\n<p>7.Web等服务端程序要处理的请求从本质上来讲是并行处理的问题，每个请求基本独立，互不依赖，几乎没有数据交互，这不是一个并发编程的模型，而并发编程框架只是解决了其语义表述的复杂性，并不是从根本上提高处理的效率，也许是并发连接和并发编程的英文都是concurrent吧，很容易产生“并发编程框架和coroutine可以高效处理大量并发连接”的误解。</p>\n<p>8.Go语言运行库封装了异步IO，所以可以写出貌似并发数很多的服务端，可即使我们通过调整$GOMAXPROCS来充分利用多核CPU并行处理，其效率也不如我们利用IO事件驱动设计的、按照事务类型划分好合适比例的线程池。在响应时间上，协作式调度是硬伤。</p>\n<p>9.goroutine最大的价值是其实现了并发协程和实际并行执行的线程的映射以及动态扩展，随着其运行库的不断发展和完善，其性能一定会越来越好，尤其是在CPU核数越来越多的未来，终有一天我们会为了代码的简洁和可维护性而放弃那一点点性能的差别。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>关于gorountine的特性, 我还是借鉴以下这篇文章来学习和总结一下, 至于一些用法在下一节channel再进行小结。</p>\n<p>源地址:<br><a href=\"http://www.infoq.com/cn/articles/knowledge-behind-goroutine\" title=\"goroutine\" target=\"_blank\" rel=\"external\">goroutine背后的系统知识</a></p>\n<p>节选(goroutine的特性):</p>\n<blockquote>\n<p>1.Go语言通过goroutine提供了目前为止所有(我所了解的)语言里对于并发编程的最清晰最直接的支持，Go语言的文档里对其特性也描述的非常全面甚至超过了，在这里，基于我们上面的系统知识介绍，列举一下goroutine的特性，算是小结：<br>","more":"</p>\n<p>2.goroutine是Go语言运行库的功能，不是操作系统提供的功能，goroutine不是用线程实现的。具体可参见Go语言源码里的pkg/runtime/proc.c</p>\n<p>3.goroutine就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个goroutine，但它们并不是被操作系统所调度执行</p>\n<p>4.除了被系统调用阻塞的线程外，Go运行库最多会启动$GOMAXPROCS个线程来运行goroutine</p>\n<p>5.goroutine是协作式调度的，如果goroutine会执行很长时间，而且不是通过等待读取或写入channel的数据来同步的话，就需要主动调用Gosched()来让出CPU</p>\n<p>6.和所有其他并发框架里的协程一样，goroutine里所谓“无锁”的优点只在单线程下有效，如果$GOMAXPROCS &gt; 1并且协程间需要通信，Go运行库会负责加锁保护数据，这也是为什么sieve.go这样的例子在多CPU多线程时反而更慢的原因</p>\n<p>7.Web等服务端程序要处理的请求从本质上来讲是并行处理的问题，每个请求基本独立，互不依赖，几乎没有数据交互，这不是一个并发编程的模型，而并发编程框架只是解决了其语义表述的复杂性，并不是从根本上提高处理的效率，也许是并发连接和并发编程的英文都是concurrent吧，很容易产生“并发编程框架和coroutine可以高效处理大量并发连接”的误解。</p>\n<p>8.Go语言运行库封装了异步IO，所以可以写出貌似并发数很多的服务端，可即使我们通过调整$GOMAXPROCS来充分利用多核CPU并行处理，其效率也不如我们利用IO事件驱动设计的、按照事务类型划分好合适比例的线程池。在响应时间上，协作式调度是硬伤。</p>\n<p>9.goroutine最大的价值是其实现了并发协程和实际并行执行的线程的映射以及动态扩展，随着其运行库的不断发展和完善，其性能一定会越来越好，尤其是在CPU核数越来越多的未来，终有一天我们会为了代码的简洁和可维护性而放弃那一点点性能的差别。</p>\n</blockquote>"},{"title":"[golang]interface","date":"2016-01-02T07:22:43.000Z","_content":"\n\n第一次接触golang, 应该是2013那年在某沙龙听许大神在介绍golang特性。<br>\n那时候据说interface可以说是golang中最具特色、设计精妙的特性之一。<br>\n现在计划写个demo， 重新学习一下interface的设计模式。\n\n### 什么是interface\n- 在golang中, interface简单可认为是一组函数的组合, 通过interface可以定义对象的一组行为。\n- interface定义了一组方法, 如果某个对象实现了某个interface的所有方法， 则我们可以认为这个对象实现了这个接口。\n- 由此可见, 不像C++、java， golang实现接口并不需要显式的implements。。。\n\n<!--more-->\n\n### interface的一些基础特性\n- interface类型不包含任何的成员变量, 只有方法;\n- interface类型进行类型转换时, 默认返回的是对象拷贝; 如果需要修改源对象, 需使用指针;\n- interface类型可以嵌套, 但不支持两个对象互相嵌套.\n\n\n### 接口的定义与实现\n一个例子\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype Human interface {\n    GetName() string\n    GetAge() int\n    GetGender() string\n}\n\n// 定义struct Employee\ntype Employee struct {\n    name   string\n    age    int\n    salary int\n    gender string\n}\n\n// 定义struct Employee 的方法\nfunc (self *Employee) GetName() string {\n    return self.name\n}\n\nfunc (self *Employee) GetAge() int {\n    return self.age\n}\n\nfunc (self *Employee) GetGender() string{\n    return self.gender\n}\n\nfunc (self *Employee) GetSalary() int {\n    return self.salary\n}\n\n// 参数为Human类型\nfunc printName(p Human) {\n    name := p.GetName()\n    fmt.Printf(\"name:%v\\n\", name)\n}\n\nfunc main() {\n    varEmployee := Employee{\n        name:   \"xiaomo\",\n        age:    30,\n        salary: 10000000,\n        gender: \"Male\",\n    }\n    // 访问GetSalary方法\n    s := varEmployee.GetSalary()\n    fmt.Printf(\"salary:%v\\n\", s)\n\n    // 子集转为超集类型Human, 作为参数传入函数中\n    var p Human = &varEmployee\n    printName(p)\n}\n```\n演示效果:\n```bash\nroot@XIAOMO:~/gopro# go build interface.go\nroot@XIAOMO:~/gopro# ./interface\nsalary:10000000\nname:xiaomo\n```\n上例中, 定义了接口Human, 内部有三个方法: GetName(), GetAge(), GetGender(); <br>\n结构Employee除了实现这三个方法外, 还实现了GetSalary()方法。 因此, 对象Employee实现Human接口。\n\nEmployee可以转换为Human类型, 作为形参传入printName()函数; 实现了多态调用。\n\n### 接口的嵌套\n一个接口可以嵌套另一个接口，根据上面的代码再修改一下， 修改部分如下:\n```golang\n// 嵌套接口Human, 那么User除了有PrintInfo()外， 也拥有了Human的所有方法\ntype User interface {\n    Human\n    PrintInfo()\n}\n\n// 实现PrintInfo()方法\nfunc (self * Employee) PrintInfo() {\n    fmt.Printf(\"name:%v age:%v salary:%v gender:%v\\n\",\n        self.name, self.age, self.salary, self.gender)\n}\n\nfunc main() {\n    varEmployee := Employee{\n        name:   \"xiaomo\",\n        age:    50,\n        salary: 100000000,\n        gender: \"Male\",\n    }\n    // 访问GetSalary方法\n    s := varEmployee.GetSalary()\n    fmt.Printf(\"salary:%v\\n\", s)\n\n    // 子集转为超集类型Human, 作为参数传入函数中\n    var p Human = &varEmployee\n    printName(p)\n\n    // Employee转换为User类型\n    var u User = &varEmployee\n    // 这时可以调用User的GetName()方法\n    fmt.Printf(\"user_name:%v\\n\", u.GetName())\n    // 调用User的PrintInfo()方法\n    u.PrintInfo()\n}\n```\n### 空接口(Any类型)\ngolang中所有对象都满足空接口interface{}, 因此interface{}可以指向任何类型的对象。\n\n```golang\nvar i1 interface{} = 100      // 将int类型赋值给interface{}\nvar i2 interface{} = \"ok\"     // 将string类型赋值给interface{}\nvar i3 interface{} = &i2      // 将*interface{}类型赋值给interface{}\nvar i4 interface{} = struct{ X int }{1}   // 将struct类型赋值给interface{}\nvar i5 interface{} = &struct{ X int }{1}  // 将*struct类型赋值给interfae{}\n```\n当一个方法需要接受任意类型的对象时, 我们将其参数声明为interface{}空类型。如fmt库中的各种print方法就使用了这种方式:\n```golang\nfunc Printf(fmt string, args ...interface{})\nfunc Println(args ...interface{})\n```\n\n### 总结\ngolang的接口和其他语言的接口区别还是比较大, 显得别具一格。\n其他大部分语言的接口是侵入式的， 需要显式的implement；而golang是非侵入式的, 实现某个接口并不需要从该接口继承，而只需要实现该接口的所有方法。\n","source":"_posts/golang/golang_interface.md","raw":"---\ntitle: '[golang]interface'\ndate: 2016-01-02 15:22:43\ntags: golang\n---\n\n\n第一次接触golang, 应该是2013那年在某沙龙听许大神在介绍golang特性。<br>\n那时候据说interface可以说是golang中最具特色、设计精妙的特性之一。<br>\n现在计划写个demo， 重新学习一下interface的设计模式。\n\n### 什么是interface\n- 在golang中, interface简单可认为是一组函数的组合, 通过interface可以定义对象的一组行为。\n- interface定义了一组方法, 如果某个对象实现了某个interface的所有方法， 则我们可以认为这个对象实现了这个接口。\n- 由此可见, 不像C++、java， golang实现接口并不需要显式的implements。。。\n\n<!--more-->\n\n### interface的一些基础特性\n- interface类型不包含任何的成员变量, 只有方法;\n- interface类型进行类型转换时, 默认返回的是对象拷贝; 如果需要修改源对象, 需使用指针;\n- interface类型可以嵌套, 但不支持两个对象互相嵌套.\n\n\n### 接口的定义与实现\n一个例子\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype Human interface {\n    GetName() string\n    GetAge() int\n    GetGender() string\n}\n\n// 定义struct Employee\ntype Employee struct {\n    name   string\n    age    int\n    salary int\n    gender string\n}\n\n// 定义struct Employee 的方法\nfunc (self *Employee) GetName() string {\n    return self.name\n}\n\nfunc (self *Employee) GetAge() int {\n    return self.age\n}\n\nfunc (self *Employee) GetGender() string{\n    return self.gender\n}\n\nfunc (self *Employee) GetSalary() int {\n    return self.salary\n}\n\n// 参数为Human类型\nfunc printName(p Human) {\n    name := p.GetName()\n    fmt.Printf(\"name:%v\\n\", name)\n}\n\nfunc main() {\n    varEmployee := Employee{\n        name:   \"xiaomo\",\n        age:    30,\n        salary: 10000000,\n        gender: \"Male\",\n    }\n    // 访问GetSalary方法\n    s := varEmployee.GetSalary()\n    fmt.Printf(\"salary:%v\\n\", s)\n\n    // 子集转为超集类型Human, 作为参数传入函数中\n    var p Human = &varEmployee\n    printName(p)\n}\n```\n演示效果:\n```bash\nroot@XIAOMO:~/gopro# go build interface.go\nroot@XIAOMO:~/gopro# ./interface\nsalary:10000000\nname:xiaomo\n```\n上例中, 定义了接口Human, 内部有三个方法: GetName(), GetAge(), GetGender(); <br>\n结构Employee除了实现这三个方法外, 还实现了GetSalary()方法。 因此, 对象Employee实现Human接口。\n\nEmployee可以转换为Human类型, 作为形参传入printName()函数; 实现了多态调用。\n\n### 接口的嵌套\n一个接口可以嵌套另一个接口，根据上面的代码再修改一下， 修改部分如下:\n```golang\n// 嵌套接口Human, 那么User除了有PrintInfo()外， 也拥有了Human的所有方法\ntype User interface {\n    Human\n    PrintInfo()\n}\n\n// 实现PrintInfo()方法\nfunc (self * Employee) PrintInfo() {\n    fmt.Printf(\"name:%v age:%v salary:%v gender:%v\\n\",\n        self.name, self.age, self.salary, self.gender)\n}\n\nfunc main() {\n    varEmployee := Employee{\n        name:   \"xiaomo\",\n        age:    50,\n        salary: 100000000,\n        gender: \"Male\",\n    }\n    // 访问GetSalary方法\n    s := varEmployee.GetSalary()\n    fmt.Printf(\"salary:%v\\n\", s)\n\n    // 子集转为超集类型Human, 作为参数传入函数中\n    var p Human = &varEmployee\n    printName(p)\n\n    // Employee转换为User类型\n    var u User = &varEmployee\n    // 这时可以调用User的GetName()方法\n    fmt.Printf(\"user_name:%v\\n\", u.GetName())\n    // 调用User的PrintInfo()方法\n    u.PrintInfo()\n}\n```\n### 空接口(Any类型)\ngolang中所有对象都满足空接口interface{}, 因此interface{}可以指向任何类型的对象。\n\n```golang\nvar i1 interface{} = 100      // 将int类型赋值给interface{}\nvar i2 interface{} = \"ok\"     // 将string类型赋值给interface{}\nvar i3 interface{} = &i2      // 将*interface{}类型赋值给interface{}\nvar i4 interface{} = struct{ X int }{1}   // 将struct类型赋值给interface{}\nvar i5 interface{} = &struct{ X int }{1}  // 将*struct类型赋值给interfae{}\n```\n当一个方法需要接受任意类型的对象时, 我们将其参数声明为interface{}空类型。如fmt库中的各种print方法就使用了这种方式:\n```golang\nfunc Printf(fmt string, args ...interface{})\nfunc Println(args ...interface{})\n```\n\n### 总结\ngolang的接口和其他语言的接口区别还是比较大, 显得别具一格。\n其他大部分语言的接口是侵入式的， 需要显式的implement；而golang是非侵入式的, 实现某个接口并不需要从该接口继承，而只需要实现该接口的所有方法。\n","slug":"golang/golang_interface","published":1,"updated":"2017-08-07T05:47:10.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dyc003n4j4d2tjut2rx","content":"<p>第一次接触golang, 应该是2013那年在某沙龙听许大神在介绍golang特性。<br><br>那时候据说interface可以说是golang中最具特色、设计精妙的特性之一。<br><br>现在计划写个demo， 重新学习一下interface的设计模式。</p>\n<h3 id=\"什么是interface\"><a href=\"#什么是interface\" class=\"headerlink\" title=\"什么是interface\"></a>什么是interface</h3><ul>\n<li>在golang中, interface简单可认为是一组函数的组合, 通过interface可以定义对象的一组行为。</li>\n<li>interface定义了一组方法, 如果某个对象实现了某个interface的所有方法， 则我们可以认为这个对象实现了这个接口。</li>\n<li>由此可见, 不像C++、java， golang实现接口并不需要显式的implements。。。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"interface的一些基础特性\"><a href=\"#interface的一些基础特性\" class=\"headerlink\" title=\"interface的一些基础特性\"></a>interface的一些基础特性</h3><ul>\n<li>interface类型不包含任何的成员变量, 只有方法;</li>\n<li>interface类型进行类型转换时, 默认返回的是对象拷贝; 如果需要修改源对象, 需使用指针;</li>\n<li>interface类型可以嵌套, 但不支持两个对象互相嵌套.</li>\n</ul>\n<h3 id=\"接口的定义与实现\"><a href=\"#接口的定义与实现\" class=\"headerlink\" title=\"接口的定义与实现\"></a>接口的定义与实现</h3><p>一个例子<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> Human <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">    GetName() <span class=\"keyword\">string</span></div><div class=\"line\">    GetAge() <span class=\"keyword\">int</span></div><div class=\"line\">    GetGender() <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义struct Employee</span></div><div class=\"line\"><span class=\"keyword\">type</span> Employee <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    name   <span class=\"keyword\">string</span></div><div class=\"line\">    age    <span class=\"keyword\">int</span></div><div class=\"line\">    salary <span class=\"keyword\">int</span></div><div class=\"line\">    gender <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义struct Employee 的方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Employee)</span> <span class=\"title\">GetName</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> self.name</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Employee)</span> <span class=\"title\">GetAge</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> self.age</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Employee)</span> <span class=\"title\">GetGender</span><span class=\"params\">()</span> <span class=\"title\">string</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> self.gender</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Employee)</span> <span class=\"title\">GetSalary</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> self.salary</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 参数为Human类型</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printName</span><span class=\"params\">(p Human)</span></span> &#123;</div><div class=\"line\">    name := p.GetName()</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"name:%v\\n\"</span>, name)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    varEmployee := Employee&#123;</div><div class=\"line\">        name:   <span class=\"string\">\"xiaomo\"</span>,</div><div class=\"line\">        age:    <span class=\"number\">30</span>,</div><div class=\"line\">        salary: <span class=\"number\">10000000</span>,</div><div class=\"line\">        gender: <span class=\"string\">\"Male\"</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 访问GetSalary方法</span></div><div class=\"line\">    s := varEmployee.GetSalary()</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"salary:%v\\n\"</span>, s)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 子集转为超集类型Human, 作为参数传入函数中</span></div><div class=\"line\">    <span class=\"keyword\">var</span> p Human = &amp;varEmployee</div><div class=\"line\">    printName(p)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>演示效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># go build interface.go</span></div><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># ./interface</span></div><div class=\"line\">salary:10000000</div><div class=\"line\">name:xiaomo</div></pre></td></tr></table></figure></p>\n<p>上例中, 定义了接口Human, 内部有三个方法: GetName(), GetAge(), GetGender(); <br><br>结构Employee除了实现这三个方法外, 还实现了GetSalary()方法。 因此, 对象Employee实现Human接口。</p>\n<p>Employee可以转换为Human类型, 作为形参传入printName()函数; 实现了多态调用。</p>\n<h3 id=\"接口的嵌套\"><a href=\"#接口的嵌套\" class=\"headerlink\" title=\"接口的嵌套\"></a>接口的嵌套</h3><p>一个接口可以嵌套另一个接口，根据上面的代码再修改一下， 修改部分如下:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 嵌套接口Human, 那么User除了有PrintInfo()外， 也拥有了Human的所有方法</span></div><div class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">    Human</div><div class=\"line\">    PrintInfo()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 实现PrintInfo()方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self * Employee)</span> <span class=\"title\">PrintInfo</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"name:%v age:%v salary:%v gender:%v\\n\"</span>,</div><div class=\"line\">        self.name, self.age, self.salary, self.gender)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    varEmployee := Employee&#123;</div><div class=\"line\">        name:   <span class=\"string\">\"xiaomo\"</span>,</div><div class=\"line\">        age:    <span class=\"number\">50</span>,</div><div class=\"line\">        salary: <span class=\"number\">100000000</span>,</div><div class=\"line\">        gender: <span class=\"string\">\"Male\"</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 访问GetSalary方法</span></div><div class=\"line\">    s := varEmployee.GetSalary()</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"salary:%v\\n\"</span>, s)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 子集转为超集类型Human, 作为参数传入函数中</span></div><div class=\"line\">    <span class=\"keyword\">var</span> p Human = &amp;varEmployee</div><div class=\"line\">    printName(p)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Employee转换为User类型</span></div><div class=\"line\">    <span class=\"keyword\">var</span> u User = &amp;varEmployee</div><div class=\"line\">    <span class=\"comment\">// 这时可以调用User的GetName()方法</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"user_name:%v\\n\"</span>, u.GetName())</div><div class=\"line\">    <span class=\"comment\">// 调用User的PrintInfo()方法</span></div><div class=\"line\">    u.PrintInfo()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"空接口-Any类型\"><a href=\"#空接口-Any类型\" class=\"headerlink\" title=\"空接口(Any类型)\"></a>空接口(Any类型)</h3><p>golang中所有对象都满足空接口interface{}, 因此interface{}可以指向任何类型的对象。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> i1 <span class=\"keyword\">interface</span>&#123;&#125; = <span class=\"number\">100</span>      <span class=\"comment\">// 将int类型赋值给interface&#123;&#125;</span></div><div class=\"line\"><span class=\"keyword\">var</span> i2 <span class=\"keyword\">interface</span>&#123;&#125; = <span class=\"string\">\"ok\"</span>     <span class=\"comment\">// 将string类型赋值给interface&#123;&#125;</span></div><div class=\"line\"><span class=\"keyword\">var</span> i3 <span class=\"keyword\">interface</span>&#123;&#125; = &amp;i2      <span class=\"comment\">// 将*interface&#123;&#125;类型赋值给interface&#123;&#125;</span></div><div class=\"line\"><span class=\"keyword\">var</span> i4 <span class=\"keyword\">interface</span>&#123;&#125; = <span class=\"keyword\">struct</span>&#123; X <span class=\"keyword\">int</span> &#125;&#123;<span class=\"number\">1</span>&#125;   <span class=\"comment\">// 将struct类型赋值给interface&#123;&#125;</span></div><div class=\"line\"><span class=\"keyword\">var</span> i5 <span class=\"keyword\">interface</span>&#123;&#125; = &amp;<span class=\"keyword\">struct</span>&#123; X <span class=\"keyword\">int</span> &#125;&#123;<span class=\"number\">1</span>&#125;  <span class=\"comment\">// 将*struct类型赋值给interfae&#123;&#125;</span></div></pre></td></tr></table></figure>\n<p>当一个方法需要接受任意类型的对象时, 我们将其参数声明为interface{}空类型。如fmt库中的各种print方法就使用了这种方式:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Printf</span><span class=\"params\">(fmt <span class=\"keyword\">string</span>, args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></div><div class=\"line\"><span class=\"title\">func</span> <span class=\"title\">Println</span><span class=\"params\">(args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>golang的接口和其他语言的接口区别还是比较大, 显得别具一格。<br>其他大部分语言的接口是侵入式的， 需要显式的implement；而golang是非侵入式的, 实现某个接口并不需要从该接口继承，而只需要实现该接口的所有方法。</p>\n","site":{"data":{}},"excerpt":"<p>第一次接触golang, 应该是2013那年在某沙龙听许大神在介绍golang特性。<br><br>那时候据说interface可以说是golang中最具特色、设计精妙的特性之一。<br><br>现在计划写个demo， 重新学习一下interface的设计模式。</p>\n<h3 id=\"什么是interface\"><a href=\"#什么是interface\" class=\"headerlink\" title=\"什么是interface\"></a>什么是interface</h3><ul>\n<li>在golang中, interface简单可认为是一组函数的组合, 通过interface可以定义对象的一组行为。</li>\n<li>interface定义了一组方法, 如果某个对象实现了某个interface的所有方法， 则我们可以认为这个对象实现了这个接口。</li>\n<li>由此可见, 不像C++、java， golang实现接口并不需要显式的implements。。。</li>\n</ul>","more":"<h3 id=\"interface的一些基础特性\"><a href=\"#interface的一些基础特性\" class=\"headerlink\" title=\"interface的一些基础特性\"></a>interface的一些基础特性</h3><ul>\n<li>interface类型不包含任何的成员变量, 只有方法;</li>\n<li>interface类型进行类型转换时, 默认返回的是对象拷贝; 如果需要修改源对象, 需使用指针;</li>\n<li>interface类型可以嵌套, 但不支持两个对象互相嵌套.</li>\n</ul>\n<h3 id=\"接口的定义与实现\"><a href=\"#接口的定义与实现\" class=\"headerlink\" title=\"接口的定义与实现\"></a>接口的定义与实现</h3><p>一个例子<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> Human <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">    GetName() <span class=\"keyword\">string</span></div><div class=\"line\">    GetAge() <span class=\"keyword\">int</span></div><div class=\"line\">    GetGender() <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义struct Employee</span></div><div class=\"line\"><span class=\"keyword\">type</span> Employee <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    name   <span class=\"keyword\">string</span></div><div class=\"line\">    age    <span class=\"keyword\">int</span></div><div class=\"line\">    salary <span class=\"keyword\">int</span></div><div class=\"line\">    gender <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义struct Employee 的方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Employee)</span> <span class=\"title\">GetName</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> self.name</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Employee)</span> <span class=\"title\">GetAge</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> self.age</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Employee)</span> <span class=\"title\">GetGender</span><span class=\"params\">()</span> <span class=\"title\">string</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> self.gender</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Employee)</span> <span class=\"title\">GetSalary</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> self.salary</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 参数为Human类型</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printName</span><span class=\"params\">(p Human)</span></span> &#123;</div><div class=\"line\">    name := p.GetName()</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"name:%v\\n\"</span>, name)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    varEmployee := Employee&#123;</div><div class=\"line\">        name:   <span class=\"string\">\"xiaomo\"</span>,</div><div class=\"line\">        age:    <span class=\"number\">30</span>,</div><div class=\"line\">        salary: <span class=\"number\">10000000</span>,</div><div class=\"line\">        gender: <span class=\"string\">\"Male\"</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 访问GetSalary方法</span></div><div class=\"line\">    s := varEmployee.GetSalary()</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"salary:%v\\n\"</span>, s)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 子集转为超集类型Human, 作为参数传入函数中</span></div><div class=\"line\">    <span class=\"keyword\">var</span> p Human = &amp;varEmployee</div><div class=\"line\">    printName(p)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>演示效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># go build interface.go</span></div><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># ./interface</span></div><div class=\"line\">salary:10000000</div><div class=\"line\">name:xiaomo</div></pre></td></tr></table></figure></p>\n<p>上例中, 定义了接口Human, 内部有三个方法: GetName(), GetAge(), GetGender(); <br><br>结构Employee除了实现这三个方法外, 还实现了GetSalary()方法。 因此, 对象Employee实现Human接口。</p>\n<p>Employee可以转换为Human类型, 作为形参传入printName()函数; 实现了多态调用。</p>\n<h3 id=\"接口的嵌套\"><a href=\"#接口的嵌套\" class=\"headerlink\" title=\"接口的嵌套\"></a>接口的嵌套</h3><p>一个接口可以嵌套另一个接口，根据上面的代码再修改一下， 修改部分如下:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 嵌套接口Human, 那么User除了有PrintInfo()外， 也拥有了Human的所有方法</span></div><div class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">    Human</div><div class=\"line\">    PrintInfo()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 实现PrintInfo()方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self * Employee)</span> <span class=\"title\">PrintInfo</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"name:%v age:%v salary:%v gender:%v\\n\"</span>,</div><div class=\"line\">        self.name, self.age, self.salary, self.gender)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    varEmployee := Employee&#123;</div><div class=\"line\">        name:   <span class=\"string\">\"xiaomo\"</span>,</div><div class=\"line\">        age:    <span class=\"number\">50</span>,</div><div class=\"line\">        salary: <span class=\"number\">100000000</span>,</div><div class=\"line\">        gender: <span class=\"string\">\"Male\"</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 访问GetSalary方法</span></div><div class=\"line\">    s := varEmployee.GetSalary()</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"salary:%v\\n\"</span>, s)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 子集转为超集类型Human, 作为参数传入函数中</span></div><div class=\"line\">    <span class=\"keyword\">var</span> p Human = &amp;varEmployee</div><div class=\"line\">    printName(p)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Employee转换为User类型</span></div><div class=\"line\">    <span class=\"keyword\">var</span> u User = &amp;varEmployee</div><div class=\"line\">    <span class=\"comment\">// 这时可以调用User的GetName()方法</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"user_name:%v\\n\"</span>, u.GetName())</div><div class=\"line\">    <span class=\"comment\">// 调用User的PrintInfo()方法</span></div><div class=\"line\">    u.PrintInfo()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"空接口-Any类型\"><a href=\"#空接口-Any类型\" class=\"headerlink\" title=\"空接口(Any类型)\"></a>空接口(Any类型)</h3><p>golang中所有对象都满足空接口interface{}, 因此interface{}可以指向任何类型的对象。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> i1 <span class=\"keyword\">interface</span>&#123;&#125; = <span class=\"number\">100</span>      <span class=\"comment\">// 将int类型赋值给interface&#123;&#125;</span></div><div class=\"line\"><span class=\"keyword\">var</span> i2 <span class=\"keyword\">interface</span>&#123;&#125; = <span class=\"string\">\"ok\"</span>     <span class=\"comment\">// 将string类型赋值给interface&#123;&#125;</span></div><div class=\"line\"><span class=\"keyword\">var</span> i3 <span class=\"keyword\">interface</span>&#123;&#125; = &amp;i2      <span class=\"comment\">// 将*interface&#123;&#125;类型赋值给interface&#123;&#125;</span></div><div class=\"line\"><span class=\"keyword\">var</span> i4 <span class=\"keyword\">interface</span>&#123;&#125; = <span class=\"keyword\">struct</span>&#123; X <span class=\"keyword\">int</span> &#125;&#123;<span class=\"number\">1</span>&#125;   <span class=\"comment\">// 将struct类型赋值给interface&#123;&#125;</span></div><div class=\"line\"><span class=\"keyword\">var</span> i5 <span class=\"keyword\">interface</span>&#123;&#125; = &amp;<span class=\"keyword\">struct</span>&#123; X <span class=\"keyword\">int</span> &#125;&#123;<span class=\"number\">1</span>&#125;  <span class=\"comment\">// 将*struct类型赋值给interfae&#123;&#125;</span></div></pre></td></tr></table></figure>\n<p>当一个方法需要接受任意类型的对象时, 我们将其参数声明为interface{}空类型。如fmt库中的各种print方法就使用了这种方式:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Printf</span><span class=\"params\">(fmt <span class=\"keyword\">string</span>, args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></div><div class=\"line\"><span class=\"title\">func</span> <span class=\"title\">Println</span><span class=\"params\">(args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>golang的接口和其他语言的接口区别还是比较大, 显得别具一格。<br>其他大部分语言的接口是侵入式的， 需要显式的implement；而golang是非侵入式的, 实现某个接口并不需要从该接口继承，而只需要实现该接口的所有方法。</p>"},{"title":"[golang]HTTP webserver","date":"2016-12-03T06:11:45.000Z","_content":"\n### 简单示例\ngolang对http网络模块有比较完备的标准库支持, 如下示例:\n\n<!--more-->\n\n```golang\npackage main\n\nimport (\n    \"io\"\n    \"net/http\"\n    \"log\"\n)\n\n\nfunc LogicServer(w http.ResponseWriter, req *http.Request) {\n    io.WriteString(w, \"I'm logic server.\")\n}\n\n\nfunc main() {\n    http.HandleFunc(\"/test\", LogicServer)\n    err := http.ListenAndServe(\":8888\", nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe Err:\", err)\n    }\n}\n```\n运行效果:\n```bash\nxiaomo@XIAOMO:~$ curl \"http://127.0.0.1:8888/test\"\nI'm logic server.xiaomo\n```\n\n### golang http包的执行流程\n参考:[Go如何使得Web工作](https://astaxie.gitbooks.io/build-web-application-with-golang/content/zh/03.3.html \"http\")\n![http包运行机制](/img/golang_http.png)\n\n### 结合goroutine处理并发\n在golang中, 为了实现高并发与高性能, 处理连接的读写事件使用了goroutine机制。因此, 对于每个请求都能保持独立性, 相互没有阻塞, 能高效响应网络请求事件。\n\n","source":"_posts/golang/golang_http-server.md","raw":"---\ntitle: '[golang]HTTP webserver'\ndate: 2016-12-03 14:11:45\ntags: golang\n---\n\n### 简单示例\ngolang对http网络模块有比较完备的标准库支持, 如下示例:\n\n<!--more-->\n\n```golang\npackage main\n\nimport (\n    \"io\"\n    \"net/http\"\n    \"log\"\n)\n\n\nfunc LogicServer(w http.ResponseWriter, req *http.Request) {\n    io.WriteString(w, \"I'm logic server.\")\n}\n\n\nfunc main() {\n    http.HandleFunc(\"/test\", LogicServer)\n    err := http.ListenAndServe(\":8888\", nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe Err:\", err)\n    }\n}\n```\n运行效果:\n```bash\nxiaomo@XIAOMO:~$ curl \"http://127.0.0.1:8888/test\"\nI'm logic server.xiaomo\n```\n\n### golang http包的执行流程\n参考:[Go如何使得Web工作](https://astaxie.gitbooks.io/build-web-application-with-golang/content/zh/03.3.html \"http\")\n![http包运行机制](/img/golang_http.png)\n\n### 结合goroutine处理并发\n在golang中, 为了实现高并发与高性能, 处理连接的读写事件使用了goroutine机制。因此, 对于每个请求都能保持独立性, 相互没有阻塞, 能高效响应网络请求事件。\n\n","slug":"golang/golang_http-server","published":1,"updated":"2017-08-07T05:47:10.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dyd003p4j4d3bx1issu","content":"<h3 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h3><p>golang对http网络模块有比较完备的标准库支持, 如下示例:</p>\n<a id=\"more\"></a>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"io\"</span></div><div class=\"line\">    <span class=\"string\">\"net/http\"</span></div><div class=\"line\">    <span class=\"string\">\"log\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LogicServer</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</div><div class=\"line\">    io.WriteString(w, <span class=\"string\">\"I'm logic server.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    http.HandleFunc(<span class=\"string\">\"/test\"</span>, LogicServer)</div><div class=\"line\">    err := http.ListenAndServe(<span class=\"string\">\":8888\"</span>, <span class=\"literal\">nil</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        log.Fatal(<span class=\"string\">\"ListenAndServe Err:\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaomo@XIAOMO:~$ curl <span class=\"string\">\"http://127.0.0.1:8888/test\"</span></div><div class=\"line\">I<span class=\"string\">'m logic server.xiaomo</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"golang-http包的执行流程\"><a href=\"#golang-http包的执行流程\" class=\"headerlink\" title=\"golang http包的执行流程\"></a>golang http包的执行流程</h3><p>参考:<a href=\"https://astaxie.gitbooks.io/build-web-application-with-golang/content/zh/03.3.html\" title=\"http\" target=\"_blank\" rel=\"external\">Go如何使得Web工作</a><br><img src=\"/img/golang_http.png\" alt=\"http包运行机制\"></p>\n<h3 id=\"结合goroutine处理并发\"><a href=\"#结合goroutine处理并发\" class=\"headerlink\" title=\"结合goroutine处理并发\"></a>结合goroutine处理并发</h3><p>在golang中, 为了实现高并发与高性能, 处理连接的读写事件使用了goroutine机制。因此, 对于每个请求都能保持独立性, 相互没有阻塞, 能高效响应网络请求事件。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h3><p>golang对http网络模块有比较完备的标准库支持, 如下示例:</p>","more":"<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"io\"</span></div><div class=\"line\">    <span class=\"string\">\"net/http\"</span></div><div class=\"line\">    <span class=\"string\">\"log\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LogicServer</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</div><div class=\"line\">    io.WriteString(w, <span class=\"string\">\"I'm logic server.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    http.HandleFunc(<span class=\"string\">\"/test\"</span>, LogicServer)</div><div class=\"line\">    err := http.ListenAndServe(<span class=\"string\">\":8888\"</span>, <span class=\"literal\">nil</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        log.Fatal(<span class=\"string\">\"ListenAndServe Err:\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行效果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaomo@XIAOMO:~$ curl <span class=\"string\">\"http://127.0.0.1:8888/test\"</span></div><div class=\"line\">I<span class=\"string\">'m logic server.xiaomo</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"golang-http包的执行流程\"><a href=\"#golang-http包的执行流程\" class=\"headerlink\" title=\"golang http包的执行流程\"></a>golang http包的执行流程</h3><p>参考:<a href=\"https://astaxie.gitbooks.io/build-web-application-with-golang/content/zh/03.3.html\" title=\"http\" target=\"_blank\" rel=\"external\">Go如何使得Web工作</a><br><img src=\"/img/golang_http.png\" alt=\"http包运行机制\"></p>\n<h3 id=\"结合goroutine处理并发\"><a href=\"#结合goroutine处理并发\" class=\"headerlink\" title=\"结合goroutine处理并发\"></a>结合goroutine处理并发</h3><p>在golang中, 为了实现高并发与高性能, 处理连接的读写事件使用了goroutine机制。因此, 对于每个请求都能保持独立性, 相互没有阻塞, 能高效响应网络请求事件。</p>"},{"title":"[golang]map/set类型","date":"2017-02-01T11:13:13.000Z","_content":"\n### map类型\n#### 1. 基础特性\n- map是一种无序的键值对的集合; 所以可以类似数组/slice一样进行迭代\n- map的值可以使内建类型, 也可以是struct类型\n- 内部使用hash表实现, map的hash表包含了一个collection of buckets（桶集合）\n\n<!--more-->\n\n#### 2. 声明与初始化\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// map[keyType]valueType\nfunc initMap() {\n    // 通过make方法创建\n    dict := make(map[string]int)\n    dict[\"age\"] = 18\n\n    // 直接创建\n    dict2 := map[string]string{\"name\":\"xiaoming\", \"phone\":\"135xxx\"}\n    dict2[\"addr\"] = \"Guangzhou\"\n\n    fmt.Printf(\"%v\\n\", dict2)\n}\n\n\nfunc main() {\n    initMap()\n}\n```\n\n#### 3. 元素访问\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype Student struct {\n    name string\n    grade int\n}\n\nfunc useMap() {\n    //使用前应该先初始化, 否则panic报错\n    // var map1 map[string]string\n    // map1[\"a\"] = \"b\" // will panic\n\n    map1 := make(map[string]Student)\n    map1[\"s1\"] = Student{name:\"xiaomo\", grade:1}\n    fmt.Printf(\"%v\\n\", map1)\n}\n\nfunc main() {\n    useMap()\n}\n\n```\n\n#### 4. 在函数中传递map\n\n在函数间传递map对象, 是传递引用而不是拷贝; 因此在函数中对map进行了修改, 引用到它的地方也会相应修改\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype Student struct {\n    name string\n    grade int\n}\n\nfunc useMap() {\n    map1 := make(map[string]Student)\n    map1[\"s1\"] = Student{name:\"xiaomo\", grade:1}\n    // 作为函数参数传递\n    printMap(map1)\n}\n\nfunc printMap(m map[string]Student) {\n    fmt.Printf(\"currentMap: %v\\n\", m)\n}\n\nfunc main() {\n    useMap()\n}\n\n```\n\n### Set类型\n\ngolang没有内置Set类型, 可以自定义实现。\n\n","source":"_posts/golang/golang_map-set.md","raw":"---\ntitle: '[golang]map/set类型'\ndate: 2017-02-01 19:13:13\ntags: golang\n---\n\n### map类型\n#### 1. 基础特性\n- map是一种无序的键值对的集合; 所以可以类似数组/slice一样进行迭代\n- map的值可以使内建类型, 也可以是struct类型\n- 内部使用hash表实现, map的hash表包含了一个collection of buckets（桶集合）\n\n<!--more-->\n\n#### 2. 声明与初始化\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// map[keyType]valueType\nfunc initMap() {\n    // 通过make方法创建\n    dict := make(map[string]int)\n    dict[\"age\"] = 18\n\n    // 直接创建\n    dict2 := map[string]string{\"name\":\"xiaoming\", \"phone\":\"135xxx\"}\n    dict2[\"addr\"] = \"Guangzhou\"\n\n    fmt.Printf(\"%v\\n\", dict2)\n}\n\n\nfunc main() {\n    initMap()\n}\n```\n\n#### 3. 元素访问\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype Student struct {\n    name string\n    grade int\n}\n\nfunc useMap() {\n    //使用前应该先初始化, 否则panic报错\n    // var map1 map[string]string\n    // map1[\"a\"] = \"b\" // will panic\n\n    map1 := make(map[string]Student)\n    map1[\"s1\"] = Student{name:\"xiaomo\", grade:1}\n    fmt.Printf(\"%v\\n\", map1)\n}\n\nfunc main() {\n    useMap()\n}\n\n```\n\n#### 4. 在函数中传递map\n\n在函数间传递map对象, 是传递引用而不是拷贝; 因此在函数中对map进行了修改, 引用到它的地方也会相应修改\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype Student struct {\n    name string\n    grade int\n}\n\nfunc useMap() {\n    map1 := make(map[string]Student)\n    map1[\"s1\"] = Student{name:\"xiaomo\", grade:1}\n    // 作为函数参数传递\n    printMap(map1)\n}\n\nfunc printMap(m map[string]Student) {\n    fmt.Printf(\"currentMap: %v\\n\", m)\n}\n\nfunc main() {\n    useMap()\n}\n\n```\n\n### Set类型\n\ngolang没有内置Set类型, 可以自定义实现。\n\n","slug":"golang/golang_map-set","published":1,"updated":"2017-08-07T05:47:10.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dye003r4j4d6amfvr3u","content":"<h3 id=\"map类型\"><a href=\"#map类型\" class=\"headerlink\" title=\"map类型\"></a>map类型</h3><h4 id=\"1-基础特性\"><a href=\"#1-基础特性\" class=\"headerlink\" title=\"1. 基础特性\"></a>1. 基础特性</h4><ul>\n<li>map是一种无序的键值对的集合; 所以可以类似数组/slice一样进行迭代</li>\n<li>map的值可以使内建类型, 也可以是struct类型</li>\n<li>内部使用hash表实现, map的hash表包含了一个collection of buckets（桶集合）</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"2-声明与初始化\"><a href=\"#2-声明与初始化\" class=\"headerlink\" title=\"2. 声明与初始化\"></a>2. 声明与初始化</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// map[keyType]valueType</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">initMap</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 通过make方法创建</span></div><div class=\"line\">    dict := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</div><div class=\"line\">    dict[<span class=\"string\">\"age\"</span>] = <span class=\"number\">18</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 直接创建</span></div><div class=\"line\">    dict2 := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"xiaoming\"</span>, <span class=\"string\">\"phone\"</span>:<span class=\"string\">\"135xxx\"</span>&#125;</div><div class=\"line\">    dict2[<span class=\"string\">\"addr\"</span>] = <span class=\"string\">\"Guangzhou\"</span></div><div class=\"line\"></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, dict2)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    initMap()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-元素访问\"><a href=\"#3-元素访问\" class=\"headerlink\" title=\"3. 元素访问\"></a>3. 元素访问</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> Student <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    name <span class=\"keyword\">string</span></div><div class=\"line\">    grade <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">useMap</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">//使用前应该先初始化, 否则panic报错</span></div><div class=\"line\">    <span class=\"comment\">// var map1 map[string]string</span></div><div class=\"line\">    <span class=\"comment\">// map1[\"a\"] = \"b\" // will panic</span></div><div class=\"line\"></div><div class=\"line\">    map1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Student)</div><div class=\"line\">    map1[<span class=\"string\">\"s1\"</span>] = Student&#123;name:<span class=\"string\">\"xiaomo\"</span>, grade:<span class=\"number\">1</span>&#125;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, map1)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    useMap()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"4-在函数中传递map\"><a href=\"#4-在函数中传递map\" class=\"headerlink\" title=\"4. 在函数中传递map\"></a>4. 在函数中传递map</h4><p>在函数间传递map对象, 是传递引用而不是拷贝; 因此在函数中对map进行了修改, 引用到它的地方也会相应修改<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> Student <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    name <span class=\"keyword\">string</span></div><div class=\"line\">    grade <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">useMap</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    map1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Student)</div><div class=\"line\">    map1[<span class=\"string\">\"s1\"</span>] = Student&#123;name:<span class=\"string\">\"xiaomo\"</span>, grade:<span class=\"number\">1</span>&#125;</div><div class=\"line\">    <span class=\"comment\">// 作为函数参数传递</span></div><div class=\"line\">    printMap(map1)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printMap</span><span class=\"params\">(m <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Student)</span></span> &#123;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"currentMap: %v\\n\"</span>, m)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    useMap()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Set类型\"><a href=\"#Set类型\" class=\"headerlink\" title=\"Set类型\"></a>Set类型</h3><p>golang没有内置Set类型, 可以自定义实现。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"map类型\"><a href=\"#map类型\" class=\"headerlink\" title=\"map类型\"></a>map类型</h3><h4 id=\"1-基础特性\"><a href=\"#1-基础特性\" class=\"headerlink\" title=\"1. 基础特性\"></a>1. 基础特性</h4><ul>\n<li>map是一种无序的键值对的集合; 所以可以类似数组/slice一样进行迭代</li>\n<li>map的值可以使内建类型, 也可以是struct类型</li>\n<li>内部使用hash表实现, map的hash表包含了一个collection of buckets（桶集合）</li>\n</ul>","more":"<h4 id=\"2-声明与初始化\"><a href=\"#2-声明与初始化\" class=\"headerlink\" title=\"2. 声明与初始化\"></a>2. 声明与初始化</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// map[keyType]valueType</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">initMap</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 通过make方法创建</span></div><div class=\"line\">    dict := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</div><div class=\"line\">    dict[<span class=\"string\">\"age\"</span>] = <span class=\"number\">18</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 直接创建</span></div><div class=\"line\">    dict2 := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"xiaoming\"</span>, <span class=\"string\">\"phone\"</span>:<span class=\"string\">\"135xxx\"</span>&#125;</div><div class=\"line\">    dict2[<span class=\"string\">\"addr\"</span>] = <span class=\"string\">\"Guangzhou\"</span></div><div class=\"line\"></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, dict2)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    initMap()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-元素访问\"><a href=\"#3-元素访问\" class=\"headerlink\" title=\"3. 元素访问\"></a>3. 元素访问</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> Student <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    name <span class=\"keyword\">string</span></div><div class=\"line\">    grade <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">useMap</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">//使用前应该先初始化, 否则panic报错</span></div><div class=\"line\">    <span class=\"comment\">// var map1 map[string]string</span></div><div class=\"line\">    <span class=\"comment\">// map1[\"a\"] = \"b\" // will panic</span></div><div class=\"line\"></div><div class=\"line\">    map1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Student)</div><div class=\"line\">    map1[<span class=\"string\">\"s1\"</span>] = Student&#123;name:<span class=\"string\">\"xiaomo\"</span>, grade:<span class=\"number\">1</span>&#125;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, map1)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    useMap()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"4-在函数中传递map\"><a href=\"#4-在函数中传递map\" class=\"headerlink\" title=\"4. 在函数中传递map\"></a>4. 在函数中传递map</h4><p>在函数间传递map对象, 是传递引用而不是拷贝; 因此在函数中对map进行了修改, 引用到它的地方也会相应修改<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> Student <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    name <span class=\"keyword\">string</span></div><div class=\"line\">    grade <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">useMap</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    map1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Student)</div><div class=\"line\">    map1[<span class=\"string\">\"s1\"</span>] = Student&#123;name:<span class=\"string\">\"xiaomo\"</span>, grade:<span class=\"number\">1</span>&#125;</div><div class=\"line\">    <span class=\"comment\">// 作为函数参数传递</span></div><div class=\"line\">    printMap(map1)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printMap</span><span class=\"params\">(m <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Student)</span></span> &#123;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"currentMap: %v\\n\"</span>, m)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    useMap()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Set类型\"><a href=\"#Set类型\" class=\"headerlink\" title=\"Set类型\"></a>Set类型</h3><p>golang没有内置Set类型, 可以自定义实现。</p>"},{"title":"[golang]工作池workerpool","date":"2016-03-15T10:19:32.000Z","_content":"\n在并发量比较高的场景中, 服务程序既要快速处理请求, 也要限制并行处理的gorontine量, 否则会造成系统资源的浪费或负载过高。\n\n创建一个goroutine工作池, 是一个比较合理的解决方案。\n\n### 示例1\n<!--more-->\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n)\n\nconst (\n\t// PoolSize defines the pool size\n\tPoolSize = 10\n)\n\n// Jobs jobs channel\nvar Jobs chan string = make(chan string, 30)\nvar Result chan string = make(chan string, 30)\n\n// Working do working\nfunc Working(workID int) {\n\tlog.Printf(\"Initiate worker %v...\", workID)\n\tfor j := range Jobs {\n\t\tlog.Printf(\"work id: %v, receive msg: %v\", workID, j)\n\t\tResult <- fmt.Sprintf(\"%v is done...\", j)\n\t\ttime.Sleep(time.Second * 1)\n\t}\n}\n\n// InitWorkerPool initialize worker pool\nfunc InitWorkerPool() {\n\tfor j := 0; j < PoolSize; j++ {\n\t\tgo Working(j)\n\t}\n}\n\nfunc main() {\n\tInitWorkerPool()\n\t// to generate jobs\n\ttime.Sleep(time.Second * 2)\n\tfor i := 0; i < 20; i++ {\n\t\tjob := fmt.Sprintf(\"JobID %v\", i)\n\t\tJobs <- job\n\t}\n\tclose(Jobs)\n\n\tfor i := 0; i < 20; i++ {\n\t\tlog.Printf(\"working result: %v\", <-Result)\n\t}\n}\n```\n运行结果:\n```bash\n2016/04/12 14:18:58 Initiate worker 0...\n2016/04/12 14:18:58 Initiate worker 1...\n2016/04/12 14:18:58 Initiate worker 2...\n2016/04/12 14:18:58 Initiate worker 3...\n2016/04/12 14:18:58 Initiate worker 4...\n2016/04/12 14:18:58 Initiate worker 5...\n2016/04/12 14:18:58 Initiate worker 6...\n2016/04/12 14:18:58 Initiate worker 7...\n2016/04/12 14:18:58 Initiate worker 8...\n2016/04/12 14:18:58 Initiate worker 9...\n2016/04/12 14:19:00 work id: 9, receive msg: JobID 0\n2016/04/12 14:19:00 work id: 0, receive msg: JobID 1\n2016/04/12 14:19:00 work id: 1, receive msg: JobID 2\n2016/04/12 14:19:00 work id: 2, receive msg: JobID 3\n2016/04/12 14:19:00 work id: 3, receive msg: JobID 4\n2016/04/12 14:19:00 work id: 4, receive msg: JobID 5\n2016/04/12 14:19:00 work id: 5, receive msg: JobID 6\n2016/04/12 14:19:00 work id: 6, receive msg: JobID 7\n2016/04/12 14:19:00 work id: 7, receive msg: JobID 8\n2016/04/12 14:19:00 work id: 8, receive msg: JobID 9\n2016/04/12 14:19:00 working result: JobID 0 is done...\n2016/04/12 14:19:00 working result: JobID 1 is done...\n2016/04/12 14:19:00 working result: JobID 2 is done...\n2016/04/12 14:19:00 working result: JobID 3 is done...\n2016/04/12 14:19:00 working result: JobID 4 is done...\n2016/04/12 14:19:00 working result: JobID 5 is done...\n2016/04/12 14:19:00 working result: JobID 6 is done...\n2016/04/12 14:19:00 working result: JobID 7 is done...\n2016/04/12 14:19:00 working result: JobID 8 is done...\n2016/04/12 14:19:00 working result: JobID 9 is done...\n2016/04/12 14:19:01 work id: 8, receive msg: JobID 10\n2016/04/12 14:19:01 work id: 9, receive msg: JobID 11\n2016/04/12 14:19:01 work id: 0, receive msg: JobID 12\n2016/04/12 14:19:01 work id: 1, receive msg: JobID 13\n2016/04/12 14:19:01 work id: 2, receive msg: JobID 14\n2016/04/12 14:19:01 work id: 3, receive msg: JobID 15\n2016/04/12 14:19:01 work id: 4, receive msg: JobID 16\n2016/04/12 14:19:01 work id: 5, receive msg: JobID 17\n2016/04/12 14:19:01 work id: 6, receive msg: JobID 18\n2016/04/12 14:19:01 work id: 7, receive msg: JobID 19\n2016/04/12 14:19:01 working result: JobID 10 is done...\n2016/04/12 14:19:01 working result: JobID 11 is done...\n2016/04/12 14:19:01 working result: JobID 12 is done...\n2016/04/12 14:19:01 working result: JobID 13 is done...\n2016/04/12 14:19:01 working result: JobID 14 is done...\n2016/04/12 14:19:01 working result: JobID 15 is done...\n2016/04/12 14:19:01 working result: JobID 16 is done...\n2016/04/12 14:19:01 working result: JobID 17 is done...\n2016/04/12 14:19:01 working result: JobID 18 is done...\n2016/04/12 14:19:01 working result: JobID 19 is done...\n```\n由上可以见, 程序中同时最多有10个工作任务在运行。\n\n### 示例2, 更规范的用法\n我们引入同步锁, 并把工作池定义成一个结构体WorkPool， 包含poolSize和tasks成员, 并实现WorkPool.Run方法:\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n\t\"time\"\n)\n\n// WorkPool worker pool definition\ntype WorkPool struct {\n\tpoolSize int\n\ttasks    chan string\n}\n\n// Run initialize worker pool, ready to run tasks\nfunc (wp *WorkPool) Run() {\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < wp.poolSize; i++ {\n\t\twg.Add(1)\n\t\ttaskID := i\n\t\tgo func() {\n\t\t\tlog.Printf(\"Initiate worker %v...\", taskID)\n\t\t\tfor j := range wp.tasks {\n\t\t\t\tlog.Printf(\"work id: %v, receive msg: %v\", taskID, j)\n\t\t\t\ttime.Sleep(time.Second * 1)\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n\tlog.Println(\"WorkPool is destroyed.\")\n}\n\nfunc main() {\n\ttasks := make(chan string, 20)\n\n\t// to generate jobs\n\tgo func() {\n\t\ttime.Sleep(time.Second * 2)\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tjob := fmt.Sprintf(\"jobID %v\", i)\n\t\t\ttasks <- job\n\t\t}\n\t\t// if not close tasks, will cause deadlock\n\t\tclose(tasks)\n\t}()\n\n\twp := WorkPool{\n\t\tpoolSize: 10,\n\t\ttasks:    tasks,\n\t}\n\twp.Run()\n}\n```\n运行结果:\n```bash\n2016/04/12 15:01:03 Initiate worker 9...\n2016/04/12 15:01:03 Initiate worker 0...\n2016/04/12 15:01:03 Initiate worker 1...\n2016/04/12 15:01:03 Initiate worker 2...\n2016/04/12 15:01:03 Initiate worker 3...\n2016/04/12 15:01:03 Initiate worker 4...\n2016/04/12 15:01:03 Initiate worker 5...\n2016/04/12 15:01:03 Initiate worker 6...\n2016/04/12 15:01:03 Initiate worker 7...\n2016/04/12 15:01:03 Initiate worker 8...\n2016/04/12 15:01:05 work id: 8, receive msg: jobID 0\n2016/04/12 15:01:05 work id: 9, receive msg: jobID 1\n2016/04/12 15:01:05 work id: 0, receive msg: jobID 2\n2016/04/12 15:01:05 work id: 1, receive msg: jobID 3\n2016/04/12 15:01:05 work id: 2, receive msg: jobID 4\n2016/04/12 15:01:05 work id: 3, receive msg: jobID 5\n2016/04/12 15:01:05 work id: 4, receive msg: jobID 6\n2016/04/12 15:01:05 work id: 5, receive msg: jobID 7\n2016/04/12 15:01:05 work id: 6, receive msg: jobID 8\n2016/04/12 15:01:05 work id: 7, receive msg: jobID 9\n2016/04/12 15:01:06 work id: 7, receive msg: jobID 10\n2016/04/12 15:01:06 work id: 8, receive msg: jobID 11\n2016/04/12 15:01:06 work id: 9, receive msg: jobID 12\n2016/04/12 15:01:06 work id: 0, receive msg: jobID 13\n2016/04/12 15:01:06 work id: 1, receive msg: jobID 14\n2016/04/12 15:01:06 work id: 2, receive msg: jobID 15\n2016/04/12 15:01:06 work id: 3, receive msg: jobID 16\n2016/04/12 15:01:06 work id: 4, receive msg: jobID 17\n2016/04/12 15:01:06 work id: 5, receive msg: jobID 18\n2016/04/12 15:01:06 work id: 6, receive msg: jobID 19\n2016/04/12 15:01:07 work id: 6, receive msg: jobID 20\n2016/04/12 15:01:07 work id: 7, receive msg: jobID 21\n2016/04/12 15:01:07 work id: 8, receive msg: jobID 22\n2016/04/12 15:01:07 work id: 9, receive msg: jobID 23\n2016/04/12 15:01:07 work id: 0, receive msg: jobID 24\n2016/04/12 15:01:07 work id: 1, receive msg: jobID 25\n2016/04/12 15:01:07 work id: 2, receive msg: jobID 26\n2016/04/12 15:01:07 work id: 3, receive msg: jobID 27\n2016/04/12 15:01:07 work id: 4, receive msg: jobID 28\n2016/04/12 15:01:07 work id: 5, receive msg: jobID 29\n2016/04/12 15:01:08 WorkPool is destroyed.\n```\n由上可见, 同时最多只有10个任务在执行；调用close(tasks)后, 所有工作任务完成, 工作池销毁, 主进程退出。\n\n","source":"_posts/golang/golang-工作池workerpool.md","raw":"---\ntitle: '[golang]工作池workerpool'\ndate: 2016-03-15 18:19:32\ntags: golang\n---\n\n在并发量比较高的场景中, 服务程序既要快速处理请求, 也要限制并行处理的gorontine量, 否则会造成系统资源的浪费或负载过高。\n\n创建一个goroutine工作池, 是一个比较合理的解决方案。\n\n### 示例1\n<!--more-->\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n)\n\nconst (\n\t// PoolSize defines the pool size\n\tPoolSize = 10\n)\n\n// Jobs jobs channel\nvar Jobs chan string = make(chan string, 30)\nvar Result chan string = make(chan string, 30)\n\n// Working do working\nfunc Working(workID int) {\n\tlog.Printf(\"Initiate worker %v...\", workID)\n\tfor j := range Jobs {\n\t\tlog.Printf(\"work id: %v, receive msg: %v\", workID, j)\n\t\tResult <- fmt.Sprintf(\"%v is done...\", j)\n\t\ttime.Sleep(time.Second * 1)\n\t}\n}\n\n// InitWorkerPool initialize worker pool\nfunc InitWorkerPool() {\n\tfor j := 0; j < PoolSize; j++ {\n\t\tgo Working(j)\n\t}\n}\n\nfunc main() {\n\tInitWorkerPool()\n\t// to generate jobs\n\ttime.Sleep(time.Second * 2)\n\tfor i := 0; i < 20; i++ {\n\t\tjob := fmt.Sprintf(\"JobID %v\", i)\n\t\tJobs <- job\n\t}\n\tclose(Jobs)\n\n\tfor i := 0; i < 20; i++ {\n\t\tlog.Printf(\"working result: %v\", <-Result)\n\t}\n}\n```\n运行结果:\n```bash\n2016/04/12 14:18:58 Initiate worker 0...\n2016/04/12 14:18:58 Initiate worker 1...\n2016/04/12 14:18:58 Initiate worker 2...\n2016/04/12 14:18:58 Initiate worker 3...\n2016/04/12 14:18:58 Initiate worker 4...\n2016/04/12 14:18:58 Initiate worker 5...\n2016/04/12 14:18:58 Initiate worker 6...\n2016/04/12 14:18:58 Initiate worker 7...\n2016/04/12 14:18:58 Initiate worker 8...\n2016/04/12 14:18:58 Initiate worker 9...\n2016/04/12 14:19:00 work id: 9, receive msg: JobID 0\n2016/04/12 14:19:00 work id: 0, receive msg: JobID 1\n2016/04/12 14:19:00 work id: 1, receive msg: JobID 2\n2016/04/12 14:19:00 work id: 2, receive msg: JobID 3\n2016/04/12 14:19:00 work id: 3, receive msg: JobID 4\n2016/04/12 14:19:00 work id: 4, receive msg: JobID 5\n2016/04/12 14:19:00 work id: 5, receive msg: JobID 6\n2016/04/12 14:19:00 work id: 6, receive msg: JobID 7\n2016/04/12 14:19:00 work id: 7, receive msg: JobID 8\n2016/04/12 14:19:00 work id: 8, receive msg: JobID 9\n2016/04/12 14:19:00 working result: JobID 0 is done...\n2016/04/12 14:19:00 working result: JobID 1 is done...\n2016/04/12 14:19:00 working result: JobID 2 is done...\n2016/04/12 14:19:00 working result: JobID 3 is done...\n2016/04/12 14:19:00 working result: JobID 4 is done...\n2016/04/12 14:19:00 working result: JobID 5 is done...\n2016/04/12 14:19:00 working result: JobID 6 is done...\n2016/04/12 14:19:00 working result: JobID 7 is done...\n2016/04/12 14:19:00 working result: JobID 8 is done...\n2016/04/12 14:19:00 working result: JobID 9 is done...\n2016/04/12 14:19:01 work id: 8, receive msg: JobID 10\n2016/04/12 14:19:01 work id: 9, receive msg: JobID 11\n2016/04/12 14:19:01 work id: 0, receive msg: JobID 12\n2016/04/12 14:19:01 work id: 1, receive msg: JobID 13\n2016/04/12 14:19:01 work id: 2, receive msg: JobID 14\n2016/04/12 14:19:01 work id: 3, receive msg: JobID 15\n2016/04/12 14:19:01 work id: 4, receive msg: JobID 16\n2016/04/12 14:19:01 work id: 5, receive msg: JobID 17\n2016/04/12 14:19:01 work id: 6, receive msg: JobID 18\n2016/04/12 14:19:01 work id: 7, receive msg: JobID 19\n2016/04/12 14:19:01 working result: JobID 10 is done...\n2016/04/12 14:19:01 working result: JobID 11 is done...\n2016/04/12 14:19:01 working result: JobID 12 is done...\n2016/04/12 14:19:01 working result: JobID 13 is done...\n2016/04/12 14:19:01 working result: JobID 14 is done...\n2016/04/12 14:19:01 working result: JobID 15 is done...\n2016/04/12 14:19:01 working result: JobID 16 is done...\n2016/04/12 14:19:01 working result: JobID 17 is done...\n2016/04/12 14:19:01 working result: JobID 18 is done...\n2016/04/12 14:19:01 working result: JobID 19 is done...\n```\n由上可以见, 程序中同时最多有10个工作任务在运行。\n\n### 示例2, 更规范的用法\n我们引入同步锁, 并把工作池定义成一个结构体WorkPool， 包含poolSize和tasks成员, 并实现WorkPool.Run方法:\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n\t\"time\"\n)\n\n// WorkPool worker pool definition\ntype WorkPool struct {\n\tpoolSize int\n\ttasks    chan string\n}\n\n// Run initialize worker pool, ready to run tasks\nfunc (wp *WorkPool) Run() {\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < wp.poolSize; i++ {\n\t\twg.Add(1)\n\t\ttaskID := i\n\t\tgo func() {\n\t\t\tlog.Printf(\"Initiate worker %v...\", taskID)\n\t\t\tfor j := range wp.tasks {\n\t\t\t\tlog.Printf(\"work id: %v, receive msg: %v\", taskID, j)\n\t\t\t\ttime.Sleep(time.Second * 1)\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n\tlog.Println(\"WorkPool is destroyed.\")\n}\n\nfunc main() {\n\ttasks := make(chan string, 20)\n\n\t// to generate jobs\n\tgo func() {\n\t\ttime.Sleep(time.Second * 2)\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tjob := fmt.Sprintf(\"jobID %v\", i)\n\t\t\ttasks <- job\n\t\t}\n\t\t// if not close tasks, will cause deadlock\n\t\tclose(tasks)\n\t}()\n\n\twp := WorkPool{\n\t\tpoolSize: 10,\n\t\ttasks:    tasks,\n\t}\n\twp.Run()\n}\n```\n运行结果:\n```bash\n2016/04/12 15:01:03 Initiate worker 9...\n2016/04/12 15:01:03 Initiate worker 0...\n2016/04/12 15:01:03 Initiate worker 1...\n2016/04/12 15:01:03 Initiate worker 2...\n2016/04/12 15:01:03 Initiate worker 3...\n2016/04/12 15:01:03 Initiate worker 4...\n2016/04/12 15:01:03 Initiate worker 5...\n2016/04/12 15:01:03 Initiate worker 6...\n2016/04/12 15:01:03 Initiate worker 7...\n2016/04/12 15:01:03 Initiate worker 8...\n2016/04/12 15:01:05 work id: 8, receive msg: jobID 0\n2016/04/12 15:01:05 work id: 9, receive msg: jobID 1\n2016/04/12 15:01:05 work id: 0, receive msg: jobID 2\n2016/04/12 15:01:05 work id: 1, receive msg: jobID 3\n2016/04/12 15:01:05 work id: 2, receive msg: jobID 4\n2016/04/12 15:01:05 work id: 3, receive msg: jobID 5\n2016/04/12 15:01:05 work id: 4, receive msg: jobID 6\n2016/04/12 15:01:05 work id: 5, receive msg: jobID 7\n2016/04/12 15:01:05 work id: 6, receive msg: jobID 8\n2016/04/12 15:01:05 work id: 7, receive msg: jobID 9\n2016/04/12 15:01:06 work id: 7, receive msg: jobID 10\n2016/04/12 15:01:06 work id: 8, receive msg: jobID 11\n2016/04/12 15:01:06 work id: 9, receive msg: jobID 12\n2016/04/12 15:01:06 work id: 0, receive msg: jobID 13\n2016/04/12 15:01:06 work id: 1, receive msg: jobID 14\n2016/04/12 15:01:06 work id: 2, receive msg: jobID 15\n2016/04/12 15:01:06 work id: 3, receive msg: jobID 16\n2016/04/12 15:01:06 work id: 4, receive msg: jobID 17\n2016/04/12 15:01:06 work id: 5, receive msg: jobID 18\n2016/04/12 15:01:06 work id: 6, receive msg: jobID 19\n2016/04/12 15:01:07 work id: 6, receive msg: jobID 20\n2016/04/12 15:01:07 work id: 7, receive msg: jobID 21\n2016/04/12 15:01:07 work id: 8, receive msg: jobID 22\n2016/04/12 15:01:07 work id: 9, receive msg: jobID 23\n2016/04/12 15:01:07 work id: 0, receive msg: jobID 24\n2016/04/12 15:01:07 work id: 1, receive msg: jobID 25\n2016/04/12 15:01:07 work id: 2, receive msg: jobID 26\n2016/04/12 15:01:07 work id: 3, receive msg: jobID 27\n2016/04/12 15:01:07 work id: 4, receive msg: jobID 28\n2016/04/12 15:01:07 work id: 5, receive msg: jobID 29\n2016/04/12 15:01:08 WorkPool is destroyed.\n```\n由上可见, 同时最多只有10个任务在执行；调用close(tasks)后, 所有工作任务完成, 工作池销毁, 主进程退出。\n\n","slug":"golang/golang-工作池workerpool","published":1,"updated":"2017-08-10T10:20:36.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dyj003t4j4dg2jlultt","content":"<p>在并发量比较高的场景中, 服务程序既要快速处理请求, 也要限制并行处理的gorontine量, 否则会造成系统资源的浪费或负载过高。</p>\n<p>创建一个goroutine工作池, 是一个比较合理的解决方案。</p>\n<h3 id=\"示例1\"><a href=\"#示例1\" class=\"headerlink\" title=\"示例1\"></a>示例1</h3><a id=\"more\"></a>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"log\"</span></div><div class=\"line\">\t<span class=\"string\">\"time\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> (</div><div class=\"line\">\t<span class=\"comment\">// PoolSize defines the pool size</span></div><div class=\"line\">\tPoolSize = <span class=\"number\">10</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Jobs jobs channel</span></div><div class=\"line\"><span class=\"keyword\">var</span> Jobs <span class=\"keyword\">chan</span> <span class=\"keyword\">string</span> = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>, <span class=\"number\">30</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> Result <span class=\"keyword\">chan</span> <span class=\"keyword\">string</span> = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>, <span class=\"number\">30</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Working do working</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Working</span><span class=\"params\">(workID <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">\tlog.Printf(<span class=\"string\">\"Initiate worker %v...\"</span>, workID)</div><div class=\"line\">\t<span class=\"keyword\">for</span> j := <span class=\"keyword\">range</span> Jobs &#123;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"work id: %v, receive msg: %v\"</span>, workID, j)</div><div class=\"line\">\t\tResult &lt;- fmt.Sprintf(<span class=\"string\">\"%v is done...\"</span>, j)</div><div class=\"line\">\t\ttime.Sleep(time.Second * <span class=\"number\">1</span>)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// InitWorkerPool initialize worker pool</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitWorkerPool</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; PoolSize; j++ &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">go</span> Working(j)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tInitWorkerPool()</div><div class=\"line\">\t<span class=\"comment\">// to generate jobs</span></div><div class=\"line\">\ttime.Sleep(time.Second * <span class=\"number\">2</span>)</div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++ &#123;</div><div class=\"line\">\t\tjob := fmt.Sprintf(<span class=\"string\">\"JobID %v\"</span>, i)</div><div class=\"line\">\t\tJobs &lt;- job</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"built_in\">close</span>(Jobs)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++ &#123;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"working result: %v\"</span>, &lt;-Result)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016/04/12 14:18:58 Initiate worker 0...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 1...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 2...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 3...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 4...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 5...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 6...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 7...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 8...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 9...</div><div class=\"line\">2016/04/12 14:19:00 work id: 9, receive msg: JobID 0</div><div class=\"line\">2016/04/12 14:19:00 work id: 0, receive msg: JobID 1</div><div class=\"line\">2016/04/12 14:19:00 work id: 1, receive msg: JobID 2</div><div class=\"line\">2016/04/12 14:19:00 work id: 2, receive msg: JobID 3</div><div class=\"line\">2016/04/12 14:19:00 work id: 3, receive msg: JobID 4</div><div class=\"line\">2016/04/12 14:19:00 work id: 4, receive msg: JobID 5</div><div class=\"line\">2016/04/12 14:19:00 work id: 5, receive msg: JobID 6</div><div class=\"line\">2016/04/12 14:19:00 work id: 6, receive msg: JobID 7</div><div class=\"line\">2016/04/12 14:19:00 work id: 7, receive msg: JobID 8</div><div class=\"line\">2016/04/12 14:19:00 work id: 8, receive msg: JobID 9</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 0 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 1 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 2 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 3 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 4 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 5 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 6 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 7 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 8 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 9 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 work id: 8, receive msg: JobID 10</div><div class=\"line\">2016/04/12 14:19:01 work id: 9, receive msg: JobID 11</div><div class=\"line\">2016/04/12 14:19:01 work id: 0, receive msg: JobID 12</div><div class=\"line\">2016/04/12 14:19:01 work id: 1, receive msg: JobID 13</div><div class=\"line\">2016/04/12 14:19:01 work id: 2, receive msg: JobID 14</div><div class=\"line\">2016/04/12 14:19:01 work id: 3, receive msg: JobID 15</div><div class=\"line\">2016/04/12 14:19:01 work id: 4, receive msg: JobID 16</div><div class=\"line\">2016/04/12 14:19:01 work id: 5, receive msg: JobID 17</div><div class=\"line\">2016/04/12 14:19:01 work id: 6, receive msg: JobID 18</div><div class=\"line\">2016/04/12 14:19:01 work id: 7, receive msg: JobID 19</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 10 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 11 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 12 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 13 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 14 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 15 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 16 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 17 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 18 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 19 is <span class=\"keyword\">done</span>...</div></pre></td></tr></table></figure></p>\n<p>由上可以见, 程序中同时最多有10个工作任务在运行。</p>\n<h3 id=\"示例2-更规范的用法\"><a href=\"#示例2-更规范的用法\" class=\"headerlink\" title=\"示例2, 更规范的用法\"></a>示例2, 更规范的用法</h3><p>我们引入同步锁, 并把工作池定义成一个结构体WorkPool， 包含poolSize和tasks成员, 并实现WorkPool.Run方法:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"log\"</span></div><div class=\"line\">\t<span class=\"string\">\"sync\"</span></div><div class=\"line\">\t<span class=\"string\">\"time\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// WorkPool worker pool definition</span></div><div class=\"line\"><span class=\"keyword\">type</span> WorkPool <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tpoolSize <span class=\"keyword\">int</span></div><div class=\"line\">\ttasks    <span class=\"keyword\">chan</span> <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Run initialize worker pool, ready to run tasks</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(wp *WorkPool)</span> <span class=\"title\">Run</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; wp.poolSize; i++ &#123;</div><div class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</div><div class=\"line\">\t\ttaskID := i</div><div class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t\t\tlog.Printf(<span class=\"string\">\"Initiate worker %v...\"</span>, taskID)</div><div class=\"line\">\t\t\t<span class=\"keyword\">for</span> j := <span class=\"keyword\">range</span> wp.tasks &#123;</div><div class=\"line\">\t\t\t\tlog.Printf(<span class=\"string\">\"work id: %v, receive msg: %v\"</span>, taskID, j)</div><div class=\"line\">\t\t\t\ttime.Sleep(time.Second * <span class=\"number\">1</span>)</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\twg.Done()</div><div class=\"line\">\t\t&#125;()</div><div class=\"line\">\t&#125;</div><div class=\"line\">\twg.Wait()</div><div class=\"line\">\tlog.Println(<span class=\"string\">\"WorkPool is destroyed.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\ttasks := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>, <span class=\"number\">20</span>)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// to generate jobs</span></div><div class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t\ttime.Sleep(time.Second * <span class=\"number\">2</span>)</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">30</span>; i++ &#123;</div><div class=\"line\">\t\t\tjob := fmt.Sprintf(<span class=\"string\">\"jobID %v\"</span>, i)</div><div class=\"line\">\t\t\ttasks &lt;- job</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">// if not close tasks, will cause deadlock</span></div><div class=\"line\">\t\t<span class=\"built_in\">close</span>(tasks)</div><div class=\"line\">\t&#125;()</div><div class=\"line\"></div><div class=\"line\">\twp := WorkPool&#123;</div><div class=\"line\">\t\tpoolSize: <span class=\"number\">10</span>,</div><div class=\"line\">\t\ttasks:    tasks,</div><div class=\"line\">\t&#125;</div><div class=\"line\">\twp.Run()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016/04/12 15:01:03 Initiate worker 9...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 0...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 1...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 2...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 3...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 4...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 5...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 6...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 7...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 8...</div><div class=\"line\">2016/04/12 15:01:05 work id: 8, receive msg: jobID 0</div><div class=\"line\">2016/04/12 15:01:05 work id: 9, receive msg: jobID 1</div><div class=\"line\">2016/04/12 15:01:05 work id: 0, receive msg: jobID 2</div><div class=\"line\">2016/04/12 15:01:05 work id: 1, receive msg: jobID 3</div><div class=\"line\">2016/04/12 15:01:05 work id: 2, receive msg: jobID 4</div><div class=\"line\">2016/04/12 15:01:05 work id: 3, receive msg: jobID 5</div><div class=\"line\">2016/04/12 15:01:05 work id: 4, receive msg: jobID 6</div><div class=\"line\">2016/04/12 15:01:05 work id: 5, receive msg: jobID 7</div><div class=\"line\">2016/04/12 15:01:05 work id: 6, receive msg: jobID 8</div><div class=\"line\">2016/04/12 15:01:05 work id: 7, receive msg: jobID 9</div><div class=\"line\">2016/04/12 15:01:06 work id: 7, receive msg: jobID 10</div><div class=\"line\">2016/04/12 15:01:06 work id: 8, receive msg: jobID 11</div><div class=\"line\">2016/04/12 15:01:06 work id: 9, receive msg: jobID 12</div><div class=\"line\">2016/04/12 15:01:06 work id: 0, receive msg: jobID 13</div><div class=\"line\">2016/04/12 15:01:06 work id: 1, receive msg: jobID 14</div><div class=\"line\">2016/04/12 15:01:06 work id: 2, receive msg: jobID 15</div><div class=\"line\">2016/04/12 15:01:06 work id: 3, receive msg: jobID 16</div><div class=\"line\">2016/04/12 15:01:06 work id: 4, receive msg: jobID 17</div><div class=\"line\">2016/04/12 15:01:06 work id: 5, receive msg: jobID 18</div><div class=\"line\">2016/04/12 15:01:06 work id: 6, receive msg: jobID 19</div><div class=\"line\">2016/04/12 15:01:07 work id: 6, receive msg: jobID 20</div><div class=\"line\">2016/04/12 15:01:07 work id: 7, receive msg: jobID 21</div><div class=\"line\">2016/04/12 15:01:07 work id: 8, receive msg: jobID 22</div><div class=\"line\">2016/04/12 15:01:07 work id: 9, receive msg: jobID 23</div><div class=\"line\">2016/04/12 15:01:07 work id: 0, receive msg: jobID 24</div><div class=\"line\">2016/04/12 15:01:07 work id: 1, receive msg: jobID 25</div><div class=\"line\">2016/04/12 15:01:07 work id: 2, receive msg: jobID 26</div><div class=\"line\">2016/04/12 15:01:07 work id: 3, receive msg: jobID 27</div><div class=\"line\">2016/04/12 15:01:07 work id: 4, receive msg: jobID 28</div><div class=\"line\">2016/04/12 15:01:07 work id: 5, receive msg: jobID 29</div><div class=\"line\">2016/04/12 15:01:08 WorkPool is destroyed.</div></pre></td></tr></table></figure></p>\n<p>由上可见, 同时最多只有10个任务在执行；调用close(tasks)后, 所有工作任务完成, 工作池销毁, 主进程退出。</p>\n","site":{"data":{}},"excerpt":"<p>在并发量比较高的场景中, 服务程序既要快速处理请求, 也要限制并行处理的gorontine量, 否则会造成系统资源的浪费或负载过高。</p>\n<p>创建一个goroutine工作池, 是一个比较合理的解决方案。</p>\n<h3 id=\"示例1\"><a href=\"#示例1\" class=\"headerlink\" title=\"示例1\"></a>示例1</h3>","more":"<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"log\"</span></div><div class=\"line\">\t<span class=\"string\">\"time\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> (</div><div class=\"line\">\t<span class=\"comment\">// PoolSize defines the pool size</span></div><div class=\"line\">\tPoolSize = <span class=\"number\">10</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Jobs jobs channel</span></div><div class=\"line\"><span class=\"keyword\">var</span> Jobs <span class=\"keyword\">chan</span> <span class=\"keyword\">string</span> = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>, <span class=\"number\">30</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> Result <span class=\"keyword\">chan</span> <span class=\"keyword\">string</span> = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>, <span class=\"number\">30</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Working do working</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Working</span><span class=\"params\">(workID <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">\tlog.Printf(<span class=\"string\">\"Initiate worker %v...\"</span>, workID)</div><div class=\"line\">\t<span class=\"keyword\">for</span> j := <span class=\"keyword\">range</span> Jobs &#123;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"work id: %v, receive msg: %v\"</span>, workID, j)</div><div class=\"line\">\t\tResult &lt;- fmt.Sprintf(<span class=\"string\">\"%v is done...\"</span>, j)</div><div class=\"line\">\t\ttime.Sleep(time.Second * <span class=\"number\">1</span>)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// InitWorkerPool initialize worker pool</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitWorkerPool</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; PoolSize; j++ &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">go</span> Working(j)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tInitWorkerPool()</div><div class=\"line\">\t<span class=\"comment\">// to generate jobs</span></div><div class=\"line\">\ttime.Sleep(time.Second * <span class=\"number\">2</span>)</div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++ &#123;</div><div class=\"line\">\t\tjob := fmt.Sprintf(<span class=\"string\">\"JobID %v\"</span>, i)</div><div class=\"line\">\t\tJobs &lt;- job</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"built_in\">close</span>(Jobs)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++ &#123;</div><div class=\"line\">\t\tlog.Printf(<span class=\"string\">\"working result: %v\"</span>, &lt;-Result)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016/04/12 14:18:58 Initiate worker 0...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 1...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 2...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 3...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 4...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 5...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 6...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 7...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 8...</div><div class=\"line\">2016/04/12 14:18:58 Initiate worker 9...</div><div class=\"line\">2016/04/12 14:19:00 work id: 9, receive msg: JobID 0</div><div class=\"line\">2016/04/12 14:19:00 work id: 0, receive msg: JobID 1</div><div class=\"line\">2016/04/12 14:19:00 work id: 1, receive msg: JobID 2</div><div class=\"line\">2016/04/12 14:19:00 work id: 2, receive msg: JobID 3</div><div class=\"line\">2016/04/12 14:19:00 work id: 3, receive msg: JobID 4</div><div class=\"line\">2016/04/12 14:19:00 work id: 4, receive msg: JobID 5</div><div class=\"line\">2016/04/12 14:19:00 work id: 5, receive msg: JobID 6</div><div class=\"line\">2016/04/12 14:19:00 work id: 6, receive msg: JobID 7</div><div class=\"line\">2016/04/12 14:19:00 work id: 7, receive msg: JobID 8</div><div class=\"line\">2016/04/12 14:19:00 work id: 8, receive msg: JobID 9</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 0 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 1 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 2 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 3 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 4 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 5 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 6 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 7 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 8 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:00 working result: JobID 9 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 work id: 8, receive msg: JobID 10</div><div class=\"line\">2016/04/12 14:19:01 work id: 9, receive msg: JobID 11</div><div class=\"line\">2016/04/12 14:19:01 work id: 0, receive msg: JobID 12</div><div class=\"line\">2016/04/12 14:19:01 work id: 1, receive msg: JobID 13</div><div class=\"line\">2016/04/12 14:19:01 work id: 2, receive msg: JobID 14</div><div class=\"line\">2016/04/12 14:19:01 work id: 3, receive msg: JobID 15</div><div class=\"line\">2016/04/12 14:19:01 work id: 4, receive msg: JobID 16</div><div class=\"line\">2016/04/12 14:19:01 work id: 5, receive msg: JobID 17</div><div class=\"line\">2016/04/12 14:19:01 work id: 6, receive msg: JobID 18</div><div class=\"line\">2016/04/12 14:19:01 work id: 7, receive msg: JobID 19</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 10 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 11 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 12 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 13 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 14 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 15 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 16 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 17 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 18 is <span class=\"keyword\">done</span>...</div><div class=\"line\">2016/04/12 14:19:01 working result: JobID 19 is <span class=\"keyword\">done</span>...</div></pre></td></tr></table></figure></p>\n<p>由上可以见, 程序中同时最多有10个工作任务在运行。</p>\n<h3 id=\"示例2-更规范的用法\"><a href=\"#示例2-更规范的用法\" class=\"headerlink\" title=\"示例2, 更规范的用法\"></a>示例2, 更规范的用法</h3><p>我们引入同步锁, 并把工作池定义成一个结构体WorkPool， 包含poolSize和tasks成员, 并实现WorkPool.Run方法:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"log\"</span></div><div class=\"line\">\t<span class=\"string\">\"sync\"</span></div><div class=\"line\">\t<span class=\"string\">\"time\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// WorkPool worker pool definition</span></div><div class=\"line\"><span class=\"keyword\">type</span> WorkPool <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tpoolSize <span class=\"keyword\">int</span></div><div class=\"line\">\ttasks    <span class=\"keyword\">chan</span> <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Run initialize worker pool, ready to run tasks</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(wp *WorkPool)</span> <span class=\"title\">Run</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</div><div class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; wp.poolSize; i++ &#123;</div><div class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</div><div class=\"line\">\t\ttaskID := i</div><div class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t\t\tlog.Printf(<span class=\"string\">\"Initiate worker %v...\"</span>, taskID)</div><div class=\"line\">\t\t\t<span class=\"keyword\">for</span> j := <span class=\"keyword\">range</span> wp.tasks &#123;</div><div class=\"line\">\t\t\t\tlog.Printf(<span class=\"string\">\"work id: %v, receive msg: %v\"</span>, taskID, j)</div><div class=\"line\">\t\t\t\ttime.Sleep(time.Second * <span class=\"number\">1</span>)</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\twg.Done()</div><div class=\"line\">\t\t&#125;()</div><div class=\"line\">\t&#125;</div><div class=\"line\">\twg.Wait()</div><div class=\"line\">\tlog.Println(<span class=\"string\">\"WorkPool is destroyed.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\ttasks := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>, <span class=\"number\">20</span>)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// to generate jobs</span></div><div class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t\ttime.Sleep(time.Second * <span class=\"number\">2</span>)</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">30</span>; i++ &#123;</div><div class=\"line\">\t\t\tjob := fmt.Sprintf(<span class=\"string\">\"jobID %v\"</span>, i)</div><div class=\"line\">\t\t\ttasks &lt;- job</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">// if not close tasks, will cause deadlock</span></div><div class=\"line\">\t\t<span class=\"built_in\">close</span>(tasks)</div><div class=\"line\">\t&#125;()</div><div class=\"line\"></div><div class=\"line\">\twp := WorkPool&#123;</div><div class=\"line\">\t\tpoolSize: <span class=\"number\">10</span>,</div><div class=\"line\">\t\ttasks:    tasks,</div><div class=\"line\">\t&#125;</div><div class=\"line\">\twp.Run()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016/04/12 15:01:03 Initiate worker 9...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 0...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 1...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 2...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 3...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 4...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 5...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 6...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 7...</div><div class=\"line\">2016/04/12 15:01:03 Initiate worker 8...</div><div class=\"line\">2016/04/12 15:01:05 work id: 8, receive msg: jobID 0</div><div class=\"line\">2016/04/12 15:01:05 work id: 9, receive msg: jobID 1</div><div class=\"line\">2016/04/12 15:01:05 work id: 0, receive msg: jobID 2</div><div class=\"line\">2016/04/12 15:01:05 work id: 1, receive msg: jobID 3</div><div class=\"line\">2016/04/12 15:01:05 work id: 2, receive msg: jobID 4</div><div class=\"line\">2016/04/12 15:01:05 work id: 3, receive msg: jobID 5</div><div class=\"line\">2016/04/12 15:01:05 work id: 4, receive msg: jobID 6</div><div class=\"line\">2016/04/12 15:01:05 work id: 5, receive msg: jobID 7</div><div class=\"line\">2016/04/12 15:01:05 work id: 6, receive msg: jobID 8</div><div class=\"line\">2016/04/12 15:01:05 work id: 7, receive msg: jobID 9</div><div class=\"line\">2016/04/12 15:01:06 work id: 7, receive msg: jobID 10</div><div class=\"line\">2016/04/12 15:01:06 work id: 8, receive msg: jobID 11</div><div class=\"line\">2016/04/12 15:01:06 work id: 9, receive msg: jobID 12</div><div class=\"line\">2016/04/12 15:01:06 work id: 0, receive msg: jobID 13</div><div class=\"line\">2016/04/12 15:01:06 work id: 1, receive msg: jobID 14</div><div class=\"line\">2016/04/12 15:01:06 work id: 2, receive msg: jobID 15</div><div class=\"line\">2016/04/12 15:01:06 work id: 3, receive msg: jobID 16</div><div class=\"line\">2016/04/12 15:01:06 work id: 4, receive msg: jobID 17</div><div class=\"line\">2016/04/12 15:01:06 work id: 5, receive msg: jobID 18</div><div class=\"line\">2016/04/12 15:01:06 work id: 6, receive msg: jobID 19</div><div class=\"line\">2016/04/12 15:01:07 work id: 6, receive msg: jobID 20</div><div class=\"line\">2016/04/12 15:01:07 work id: 7, receive msg: jobID 21</div><div class=\"line\">2016/04/12 15:01:07 work id: 8, receive msg: jobID 22</div><div class=\"line\">2016/04/12 15:01:07 work id: 9, receive msg: jobID 23</div><div class=\"line\">2016/04/12 15:01:07 work id: 0, receive msg: jobID 24</div><div class=\"line\">2016/04/12 15:01:07 work id: 1, receive msg: jobID 25</div><div class=\"line\">2016/04/12 15:01:07 work id: 2, receive msg: jobID 26</div><div class=\"line\">2016/04/12 15:01:07 work id: 3, receive msg: jobID 27</div><div class=\"line\">2016/04/12 15:01:07 work id: 4, receive msg: jobID 28</div><div class=\"line\">2016/04/12 15:01:07 work id: 5, receive msg: jobID 29</div><div class=\"line\">2016/04/12 15:01:08 WorkPool is destroyed.</div></pre></td></tr></table></figure></p>\n<p>由上可见, 同时最多只有10个任务在执行；调用close(tasks)后, 所有工作任务完成, 工作池销毁, 主进程退出。</p>"},{"title":"[golang]异常处理","date":"2016-03-10T05:53:30.000Z","_content":"\n### 关于异常处理\n\ngolang并不支持try-catch-finally机制，而是通过panic和defer函数来处理运行时异常。<br>\n一般情况下，golang中使用多值来返回错误；个别情况下才需要用到Exception异常处理: defer, panic, recover。\n\n<!--more-->\n示例:\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// 一个函数可以声明多个defer, 按FILO规则执行\nfunc SimpleExceptionSample() {\n    defer func() {\n        // recover()可以获取panic的参数\n        if err := recover(); err != nil {\n            fmt.Println(\"panic_1 msg: \", err)\n        }\n    }()\n\n    defer func() {\n        fmt.Println(\"panic_2.\")\n    }()\n\n    defer func() {\n        fmt.Println(\"panic_3.\")\n    }()\n\n    panic(\"something wrong.\")\n}\n\nfunc main() {\n    SimpleExceptionSample()\n}\n```\n运行结果:\n```bash\nroot@XIAOMO:~/gopro# go build excep.go\nroot@XIAOMO:~/gopro# ./excep\npanic_3.\npanic_2.\npanic_1 msg:  something wrong.\n```\n\n### defer的三个特性\ndefer在函数返回之前执行, 其有三个明显特性:\n\n+ defer表达式中参数变量的值在定义时就已经确定\n```golang\nfunc a() {\n    i := 1\n    defer fmt.Println(\"i=\", i)\n    i = i+1\n    return\n}\n```\n这样会输出 i=1而非i=2\n\n+ defer表达式的执行顺序遵循FILO(参考第一个示例)\n+ defer表达式能修改函数中的命名返回参数值\n```golang\nfunc c() (i int) {\n    defer func() { i++ }()\n    return i\n}\n```\n这样返回值为1而非0(命名返回参数的默认值为0)。\n\n","source":"_posts/golang/golang-异常处理.md","raw":"---\ntitle: '[golang]异常处理'\ndate: 2016-03-10 13:53:30\ntags: golang\n---\n\n### 关于异常处理\n\ngolang并不支持try-catch-finally机制，而是通过panic和defer函数来处理运行时异常。<br>\n一般情况下，golang中使用多值来返回错误；个别情况下才需要用到Exception异常处理: defer, panic, recover。\n\n<!--more-->\n示例:\n```golang\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// 一个函数可以声明多个defer, 按FILO规则执行\nfunc SimpleExceptionSample() {\n    defer func() {\n        // recover()可以获取panic的参数\n        if err := recover(); err != nil {\n            fmt.Println(\"panic_1 msg: \", err)\n        }\n    }()\n\n    defer func() {\n        fmt.Println(\"panic_2.\")\n    }()\n\n    defer func() {\n        fmt.Println(\"panic_3.\")\n    }()\n\n    panic(\"something wrong.\")\n}\n\nfunc main() {\n    SimpleExceptionSample()\n}\n```\n运行结果:\n```bash\nroot@XIAOMO:~/gopro# go build excep.go\nroot@XIAOMO:~/gopro# ./excep\npanic_3.\npanic_2.\npanic_1 msg:  something wrong.\n```\n\n### defer的三个特性\ndefer在函数返回之前执行, 其有三个明显特性:\n\n+ defer表达式中参数变量的值在定义时就已经确定\n```golang\nfunc a() {\n    i := 1\n    defer fmt.Println(\"i=\", i)\n    i = i+1\n    return\n}\n```\n这样会输出 i=1而非i=2\n\n+ defer表达式的执行顺序遵循FILO(参考第一个示例)\n+ defer表达式能修改函数中的命名返回参数值\n```golang\nfunc c() (i int) {\n    defer func() { i++ }()\n    return i\n}\n```\n这样返回值为1而非0(命名返回参数的默认值为0)。\n\n","slug":"golang/golang-异常处理","published":1,"updated":"2017-08-10T05:57:53.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dyl003v4j4d6ed1kkdg","content":"<h3 id=\"关于异常处理\"><a href=\"#关于异常处理\" class=\"headerlink\" title=\"关于异常处理\"></a>关于异常处理</h3><p>golang并不支持try-catch-finally机制，而是通过panic和defer函数来处理运行时异常。<br><br>一般情况下，golang中使用多值来返回错误；个别情况下才需要用到Exception异常处理: defer, panic, recover。</p>\n<a id=\"more\"></a>\n<p>示例:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 一个函数可以声明多个defer, 按FILO规则执行</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SimpleExceptionSample</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"comment\">// recover()可以获取panic的参数</span></div><div class=\"line\">        <span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            fmt.Println(<span class=\"string\">\"panic_1 msg: \"</span>, err)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        fmt.Println(<span class=\"string\">\"panic_2.\"</span>)</div><div class=\"line\">    &#125;()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        fmt.Println(<span class=\"string\">\"panic_3.\"</span>)</div><div class=\"line\">    &#125;()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"something wrong.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    SimpleExceptionSample()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># go build excep.go</span></div><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># ./excep</span></div><div class=\"line\">panic_3.</div><div class=\"line\">panic_2.</div><div class=\"line\">panic_1 msg:  something wrong.</div></pre></td></tr></table></figure></p>\n<h3 id=\"defer的三个特性\"><a href=\"#defer的三个特性\" class=\"headerlink\" title=\"defer的三个特性\"></a>defer的三个特性</h3><p>defer在函数返回之前执行, 其有三个明显特性:</p>\n<ul>\n<li>defer表达式中参数变量的值在定义时就已经确定<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">a</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    i := <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">defer</span> fmt.Println(<span class=\"string\">\"i=\"</span>, i)</div><div class=\"line\">    i = i+<span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样会输出 i=1而非i=2</p>\n<ul>\n<li>defer表达式的执行顺序遵循FILO(参考第一个示例)</li>\n<li>defer表达式能修改函数中的命名返回参数值<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">c</span><span class=\"params\">()</span> <span class=\"params\">(i <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; i++ &#125;()</div><div class=\"line\">    <span class=\"keyword\">return</span> i</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样返回值为1而非0(命名返回参数的默认值为0)。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"关于异常处理\"><a href=\"#关于异常处理\" class=\"headerlink\" title=\"关于异常处理\"></a>关于异常处理</h3><p>golang并不支持try-catch-finally机制，而是通过panic和defer函数来处理运行时异常。<br><br>一般情况下，golang中使用多值来返回错误；个别情况下才需要用到Exception异常处理: defer, panic, recover。</p>","more":"<p>示例:<br><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 一个函数可以声明多个defer, 按FILO规则执行</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SimpleExceptionSample</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"comment\">// recover()可以获取panic的参数</span></div><div class=\"line\">        <span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            fmt.Println(<span class=\"string\">\"panic_1 msg: \"</span>, err)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        fmt.Println(<span class=\"string\">\"panic_2.\"</span>)</div><div class=\"line\">    &#125;()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        fmt.Println(<span class=\"string\">\"panic_3.\"</span>)</div><div class=\"line\">    &#125;()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"something wrong.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    SimpleExceptionSample()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># go build excep.go</span></div><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># ./excep</span></div><div class=\"line\">panic_3.</div><div class=\"line\">panic_2.</div><div class=\"line\">panic_1 msg:  something wrong.</div></pre></td></tr></table></figure></p>\n<h3 id=\"defer的三个特性\"><a href=\"#defer的三个特性\" class=\"headerlink\" title=\"defer的三个特性\"></a>defer的三个特性</h3><p>defer在函数返回之前执行, 其有三个明显特性:</p>\n<ul>\n<li>defer表达式中参数变量的值在定义时就已经确定<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">a</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    i := <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">defer</span> fmt.Println(<span class=\"string\">\"i=\"</span>, i)</div><div class=\"line\">    i = i+<span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样会输出 i=1而非i=2</p>\n<ul>\n<li>defer表达式的执行顺序遵循FILO(参考第一个示例)</li>\n<li>defer表达式能修改函数中的命名返回参数值<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">c</span><span class=\"params\">()</span> <span class=\"params\">(i <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; i++ &#125;()</div><div class=\"line\">    <span class=\"keyword\">return</span> i</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样返回值为1而非0(命名返回参数的默认值为0)。</p>"},{"title":"[golang]指针类型","date":"2016-04-05T11:35:16.000Z","_content":"\n### 关于golang指针类型\nGolang保留了指针类型,支持指针操作。<br>\n可以使用操作符&取变量地址，使用操作符*通过指针变量间接访问目标对象。<br>\nunsafe.Pointer可以与任意指针类型转换, 可以将unsafe.Pointer转换为uintptr,然后做指针运算。<br>\nuintptr类型可以转换为整数。\n<!--more-->\n### 指针使用示例\n\n```golang\npackage main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\ntype User struct {\n    Id int\n    Name string\n}\n\nfunc main(){\n    i := 10\n    var p *int = &i  //取地址\n    fmt.Println(*p) // 取值\n\n    user := &User{1, \"xiaomo\"}\n    user.Id = 100  //直接对指针对象的成员赋值\n    fmt.Println(user)\n\n    user2 := *user  //拷贝对象\n    user2.Id = 200\n    user2.Name = \"xiaomomo\"\n    fmt.Println(user, user2)\n\n    up := unsafe.Pointer(p)  // 转为通用指针类型\n    uptr := uintptr(up)      // 转为uintptr指针类型\n    fmt.Println(up, uptr)\n}\n```\n\n###运行效果如下:\n```bash\nroot@XIAOMO:~/gopro# go build main.go\nroot@XIAOMO:~/gopro# ./main\n10\n&{100 xiaomo}\n&{100 xiaomo} {200 xiaomomo}\n0xc210000070 833492090992\n```\n","source":"_posts/golang/golang_pointer.md","raw":"---\ntitle: '[golang]指针类型'\ndate: 2016-04-05 19:35:16\ntags: golang\n---\n\n### 关于golang指针类型\nGolang保留了指针类型,支持指针操作。<br>\n可以使用操作符&取变量地址，使用操作符*通过指针变量间接访问目标对象。<br>\nunsafe.Pointer可以与任意指针类型转换, 可以将unsafe.Pointer转换为uintptr,然后做指针运算。<br>\nuintptr类型可以转换为整数。\n<!--more-->\n### 指针使用示例\n\n```golang\npackage main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\ntype User struct {\n    Id int\n    Name string\n}\n\nfunc main(){\n    i := 10\n    var p *int = &i  //取地址\n    fmt.Println(*p) // 取值\n\n    user := &User{1, \"xiaomo\"}\n    user.Id = 100  //直接对指针对象的成员赋值\n    fmt.Println(user)\n\n    user2 := *user  //拷贝对象\n    user2.Id = 200\n    user2.Name = \"xiaomomo\"\n    fmt.Println(user, user2)\n\n    up := unsafe.Pointer(p)  // 转为通用指针类型\n    uptr := uintptr(up)      // 转为uintptr指针类型\n    fmt.Println(up, uptr)\n}\n```\n\n###运行效果如下:\n```bash\nroot@XIAOMO:~/gopro# go build main.go\nroot@XIAOMO:~/gopro# ./main\n10\n&{100 xiaomo}\n&{100 xiaomo} {200 xiaomomo}\n0xc210000070 833492090992\n```\n","slug":"golang/golang_pointer","published":1,"updated":"2017-08-07T02:58:37.447Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dyn003x4j4d2x4mu1ro","content":"<h3 id=\"关于golang指针类型\"><a href=\"#关于golang指针类型\" class=\"headerlink\" title=\"关于golang指针类型\"></a>关于golang指针类型</h3><p>Golang保留了指针类型,支持指针操作。<br><br>可以使用操作符&amp;取变量地址，使用操作符*通过指针变量间接访问目标对象。<br><br>unsafe.Pointer可以与任意指针类型转换, 可以将unsafe.Pointer转换为uintptr,然后做指针运算。<br><br>uintptr类型可以转换为整数。<br><a id=\"more\"></a></p>\n<h3 id=\"指针使用示例\"><a href=\"#指针使用示例\" class=\"headerlink\" title=\"指针使用示例\"></a>指针使用示例</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">    <span class=\"string\">\"unsafe\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    Id <span class=\"keyword\">int</span></div><div class=\"line\">    Name <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    i := <span class=\"number\">10</span></div><div class=\"line\">    <span class=\"keyword\">var</span> p *<span class=\"keyword\">int</span> = &amp;i  <span class=\"comment\">//取地址</span></div><div class=\"line\">    fmt.Println(*p) <span class=\"comment\">// 取值</span></div><div class=\"line\"></div><div class=\"line\">    user := &amp;User&#123;<span class=\"number\">1</span>, <span class=\"string\">\"xiaomo\"</span>&#125;</div><div class=\"line\">    user.Id = <span class=\"number\">100</span>  <span class=\"comment\">//直接对指针对象的成员赋值</span></div><div class=\"line\">    fmt.Println(user)</div><div class=\"line\"></div><div class=\"line\">    user2 := *user  <span class=\"comment\">//拷贝对象</span></div><div class=\"line\">    user2.Id = <span class=\"number\">200</span></div><div class=\"line\">    user2.Name = <span class=\"string\">\"xiaomomo\"</span></div><div class=\"line\">    fmt.Println(user, user2)</div><div class=\"line\"></div><div class=\"line\">    up := unsafe.Pointer(p)  <span class=\"comment\">// 转为通用指针类型</span></div><div class=\"line\">    uptr := <span class=\"keyword\">uintptr</span>(up)      <span class=\"comment\">// 转为uintptr指针类型</span></div><div class=\"line\">    fmt.Println(up, uptr)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>###运行效果如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># go build main.go</span></div><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># ./main</span></div><div class=\"line\">10</div><div class=\"line\">&amp;&#123;100 xiaomo&#125;</div><div class=\"line\">&amp;&#123;100 xiaomo&#125; &#123;200 xiaomomo&#125;</div><div class=\"line\">0xc210000070 833492090992</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"关于golang指针类型\"><a href=\"#关于golang指针类型\" class=\"headerlink\" title=\"关于golang指针类型\"></a>关于golang指针类型</h3><p>Golang保留了指针类型,支持指针操作。<br><br>可以使用操作符&amp;取变量地址，使用操作符*通过指针变量间接访问目标对象。<br><br>unsafe.Pointer可以与任意指针类型转换, 可以将unsafe.Pointer转换为uintptr,然后做指针运算。<br><br>uintptr类型可以转换为整数。<br>","more":"</p>\n<h3 id=\"指针使用示例\"><a href=\"#指针使用示例\" class=\"headerlink\" title=\"指针使用示例\"></a>指针使用示例</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">    <span class=\"string\">\"unsafe\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    Id <span class=\"keyword\">int</span></div><div class=\"line\">    Name <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    i := <span class=\"number\">10</span></div><div class=\"line\">    <span class=\"keyword\">var</span> p *<span class=\"keyword\">int</span> = &amp;i  <span class=\"comment\">//取地址</span></div><div class=\"line\">    fmt.Println(*p) <span class=\"comment\">// 取值</span></div><div class=\"line\"></div><div class=\"line\">    user := &amp;User&#123;<span class=\"number\">1</span>, <span class=\"string\">\"xiaomo\"</span>&#125;</div><div class=\"line\">    user.Id = <span class=\"number\">100</span>  <span class=\"comment\">//直接对指针对象的成员赋值</span></div><div class=\"line\">    fmt.Println(user)</div><div class=\"line\"></div><div class=\"line\">    user2 := *user  <span class=\"comment\">//拷贝对象</span></div><div class=\"line\">    user2.Id = <span class=\"number\">200</span></div><div class=\"line\">    user2.Name = <span class=\"string\">\"xiaomomo\"</span></div><div class=\"line\">    fmt.Println(user, user2)</div><div class=\"line\"></div><div class=\"line\">    up := unsafe.Pointer(p)  <span class=\"comment\">// 转为通用指针类型</span></div><div class=\"line\">    uptr := <span class=\"keyword\">uintptr</span>(up)      <span class=\"comment\">// 转为uintptr指针类型</span></div><div class=\"line\">    fmt.Println(up, uptr)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>###运行效果如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># go build main.go</span></div><div class=\"line\">root@XIAOMO:~/gopro<span class=\"comment\"># ./main</span></div><div class=\"line\">10</div><div class=\"line\">&amp;&#123;100 xiaomo&#125;</div><div class=\"line\">&amp;&#123;100 xiaomo&#125; &#123;200 xiaomomo&#125;</div><div class=\"line\">0xc210000070 833492090992</div></pre></td></tr></table></figure></p>"},{"title":"Go实现raft协议","date":"2018-05-28T07:24:35.000Z","_content":"\n之前对raft算法是有所了解但无深究，偶然机会下读了下大牛的[goraft代码](https://github.com/goraft/raft) 后，决定自己实现一把。\n目前代码基本完成，本人水平有限，代码基本能用，未经严格测试，欢迎指导：[源码github地址](https://github.com/moxiaomomo/goRaft)\n以下是项目说明README：\n\n#### raft协议的go版本，实现功能包括：\n\n-  选主投票\n- 节点心跳\n- 日志同步\n- 成员变更\n- 日志压缩\n\n<!--more-->\n\n#### 存在的问题或需要解决的问题：\n\n- 完善snapshot快照同步逻辑\n- 成员变更，每次只允许变动一个节点\n- 成员变更日志，leader节点在追加持久化后即可apply\n- 非leader节点转发请求，考虑改用rpc方式\n- 改善和统一运行日志\n- 改善状态机。。。。。。\n\n#### 测试启动：\n\n在主目录下，启动多个测试节点，比如(测试配置文件中定义了三个节点):\n```bash\n$ go test -confpath raft_test0.cfg\nconfig: &{LogPrefix:raft-log- CommitIndex:0 PeerHosts:[127.0.0.1:3001 127.0.0.1:3002 127.0.0.1:3000] Host:127.0.0.1:3000 Client:127.0.0.1:4000 Name:server0}\nstate loaded: &{CommitIndex:2 Term:87 VoteFor:}\ncurrent state:follower, term:87\nlisten internal rpc address: 127.0.0.1:3000\nextra handlefunc: map[]\nlisten client address: 127.0.0.1:4000\ncurrent state:candidate, term:87\ncurrent state:leader, term:95\nTo rewrite configuration to persistent storage.\nAppendentries succeeded: 127.0.0.1:3003 Success:true Term:95 Index:4 \n```\n```bash\n$ go test -confpath raft_test1.cfg\nconfig: &{LogPrefix:raft-log- CommitIndex:0 PeerHosts:[127.0.0.1:3002 127.0.0.1:3000 127.0.0.1:3001] Host:127.0.0.1:3001 Client:127.0.0.1:4001 Name:server1}\nstate loaded: &{CommitIndex:2 Term:87 VoteFor:}\ncurrent state:follower, term:87\nextra handlefunc: map[]\nlisten client address: 127.0.0.1:4001\nlisten internal rpc address: 127.0.0.1:3001\ncurrent state:candidate, term:87\ncurrent state:follower, term:95\n```\n```bash\n$ go test -confpath raft_test2.cfg\nconfig: &{LogPrefix:raft-log- CommitIndex:0 PeerHosts:[127.0.0.1:3002 127.0.0.1:3000 127.0.0.1:3001] Host:127.0.0.1:3002 Client:127.0.0.1:4002 Name:server2}\nstate loaded: &{CommitIndex:2 Term:87 VoteFor:}\ncurrent state:follower, term:87\nlisten internal rpc address: 127.0.0.1:3002\nextra handlefunc: map[]\nlisten client address: 127.0.0.1:4002\n```\n#### 测试成员变更\n\n启动要加入集群的新节点后，随机向已组成集群的节点发送请求，比如：\n\n```bash\n添加节点：\ncurl \"http://localhost:4001/internal/join?name=server3&host=127.0.0.1:3003\"\n剔除节点：\ncurl \"http://localhost:4002/internal/leave?name=server3&host=127.0.0.1:3003\"\n```\n#### 日志同步状态检查\n\n在raft集群运行过程中，想简单检查日志log/节点状态是否一致，可直接尝试：\n\n```bash\n$ sha1sum internlog/raft-log-server*\nae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server0\nae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server1\nae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server2\nae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server3\n\n$ sha1sum internlog/state-server*\nc77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server0\nc77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server1\nc77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server2\nc77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server3\n```\n","source":"_posts/golang/goraft.md","raw":"---\ntitle: 'Go实现raft协议'\ndate: 2018-05-28 15:24:35\ntags: microservice\n---\n\n之前对raft算法是有所了解但无深究，偶然机会下读了下大牛的[goraft代码](https://github.com/goraft/raft) 后，决定自己实现一把。\n目前代码基本完成，本人水平有限，代码基本能用，未经严格测试，欢迎指导：[源码github地址](https://github.com/moxiaomomo/goRaft)\n以下是项目说明README：\n\n#### raft协议的go版本，实现功能包括：\n\n-  选主投票\n- 节点心跳\n- 日志同步\n- 成员变更\n- 日志压缩\n\n<!--more-->\n\n#### 存在的问题或需要解决的问题：\n\n- 完善snapshot快照同步逻辑\n- 成员变更，每次只允许变动一个节点\n- 成员变更日志，leader节点在追加持久化后即可apply\n- 非leader节点转发请求，考虑改用rpc方式\n- 改善和统一运行日志\n- 改善状态机。。。。。。\n\n#### 测试启动：\n\n在主目录下，启动多个测试节点，比如(测试配置文件中定义了三个节点):\n```bash\n$ go test -confpath raft_test0.cfg\nconfig: &{LogPrefix:raft-log- CommitIndex:0 PeerHosts:[127.0.0.1:3001 127.0.0.1:3002 127.0.0.1:3000] Host:127.0.0.1:3000 Client:127.0.0.1:4000 Name:server0}\nstate loaded: &{CommitIndex:2 Term:87 VoteFor:}\ncurrent state:follower, term:87\nlisten internal rpc address: 127.0.0.1:3000\nextra handlefunc: map[]\nlisten client address: 127.0.0.1:4000\ncurrent state:candidate, term:87\ncurrent state:leader, term:95\nTo rewrite configuration to persistent storage.\nAppendentries succeeded: 127.0.0.1:3003 Success:true Term:95 Index:4 \n```\n```bash\n$ go test -confpath raft_test1.cfg\nconfig: &{LogPrefix:raft-log- CommitIndex:0 PeerHosts:[127.0.0.1:3002 127.0.0.1:3000 127.0.0.1:3001] Host:127.0.0.1:3001 Client:127.0.0.1:4001 Name:server1}\nstate loaded: &{CommitIndex:2 Term:87 VoteFor:}\ncurrent state:follower, term:87\nextra handlefunc: map[]\nlisten client address: 127.0.0.1:4001\nlisten internal rpc address: 127.0.0.1:3001\ncurrent state:candidate, term:87\ncurrent state:follower, term:95\n```\n```bash\n$ go test -confpath raft_test2.cfg\nconfig: &{LogPrefix:raft-log- CommitIndex:0 PeerHosts:[127.0.0.1:3002 127.0.0.1:3000 127.0.0.1:3001] Host:127.0.0.1:3002 Client:127.0.0.1:4002 Name:server2}\nstate loaded: &{CommitIndex:2 Term:87 VoteFor:}\ncurrent state:follower, term:87\nlisten internal rpc address: 127.0.0.1:3002\nextra handlefunc: map[]\nlisten client address: 127.0.0.1:4002\n```\n#### 测试成员变更\n\n启动要加入集群的新节点后，随机向已组成集群的节点发送请求，比如：\n\n```bash\n添加节点：\ncurl \"http://localhost:4001/internal/join?name=server3&host=127.0.0.1:3003\"\n剔除节点：\ncurl \"http://localhost:4002/internal/leave?name=server3&host=127.0.0.1:3003\"\n```\n#### 日志同步状态检查\n\n在raft集群运行过程中，想简单检查日志log/节点状态是否一致，可直接尝试：\n\n```bash\n$ sha1sum internlog/raft-log-server*\nae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server0\nae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server1\nae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server2\nae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server3\n\n$ sha1sum internlog/state-server*\nc77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server0\nc77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server1\nc77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server2\nc77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server3\n```\n","slug":"golang/goraft","published":1,"updated":"2018-05-28T07:26:59.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dyo003z4j4d2i0kc0qm","content":"<p>之前对raft算法是有所了解但无深究，偶然机会下读了下大牛的<a href=\"https://github.com/goraft/raft\" target=\"_blank\" rel=\"external\">goraft代码</a> 后，决定自己实现一把。<br>目前代码基本完成，本人水平有限，代码基本能用，未经严格测试，欢迎指导：<a href=\"https://github.com/moxiaomomo/goRaft\" target=\"_blank\" rel=\"external\">源码github地址</a><br>以下是项目说明README：</p>\n<h4 id=\"raft协议的go版本，实现功能包括：\"><a href=\"#raft协议的go版本，实现功能包括：\" class=\"headerlink\" title=\"raft协议的go版本，实现功能包括：\"></a>raft协议的go版本，实现功能包括：</h4><ul>\n<li>选主投票</li>\n<li>节点心跳</li>\n<li>日志同步</li>\n<li>成员变更</li>\n<li>日志压缩</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"存在的问题或需要解决的问题：\"><a href=\"#存在的问题或需要解决的问题：\" class=\"headerlink\" title=\"存在的问题或需要解决的问题：\"></a>存在的问题或需要解决的问题：</h4><ul>\n<li>完善snapshot快照同步逻辑</li>\n<li>成员变更，每次只允许变动一个节点</li>\n<li>成员变更日志，leader节点在追加持久化后即可apply</li>\n<li>非leader节点转发请求，考虑改用rpc方式</li>\n<li>改善和统一运行日志</li>\n<li>改善状态机。。。。。。</li>\n</ul>\n<h4 id=\"测试启动：\"><a href=\"#测试启动：\" class=\"headerlink\" title=\"测试启动：\"></a>测试启动：</h4><p>在主目录下，启动多个测试节点，比如(测试配置文件中定义了三个节点):<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ go <span class=\"built_in\">test</span> -confpath raft_test0.cfg</div><div class=\"line\">config: &amp;&#123;LogPrefix:raft-log- CommitIndex:0 PeerHosts:[127.0.0.1:3001 127.0.0.1:3002 127.0.0.1:3000] Host:127.0.0.1:3000 Client:127.0.0.1:4000 Name:server0&#125;</div><div class=\"line\">state loaded: &amp;&#123;CommitIndex:2 Term:87 VoteFor:&#125;</div><div class=\"line\">current state:follower, term:87</div><div class=\"line\">listen internal rpc address: 127.0.0.1:3000</div><div class=\"line\">extra handlefunc: map[]</div><div class=\"line\">listen client address: 127.0.0.1:4000</div><div class=\"line\">current state:candidate, term:87</div><div class=\"line\">current state:leader, term:95</div><div class=\"line\">To rewrite configuration to persistent storage.</div><div class=\"line\">Appendentries succeeded: 127.0.0.1:3003 Success:<span class=\"literal\">true</span> Term:95 Index:4</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ go <span class=\"built_in\">test</span> -confpath raft_test1.cfg</div><div class=\"line\">config: &amp;&#123;LogPrefix:raft-log- CommitIndex:0 PeerHosts:[127.0.0.1:3002 127.0.0.1:3000 127.0.0.1:3001] Host:127.0.0.1:3001 Client:127.0.0.1:4001 Name:server1&#125;</div><div class=\"line\">state loaded: &amp;&#123;CommitIndex:2 Term:87 VoteFor:&#125;</div><div class=\"line\">current state:follower, term:87</div><div class=\"line\">extra handlefunc: map[]</div><div class=\"line\">listen client address: 127.0.0.1:4001</div><div class=\"line\">listen internal rpc address: 127.0.0.1:3001</div><div class=\"line\">current state:candidate, term:87</div><div class=\"line\">current state:follower, term:95</div></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ go <span class=\"built_in\">test</span> -confpath raft_test2.cfg</div><div class=\"line\">config: &amp;&#123;LogPrefix:raft-log- CommitIndex:0 PeerHosts:[127.0.0.1:3002 127.0.0.1:3000 127.0.0.1:3001] Host:127.0.0.1:3002 Client:127.0.0.1:4002 Name:server2&#125;</div><div class=\"line\">state loaded: &amp;&#123;CommitIndex:2 Term:87 VoteFor:&#125;</div><div class=\"line\">current state:follower, term:87</div><div class=\"line\">listen internal rpc address: 127.0.0.1:3002</div><div class=\"line\">extra handlefunc: map[]</div><div class=\"line\">listen client address: 127.0.0.1:4002</div></pre></td></tr></table></figure>\n<h4 id=\"测试成员变更\"><a href=\"#测试成员变更\" class=\"headerlink\" title=\"测试成员变更\"></a>测试成员变更</h4><p>启动要加入集群的新节点后，随机向已组成集群的节点发送请求，比如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">添加节点：</div><div class=\"line\">curl <span class=\"string\">\"http://localhost:4001/internal/join?name=server3&amp;host=127.0.0.1:3003\"</span></div><div class=\"line\">剔除节点：</div><div class=\"line\">curl <span class=\"string\">\"http://localhost:4002/internal/leave?name=server3&amp;host=127.0.0.1:3003\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"日志同步状态检查\"><a href=\"#日志同步状态检查\" class=\"headerlink\" title=\"日志同步状态检查\"></a>日志同步状态检查</h4><p>在raft集群运行过程中，想简单检查日志log/节点状态是否一致，可直接尝试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sha1sum internlog/raft-log-server*</div><div class=\"line\">ae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server0</div><div class=\"line\">ae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server1</div><div class=\"line\">ae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server2</div><div class=\"line\">ae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server3</div><div class=\"line\"></div><div class=\"line\">$ sha1sum internlog/state-server*</div><div class=\"line\">c77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server0</div><div class=\"line\">c77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server1</div><div class=\"line\">c77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server2</div><div class=\"line\">c77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server3</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>之前对raft算法是有所了解但无深究，偶然机会下读了下大牛的<a href=\"https://github.com/goraft/raft\" target=\"_blank\" rel=\"external\">goraft代码</a> 后，决定自己实现一把。<br>目前代码基本完成，本人水平有限，代码基本能用，未经严格测试，欢迎指导：<a href=\"https://github.com/moxiaomomo/goRaft\" target=\"_blank\" rel=\"external\">源码github地址</a><br>以下是项目说明README：</p>\n<h4 id=\"raft协议的go版本，实现功能包括：\"><a href=\"#raft协议的go版本，实现功能包括：\" class=\"headerlink\" title=\"raft协议的go版本，实现功能包括：\"></a>raft协议的go版本，实现功能包括：</h4><ul>\n<li>选主投票</li>\n<li>节点心跳</li>\n<li>日志同步</li>\n<li>成员变更</li>\n<li>日志压缩</li>\n</ul>","more":"<h4 id=\"存在的问题或需要解决的问题：\"><a href=\"#存在的问题或需要解决的问题：\" class=\"headerlink\" title=\"存在的问题或需要解决的问题：\"></a>存在的问题或需要解决的问题：</h4><ul>\n<li>完善snapshot快照同步逻辑</li>\n<li>成员变更，每次只允许变动一个节点</li>\n<li>成员变更日志，leader节点在追加持久化后即可apply</li>\n<li>非leader节点转发请求，考虑改用rpc方式</li>\n<li>改善和统一运行日志</li>\n<li>改善状态机。。。。。。</li>\n</ul>\n<h4 id=\"测试启动：\"><a href=\"#测试启动：\" class=\"headerlink\" title=\"测试启动：\"></a>测试启动：</h4><p>在主目录下，启动多个测试节点，比如(测试配置文件中定义了三个节点):<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ go <span class=\"built_in\">test</span> -confpath raft_test0.cfg</div><div class=\"line\">config: &amp;&#123;LogPrefix:raft-log- CommitIndex:0 PeerHosts:[127.0.0.1:3001 127.0.0.1:3002 127.0.0.1:3000] Host:127.0.0.1:3000 Client:127.0.0.1:4000 Name:server0&#125;</div><div class=\"line\">state loaded: &amp;&#123;CommitIndex:2 Term:87 VoteFor:&#125;</div><div class=\"line\">current state:follower, term:87</div><div class=\"line\">listen internal rpc address: 127.0.0.1:3000</div><div class=\"line\">extra handlefunc: map[]</div><div class=\"line\">listen client address: 127.0.0.1:4000</div><div class=\"line\">current state:candidate, term:87</div><div class=\"line\">current state:leader, term:95</div><div class=\"line\">To rewrite configuration to persistent storage.</div><div class=\"line\">Appendentries succeeded: 127.0.0.1:3003 Success:<span class=\"literal\">true</span> Term:95 Index:4</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ go <span class=\"built_in\">test</span> -confpath raft_test1.cfg</div><div class=\"line\">config: &amp;&#123;LogPrefix:raft-log- CommitIndex:0 PeerHosts:[127.0.0.1:3002 127.0.0.1:3000 127.0.0.1:3001] Host:127.0.0.1:3001 Client:127.0.0.1:4001 Name:server1&#125;</div><div class=\"line\">state loaded: &amp;&#123;CommitIndex:2 Term:87 VoteFor:&#125;</div><div class=\"line\">current state:follower, term:87</div><div class=\"line\">extra handlefunc: map[]</div><div class=\"line\">listen client address: 127.0.0.1:4001</div><div class=\"line\">listen internal rpc address: 127.0.0.1:3001</div><div class=\"line\">current state:candidate, term:87</div><div class=\"line\">current state:follower, term:95</div></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ go <span class=\"built_in\">test</span> -confpath raft_test2.cfg</div><div class=\"line\">config: &amp;&#123;LogPrefix:raft-log- CommitIndex:0 PeerHosts:[127.0.0.1:3002 127.0.0.1:3000 127.0.0.1:3001] Host:127.0.0.1:3002 Client:127.0.0.1:4002 Name:server2&#125;</div><div class=\"line\">state loaded: &amp;&#123;CommitIndex:2 Term:87 VoteFor:&#125;</div><div class=\"line\">current state:follower, term:87</div><div class=\"line\">listen internal rpc address: 127.0.0.1:3002</div><div class=\"line\">extra handlefunc: map[]</div><div class=\"line\">listen client address: 127.0.0.1:4002</div></pre></td></tr></table></figure>\n<h4 id=\"测试成员变更\"><a href=\"#测试成员变更\" class=\"headerlink\" title=\"测试成员变更\"></a>测试成员变更</h4><p>启动要加入集群的新节点后，随机向已组成集群的节点发送请求，比如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">添加节点：</div><div class=\"line\">curl <span class=\"string\">\"http://localhost:4001/internal/join?name=server3&amp;host=127.0.0.1:3003\"</span></div><div class=\"line\">剔除节点：</div><div class=\"line\">curl <span class=\"string\">\"http://localhost:4002/internal/leave?name=server3&amp;host=127.0.0.1:3003\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"日志同步状态检查\"><a href=\"#日志同步状态检查\" class=\"headerlink\" title=\"日志同步状态检查\"></a>日志同步状态检查</h4><p>在raft集群运行过程中，想简单检查日志log/节点状态是否一致，可直接尝试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sha1sum internlog/raft-log-server*</div><div class=\"line\">ae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server0</div><div class=\"line\">ae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server1</div><div class=\"line\">ae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server2</div><div class=\"line\">ae58578bc6513c96eb79714c45cddadbbc2d7eb9  internlog/raft-log-server3</div><div class=\"line\"></div><div class=\"line\">$ sha1sum internlog/state-server*</div><div class=\"line\">c77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server0</div><div class=\"line\">c77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server1</div><div class=\"line\">c77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server2</div><div class=\"line\">c77e5ac4aefd215f212e083e32ada9087bd3a7d5  internlog/state-server3</div></pre></td></tr></table></figure>"},{"title":"grpc-jaeger调用链跟踪模块","date":"2018-06-17T09:04:05.000Z","_content":"\n# grpc-jaeger说明\n\n具体源码可参考[我的github源码][1]\n\ngrpc-jaeger是基于Go的针对gRPC的一种拦截器实现，用于结合jaeger来实现rpc调用链跟踪；可用于集成到微服务的分布式trace功能中。\n\ngrpc包中对外暴露了两个接口：grpc.UnaryClientInterceptor及grpc.UnaryServerInterceptor， 只要将这两个函数重写即可以自定义拦截器，从而注入jaeger相关跟踪代码。\n\n<!--more-->\n\n# grpc-jaeger源依赖\n\n```\ngoogle.golang.org/grpc\ngithub.com/opentracing/opentracing-go\ngithub.com/uber/jaeger-client-go\n```\n\n# grpc-jaeger使用示例\n\n- 在grpc client端，添加grpc-jaeger\n\n```golang\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\n\tgtrace \"github.com/moxiaomomo/grpc-jaeger\"\n\t\"google.golang.org/grpc\"\n)\n\nfunc rpcCli(dialOpts []grpc.DialOption) {\n\t\tconn, err := grpc.Dial(\"127.0.0.1:8001\", dialOpts...)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"grpc connect failed, err:%+v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\t\t\n\t\t// TODO: do some rpc-call\n\t\t// ...\n}\n\nfunc main() {\n\t\tdialOpts := []grpc.DialOption{grpc.WithInsecure()}\n\t\ttracer, _, err := gtrace.NewJaegerTracer(\"testCli\", \"127.0.0.1:6831\")\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"new tracer err: %+v\\n\", err)\n\t\t\tos.Exit(-1)\n\t\t}\n\n\t\tif tracer != nil {\n\t\t\tdialOpts = append(dialOpts, gtrace.DialOption(tracer))\n\t\t}\n\t\t// do rpc-call with dialOpts\n\t\trpcCli(dialOpts)\n}\n```\n\n- 在grpc server端，添加grpc-jaeger\n\n```golang\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\n\tgtrace \"github.com/moxiaomomo/grpc-jaeger\"\n\t\"google.golang.org/grpc\"\n)\n\nfunc main() {\n\tvar servOpts []grpc.ServerOption\n\ttracer, _, err := gtrace.NewJaegerTracer(\"testSrv\", \"127.0.0.1:6831\")\n\tif err != nil {\n\t\tfmt.Printf(\"new tracer err: %+v\\n\", err)\n\t\tos.Exit(-1)\n\t}\n\tif tracer != nil {\n\t\tservOpts = append(servOpts, gtrace.ServerOption(tracer))\n\t}\n\tsvr := grpc.NewServer(servOpts...)\n\t// TODO: register some rpc-service to grpc server\n\t\n\tln, err := net.Listen(\"tcp\", \"127.0.0.1:8001\")\n\tif err != nil {\n\t\tos.Exit(-1)\n\t}\n\tsvr.Serve(ln)\n}\n```\n\n# 结合jaeger服务进行测试\n\n## 1）部署jaeger\n\n假设在某个节点已部署好jaeger测试服务，<br>\njaeger-agent地址为`192.168.1.100:6831`，<br>\njaeger-ui地址为`http://192.168.1.100:16686/`。\n\n## 2）运行测试\n\n具体测试用例在wrapper_test.go中，可直接在该文件当前目录中运行`go test`\n\n```bash\ntest@MG:/yourpath/grpc-jaeger$ go test\n2018/06/17 15:06:05 Initializing logging reporter\n2018/06/17 15:06:06 Initializing logging reporter\nSayHello Called.\n2018/06/17 15:06:06 Reporting span 107bf923fcfc238e:1f607766f1329efd:107bf923fcfc238e:1\n2018/06/17 15:06:06 Reporting span 107bf923fcfc238e:107bf923fcfc238e:0:1\ncall sayhello suc, res:message:\"Hi im tester\\n\"\nPASS\nok  \tgithub.com/moxiaomomo/grpc-jaeger\t3.004s\n```\n\n## 3）查看jaegerUI\n打开`http://192.168.1.100:16686/`后查询对应Service， 可看到以下跟踪结果：![jaegerUI][2]\n\n  [1]: http://github.com/moxiaomomo/grpc-jaeger\n  [2]: https://github.com/moxiaomomo/grpc-jaeger/blob/master/jaegerui.png?raw=true\n","source":"_posts/golang/grpc-jaeger.md","raw":"---\ntitle: grpc-jaeger调用链跟踪模块\ndate: 2018-06-17 17:04:05\ntags: [\"golang\",\"tracing\"]\n---\n\n# grpc-jaeger说明\n\n具体源码可参考[我的github源码][1]\n\ngrpc-jaeger是基于Go的针对gRPC的一种拦截器实现，用于结合jaeger来实现rpc调用链跟踪；可用于集成到微服务的分布式trace功能中。\n\ngrpc包中对外暴露了两个接口：grpc.UnaryClientInterceptor及grpc.UnaryServerInterceptor， 只要将这两个函数重写即可以自定义拦截器，从而注入jaeger相关跟踪代码。\n\n<!--more-->\n\n# grpc-jaeger源依赖\n\n```\ngoogle.golang.org/grpc\ngithub.com/opentracing/opentracing-go\ngithub.com/uber/jaeger-client-go\n```\n\n# grpc-jaeger使用示例\n\n- 在grpc client端，添加grpc-jaeger\n\n```golang\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\n\tgtrace \"github.com/moxiaomomo/grpc-jaeger\"\n\t\"google.golang.org/grpc\"\n)\n\nfunc rpcCli(dialOpts []grpc.DialOption) {\n\t\tconn, err := grpc.Dial(\"127.0.0.1:8001\", dialOpts...)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"grpc connect failed, err:%+v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\t\t\n\t\t// TODO: do some rpc-call\n\t\t// ...\n}\n\nfunc main() {\n\t\tdialOpts := []grpc.DialOption{grpc.WithInsecure()}\n\t\ttracer, _, err := gtrace.NewJaegerTracer(\"testCli\", \"127.0.0.1:6831\")\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"new tracer err: %+v\\n\", err)\n\t\t\tos.Exit(-1)\n\t\t}\n\n\t\tif tracer != nil {\n\t\t\tdialOpts = append(dialOpts, gtrace.DialOption(tracer))\n\t\t}\n\t\t// do rpc-call with dialOpts\n\t\trpcCli(dialOpts)\n}\n```\n\n- 在grpc server端，添加grpc-jaeger\n\n```golang\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\n\tgtrace \"github.com/moxiaomomo/grpc-jaeger\"\n\t\"google.golang.org/grpc\"\n)\n\nfunc main() {\n\tvar servOpts []grpc.ServerOption\n\ttracer, _, err := gtrace.NewJaegerTracer(\"testSrv\", \"127.0.0.1:6831\")\n\tif err != nil {\n\t\tfmt.Printf(\"new tracer err: %+v\\n\", err)\n\t\tos.Exit(-1)\n\t}\n\tif tracer != nil {\n\t\tservOpts = append(servOpts, gtrace.ServerOption(tracer))\n\t}\n\tsvr := grpc.NewServer(servOpts...)\n\t// TODO: register some rpc-service to grpc server\n\t\n\tln, err := net.Listen(\"tcp\", \"127.0.0.1:8001\")\n\tif err != nil {\n\t\tos.Exit(-1)\n\t}\n\tsvr.Serve(ln)\n}\n```\n\n# 结合jaeger服务进行测试\n\n## 1）部署jaeger\n\n假设在某个节点已部署好jaeger测试服务，<br>\njaeger-agent地址为`192.168.1.100:6831`，<br>\njaeger-ui地址为`http://192.168.1.100:16686/`。\n\n## 2）运行测试\n\n具体测试用例在wrapper_test.go中，可直接在该文件当前目录中运行`go test`\n\n```bash\ntest@MG:/yourpath/grpc-jaeger$ go test\n2018/06/17 15:06:05 Initializing logging reporter\n2018/06/17 15:06:06 Initializing logging reporter\nSayHello Called.\n2018/06/17 15:06:06 Reporting span 107bf923fcfc238e:1f607766f1329efd:107bf923fcfc238e:1\n2018/06/17 15:06:06 Reporting span 107bf923fcfc238e:107bf923fcfc238e:0:1\ncall sayhello suc, res:message:\"Hi im tester\\n\"\nPASS\nok  \tgithub.com/moxiaomomo/grpc-jaeger\t3.004s\n```\n\n## 3）查看jaegerUI\n打开`http://192.168.1.100:16686/`后查询对应Service， 可看到以下跟踪结果：![jaegerUI][2]\n\n  [1]: http://github.com/moxiaomomo/grpc-jaeger\n  [2]: https://github.com/moxiaomomo/grpc-jaeger/blob/master/jaegerui.png?raw=true\n","slug":"golang/grpc-jaeger","published":1,"updated":"2018-06-18T09:07:38.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dyp00414j4dlzrtffrs","content":"<h1 id=\"grpc-jaeger说明\"><a href=\"#grpc-jaeger说明\" class=\"headerlink\" title=\"grpc-jaeger说明\"></a>grpc-jaeger说明</h1><p>具体源码可参考<a href=\"http://github.com/moxiaomomo/grpc-jaeger\" target=\"_blank\" rel=\"external\">我的github源码</a></p>\n<p>grpc-jaeger是基于Go的针对gRPC的一种拦截器实现，用于结合jaeger来实现rpc调用链跟踪；可用于集成到微服务的分布式trace功能中。</p>\n<p>grpc包中对外暴露了两个接口：grpc.UnaryClientInterceptor及grpc.UnaryServerInterceptor， 只要将这两个函数重写即可以自定义拦截器，从而注入jaeger相关跟踪代码。</p>\n<a id=\"more\"></a>\n<h1 id=\"grpc-jaeger源依赖\"><a href=\"#grpc-jaeger源依赖\" class=\"headerlink\" title=\"grpc-jaeger源依赖\"></a>grpc-jaeger源依赖</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">google.golang.org/grpc</div><div class=\"line\">github.com/opentracing/opentracing-go</div><div class=\"line\">github.com/uber/jaeger-client-go</div></pre></td></tr></table></figure>\n<h1 id=\"grpc-jaeger使用示例\"><a href=\"#grpc-jaeger使用示例\" class=\"headerlink\" title=\"grpc-jaeger使用示例\"></a>grpc-jaeger使用示例</h1><ul>\n<li>在grpc client端，添加grpc-jaeger</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"os\"</span></div><div class=\"line\">\t</div><div class=\"line\">\tgtrace <span class=\"string\">\"github.com/moxiaomomo/grpc-jaeger\"</span></div><div class=\"line\">\t<span class=\"string\">\"google.golang.org/grpc\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rpcCli</span><span class=\"params\">(dialOpts []grpc.DialOption)</span></span> &#123;</div><div class=\"line\">\t\tconn, err := grpc.Dial(<span class=\"string\">\"127.0.0.1:8001\"</span>, dialOpts...)</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">\"grpc connect failed, err:%+v\\n\"</span>, err)</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">defer</span> conn.Close()</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> do some rpc-call</span></div><div class=\"line\">\t\t<span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t\tdialOpts := []grpc.DialOption&#123;grpc.WithInsecure()&#125;</div><div class=\"line\">\t\ttracer, _, err := gtrace.NewJaegerTracer(<span class=\"string\">\"testCli\"</span>, <span class=\"string\">\"127.0.0.1:6831\"</span>)</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">\"new tracer err: %+v\\n\"</span>, err)</div><div class=\"line\">\t\t\tos.Exit(<span class=\"number\">-1</span>)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> tracer != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\tdialOpts = <span class=\"built_in\">append</span>(dialOpts, gtrace.DialOption(tracer))</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">// do rpc-call with dialOpts</span></div><div class=\"line\">\t\trpcCli(dialOpts)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>在grpc server端，添加grpc-jaeger</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"os\"</span></div><div class=\"line\">\t</div><div class=\"line\">\tgtrace <span class=\"string\">\"github.com/moxiaomomo/grpc-jaeger\"</span></div><div class=\"line\">\t<span class=\"string\">\"google.golang.org/grpc\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> servOpts []grpc.ServerOption</div><div class=\"line\">\ttracer, _, err := gtrace.NewJaegerTracer(<span class=\"string\">\"testSrv\"</span>, <span class=\"string\">\"127.0.0.1:6831\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"new tracer err: %+v\\n\"</span>, err)</div><div class=\"line\">\t\tos.Exit(<span class=\"number\">-1</span>)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">if</span> tracer != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tservOpts = <span class=\"built_in\">append</span>(servOpts, gtrace.ServerOption(tracer))</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tsvr := grpc.NewServer(servOpts...)</div><div class=\"line\">\t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> register some rpc-service to grpc server</span></div><div class=\"line\">\t</div><div class=\"line\">\tln, err := net.Listen(<span class=\"string\">\"tcp\"</span>, <span class=\"string\">\"127.0.0.1:8001\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tos.Exit(<span class=\"number\">-1</span>)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tsvr.Serve(ln)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"结合jaeger服务进行测试\"><a href=\"#结合jaeger服务进行测试\" class=\"headerlink\" title=\"结合jaeger服务进行测试\"></a>结合jaeger服务进行测试</h1><h2 id=\"1）部署jaeger\"><a href=\"#1）部署jaeger\" class=\"headerlink\" title=\"1）部署jaeger\"></a>1）部署jaeger</h2><p>假设在某个节点已部署好jaeger测试服务，<br><br>jaeger-agent地址为<code>192.168.1.100:6831</code>，<br><br>jaeger-ui地址为<code>http://192.168.1.100:16686/</code>。</p>\n<h2 id=\"2）运行测试\"><a href=\"#2）运行测试\" class=\"headerlink\" title=\"2）运行测试\"></a>2）运行测试</h2><p>具体测试用例在wrapper_test.go中，可直接在该文件当前目录中运行<code>go test</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">test</span>@MG:/yourpath/grpc-jaeger$ go <span class=\"built_in\">test</span></div><div class=\"line\">2018/06/17 15:06:05 Initializing logging reporter</div><div class=\"line\">2018/06/17 15:06:06 Initializing logging reporter</div><div class=\"line\">SayHello Called.</div><div class=\"line\">2018/06/17 15:06:06 Reporting span 107bf923fcfc238e:1f607766f1329efd:107bf923fcfc238e:1</div><div class=\"line\">2018/06/17 15:06:06 Reporting span 107bf923fcfc238e:107bf923fcfc238e:0:1</div><div class=\"line\">call sayhello suc, res:message:<span class=\"string\">\"Hi im tester\\n\"</span></div><div class=\"line\">PASS</div><div class=\"line\">ok  \tgithub.com/moxiaomomo/grpc-jaeger\t3.004s</div></pre></td></tr></table></figure>\n<h2 id=\"3）查看jaegerUI\"><a href=\"#3）查看jaegerUI\" class=\"headerlink\" title=\"3）查看jaegerUI\"></a>3）查看jaegerUI</h2><p>打开<code>http://192.168.1.100:16686/</code>后查询对应Service， 可看到以下跟踪结果：<img src=\"https://github.com/moxiaomomo/grpc-jaeger/blob/master/jaegerui.png?raw=true\" alt=\"jaegerUI\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"grpc-jaeger说明\"><a href=\"#grpc-jaeger说明\" class=\"headerlink\" title=\"grpc-jaeger说明\"></a>grpc-jaeger说明</h1><p>具体源码可参考<a href=\"http://github.com/moxiaomomo/grpc-jaeger\" target=\"_blank\" rel=\"external\">我的github源码</a></p>\n<p>grpc-jaeger是基于Go的针对gRPC的一种拦截器实现，用于结合jaeger来实现rpc调用链跟踪；可用于集成到微服务的分布式trace功能中。</p>\n<p>grpc包中对外暴露了两个接口：grpc.UnaryClientInterceptor及grpc.UnaryServerInterceptor， 只要将这两个函数重写即可以自定义拦截器，从而注入jaeger相关跟踪代码。</p>","more":"<h1 id=\"grpc-jaeger源依赖\"><a href=\"#grpc-jaeger源依赖\" class=\"headerlink\" title=\"grpc-jaeger源依赖\"></a>grpc-jaeger源依赖</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">google.golang.org/grpc</div><div class=\"line\">github.com/opentracing/opentracing-go</div><div class=\"line\">github.com/uber/jaeger-client-go</div></pre></td></tr></table></figure>\n<h1 id=\"grpc-jaeger使用示例\"><a href=\"#grpc-jaeger使用示例\" class=\"headerlink\" title=\"grpc-jaeger使用示例\"></a>grpc-jaeger使用示例</h1><ul>\n<li>在grpc client端，添加grpc-jaeger</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"os\"</span></div><div class=\"line\">\t</div><div class=\"line\">\tgtrace <span class=\"string\">\"github.com/moxiaomomo/grpc-jaeger\"</span></div><div class=\"line\">\t<span class=\"string\">\"google.golang.org/grpc\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rpcCli</span><span class=\"params\">(dialOpts []grpc.DialOption)</span></span> &#123;</div><div class=\"line\">\t\tconn, err := grpc.Dial(<span class=\"string\">\"127.0.0.1:8001\"</span>, dialOpts...)</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">\"grpc connect failed, err:%+v\\n\"</span>, err)</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">defer</span> conn.Close()</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> do some rpc-call</span></div><div class=\"line\">\t\t<span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t\tdialOpts := []grpc.DialOption&#123;grpc.WithInsecure()&#125;</div><div class=\"line\">\t\ttracer, _, err := gtrace.NewJaegerTracer(<span class=\"string\">\"testCli\"</span>, <span class=\"string\">\"127.0.0.1:6831\"</span>)</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">\"new tracer err: %+v\\n\"</span>, err)</div><div class=\"line\">\t\t\tos.Exit(<span class=\"number\">-1</span>)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> tracer != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\tdialOpts = <span class=\"built_in\">append</span>(dialOpts, gtrace.DialOption(tracer))</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">// do rpc-call with dialOpts</span></div><div class=\"line\">\t\trpcCli(dialOpts)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>在grpc server端，添加grpc-jaeger</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"os\"</span></div><div class=\"line\">\t</div><div class=\"line\">\tgtrace <span class=\"string\">\"github.com/moxiaomomo/grpc-jaeger\"</span></div><div class=\"line\">\t<span class=\"string\">\"google.golang.org/grpc\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> servOpts []grpc.ServerOption</div><div class=\"line\">\ttracer, _, err := gtrace.NewJaegerTracer(<span class=\"string\">\"testSrv\"</span>, <span class=\"string\">\"127.0.0.1:6831\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"new tracer err: %+v\\n\"</span>, err)</div><div class=\"line\">\t\tos.Exit(<span class=\"number\">-1</span>)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">if</span> tracer != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tservOpts = <span class=\"built_in\">append</span>(servOpts, gtrace.ServerOption(tracer))</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tsvr := grpc.NewServer(servOpts...)</div><div class=\"line\">\t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> register some rpc-service to grpc server</span></div><div class=\"line\">\t</div><div class=\"line\">\tln, err := net.Listen(<span class=\"string\">\"tcp\"</span>, <span class=\"string\">\"127.0.0.1:8001\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tos.Exit(<span class=\"number\">-1</span>)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tsvr.Serve(ln)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"结合jaeger服务进行测试\"><a href=\"#结合jaeger服务进行测试\" class=\"headerlink\" title=\"结合jaeger服务进行测试\"></a>结合jaeger服务进行测试</h1><h2 id=\"1）部署jaeger\"><a href=\"#1）部署jaeger\" class=\"headerlink\" title=\"1）部署jaeger\"></a>1）部署jaeger</h2><p>假设在某个节点已部署好jaeger测试服务，<br><br>jaeger-agent地址为<code>192.168.1.100:6831</code>，<br><br>jaeger-ui地址为<code>http://192.168.1.100:16686/</code>。</p>\n<h2 id=\"2）运行测试\"><a href=\"#2）运行测试\" class=\"headerlink\" title=\"2）运行测试\"></a>2）运行测试</h2><p>具体测试用例在wrapper_test.go中，可直接在该文件当前目录中运行<code>go test</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">test</span>@MG:/yourpath/grpc-jaeger$ go <span class=\"built_in\">test</span></div><div class=\"line\">2018/06/17 15:06:05 Initializing logging reporter</div><div class=\"line\">2018/06/17 15:06:06 Initializing logging reporter</div><div class=\"line\">SayHello Called.</div><div class=\"line\">2018/06/17 15:06:06 Reporting span 107bf923fcfc238e:1f607766f1329efd:107bf923fcfc238e:1</div><div class=\"line\">2018/06/17 15:06:06 Reporting span 107bf923fcfc238e:107bf923fcfc238e:0:1</div><div class=\"line\">call sayhello suc, res:message:<span class=\"string\">\"Hi im tester\\n\"</span></div><div class=\"line\">PASS</div><div class=\"line\">ok  \tgithub.com/moxiaomomo/grpc-jaeger\t3.004s</div></pre></td></tr></table></figure>\n<h2 id=\"3）查看jaegerUI\"><a href=\"#3）查看jaegerUI\" class=\"headerlink\" title=\"3）查看jaegerUI\"></a>3）查看jaegerUI</h2><p>打开<code>http://192.168.1.100:16686/</code>后查询对应Service， 可看到以下跟踪结果：<img src=\"https://github.com/moxiaomomo/grpc-jaeger/blob/master/jaegerui.png?raw=true\" alt=\"jaegerUI\"></p>"},{"title":"golang并发下载文件","date":"2018-01-03T09:43:52.000Z","_content":"\n#### 背景说明\n假设有一个分布式文件系统，现需要从该系统中并发下载一部分文件到本地机器。\n已知该文件系统的部分节点ip, 以及需要下载的文件fileID列表，并能通过这些信息来拼接下载地址。\n其中节点ip列表保存在xx_node.txt， 要下载的fileID保存在xx_fileID.txt中。\n\n<!--more-->\n#### 代码示例\n```golang\npackage main\n\nimport (\n\t\"bufio\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nvar (\n\tclustername = flag.String(\"clustername\", \"c1\", \"download clustername\")\n)\n\n// 逐行读取文件内容\nfunc ReadLines(fpath string) []string {\n\tfd, err := os.Open(fpath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer fd.Close()\n\n\tvar lines []string\n\tscanner := bufio.NewScanner(fd)\n\tfor scanner.Scan() {\n\t\tlines = append(lines, scanner.Text())\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t}\n\n\treturn lines\n}\n\n// 实现单个文件的下载\nfunc Download(clustername string, node string, fileID string) string {\n\tnt := time.Now().Format(\"2006-01-02 15:04:05\")\n\tfmt.Printf(\"[%s]To download %s\\n\", nt, fileID)\n\n\turl := fmt.Sprintf(\"http://%s/file/%s\", node, fileID)\n\tfpath := fmt.Sprintf(\"/yourpath/download/%s_%s\", clustername, fileID)\n\tnewFile, err := os.Create(fpath)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn \"process failed for \" + fileID\n\t}\n\tdefer newFile.Close()\n\n\tclient := http.Client{Timeout: 900 * time.Second}\n\tresp, err := client.Get(url)\n\tdefer resp.Body.Close()\n\n\t_, err = io.Copy(newFile, resp.Body)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t}\n\treturn fileID\n}\n\nfunc main() {\n\tflag.Parse()\n\t\n\t// 从文件中读取节点ip列表\n\tnodelist := ReadLines(fmt.Sprintf(\"%s_node.txt\", *clustername))\n\tif len(nodelist) == 0 {\n\t\treturn\n\t}\n\t\n\t// 从文件中读取待下载的文件ID列表\n\tfileIDlist := ReadLines(fmt.Sprintf(\"%s_fileID.txt\", *clustername))\n\tif len(fileIDlist) == 0 {\n\t\treturn\n\t}\n\n\tch := make(chan string)\n\t\n\t// 每个goroutine处理一个文件的下载\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\tfor _, fileID := range fileIDlist {\n\t\tnode := nodelist[r.Intn(len(nodelist))]\n\t\tgo func(node, fileID string) {\n\t\t\tch <- Download(*clustername, node, fileID)\n\t\t}(node, fileID)\n\t}\n\t\n\t// 等待每个文件下载的完成，并检查超时\n\ttimeout := time.After(900 * time.Second)\n\tfor idx := 0; idx < len(fileIDlist); idx++ {\n\t\tselect {\n\t\tcase res := <-ch:\n\t\t\tnt := time.Now().Format(\"2006-01-02 15:04:05\")\n\t\t\tfmt.Printf(\"[%s]Finish download %s\\n\", nt, res)\n\t\tcase <-timeout:\n\t\t\tfmt.Println(\"Timeout...\")\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n#### 小结\n下载时没有用到默认的http Client, 并指定了超时时间；\n下载文件时调用了系统调用, goroutine会被挂起；\n下载文件完成后会唤醒被挂起的goroutine, 该goroutine执行完后面的代码后便退出；\n全局超时控制，超时后主线程退出。\n","source":"_posts/golang/parallel-download-file-md.md","raw":"---\ntitle: 'golang并发下载文件'\ndate: 2018-01-03 17:43:52\ntags: golang\n---\n\n#### 背景说明\n假设有一个分布式文件系统，现需要从该系统中并发下载一部分文件到本地机器。\n已知该文件系统的部分节点ip, 以及需要下载的文件fileID列表，并能通过这些信息来拼接下载地址。\n其中节点ip列表保存在xx_node.txt， 要下载的fileID保存在xx_fileID.txt中。\n\n<!--more-->\n#### 代码示例\n```golang\npackage main\n\nimport (\n\t\"bufio\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nvar (\n\tclustername = flag.String(\"clustername\", \"c1\", \"download clustername\")\n)\n\n// 逐行读取文件内容\nfunc ReadLines(fpath string) []string {\n\tfd, err := os.Open(fpath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer fd.Close()\n\n\tvar lines []string\n\tscanner := bufio.NewScanner(fd)\n\tfor scanner.Scan() {\n\t\tlines = append(lines, scanner.Text())\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t}\n\n\treturn lines\n}\n\n// 实现单个文件的下载\nfunc Download(clustername string, node string, fileID string) string {\n\tnt := time.Now().Format(\"2006-01-02 15:04:05\")\n\tfmt.Printf(\"[%s]To download %s\\n\", nt, fileID)\n\n\turl := fmt.Sprintf(\"http://%s/file/%s\", node, fileID)\n\tfpath := fmt.Sprintf(\"/yourpath/download/%s_%s\", clustername, fileID)\n\tnewFile, err := os.Create(fpath)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn \"process failed for \" + fileID\n\t}\n\tdefer newFile.Close()\n\n\tclient := http.Client{Timeout: 900 * time.Second}\n\tresp, err := client.Get(url)\n\tdefer resp.Body.Close()\n\n\t_, err = io.Copy(newFile, resp.Body)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t}\n\treturn fileID\n}\n\nfunc main() {\n\tflag.Parse()\n\t\n\t// 从文件中读取节点ip列表\n\tnodelist := ReadLines(fmt.Sprintf(\"%s_node.txt\", *clustername))\n\tif len(nodelist) == 0 {\n\t\treturn\n\t}\n\t\n\t// 从文件中读取待下载的文件ID列表\n\tfileIDlist := ReadLines(fmt.Sprintf(\"%s_fileID.txt\", *clustername))\n\tif len(fileIDlist) == 0 {\n\t\treturn\n\t}\n\n\tch := make(chan string)\n\t\n\t// 每个goroutine处理一个文件的下载\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\tfor _, fileID := range fileIDlist {\n\t\tnode := nodelist[r.Intn(len(nodelist))]\n\t\tgo func(node, fileID string) {\n\t\t\tch <- Download(*clustername, node, fileID)\n\t\t}(node, fileID)\n\t}\n\t\n\t// 等待每个文件下载的完成，并检查超时\n\ttimeout := time.After(900 * time.Second)\n\tfor idx := 0; idx < len(fileIDlist); idx++ {\n\t\tselect {\n\t\tcase res := <-ch:\n\t\t\tnt := time.Now().Format(\"2006-01-02 15:04:05\")\n\t\t\tfmt.Printf(\"[%s]Finish download %s\\n\", nt, res)\n\t\tcase <-timeout:\n\t\t\tfmt.Println(\"Timeout...\")\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n#### 小结\n下载时没有用到默认的http Client, 并指定了超时时间；\n下载文件时调用了系统调用, goroutine会被挂起；\n下载文件完成后会唤醒被挂起的goroutine, 该goroutine执行完后面的代码后便退出；\n全局超时控制，超时后主线程退出。\n","slug":"golang/parallel-download-file-md","published":1,"updated":"2018-01-03T09:44:41.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dyq00434j4dovc4vyfs","content":"<h4 id=\"背景说明\"><a href=\"#背景说明\" class=\"headerlink\" title=\"背景说明\"></a>背景说明</h4><p>假设有一个分布式文件系统，现需要从该系统中并发下载一部分文件到本地机器。<br>已知该文件系统的部分节点ip, 以及需要下载的文件fileID列表，并能通过这些信息来拼接下载地址。<br>其中节点ip列表保存在xx_node.txt， 要下载的fileID保存在xx_fileID.txt中。</p>\n<a id=\"more\"></a>\n<h4 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"bufio\"</span></div><div class=\"line\">\t<span class=\"string\">\"flag\"</span></div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"io\"</span></div><div class=\"line\">\t<span class=\"string\">\"math/rand\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/http\"</span></div><div class=\"line\">\t<span class=\"string\">\"os\"</span></div><div class=\"line\">\t<span class=\"string\">\"time\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">\tclustername = flag.String(<span class=\"string\">\"clustername\"</span>, <span class=\"string\">\"c1\"</span>, <span class=\"string\">\"download clustername\"</span>)</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 逐行读取文件内容</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadLines</span><span class=\"params\">(fpath <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123;</div><div class=\"line\">\tfd, err := os.Open(fpath)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> fd.Close()</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> lines []<span class=\"keyword\">string</span></div><div class=\"line\">\tscanner := bufio.NewScanner(fd)</div><div class=\"line\">\t<span class=\"keyword\">for</span> scanner.Scan() &#123;</div><div class=\"line\">\t\tlines = <span class=\"built_in\">append</span>(lines, scanner.Text())</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">if</span> err := scanner.Err(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Fprintln(os.Stderr, err)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> lines</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 实现单个文件的下载</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Download</span><span class=\"params\">(clustername <span class=\"keyword\">string</span>, node <span class=\"keyword\">string</span>, fileID <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">\tnt := time.Now().Format(<span class=\"string\">\"2006-01-02 15:04:05\"</span>)</div><div class=\"line\">\tfmt.Printf(<span class=\"string\">\"[%s]To download %s\\n\"</span>, nt, fileID)</div><div class=\"line\"></div><div class=\"line\">\turl := fmt.Sprintf(<span class=\"string\">\"http://%s/file/%s\"</span>, node, fileID)</div><div class=\"line\">\tfpath := fmt.Sprintf(<span class=\"string\">\"/yourpath/download/%s_%s\"</span>, clustername, fileID)</div><div class=\"line\">\tnewFile, err := os.Create(fpath)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Println(err.Error())</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"process failed for \"</span> + fileID</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> newFile.Close()</div><div class=\"line\"></div><div class=\"line\">\tclient := http.Client&#123;Timeout: <span class=\"number\">900</span> * time.Second&#125;</div><div class=\"line\">\tresp, err := client.Get(url)</div><div class=\"line\">\t<span class=\"keyword\">defer</span> resp.Body.Close()</div><div class=\"line\"></div><div class=\"line\">\t_, err = io.Copy(newFile, resp.Body)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Println(err.Error())</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> fileID</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tflag.Parse()</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">// 从文件中读取节点ip列表</span></div><div class=\"line\">\tnodelist := ReadLines(fmt.Sprintf(<span class=\"string\">\"%s_node.txt\"</span>, *clustername))</div><div class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(nodelist) == <span class=\"number\">0</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">// 从文件中读取待下载的文件ID列表</span></div><div class=\"line\">\tfileIDlist := ReadLines(fmt.Sprintf(<span class=\"string\">\"%s_fileID.txt\"</span>, *clustername))</div><div class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(fileIDlist) == <span class=\"number\">0</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>)</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">// 每个goroutine处理一个文件的下载</span></div><div class=\"line\">\tr := rand.New(rand.NewSource(time.Now().UnixNano()))</div><div class=\"line\">\t<span class=\"keyword\">for</span> _, fileID := <span class=\"keyword\">range</span> fileIDlist &#123;</div><div class=\"line\">\t\tnode := nodelist[r.Intn(<span class=\"built_in\">len</span>(nodelist))]</div><div class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(node, fileID <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">\t\t\tch &lt;- Download(*clustername, node, fileID)</div><div class=\"line\">\t\t&#125;(node, fileID)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">// 等待每个文件下载的完成，并检查超时</span></div><div class=\"line\">\ttimeout := time.After(<span class=\"number\">900</span> * time.Second)</div><div class=\"line\">\t<span class=\"keyword\">for</span> idx := <span class=\"number\">0</span>; idx &lt; <span class=\"built_in\">len</span>(fileIDlist); idx++ &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">select</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> res := &lt;-ch:</div><div class=\"line\">\t\t\tnt := time.Now().Format(<span class=\"string\">\"2006-01-02 15:04:05\"</span>)</div><div class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">\"[%s]Finish download %s\\n\"</span>, nt, res)</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> &lt;-timeout:</div><div class=\"line\">\t\t\tfmt.Println(<span class=\"string\">\"Timeout...\"</span>)</div><div class=\"line\">\t\t\t<span class=\"keyword\">break</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>下载时没有用到默认的http Client, 并指定了超时时间；<br>下载文件时调用了系统调用, goroutine会被挂起；<br>下载文件完成后会唤醒被挂起的goroutine, 该goroutine执行完后面的代码后便退出；<br>全局超时控制，超时后主线程退出。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"背景说明\"><a href=\"#背景说明\" class=\"headerlink\" title=\"背景说明\"></a>背景说明</h4><p>假设有一个分布式文件系统，现需要从该系统中并发下载一部分文件到本地机器。<br>已知该文件系统的部分节点ip, 以及需要下载的文件fileID列表，并能通过这些信息来拼接下载地址。<br>其中节点ip列表保存在xx_node.txt， 要下载的fileID保存在xx_fileID.txt中。</p>","more":"<h4 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">\t<span class=\"string\">\"bufio\"</span></div><div class=\"line\">\t<span class=\"string\">\"flag\"</span></div><div class=\"line\">\t<span class=\"string\">\"fmt\"</span></div><div class=\"line\">\t<span class=\"string\">\"io\"</span></div><div class=\"line\">\t<span class=\"string\">\"math/rand\"</span></div><div class=\"line\">\t<span class=\"string\">\"net/http\"</span></div><div class=\"line\">\t<span class=\"string\">\"os\"</span></div><div class=\"line\">\t<span class=\"string\">\"time\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">\tclustername = flag.String(<span class=\"string\">\"clustername\"</span>, <span class=\"string\">\"c1\"</span>, <span class=\"string\">\"download clustername\"</span>)</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 逐行读取文件内容</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadLines</span><span class=\"params\">(fpath <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123;</div><div class=\"line\">\tfd, err := os.Open(fpath)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> fd.Close()</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> lines []<span class=\"keyword\">string</span></div><div class=\"line\">\tscanner := bufio.NewScanner(fd)</div><div class=\"line\">\t<span class=\"keyword\">for</span> scanner.Scan() &#123;</div><div class=\"line\">\t\tlines = <span class=\"built_in\">append</span>(lines, scanner.Text())</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">if</span> err := scanner.Err(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Fprintln(os.Stderr, err)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> lines</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 实现单个文件的下载</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Download</span><span class=\"params\">(clustername <span class=\"keyword\">string</span>, node <span class=\"keyword\">string</span>, fileID <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">\tnt := time.Now().Format(<span class=\"string\">\"2006-01-02 15:04:05\"</span>)</div><div class=\"line\">\tfmt.Printf(<span class=\"string\">\"[%s]To download %s\\n\"</span>, nt, fileID)</div><div class=\"line\"></div><div class=\"line\">\turl := fmt.Sprintf(<span class=\"string\">\"http://%s/file/%s\"</span>, node, fileID)</div><div class=\"line\">\tfpath := fmt.Sprintf(<span class=\"string\">\"/yourpath/download/%s_%s\"</span>, clustername, fileID)</div><div class=\"line\">\tnewFile, err := os.Create(fpath)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Println(err.Error())</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"process failed for \"</span> + fileID</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">defer</span> newFile.Close()</div><div class=\"line\"></div><div class=\"line\">\tclient := http.Client&#123;Timeout: <span class=\"number\">900</span> * time.Second&#125;</div><div class=\"line\">\tresp, err := client.Get(url)</div><div class=\"line\">\t<span class=\"keyword\">defer</span> resp.Body.Close()</div><div class=\"line\"></div><div class=\"line\">\t_, err = io.Copy(newFile, resp.Body)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tfmt.Println(err.Error())</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> fileID</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tflag.Parse()</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">// 从文件中读取节点ip列表</span></div><div class=\"line\">\tnodelist := ReadLines(fmt.Sprintf(<span class=\"string\">\"%s_node.txt\"</span>, *clustername))</div><div class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(nodelist) == <span class=\"number\">0</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">// 从文件中读取待下载的文件ID列表</span></div><div class=\"line\">\tfileIDlist := ReadLines(fmt.Sprintf(<span class=\"string\">\"%s_fileID.txt\"</span>, *clustername))</div><div class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(fileIDlist) == <span class=\"number\">0</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>)</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">// 每个goroutine处理一个文件的下载</span></div><div class=\"line\">\tr := rand.New(rand.NewSource(time.Now().UnixNano()))</div><div class=\"line\">\t<span class=\"keyword\">for</span> _, fileID := <span class=\"keyword\">range</span> fileIDlist &#123;</div><div class=\"line\">\t\tnode := nodelist[r.Intn(<span class=\"built_in\">len</span>(nodelist))]</div><div class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(node, fileID <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">\t\t\tch &lt;- Download(*clustername, node, fileID)</div><div class=\"line\">\t\t&#125;(node, fileID)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">// 等待每个文件下载的完成，并检查超时</span></div><div class=\"line\">\ttimeout := time.After(<span class=\"number\">900</span> * time.Second)</div><div class=\"line\">\t<span class=\"keyword\">for</span> idx := <span class=\"number\">0</span>; idx &lt; <span class=\"built_in\">len</span>(fileIDlist); idx++ &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">select</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> res := &lt;-ch:</div><div class=\"line\">\t\t\tnt := time.Now().Format(<span class=\"string\">\"2006-01-02 15:04:05\"</span>)</div><div class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">\"[%s]Finish download %s\\n\"</span>, nt, res)</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> &lt;-timeout:</div><div class=\"line\">\t\t\tfmt.Println(<span class=\"string\">\"Timeout...\"</span>)</div><div class=\"line\">\t\t\t<span class=\"keyword\">break</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>下载时没有用到默认的http Client, 并指定了超时时间；<br>下载文件时调用了系统调用, goroutine会被挂起；<br>下载文件完成后会唤醒被挂起的goroutine, 该goroutine执行完后面的代码后便退出；<br>全局超时控制，超时后主线程退出。</p>"},{"title":"基于环形队列和令牌桶实现的限流模块","date":"2018-06-01T02:17:40.000Z","_content":"\n### 概述\n\n在分布式服务架构下，比如微服务架构，一般需要构建一个独立的gateway模块。gateway模块的主要作用包括流量控制，规则路由，负载均衡，鉴权，熔断等等；而gateway一般是stateless的，因此可自由弹性伸缩集群规模，以应对实际的访问场景。\n本文主要介绍通过golang实现限流模块的一种方案，其关键点主要有两个：\n\n- 环形队列(ring queue)\n- 令牌桶算法(token bucket)\n\n<!--more-->\n\n### 基于环形队列(ring queue)\n\n```golang\ntype Queue struct {\n\tmtx      sync.RWMutex\n\thead     int64\n\ttail     int64\n\tcapacity int64\n\telemcnt  int64\n\tdata     []interface{}\n}\n\n// 将一个元素推入队列n次\nfunc func (q *Queue) AtomEnqueue(d interface{}, n int64) bool {\n}\n\n// 根据自定义方法的判定结果，将符合条件的元素推出队列\nfunc (q *Queue) DequeueBy(fc func(interface{}) bool) []interface{\n}\n```\n\n环形队列在限流中的作用是，提供一个状态保存空间，用以判断当前访问频率是否已达到限制值。\n\n在使用这种队列之前，尝试过用time.Tick()时钟方法来实现令牌的定期发放，容易实现但是性能是不高的。因为据说在频率超过1000rps时， 不建议用time.Tick, 具体可以参考这里[controlling throughput with rate.limiter][2] 。\n\n另外如果用到time.Tick()， 一般就需要新开goroutine来进行定期执行了。虽然并没有消耗太多性能，但能避免总是好的。而且如果限流是要实现到针对ip，或者user级别的粒度，那开销就很难忽略了。\n\n而环形队列的一个好处是内存从初始化后就基本是固定的，队列里的每一个元素存放的是每个请求的状态(当前示例里存的是访问时间戳)，在请求到达时查询流量状态的同时，进行队列元素的更新(有别于time.Tick的定期性，这个是依靠请求到达来触发的，也就不需要依赖到其他系统资源)。另一个好处就是访问速度快，也没有过多的内存拷贝。其中要注意的是解决并发竞争的问题，用读写锁是其中一种解决方法。\n\n### 基于令牌桶(token bucket)算法\n\n```golang\ntype TokenBucket struct {\n\tmutex    sync.Mutex\n\tcapacity int64\n\tinterval time.Duration\n\ttsQ      *Queue\n}\n\n// 获取token， 成功返回true， 失败返回false及需要等待的时间\nfunc (tb *TokenBucket) Take(n int64) (bool, time.Duration) {\n}\n\n// 获取token， 成功返回true，失败则等待直至超时\nfunc (tb *TokenBucket) Wait(n int64, t time.Duration) bool {\n}\n```\n常用的限流算法有两种: 漏桶算法， 令牌桶算法。网上有更详细的算法描述，这里不展开讲了。\n\n我这里采取的是类似令牌桶的算法，原算法是每隔一段时间往桶里放一个token，有请求来时就拿走token，没有token时请求就等待（Wait）或直接返回失败（Take）；这里的实现有所区别：\n\n- 首先是实现中并不是放token， 而是记录每个到达请求的时间戳，环形队列中有空闲的元素才能记录成功，否则等待或返回失败， \n- 另外触发时机也不一样，不是基于时钟的周期触发，而是依靠请求到达来触发\n\n### 源码地址及测试用例\n\n[github项目地址][1]\n\n未严格验证，欢迎各位大大帮忙甩bug。其中测试用例参考如下：\n```shell\n$ go test\n[1 2 3 4 5 6]\n[1 2 3 4 5 6 7 8]\n[3 4 5 6 7 8 9 10]\n[9 10 3 4 5 6 7 8]\n[10 11 12 13 14 15 16 17]\n[10 11 12 13 14]\n[15 16 17]\n[]\n[9 10 haha 15 3 6]\n[9 10]\ntake-n:1 time-used:3.327341023s suc-cnt:4000 fail-cnt:9996000\ntake-n:2 time-used:3.334162956s suc-cnt:2000 fail-cnt:9998000\ntake-n:1 time-used:1.257582083s suc-cnt:1499 fail-cnt:1001\ntake-n:1 time-used:2.250956732s suc-cnt:2500 fail-cnt:0\ntake-n:2 time-used:1.254886958s suc-cnt:999 fail-cnt:1501\ntake-n:2 time-used:4.251330391s suc-cnt:2499 fail-cnt:1\ntake-n:2 time-used:2.251117604s suc-cnt:2500 fail-cnt:0\nPASS\nok      github.com/moxiaomomo/token-bucket23.931s\n```\n\n  [1]: https://github.com/moxiaomomo/token-bucket\n  [2]: https://rodaine.com/2017/05/x-files-time-rate-golang\n\n慕课网同步链接：https://www.imooc.com/article/31788\n","source":"_posts/golang/token-bucket.md","raw":"---\ntitle: 基于环形队列和令牌桶实现的限流模块\ndate: 2018-06-01 10:17:40\ntags: [\"golang\",\"microservice\"]\n---\n\n### 概述\n\n在分布式服务架构下，比如微服务架构，一般需要构建一个独立的gateway模块。gateway模块的主要作用包括流量控制，规则路由，负载均衡，鉴权，熔断等等；而gateway一般是stateless的，因此可自由弹性伸缩集群规模，以应对实际的访问场景。\n本文主要介绍通过golang实现限流模块的一种方案，其关键点主要有两个：\n\n- 环形队列(ring queue)\n- 令牌桶算法(token bucket)\n\n<!--more-->\n\n### 基于环形队列(ring queue)\n\n```golang\ntype Queue struct {\n\tmtx      sync.RWMutex\n\thead     int64\n\ttail     int64\n\tcapacity int64\n\telemcnt  int64\n\tdata     []interface{}\n}\n\n// 将一个元素推入队列n次\nfunc func (q *Queue) AtomEnqueue(d interface{}, n int64) bool {\n}\n\n// 根据自定义方法的判定结果，将符合条件的元素推出队列\nfunc (q *Queue) DequeueBy(fc func(interface{}) bool) []interface{\n}\n```\n\n环形队列在限流中的作用是，提供一个状态保存空间，用以判断当前访问频率是否已达到限制值。\n\n在使用这种队列之前，尝试过用time.Tick()时钟方法来实现令牌的定期发放，容易实现但是性能是不高的。因为据说在频率超过1000rps时， 不建议用time.Tick, 具体可以参考这里[controlling throughput with rate.limiter][2] 。\n\n另外如果用到time.Tick()， 一般就需要新开goroutine来进行定期执行了。虽然并没有消耗太多性能，但能避免总是好的。而且如果限流是要实现到针对ip，或者user级别的粒度，那开销就很难忽略了。\n\n而环形队列的一个好处是内存从初始化后就基本是固定的，队列里的每一个元素存放的是每个请求的状态(当前示例里存的是访问时间戳)，在请求到达时查询流量状态的同时，进行队列元素的更新(有别于time.Tick的定期性，这个是依靠请求到达来触发的，也就不需要依赖到其他系统资源)。另一个好处就是访问速度快，也没有过多的内存拷贝。其中要注意的是解决并发竞争的问题，用读写锁是其中一种解决方法。\n\n### 基于令牌桶(token bucket)算法\n\n```golang\ntype TokenBucket struct {\n\tmutex    sync.Mutex\n\tcapacity int64\n\tinterval time.Duration\n\ttsQ      *Queue\n}\n\n// 获取token， 成功返回true， 失败返回false及需要等待的时间\nfunc (tb *TokenBucket) Take(n int64) (bool, time.Duration) {\n}\n\n// 获取token， 成功返回true，失败则等待直至超时\nfunc (tb *TokenBucket) Wait(n int64, t time.Duration) bool {\n}\n```\n常用的限流算法有两种: 漏桶算法， 令牌桶算法。网上有更详细的算法描述，这里不展开讲了。\n\n我这里采取的是类似令牌桶的算法，原算法是每隔一段时间往桶里放一个token，有请求来时就拿走token，没有token时请求就等待（Wait）或直接返回失败（Take）；这里的实现有所区别：\n\n- 首先是实现中并不是放token， 而是记录每个到达请求的时间戳，环形队列中有空闲的元素才能记录成功，否则等待或返回失败， \n- 另外触发时机也不一样，不是基于时钟的周期触发，而是依靠请求到达来触发\n\n### 源码地址及测试用例\n\n[github项目地址][1]\n\n未严格验证，欢迎各位大大帮忙甩bug。其中测试用例参考如下：\n```shell\n$ go test\n[1 2 3 4 5 6]\n[1 2 3 4 5 6 7 8]\n[3 4 5 6 7 8 9 10]\n[9 10 3 4 5 6 7 8]\n[10 11 12 13 14 15 16 17]\n[10 11 12 13 14]\n[15 16 17]\n[]\n[9 10 haha 15 3 6]\n[9 10]\ntake-n:1 time-used:3.327341023s suc-cnt:4000 fail-cnt:9996000\ntake-n:2 time-used:3.334162956s suc-cnt:2000 fail-cnt:9998000\ntake-n:1 time-used:1.257582083s suc-cnt:1499 fail-cnt:1001\ntake-n:1 time-used:2.250956732s suc-cnt:2500 fail-cnt:0\ntake-n:2 time-used:1.254886958s suc-cnt:999 fail-cnt:1501\ntake-n:2 time-used:4.251330391s suc-cnt:2499 fail-cnt:1\ntake-n:2 time-used:2.251117604s suc-cnt:2500 fail-cnt:0\nPASS\nok      github.com/moxiaomomo/token-bucket23.931s\n```\n\n  [1]: https://github.com/moxiaomomo/token-bucket\n  [2]: https://rodaine.com/2017/05/x-files-time-rate-golang\n\n慕课网同步链接：https://www.imooc.com/article/31788\n","slug":"golang/token-bucket","published":1,"updated":"2018-06-18T09:08:21.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2c00dzl004a4j4dcfsfyrwz","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>在分布式服务架构下，比如微服务架构，一般需要构建一个独立的gateway模块。gateway模块的主要作用包括流量控制，规则路由，负载均衡，鉴权，熔断等等；而gateway一般是stateless的，因此可自由弹性伸缩集群规模，以应对实际的访问场景。<br>本文主要介绍通过golang实现限流模块的一种方案，其关键点主要有两个：</p>\n<ul>\n<li>环形队列(ring queue)</li>\n<li>令牌桶算法(token bucket)</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"基于环形队列-ring-queue\"><a href=\"#基于环形队列-ring-queue\" class=\"headerlink\" title=\"基于环形队列(ring queue)\"></a>基于环形队列(ring queue)</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Queue <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tmtx      sync.RWMutex</div><div class=\"line\">\thead     <span class=\"keyword\">int64</span></div><div class=\"line\">\ttail     <span class=\"keyword\">int64</span></div><div class=\"line\">\tcapacity <span class=\"keyword\">int64</span></div><div class=\"line\">\telemcnt  <span class=\"keyword\">int64</span></div><div class=\"line\">\tdata     []<span class=\"keyword\">interface</span>&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将一个元素推入队列n次</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">func</span> <span class=\"params\">(q *Queue)</span> <span class=\"title\">AtomEnqueue</span><span class=\"params\">(d <span class=\"keyword\">interface</span>&#123;&#125;, n <span class=\"keyword\">int64</span>)</span> <span class=\"title\">bool</span></span> &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 根据自定义方法的判定结果，将符合条件的元素推出队列</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *Queue)</span> <span class=\"title\">DequeueBy</span><span class=\"params\">(fc <span class=\"keyword\">func</span>(<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">bool</span>) []<span class=\"title\">interface</span></span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>环形队列在限流中的作用是，提供一个状态保存空间，用以判断当前访问频率是否已达到限制值。</p>\n<p>在使用这种队列之前，尝试过用time.Tick()时钟方法来实现令牌的定期发放，容易实现但是性能是不高的。因为据说在频率超过1000rps时， 不建议用time.Tick, 具体可以参考这里<a href=\"https://rodaine.com/2017/05/x-files-time-rate-golang\" target=\"_blank\" rel=\"external\">controlling throughput with rate.limiter</a> 。</p>\n<p>另外如果用到time.Tick()， 一般就需要新开goroutine来进行定期执行了。虽然并没有消耗太多性能，但能避免总是好的。而且如果限流是要实现到针对ip，或者user级别的粒度，那开销就很难忽略了。</p>\n<p>而环形队列的一个好处是内存从初始化后就基本是固定的，队列里的每一个元素存放的是每个请求的状态(当前示例里存的是访问时间戳)，在请求到达时查询流量状态的同时，进行队列元素的更新(有别于time.Tick的定期性，这个是依靠请求到达来触发的，也就不需要依赖到其他系统资源)。另一个好处就是访问速度快，也没有过多的内存拷贝。其中要注意的是解决并发竞争的问题，用读写锁是其中一种解决方法。</p>\n<h3 id=\"基于令牌桶-token-bucket-算法\"><a href=\"#基于令牌桶-token-bucket-算法\" class=\"headerlink\" title=\"基于令牌桶(token bucket)算法\"></a>基于令牌桶(token bucket)算法</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> TokenBucket <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tmutex    sync.Mutex</div><div class=\"line\">\tcapacity <span class=\"keyword\">int64</span></div><div class=\"line\">\tinterval time.Duration</div><div class=\"line\">\ttsQ      *Queue</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取token， 成功返回true， 失败返回false及需要等待的时间</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(tb *TokenBucket)</span> <span class=\"title\">Take</span><span class=\"params\">(n <span class=\"keyword\">int64</span>)</span> <span class=\"params\">(<span class=\"keyword\">bool</span>, time.Duration)</span></span> &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取token， 成功返回true，失败则等待直至超时</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(tb *TokenBucket)</span> <span class=\"title\">Wait</span><span class=\"params\">(n <span class=\"keyword\">int64</span>, t time.Duration)</span> <span class=\"title\">bool</span></span> &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>常用的限流算法有两种: 漏桶算法， 令牌桶算法。网上有更详细的算法描述，这里不展开讲了。</p>\n<p>我这里采取的是类似令牌桶的算法，原算法是每隔一段时间往桶里放一个token，有请求来时就拿走token，没有token时请求就等待（Wait）或直接返回失败（Take）；这里的实现有所区别：</p>\n<ul>\n<li>首先是实现中并不是放token， 而是记录每个到达请求的时间戳，环形队列中有空闲的元素才能记录成功，否则等待或返回失败， </li>\n<li>另外触发时机也不一样，不是基于时钟的周期触发，而是依靠请求到达来触发</li>\n</ul>\n<h3 id=\"源码地址及测试用例\"><a href=\"#源码地址及测试用例\" class=\"headerlink\" title=\"源码地址及测试用例\"></a>源码地址及测试用例</h3><p><a href=\"https://github.com/moxiaomomo/token-bucket\" target=\"_blank\" rel=\"external\">github项目地址</a></p>\n<p>未严格验证，欢迎各位大大帮忙甩bug。其中测试用例参考如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> go <span class=\"built_in\">test</span></span></div><div class=\"line\">[1 2 3 4 5 6]</div><div class=\"line\">[1 2 3 4 5 6 7 8]</div><div class=\"line\">[3 4 5 6 7 8 9 10]</div><div class=\"line\">[9 10 3 4 5 6 7 8]</div><div class=\"line\">[10 11 12 13 14 15 16 17]</div><div class=\"line\">[10 11 12 13 14]</div><div class=\"line\">[15 16 17]</div><div class=\"line\">[]</div><div class=\"line\">[9 10 haha 15 3 6]</div><div class=\"line\">[9 10]</div><div class=\"line\">take-n:1 time-used:3.327341023s suc-cnt:4000 fail-cnt:9996000</div><div class=\"line\">take-n:2 time-used:3.334162956s suc-cnt:2000 fail-cnt:9998000</div><div class=\"line\">take-n:1 time-used:1.257582083s suc-cnt:1499 fail-cnt:1001</div><div class=\"line\">take-n:1 time-used:2.250956732s suc-cnt:2500 fail-cnt:0</div><div class=\"line\">take-n:2 time-used:1.254886958s suc-cnt:999 fail-cnt:1501</div><div class=\"line\">take-n:2 time-used:4.251330391s suc-cnt:2499 fail-cnt:1</div><div class=\"line\">take-n:2 time-used:2.251117604s suc-cnt:2500 fail-cnt:0</div><div class=\"line\">PASS</div><div class=\"line\">ok      github.com/moxiaomomo/token-bucket23.931s</div></pre></td></tr></table></figure></p>\n<p>慕课网同步链接：<a href=\"https://www.imooc.com/article/31788\" target=\"_blank\" rel=\"external\">https://www.imooc.com/article/31788</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>在分布式服务架构下，比如微服务架构，一般需要构建一个独立的gateway模块。gateway模块的主要作用包括流量控制，规则路由，负载均衡，鉴权，熔断等等；而gateway一般是stateless的，因此可自由弹性伸缩集群规模，以应对实际的访问场景。<br>本文主要介绍通过golang实现限流模块的一种方案，其关键点主要有两个：</p>\n<ul>\n<li>环形队列(ring queue)</li>\n<li>令牌桶算法(token bucket)</li>\n</ul>","more":"<h3 id=\"基于环形队列-ring-queue\"><a href=\"#基于环形队列-ring-queue\" class=\"headerlink\" title=\"基于环形队列(ring queue)\"></a>基于环形队列(ring queue)</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Queue <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tmtx      sync.RWMutex</div><div class=\"line\">\thead     <span class=\"keyword\">int64</span></div><div class=\"line\">\ttail     <span class=\"keyword\">int64</span></div><div class=\"line\">\tcapacity <span class=\"keyword\">int64</span></div><div class=\"line\">\telemcnt  <span class=\"keyword\">int64</span></div><div class=\"line\">\tdata     []<span class=\"keyword\">interface</span>&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将一个元素推入队列n次</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">func</span> <span class=\"params\">(q *Queue)</span> <span class=\"title\">AtomEnqueue</span><span class=\"params\">(d <span class=\"keyword\">interface</span>&#123;&#125;, n <span class=\"keyword\">int64</span>)</span> <span class=\"title\">bool</span></span> &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 根据自定义方法的判定结果，将符合条件的元素推出队列</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *Queue)</span> <span class=\"title\">DequeueBy</span><span class=\"params\">(fc <span class=\"keyword\">func</span>(<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">bool</span>) []<span class=\"title\">interface</span></span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>环形队列在限流中的作用是，提供一个状态保存空间，用以判断当前访问频率是否已达到限制值。</p>\n<p>在使用这种队列之前，尝试过用time.Tick()时钟方法来实现令牌的定期发放，容易实现但是性能是不高的。因为据说在频率超过1000rps时， 不建议用time.Tick, 具体可以参考这里<a href=\"https://rodaine.com/2017/05/x-files-time-rate-golang\" target=\"_blank\" rel=\"external\">controlling throughput with rate.limiter</a> 。</p>\n<p>另外如果用到time.Tick()， 一般就需要新开goroutine来进行定期执行了。虽然并没有消耗太多性能，但能避免总是好的。而且如果限流是要实现到针对ip，或者user级别的粒度，那开销就很难忽略了。</p>\n<p>而环形队列的一个好处是内存从初始化后就基本是固定的，队列里的每一个元素存放的是每个请求的状态(当前示例里存的是访问时间戳)，在请求到达时查询流量状态的同时，进行队列元素的更新(有别于time.Tick的定期性，这个是依靠请求到达来触发的，也就不需要依赖到其他系统资源)。另一个好处就是访问速度快，也没有过多的内存拷贝。其中要注意的是解决并发竞争的问题，用读写锁是其中一种解决方法。</p>\n<h3 id=\"基于令牌桶-token-bucket-算法\"><a href=\"#基于令牌桶-token-bucket-算法\" class=\"headerlink\" title=\"基于令牌桶(token bucket)算法\"></a>基于令牌桶(token bucket)算法</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> TokenBucket <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tmutex    sync.Mutex</div><div class=\"line\">\tcapacity <span class=\"keyword\">int64</span></div><div class=\"line\">\tinterval time.Duration</div><div class=\"line\">\ttsQ      *Queue</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取token， 成功返回true， 失败返回false及需要等待的时间</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(tb *TokenBucket)</span> <span class=\"title\">Take</span><span class=\"params\">(n <span class=\"keyword\">int64</span>)</span> <span class=\"params\">(<span class=\"keyword\">bool</span>, time.Duration)</span></span> &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取token， 成功返回true，失败则等待直至超时</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(tb *TokenBucket)</span> <span class=\"title\">Wait</span><span class=\"params\">(n <span class=\"keyword\">int64</span>, t time.Duration)</span> <span class=\"title\">bool</span></span> &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>常用的限流算法有两种: 漏桶算法， 令牌桶算法。网上有更详细的算法描述，这里不展开讲了。</p>\n<p>我这里采取的是类似令牌桶的算法，原算法是每隔一段时间往桶里放一个token，有请求来时就拿走token，没有token时请求就等待（Wait）或直接返回失败（Take）；这里的实现有所区别：</p>\n<ul>\n<li>首先是实现中并不是放token， 而是记录每个到达请求的时间戳，环形队列中有空闲的元素才能记录成功，否则等待或返回失败， </li>\n<li>另外触发时机也不一样，不是基于时钟的周期触发，而是依靠请求到达来触发</li>\n</ul>\n<h3 id=\"源码地址及测试用例\"><a href=\"#源码地址及测试用例\" class=\"headerlink\" title=\"源码地址及测试用例\"></a>源码地址及测试用例</h3><p><a href=\"https://github.com/moxiaomomo/token-bucket\" target=\"_blank\" rel=\"external\">github项目地址</a></p>\n<p>未严格验证，欢迎各位大大帮忙甩bug。其中测试用例参考如下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> go <span class=\"built_in\">test</span></span></div><div class=\"line\">[1 2 3 4 5 6]</div><div class=\"line\">[1 2 3 4 5 6 7 8]</div><div class=\"line\">[3 4 5 6 7 8 9 10]</div><div class=\"line\">[9 10 3 4 5 6 7 8]</div><div class=\"line\">[10 11 12 13 14 15 16 17]</div><div class=\"line\">[10 11 12 13 14]</div><div class=\"line\">[15 16 17]</div><div class=\"line\">[]</div><div class=\"line\">[9 10 haha 15 3 6]</div><div class=\"line\">[9 10]</div><div class=\"line\">take-n:1 time-used:3.327341023s suc-cnt:4000 fail-cnt:9996000</div><div class=\"line\">take-n:2 time-used:3.334162956s suc-cnt:2000 fail-cnt:9998000</div><div class=\"line\">take-n:1 time-used:1.257582083s suc-cnt:1499 fail-cnt:1001</div><div class=\"line\">take-n:1 time-used:2.250956732s suc-cnt:2500 fail-cnt:0</div><div class=\"line\">take-n:2 time-used:1.254886958s suc-cnt:999 fail-cnt:1501</div><div class=\"line\">take-n:2 time-used:4.251330391s suc-cnt:2499 fail-cnt:1</div><div class=\"line\">take-n:2 time-used:2.251117604s suc-cnt:2500 fail-cnt:0</div><div class=\"line\">PASS</div><div class=\"line\">ok      github.com/moxiaomomo/token-bucket23.931s</div></pre></td></tr></table></figure></p>\n<p>慕课网同步链接：<a href=\"https://www.imooc.com/article/31788\" target=\"_blank\" rel=\"external\">https://www.imooc.com/article/31788</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck2c00dsq00004j4dfjt3nux7","tag_id":"ck2c00dsz00014j4d0ijps863","_id":"ck2c00dt200024j4d11bhib2d"},{"post_id":"ck2c00duv00074j4dtoi2n7wz","tag_id":"ck2c00dux00094j4da72mcdqt","_id":"ck2c00dva000e4j4dpg1zb9ml"},{"post_id":"ck2c00duw00084j4d5ee0bp1g","tag_id":"ck2c00dux00094j4da72mcdqt","_id":"ck2c00dvd000i4j4d1q0z19ne"},{"post_id":"ck2c00dvc000g4j4d59iwncg7","tag_id":"ck2c00dux00094j4da72mcdqt","_id":"ck2c00dvq000k4j4dbopmgoli"},{"post_id":"ck2c00dux000a4j4d4e30q3fu","tag_id":"ck2c00dvc000h4j4do6qa75yl","_id":"ck2c00dvs000o4j4dbi4z2431"},{"post_id":"ck2c00dv5000b4j4ddeu8rxen","tag_id":"ck2c00dvr000m4j4dly64w043","_id":"ck2c00dvv000s4j4d03ctgcp8"},{"post_id":"ck2c00dv6000c4j4difiusvnh","tag_id":"ck2c00dvt000q4j4dgwpcej7u","_id":"ck2c00dvx000w4j4d4cmw4ow4"},{"post_id":"ck2c00dva000f4j4dmtu4m2ro","tag_id":"ck2c00dvw000u4j4djrdpgyaw","_id":"ck2c00dw200104j4daq0081u9"},{"post_id":"ck2c00dvd000j4j4dd584ppbb","tag_id":"ck2c00dw1000z4j4dvyf27lq8","_id":"ck2c00dw600154j4dawi341zk"},{"post_id":"ck2c00dvq000l4j4dju02hmj8","tag_id":"ck2c00dw500134j4dz8zf9s8k","_id":"ck2c00dw900194j4dbfni8w1b"},{"post_id":"ck2c00dvr000n4j4dg87c15ra","tag_id":"ck2c00dw800174j4dc80f7ynq","_id":"ck2c00dwg001d4j4d6uzmay7m"},{"post_id":"ck2c00dvt000p4j4d1feaqinl","tag_id":"ck2c00dwe001b4j4dp8792fdp","_id":"ck2c00dwm001l4j4djgl8cmp3"},{"post_id":"ck2c00dvt000p4j4d1feaqinl","tag_id":"ck2c00dwi001g4j4d71fg0exz","_id":"ck2c00dwm001m4j4dinsarv8h"},{"post_id":"ck2c00dvu000r4j4d6g0y3nr0","tag_id":"ck2c00dwk001j4j4dbr893f3j","_id":"ck2c00dwn001o4j4dz0uv9skv"},{"post_id":"ck2c00dvv000t4j4d2pqykzrz","tag_id":"ck2c00dwk001j4j4dbr893f3j","_id":"ck2c00dwn001r4j4dglllqj8y"},{"post_id":"ck2c00dvv000t4j4d2pqykzrz","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dwn001s4j4di41nv4hl"},{"post_id":"ck2c00dvw000v4j4da37txzlk","tag_id":"ck2c00dwn001q4j4dc0j9ys83","_id":"ck2c00dwo001u4j4d79g7832r"},{"post_id":"ck2c00dvx000x4j4daydtgc3h","tag_id":"ck2c00dwn001t4j4dbircyelj","_id":"ck2c00dwq001w4j4dwiey7j4a"},{"post_id":"ck2c00dw0000y4j4doa30vpju","tag_id":"ck2c00dwp001v4j4d18ezuysh","_id":"ck2c00dwq001y4j4dstjzunmr"},{"post_id":"ck2c00dw300114j4d7etvtera","tag_id":"ck2c00dwq001x4j4ddu6ga1fi","_id":"ck2c00dwr00204j4dt6hzll4w"},{"post_id":"ck2c00dw700164j4dp546tlwd","tag_id":"ck2c00dwq001z4j4do0ejyzed","_id":"ck2c00dwr00224j4dwmz6tmjt"},{"post_id":"ck2c00dw800184j4donm15390","tag_id":"ck2c00dwq001z4j4do0ejyzed","_id":"ck2c00dws00244j4di5mwb9ma"},{"post_id":"ck2c00dw9001a4j4dhn3vo2j7","tag_id":"ck2c00dwq001z4j4do0ejyzed","_id":"ck2c00dwt00264j4d6arf6y5j"},{"post_id":"ck2c00dwf001c4j4d4dhkasd4","tag_id":"ck2c00dwq001z4j4do0ejyzed","_id":"ck2c00dwt00284j4dl73xjimo"},{"post_id":"ck2c00dwh001e4j4dzhhs89fc","tag_id":"ck2c00dwt00274j4d8akgn7ph","_id":"ck2c00dwu002b4j4d8fkfgbig"},{"post_id":"ck2c00dwh001e4j4dzhhs89fc","tag_id":"ck2c00dwt00294j4dunwc5xld","_id":"ck2c00dwu002c4j4dxq2fel71"},{"post_id":"ck2c00dwh001f4j4d8o2dwzyq","tag_id":"ck2c00dwu002a4j4d210zagg8","_id":"ck2c00dwv002e4j4djzn2pyhf"},{"post_id":"ck2c00dwj001h4j4di7ggg7hv","tag_id":"ck2c00dwt00274j4d8akgn7ph","_id":"ck2c00dwv002g4j4dpmc73krl"},{"post_id":"ck2c00dwk001i4j4dnudlkgti","tag_id":"ck2c00dwu002a4j4d210zagg8","_id":"ck2c00dww002i4j4d8sjze5qu"},{"post_id":"ck2c00dwl001k4j4dt52thr9j","tag_id":"ck2c00dwu002a4j4d210zagg8","_id":"ck2c00dww002j4j4dur02vmvt"},{"post_id":"ck2c00dx7002o4j4dn4zfy3k9","tag_id":"ck2c00dx6002m4j4dob1ku7yk","_id":"ck2c00dxc002r4j4dq4ef3mt8"},{"post_id":"ck2c00dx3002k4j4dcy0jqmpl","tag_id":"ck2c00dx6002m4j4dob1ku7yk","_id":"ck2c00dxf002t4j4drut0kfv0"},{"post_id":"ck2c00dxc002s4j4d2gyoifmu","tag_id":"ck2c00dx6002m4j4dob1ku7yk","_id":"ck2c00dxi002w4j4diq1w897z"},{"post_id":"ck2c00dx4002l4j4d3p3qwso2","tag_id":"ck2c00dx6002m4j4dob1ku7yk","_id":"ck2c00dxj002y4j4dwnq447qc"},{"post_id":"ck2c00dxi002x4j4dcd7r49q6","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dxk00314j4d0jyx9ki7"},{"post_id":"ck2c00dx6002n4j4dh9lrq8d8","tag_id":"ck2c00dx6002m4j4dob1ku7yk","_id":"ck2c00dxm00334j4dthls26dr"},{"post_id":"ck2c00dxj002z4j4d0ekjjzjl","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dxw00364j4dkvyy3n03"},{"post_id":"ck2c00dxl00324j4dozec2d3h","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dxx00384j4dilbz7mw1"},{"post_id":"ck2c00dx9002p4j4dnj6m6l15","tag_id":"ck2c00dxk00304j4d4dfm83ej","_id":"ck2c00dxz003a4j4dywkv8zmb"},{"post_id":"ck2c00dxm00344j4dni61ykuf","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dy1003c4j4doxsif9rd"},{"post_id":"ck2c00dxw00374j4dc6vxf1gz","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dy5003e4j4d9bg2979n"},{"post_id":"ck2c00dxg002u4j4dtfvn8e8p","tag_id":"ck2c00dxu00354j4d2i6yl8ss","_id":"ck2c00dy8003g4j4df3j9b6dh"},{"post_id":"ck2c00dxy00394j4dvbxowmv4","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dy9003i4j4ddjamv0xq"},{"post_id":"ck2c00dy0003b4j4dl1xl33i3","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dya003k4j4d0ngriijn"},{"post_id":"ck2c00dy1003d4j4datnhhz2l","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dyc003m4j4dmhxbjb40"},{"post_id":"ck2c00dy5003f4j4dqr0q03f8","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dyd003o4j4dyic4mph0"},{"post_id":"ck2c00dy8003h4j4d003duzn0","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dye003q4j4dh34aame8"},{"post_id":"ck2c00dy9003j4j4d9pwynzbg","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dyj003s4j4dtg47cnqv"},{"post_id":"ck2c00dyb003l4j4dvyn1eyq6","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dyl003u4j4dzfr2e00y"},{"post_id":"ck2c00dyc003n4j4d2tjut2rx","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dym003w4j4dfqa353qe"},{"post_id":"ck2c00dyd003p4j4d3bx1issu","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dyo003y4j4dwbb1btv4"},{"post_id":"ck2c00dye003r4j4d6amfvr3u","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dyp00404j4dmhoommg5"},{"post_id":"ck2c00dyj003t4j4dg2jlultt","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dyq00424j4dpu5g7736"},{"post_id":"ck2c00dyl003v4j4d6ed1kkdg","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dys00444j4dxdly37p0"},{"post_id":"ck2c00dyn003x4j4d2x4mu1ro","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dys00454j4d72sig47b"},{"post_id":"ck2c00dyo003z4j4d2i0kc0qm","tag_id":"ck2c00dwk001j4j4dbr893f3j","_id":"ck2c00dyu00464j4doz9cz6n2"},{"post_id":"ck2c00dyp00414j4dlzrtffrs","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dyv00474j4dyq9l41li"},{"post_id":"ck2c00dyp00414j4dlzrtffrs","tag_id":"ck2c00dwe001b4j4dp8792fdp","_id":"ck2c00dyv00484j4djdegefkz"},{"post_id":"ck2c00dyq00434j4dovc4vyfs","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dyv00494j4dz08eyl1f"},{"post_id":"ck2c00dzl004a4j4dcfsfyrwz","tag_id":"ck2c00dwn001p4j4d5ch4hnm4","_id":"ck2c00dzt004b4j4d66u3qtjx"},{"post_id":"ck2c00dzl004a4j4dcfsfyrwz","tag_id":"ck2c00dwk001j4j4dbr893f3j","_id":"ck2c00dzt004c4j4dhwfvcg4a"}],"Tag":[{"name":"threejs Object3D","_id":"ck2c00dsz00014j4d0ijps863"},{"name":"bigdata","_id":"ck2c00dux00094j4da72mcdqt"},{"name":"flume-kafka","_id":"ck2c00dvc000h4j4do6qa75yl"},{"name":"elasticsearch 备份恢复","_id":"ck2c00dvr000m4j4dly64w043"},{"name":"flume spark_streaming","_id":"ck2c00dvt000q4j4dgwpcej7u"},{"name":"视频","_id":"ck2c00dvw000u4j4djrdpgyaw"},{"name":"ionic","_id":"ck2c00dw1000z4j4dvyf27lq8"},{"name":"spring","_id":"ck2c00dw500134j4dz8zf9s8k"},{"name":"consul","_id":"ck2c00dw800174j4dc80f7ynq"},{"name":"tracing","_id":"ck2c00dwe001b4j4dp8792fdp"},{"name":"docker","_id":"ck2c00dwi001g4j4d71fg0exz"},{"name":"microservice","_id":"ck2c00dwk001j4j4dbr893f3j"},{"name":"golang","_id":"ck2c00dwn001p4j4d5ch4hnm4"},{"name":"mysql","_id":"ck2c00dwn001q4j4dc0j9ys83"},{"name":"Centos, DevOps","_id":"ck2c00dwn001t4j4dbircyelj"},{"name":"OS kernel","_id":"ck2c00dwp001v4j4d18ezuysh"},{"name":"linux kernel","_id":"ck2c00dwq001x4j4ddu6ga1fi"},{"name":"networking","_id":"ck2c00dwq001z4j4do0ejyzed"},{"name":"java","_id":"ck2c00dwt00274j4d8akgn7ph"},{"name":"springboot","_id":"ck2c00dwt00294j4dunwc5xld"},{"name":"shell","_id":"ck2c00dwu002a4j4d210zagg8"},{"name":"python","_id":"ck2c00dx6002m4j4dob1ku7yk"},{"name":"elasticsearch","_id":"ck2c00dxk00304j4d4dfm83ej"},{"name":"nginx","_id":"ck2c00dxu00354j4d2i6yl8ss"}]}}